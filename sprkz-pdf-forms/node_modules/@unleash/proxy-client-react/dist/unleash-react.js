import { UnleashClient as H } from "unleash-proxy-client";
import { InMemoryStorageProvider as Z, LocalStorageProvider as $, UnleashClient as N } from "unleash-proxy-client";
import g, { useState as b, useEffect as p, useMemo as C, useContext as M, useRef as k } from "react";
const A = g.createContext(null), _ = {
  bootstrap: [],
  disableRefresh: !0,
  disableMetrics: !0,
  url: "http://localhost",
  appName: "offline",
  clientKey: "not-used"
}, q = "startTransition", I = g[q] || ((e) => e()), K = ({
  config: e,
  children: r,
  unleashClient: t,
  startClient: a = !0,
  stopClient: u = !0,
  startTransition: s = I
}) => {
  var h, m, R;
  const l = e || _, o = g.useRef(
    t || new H(l)
  ), [n, x] = g.useState(
    !!(t ? e != null && e.bootstrap && (e == null ? void 0 : e.bootstrapOverride) !== !1 || (h = t.isReady) != null && h.call(t) : l.bootstrap && l.bootstrapOverride !== !1)
  ), [E, y] = b(((R = (m = o.current).getError) == null ? void 0 : R.call(m)) || null);
  p(() => {
    !l && !t && console.error(
      `You must provide either a config or an unleash client to the flag provider.
        If you are initializing the client in useEffect, you can avoid this warning
        by checking if the client exists before rendering.`
    );
    const c = (v) => {
      s(() => {
        y((U) => U || v);
      });
    }, d = (v) => {
      s(() => {
        y(null);
      });
    };
    let i = null;
    const P = () => {
      i = setTimeout(() => {
        s(() => {
          x(!0);
        });
      }, 0);
    };
    return o.current.on("ready", P), o.current.on("error", c), o.current.on("recovered", d), a && (o.current.stop(), o.current.start()), function() {
      o.current && (o.current.off("error", c), o.current.off("ready", P), o.current.off("recovered", d), u && o.current.stop()), i && clearTimeout(i);
    };
  }, []);
  const T = C(
    () => ({
      on: (c, d, i) => o.current.on(c, d, i),
      off: (c, d) => o.current.off(c, d),
      updateContext: async (c) => await o.current.updateContext(c),
      isEnabled: (c) => o.current.isEnabled(c),
      getVariant: (c) => o.current.getVariant(c),
      client: o.current,
      flagsReady: n,
      flagsError: E,
      setFlagsReady: x,
      setFlagsError: y
    }),
    [n, E]
  );
  return /* @__PURE__ */ g.createElement(A.Provider, { value: T }, r);
}, S = {
  on: (e, r, t) => (console.error("on() must be used within a FlagProvider"), F),
  off: (e, r) => (console.error("off() must be used within a FlagProvider"), F),
  updateContext: async () => {
    console.error("updateContext() must be used within a FlagProvider");
  },
  isEnabled: () => (console.error("isEnabled() must be used within a FlagProvider"), !1),
  getVariant: () => (console.error("getVariant() must be used within a FlagProvider"), { name: "disabled", enabled: !1 })
}, F = {
  ...S,
  toggles: [],
  impressionDataAll: {},
  context: {},
  storage: {},
  start: () => {
  },
  stop: () => {
  },
  isReady: () => !1,
  getError: () => null,
  getAllToggles: () => []
}, O = {
  ...S,
  client: F,
  flagsReady: !1,
  setFlagsReady: () => {
    console.error("setFlagsReady() must be used within a FlagProvider");
  },
  flagsError: null,
  setFlagsError: () => {
    console.error("setFlagsError() must be used within a FlagProvider");
  }
};
function f() {
  const e = M(A);
  return e || (console.error("useFlagContext() must be used within a FlagProvider"), O);
}
const L = (e) => {
  const { isEnabled: r, client: t } = f(), [a, u] = b(!!r(e)), s = k();
  return s.current = a, p(() => {
    if (!t)
      return;
    const l = () => {
      const n = r(e);
      n !== s.current && (s.current = n, u(!!n));
    }, o = () => {
      const n = r(e);
      s.current = n, u(n);
    };
    return t.on("update", l), t.on("ready", o), () => {
      t.off("update", l), t.off("ready", o);
    };
  }, [t]), a;
}, Y = () => {
  const { client: e } = f(), [r, t] = b(e.getAllToggles());
  return p(() => {
    const a = () => {
      t(e.getAllToggles());
    };
    return e.on("update", a), () => {
      e.off("update", a);
    };
  }, []), r;
}, j = () => {
  const { flagsReady: e, flagsError: r } = f();
  return { flagsReady: e, flagsError: r };
}, z = (e, r) => {
  var a, u, s, l;
  return !(e.name === (r == null ? void 0 : r.name) && e.enabled === (r == null ? void 0 : r.enabled) && e.feature_enabled === (r == null ? void 0 : r.feature_enabled) && ((a = e.payload) == null ? void 0 : a.type) === ((u = r == null ? void 0 : r.payload) == null ? void 0 : u.type) && ((s = e.payload) == null ? void 0 : s.value) === ((l = r == null ? void 0 : r.payload) == null ? void 0 : l.value));
}, G = (e) => {
  const { getVariant: r, client: t } = f(), [a, u] = b(r(e)), s = k({
    name: a.name,
    enabled: a.enabled
  });
  return s.current = a, p(() => {
    if (!t)
      return;
    const l = () => {
      const n = r(e);
      z(s.current, n) && (u(n), s.current = n);
    }, o = () => {
      const n = r(e);
      s.current.name = n == null ? void 0 : n.name, s.current.enabled = n == null ? void 0 : n.enabled, u(n);
    };
    return t.on("update", l), t.on("ready", o), () => {
      t.off("update", l), t.off("ready", o);
    };
  }, [t]), a || {};
}, J = () => {
  const { updateContext: e } = f();
  return e;
}, Q = () => {
  const { client: e } = f();
  return e;
};
export {
  A as FlagContext,
  K as FlagProvider,
  Z as InMemoryStorageProvider,
  $ as LocalStorageProvider,
  N as UnleashClient,
  K as default,
  L as useFlag,
  Y as useFlags,
  j as useFlagsStatus,
  Q as useUnleashClient,
  J as useUnleashContext,
  G as useVariant
};
//# sourceMappingURL=unleash-react.js.map
