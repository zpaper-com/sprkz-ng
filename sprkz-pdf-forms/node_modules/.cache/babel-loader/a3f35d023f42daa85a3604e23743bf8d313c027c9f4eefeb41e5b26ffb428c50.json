{"ast":null,"code":"import { getGlobalScope, getCurrentScope, addBreadcrumb, getClient, addNonEnumerableProperty } from '@sentry/core';\nconst ACTION_BREADCRUMB_CATEGORY = 'redux.action';\nconst ACTION_BREADCRUMB_TYPE = 'info';\nconst defaultOptions = {\n  attachReduxState: true,\n  actionTransformer: action => action,\n  stateTransformer: state => state || null\n};\n\n/**\n * Creates an enhancer that would be passed to Redux's createStore to log actions and the latest state to Sentry.\n *\n * @param enhancerOptions Options to pass to the enhancer\n */\nfunction createReduxEnhancer(enhancerOptions) {\n  // Note: We return an any type as to not have type conflicts.\n  const options = {\n    ...defaultOptions,\n    ...enhancerOptions\n  };\n  return next => (reducer, initialState) => {\n    options.attachReduxState && getGlobalScope().addEventProcessor((event, hint) => {\n      try {\n        // @ts-expect-error try catch to reduce bundle size\n        if (event.type === undefined && event.contexts.state.state.type === 'redux') {\n          hint.attachments = [...(hint.attachments || []),\n          // @ts-expect-error try catch to reduce bundle size\n          {\n            filename: 'redux_state.json',\n            data: JSON.stringify(event.contexts.state.state.value)\n          }];\n        }\n      } catch {\n        // empty\n      }\n      return event;\n    });\n    function sentryWrapReducer(reducer) {\n      return (state, action) => {\n        const newState = reducer(state, action);\n        const scope = getCurrentScope();\n\n        /* Action breadcrumbs */\n        const transformedAction = options.actionTransformer(action);\n        if (typeof transformedAction !== 'undefined' && transformedAction !== null) {\n          addBreadcrumb({\n            category: ACTION_BREADCRUMB_CATEGORY,\n            data: transformedAction,\n            type: ACTION_BREADCRUMB_TYPE\n          });\n        }\n\n        /* Set latest state to scope */\n        const transformedState = options.stateTransformer(newState);\n        if (typeof transformedState !== 'undefined' && transformedState !== null) {\n          const client = getClient();\n          const options = client?.getOptions();\n          const normalizationDepth = options?.normalizeDepth || 3; // default state normalization depth to 3\n\n          // Set the normalization depth of the redux state to the configured `normalizeDepth` option or a sane number as a fallback\n          const newStateContext = {\n            state: {\n              type: 'redux',\n              value: transformedState\n            }\n          };\n          addNonEnumerableProperty(newStateContext, '__sentry_override_normalization_depth__', 3 +\n          // 3 layers for `state.value.transformedState`\n          normalizationDepth // rest for the actual state\n          );\n          scope.setContext('state', newStateContext);\n        } else {\n          scope.setContext('state', null);\n        }\n\n        /* Allow user to configure scope with latest state */\n        const {\n          configureScopeWithState\n        } = options;\n        if (typeof configureScopeWithState === 'function') {\n          configureScopeWithState(scope, newState);\n        }\n        return newState;\n      };\n    }\n    const store = next(sentryWrapReducer(reducer), initialState);\n\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    store.replaceReducer = new Proxy(store.replaceReducer, {\n      apply: function (target, thisArg, args) {\n        target.apply(thisArg, [sentryWrapReducer(args[0])]);\n      }\n    });\n    return store;\n  };\n}\nexport { createReduxEnhancer };\n//# sourceMappingURL=redux.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}