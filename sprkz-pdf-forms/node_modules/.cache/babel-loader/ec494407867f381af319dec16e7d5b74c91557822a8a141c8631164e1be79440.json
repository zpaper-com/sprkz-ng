{"ast":null,"code":"import { consoleSandbox, getLocationHref } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { WINDOW } from '../helpers.js';\n\n/**\n * Returns true if the SDK is running in an embedded browser extension.\n * Stand-alone browser extensions (which do not share the same data as the main browser page) are fine.\n */\nfunction checkAndWarnIfIsEmbeddedBrowserExtension() {\n  if (_isEmbeddedBrowserExtension()) {\n    if (DEBUG_BUILD) {\n      consoleSandbox(() => {\n        // eslint-disable-next-line no-console\n        console.error('[Sentry] You cannot use Sentry.init() in a browser extension, see: https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/');\n      });\n    }\n    return true;\n  }\n  return false;\n}\nfunction _isEmbeddedBrowserExtension() {\n  if (typeof WINDOW.window === 'undefined') {\n    // No need to show the error if we're not in a browser window environment (e.g. service workers)\n    return false;\n  }\n  const _window = WINDOW;\n\n  // Running the SDK in NW.js, which appears like a browser extension but isn't, is also fine\n  // see: https://github.com/getsentry/sentry-javascript/issues/12668\n  if (_window.nw) {\n    return false;\n  }\n  const extensionObject = _window['chrome'] || _window['browser'];\n  if (!extensionObject?.runtime?.id) {\n    return false;\n  }\n  const href = getLocationHref();\n  const extensionProtocols = ['chrome-extension', 'moz-extension', 'ms-browser-extension', 'safari-web-extension'];\n\n  // Running the SDK in a dedicated extension page and calling Sentry.init is fine; no risk of data leakage\n  const isDedicatedExtensionPage = WINDOW === WINDOW.top && extensionProtocols.some(protocol => href.startsWith(`${protocol}://`));\n  return !isDedicatedExtensionPage;\n}\nexport { checkAndWarnIfIsEmbeddedBrowserExtension };\n//# sourceMappingURL=detectBrowserExtension.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}