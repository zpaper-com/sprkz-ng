{"ast":null,"code":"import { UNKNOWN_FUNCTION } from './stacktrace.js';\n\n/**\n * Does this filename look like it's part of the app code?\n */\nfunction filenameIsInApp(filename) {\n  let isNative = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const isInternal = isNative || filename &&\n  // It's not internal if it's an absolute linux path\n  !filename.startsWith('/') &&\n  // It's not internal if it's an absolute windows path\n  !filename.match(/^[A-Z]:/) &&\n  // It's not internal if the path is starting with a dot\n  !filename.startsWith('.') &&\n  // It's not internal if the frame has a protocol. In node, this is usually the case if the file got pre-processed with a bundler like webpack\n  !filename.match(/^[a-zA-Z]([a-zA-Z0-9.\\-+])*:\\/\\//); // Schema from: https://stackoverflow.com/a/3641782\n\n  // in_app is all that's not an internal Node function or a module within node_modules\n  // note that isNative appears to return true even for node core libraries\n  // see https://github.com/getsentry/raven-node/issues/176\n\n  return !isInternal && filename !== undefined && !filename.includes('node_modules/');\n}\n\n/** Node Stack line parser */\nfunction node(getModule) {\n  const FILENAME_MATCH = /^\\s*[-]{4,}$/;\n  const FULL_MATCH = /at (?:async )?(?:(.+?)\\s+\\()?(?:(.+):(\\d+):(\\d+)?|([^)]+))\\)?/;\n\n  // eslint-disable-next-line complexity\n  return line => {\n    const lineMatch = line.match(FULL_MATCH);\n    if (lineMatch) {\n      let object;\n      let method;\n      let functionName;\n      let typeName;\n      let methodName;\n      if (lineMatch[1]) {\n        functionName = lineMatch[1];\n        let methodStart = functionName.lastIndexOf('.');\n        if (functionName[methodStart - 1] === '.') {\n          methodStart--;\n        }\n        if (methodStart > 0) {\n          object = functionName.slice(0, methodStart);\n          method = functionName.slice(methodStart + 1);\n          const objectEnd = object.indexOf('.Module');\n          if (objectEnd > 0) {\n            functionName = functionName.slice(objectEnd + 1);\n            object = object.slice(0, objectEnd);\n          }\n        }\n        typeName = undefined;\n      }\n      if (method) {\n        typeName = object;\n        methodName = method;\n      }\n      if (method === '<anonymous>') {\n        methodName = undefined;\n        functionName = undefined;\n      }\n      if (functionName === undefined) {\n        methodName = methodName || UNKNOWN_FUNCTION;\n        functionName = typeName ? `${typeName}.${methodName}` : methodName;\n      }\n      let filename = lineMatch[2]?.startsWith('file://') ? lineMatch[2].slice(7) : lineMatch[2];\n      const isNative = lineMatch[5] === 'native';\n\n      // If it's a Windows path, trim the leading slash so that `/C:/foo` becomes `C:/foo`\n      if (filename?.match(/\\/[A-Z]:/)) {\n        filename = filename.slice(1);\n      }\n      if (!filename && lineMatch[5] && !isNative) {\n        filename = lineMatch[5];\n      }\n      return {\n        filename: filename ? decodeURI(filename) : undefined,\n        module: getModule ? getModule(filename) : undefined,\n        function: functionName,\n        lineno: _parseIntOrUndefined(lineMatch[3]),\n        colno: _parseIntOrUndefined(lineMatch[4]),\n        in_app: filenameIsInApp(filename || '', isNative)\n      };\n    }\n    if (line.match(FILENAME_MATCH)) {\n      return {\n        filename: line\n      };\n    }\n    return undefined;\n  };\n}\n\n/**\n * Node.js stack line parser\n *\n * This is in @sentry/core so it can be used from the Electron SDK in the browser for when `nodeIntegration == true`.\n * This allows it to be used without referencing or importing any node specific code which causes bundlers to complain\n */\nfunction nodeStackLineParser(getModule) {\n  return [90, node(getModule)];\n}\nfunction _parseIntOrUndefined(input) {\n  return parseInt(input || '', 10) || undefined;\n}\nexport { filenameIsInApp, node, nodeStackLineParser };\n//# sourceMappingURL=node-stack-trace.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}