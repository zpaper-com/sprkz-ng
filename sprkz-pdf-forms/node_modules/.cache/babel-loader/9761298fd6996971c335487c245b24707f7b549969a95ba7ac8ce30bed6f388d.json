{"ast":null,"code":"import { browserPerformanceTimeOrigin, spanToJSON, setMeasurement, getActiveSpan, parseUrl, stringMatchesSomePattern, isPrimitive, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, htmlTreeAsString, getComponentName } from '@sentry/core';\nimport { WINDOW } from '../types.js';\nimport { trackClsAsStandaloneSpan } from './cls.js';\nimport { addPerformanceInstrumentationHandler, addFidInstrumentationHandler, addLcpInstrumentationHandler, addTtfbInstrumentationHandler, addClsInstrumentationHandler } from './instrument.js';\nimport { trackLcpAsStandaloneSpan } from './lcp.js';\nimport { getBrowserPerformanceAPI, msToSec, startAndEndSpan, extractNetworkProtocol, isMeasurementValue } from './utils.js';\nimport { getActivationStart } from './web-vitals/lib/getActivationStart.js';\nimport { getNavigationEntry } from './web-vitals/lib/getNavigationEntry.js';\nimport { getVisibilityWatcher } from './web-vitals/lib/getVisibilityWatcher.js';\nconst MAX_INT_AS_BYTES = 2147483647;\nlet _performanceCursor = 0;\nlet _measurements = {};\nlet _lcpEntry;\nlet _clsEntry;\n\n/**\n * Start tracking web vitals.\n * The callback returned by this function can be used to stop tracking & ensure all measurements are final & captured.\n *\n * @returns A function that forces web vitals collection\n */\nfunction startTrackingWebVitals({\n  recordClsStandaloneSpans,\n  recordLcpStandaloneSpans,\n  client\n}) {\n  const performance = getBrowserPerformanceAPI();\n  if (performance && browserPerformanceTimeOrigin()) {\n    // @ts-expect-error we want to make sure all of these are available, even if TS is sure they are\n    if (performance.mark) {\n      WINDOW.performance.mark('sentry-tracing-init');\n    }\n    const fidCleanupCallback = _trackFID();\n    const lcpCleanupCallback = recordLcpStandaloneSpans ? trackLcpAsStandaloneSpan(client) : _trackLCP();\n    const ttfbCleanupCallback = _trackTtfb();\n    const clsCleanupCallback = recordClsStandaloneSpans ? trackClsAsStandaloneSpan(client) : _trackCLS();\n    return () => {\n      fidCleanupCallback();\n      lcpCleanupCallback?.();\n      ttfbCleanupCallback();\n      clsCleanupCallback?.();\n    };\n  }\n  return () => undefined;\n}\n\n/**\n * Start tracking long tasks.\n */\nfunction startTrackingLongTasks() {\n  addPerformanceInstrumentationHandler('longtask', ({\n    entries\n  }) => {\n    const parent = getActiveSpan();\n    if (!parent) {\n      return;\n    }\n    const {\n      op: parentOp,\n      start_timestamp: parentStartTimestamp\n    } = spanToJSON(parent);\n    for (const entry of entries) {\n      const startTime = msToSec(browserPerformanceTimeOrigin() + entry.startTime);\n      const duration = msToSec(entry.duration);\n      if (parentOp === 'navigation' && parentStartTimestamp && startTime < parentStartTimestamp) {\n        // Skip adding a span if the long task started before the navigation started.\n        // `startAndEndSpan` will otherwise adjust the parent's start time to the span's start\n        // time, potentially skewing the duration of the actual navigation as reported via our\n        // routing instrumentations\n        continue;\n      }\n      startAndEndSpan(parent, startTime, startTime + duration, {\n        name: 'Main UI thread blocked',\n        op: 'ui.long-task',\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics'\n        }\n      });\n    }\n  });\n}\n\n/**\n * Start tracking long animation frames.\n */\nfunction startTrackingLongAnimationFrames() {\n  // NOTE: the current web-vitals version (3.5.2) does not support long-animation-frame, so\n  // we directly observe `long-animation-frame` events instead of through the web-vitals\n  // `observe` helper function.\n  const observer = new PerformanceObserver(list => {\n    const parent = getActiveSpan();\n    if (!parent) {\n      return;\n    }\n    for (const entry of list.getEntries()) {\n      if (!entry.scripts[0]) {\n        continue;\n      }\n      const startTime = msToSec(browserPerformanceTimeOrigin() + entry.startTime);\n      const {\n        start_timestamp: parentStartTimestamp,\n        op: parentOp\n      } = spanToJSON(parent);\n      if (parentOp === 'navigation' && parentStartTimestamp && startTime < parentStartTimestamp) {\n        // Skip adding the span if the long animation frame started before the navigation started.\n        // `startAndEndSpan` will otherwise adjust the parent's start time to the span's start\n        // time, potentially skewing the duration of the actual navigation as reported via our\n        // routing instrumentations\n        continue;\n      }\n      const duration = msToSec(entry.duration);\n      const attributes = {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics'\n      };\n      const initialScript = entry.scripts[0];\n      const {\n        invoker,\n        invokerType,\n        sourceURL,\n        sourceFunctionName,\n        sourceCharPosition\n      } = initialScript;\n      attributes['browser.script.invoker'] = invoker;\n      attributes['browser.script.invoker_type'] = invokerType;\n      if (sourceURL) {\n        attributes['code.filepath'] = sourceURL;\n      }\n      if (sourceFunctionName) {\n        attributes['code.function'] = sourceFunctionName;\n      }\n      if (sourceCharPosition !== -1) {\n        attributes['browser.script.source_char_position'] = sourceCharPosition;\n      }\n      startAndEndSpan(parent, startTime, startTime + duration, {\n        name: 'Main UI thread blocked',\n        op: 'ui.long-animation-frame',\n        attributes\n      });\n    }\n  });\n  observer.observe({\n    type: 'long-animation-frame',\n    buffered: true\n  });\n}\n\n/**\n * Start tracking interaction events.\n */\nfunction startTrackingInteractions() {\n  addPerformanceInstrumentationHandler('event', ({\n    entries\n  }) => {\n    const parent = getActiveSpan();\n    if (!parent) {\n      return;\n    }\n    for (const entry of entries) {\n      if (entry.name === 'click') {\n        const startTime = msToSec(browserPerformanceTimeOrigin() + entry.startTime);\n        const duration = msToSec(entry.duration);\n        const spanOptions = {\n          name: htmlTreeAsString(entry.target),\n          op: `ui.interaction.${entry.name}`,\n          startTime: startTime,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics'\n          }\n        };\n        const componentName = getComponentName(entry.target);\n        if (componentName) {\n          spanOptions.attributes['ui.component_name'] = componentName;\n        }\n        startAndEndSpan(parent, startTime, startTime + duration, spanOptions);\n      }\n    }\n  });\n}\n\n/**\n * Starts tracking the Cumulative Layout Shift on the current page and collects the value and last entry\n * to the `_measurements` object which ultimately is applied to the pageload span's measurements.\n */\nfunction _trackCLS() {\n  return addClsInstrumentationHandler(({\n    metric\n  }) => {\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n    _measurements['cls'] = {\n      value: metric.value,\n      unit: ''\n    };\n    _clsEntry = entry;\n  }, true);\n}\n\n/** Starts tracking the Largest Contentful Paint on the current page. */\nfunction _trackLCP() {\n  return addLcpInstrumentationHandler(({\n    metric\n  }) => {\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n    _measurements['lcp'] = {\n      value: metric.value,\n      unit: 'millisecond'\n    };\n    _lcpEntry = entry;\n  }, true);\n}\n\n/** Starts tracking the First Input Delay on the current page. */\nfunction _trackFID() {\n  return addFidInstrumentationHandler(({\n    metric\n  }) => {\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n    const timeOrigin = msToSec(browserPerformanceTimeOrigin());\n    const startTime = msToSec(entry.startTime);\n    _measurements['fid'] = {\n      value: metric.value,\n      unit: 'millisecond'\n    };\n    _measurements['mark.fid'] = {\n      value: timeOrigin + startTime,\n      unit: 'second'\n    };\n  });\n}\nfunction _trackTtfb() {\n  return addTtfbInstrumentationHandler(({\n    metric\n  }) => {\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n    _measurements['ttfb'] = {\n      value: metric.value,\n      unit: 'millisecond'\n    };\n  });\n}\n\n/** Add performance related spans to a transaction */\nfunction addPerformanceEntries(span, options) {\n  const performance = getBrowserPerformanceAPI();\n  const origin = browserPerformanceTimeOrigin();\n  if (!performance?.getEntries || !origin) {\n    // Gatekeeper if performance API not available\n    return;\n  }\n  const timeOrigin = msToSec(origin);\n  const performanceEntries = performance.getEntries();\n  const {\n    op,\n    start_timestamp: transactionStartTime\n  } = spanToJSON(span);\n  performanceEntries.slice(_performanceCursor).forEach(entry => {\n    const startTime = msToSec(entry.startTime);\n    const duration = msToSec(\n    // Inexplicably, Chrome sometimes emits a negative duration. We need to work around this.\n    // There is a SO post attempting to explain this, but it leaves one with open questions: https://stackoverflow.com/questions/23191918/peformance-getentries-and-negative-duration-display\n    // The way we clamp the value is probably not accurate, since we have observed this happen for things that may take a while to load, like for example the replay worker.\n    // TODO: Investigate why this happens and how to properly mitigate. For now, this is a workaround to prevent transactions being dropped due to negative duration spans.\n    Math.max(0, entry.duration));\n    if (op === 'navigation' && transactionStartTime && timeOrigin + startTime < transactionStartTime) {\n      return;\n    }\n    switch (entry.entryType) {\n      case 'navigation':\n        {\n          _addNavigationSpans(span, entry, timeOrigin);\n          break;\n        }\n      case 'mark':\n      case 'paint':\n      case 'measure':\n        {\n          _addMeasureSpans(span, entry, startTime, duration, timeOrigin, options.ignorePerformanceApiSpans);\n\n          // capture web vitals\n          const firstHidden = getVisibilityWatcher();\n          // Only report if the page wasn't hidden prior to the web vital.\n          const shouldRecord = entry.startTime < firstHidden.firstHiddenTime;\n          if (entry.name === 'first-paint' && shouldRecord) {\n            _measurements['fp'] = {\n              value: entry.startTime,\n              unit: 'millisecond'\n            };\n          }\n          if (entry.name === 'first-contentful-paint' && shouldRecord) {\n            _measurements['fcp'] = {\n              value: entry.startTime,\n              unit: 'millisecond'\n            };\n          }\n          break;\n        }\n      case 'resource':\n        {\n          _addResourceSpans(span, entry, entry.name, startTime, duration, timeOrigin, options.ignoreResourceSpans);\n          break;\n        }\n      // Ignore other entry types.\n    }\n  });\n  _performanceCursor = Math.max(performanceEntries.length - 1, 0);\n  _trackNavigator(span);\n\n  // Measurements are only available for pageload transactions\n  if (op === 'pageload') {\n    _addTtfbRequestTimeToMeasurements(_measurements);\n    const fidMark = _measurements['mark.fid'];\n    if (fidMark && _measurements['fid']) {\n      // create span for FID\n      startAndEndSpan(span, fidMark.value, fidMark.value + msToSec(_measurements['fid'].value), {\n        name: 'first input delay',\n        op: 'ui.action',\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics'\n        }\n      });\n\n      // Delete mark.fid as we don't want it to be part of final payload\n      delete _measurements['mark.fid'];\n    }\n\n    // If FCP is not recorded we should not record the cls value\n    // according to the new definition of CLS.\n    // TODO: Check if the first condition is still necessary: `onCLS` already only fires once `onFCP` was called.\n    if (!('fcp' in _measurements) || !options.recordClsOnPageloadSpan) {\n      delete _measurements.cls;\n    }\n\n    // If LCP standalone spans are enabled, don't record LCP as a measurement\n    if (!options.recordLcpOnPageloadSpan) {\n      delete _measurements.lcp;\n    }\n    Object.entries(_measurements).forEach(([measurementName, measurement]) => {\n      setMeasurement(measurementName, measurement.value, measurement.unit);\n    });\n\n    // Set timeOrigin which denotes the timestamp which to base the LCP/FCP/FP/TTFB measurements on\n    span.setAttribute('performance.timeOrigin', timeOrigin);\n\n    // In prerendering scenarios, where a page might be prefetched and pre-rendered before the user clicks the link,\n    // the navigation starts earlier than when the user clicks it. Web Vitals should always be based on the\n    // user-perceived time, so they are not reported from the actual start of the navigation, but rather from the\n    // time where the user actively started the navigation, for example by clicking a link.\n    // This is user action is called \"activation\" and the time between navigation and activation is stored in\n    // the `activationStart` attribute of the \"navigation\" PerformanceEntry.\n    span.setAttribute('performance.activationStart', getActivationStart());\n    _setWebVitalAttributes(span, options);\n  }\n  _lcpEntry = undefined;\n  _clsEntry = undefined;\n  _measurements = {};\n}\n\n/**\n * Create measure related spans.\n * Exported only for tests.\n */\nfunction _addMeasureSpans(span, entry, startTime, duration, timeOrigin, ignorePerformanceApiSpans) {\n  if (['mark', 'measure'].includes(entry.entryType) && stringMatchesSomePattern(entry.name, ignorePerformanceApiSpans)) {\n    return;\n  }\n  const navEntry = getNavigationEntry(false);\n  const requestTime = msToSec(navEntry ? navEntry.requestStart : 0);\n  // Because performance.measure accepts arbitrary timestamps it can produce\n  // spans that happen before the browser even makes a request for the page.\n  //\n  // An example of this is the automatically generated Next.js-before-hydration\n  // spans created by the Next.js framework.\n  //\n  // To prevent this we will pin the start timestamp to the request start time\n  // This does make duration inaccurate, so if this does happen, we will add\n  // an attribute to the span\n  const measureStartTimestamp = timeOrigin + Math.max(startTime, requestTime);\n  const startTimeStamp = timeOrigin + startTime;\n  const measureEndTimestamp = startTimeStamp + duration;\n  const attributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.resource.browser.metrics'\n  };\n  if (measureStartTimestamp !== startTimeStamp) {\n    attributes['sentry.browser.measure_happened_before_request'] = true;\n    attributes['sentry.browser.measure_start_time'] = measureStartTimestamp;\n  }\n  _addDetailToSpanAttributes(attributes, entry);\n\n  // Measurements from third parties can be off, which would create invalid spans, dropping transactions in the process.\n  if (measureStartTimestamp <= measureEndTimestamp) {\n    startAndEndSpan(span, measureStartTimestamp, measureEndTimestamp, {\n      name: entry.name,\n      op: entry.entryType,\n      attributes\n    });\n  }\n}\nfunction _addDetailToSpanAttributes(attributes, performanceMeasure) {\n  try {\n    // Accessing detail might throw in some browsers (e.g., Firefox) due to security restrictions\n    const detail = performanceMeasure.detail;\n    if (!detail) {\n      return;\n    }\n\n    // Process detail based on its type\n    if (typeof detail === 'object') {\n      // Handle object details\n      for (const [key, value] of Object.entries(detail)) {\n        if (value && isPrimitive(value)) {\n          attributes[`sentry.browser.measure.detail.${key}`] = value;\n        } else if (value !== undefined) {\n          try {\n            // This is user defined so we can't guarantee it's serializable\n            attributes[`sentry.browser.measure.detail.${key}`] = JSON.stringify(value);\n          } catch {\n            // Skip values that can't be stringified\n          }\n        }\n      }\n      return;\n    }\n    if (isPrimitive(detail)) {\n      // Handle primitive details\n      attributes['sentry.browser.measure.detail'] = detail;\n      return;\n    }\n    try {\n      attributes['sentry.browser.measure.detail'] = JSON.stringify(detail);\n    } catch {\n      // Skip if stringification fails\n    }\n  } catch {\n    // Silently ignore any errors when accessing detail\n    // This handles the Firefox \"Permission denied to access object\" error\n  }\n}\n\n/**\n * Instrument navigation entries\n * exported only for tests\n */\nfunction _addNavigationSpans(span, entry, timeOrigin) {\n  ['unloadEvent', 'redirect', 'domContentLoadedEvent', 'loadEvent', 'connect'].forEach(event => {\n    _addPerformanceNavigationTiming(span, entry, event, timeOrigin);\n  });\n  _addPerformanceNavigationTiming(span, entry, 'secureConnection', timeOrigin, 'TLS/SSL');\n  _addPerformanceNavigationTiming(span, entry, 'fetch', timeOrigin, 'cache');\n  _addPerformanceNavigationTiming(span, entry, 'domainLookup', timeOrigin, 'DNS');\n  _addRequest(span, entry, timeOrigin);\n}\n\n/** Create performance navigation related spans */\nfunction _addPerformanceNavigationTiming(span, entry, event, timeOrigin, name = event) {\n  const eventEnd = _getEndPropertyNameForNavigationTiming(event);\n  const end = entry[eventEnd];\n  const start = entry[`${event}Start`];\n  if (!start || !end) {\n    return;\n  }\n  startAndEndSpan(span, timeOrigin + msToSec(start), timeOrigin + msToSec(end), {\n    op: `browser.${name}`,\n    name: entry.name,\n    attributes: {\n      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n      ...(event === 'redirect' && entry.redirectCount != null ? {\n        'http.redirect_count': entry.redirectCount\n      } : {})\n    }\n  });\n}\nfunction _getEndPropertyNameForNavigationTiming(event) {\n  if (event === 'secureConnection') {\n    return 'connectEnd';\n  }\n  if (event === 'fetch') {\n    return 'domainLookupStart';\n  }\n  return `${event}End`;\n}\n\n/** Create request and response related spans */\nfunction _addRequest(span, entry, timeOrigin) {\n  const requestStartTimestamp = timeOrigin + msToSec(entry.requestStart);\n  const responseEndTimestamp = timeOrigin + msToSec(entry.responseEnd);\n  const responseStartTimestamp = timeOrigin + msToSec(entry.responseStart);\n  if (entry.responseEnd) {\n    // It is possible that we are collecting these metrics when the page hasn't finished loading yet, for example when the HTML slowly streams in.\n    // In this case, ie. when the document request hasn't finished yet, `entry.responseEnd` will be 0.\n    // In order not to produce faulty spans, where the end timestamp is before the start timestamp, we will only collect\n    // these spans when the responseEnd value is available. The backend (Relay) would drop the entire span if it contained faulty spans.\n    startAndEndSpan(span, requestStartTimestamp, responseEndTimestamp, {\n      op: 'browser.request',\n      name: entry.name,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics'\n      }\n    });\n    startAndEndSpan(span, responseStartTimestamp, responseEndTimestamp, {\n      op: 'browser.response',\n      name: entry.name,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics'\n      }\n    });\n  }\n}\n\n/**\n * Create resource-related spans.\n * Exported only for tests.\n */\nfunction _addResourceSpans(span, entry, resourceUrl, startTime, duration, timeOrigin, ignoreResourceSpans) {\n  // we already instrument based on fetch and xhr, so we don't need to\n  // duplicate spans here.\n  if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {\n    return;\n  }\n  const op = entry.initiatorType ? `resource.${entry.initiatorType}` : 'resource.other';\n  if (ignoreResourceSpans?.includes(op)) {\n    return;\n  }\n  const parsedUrl = parseUrl(resourceUrl);\n  const attributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.resource.browser.metrics'\n  };\n  setResourceEntrySizeData(attributes, entry, 'transferSize', 'http.response_transfer_size');\n  setResourceEntrySizeData(attributes, entry, 'encodedBodySize', 'http.response_content_length');\n  setResourceEntrySizeData(attributes, entry, 'decodedBodySize', 'http.decoded_response_content_length');\n\n  // `deliveryType` is experimental and does not exist everywhere\n  const deliveryType = entry.deliveryType;\n  if (deliveryType != null) {\n    attributes['http.response_delivery_type'] = deliveryType;\n  }\n\n  // Types do not reflect this property yet\n  const renderBlockingStatus = entry.renderBlockingStatus;\n  if (renderBlockingStatus) {\n    attributes['resource.render_blocking_status'] = renderBlockingStatus;\n  }\n  if (parsedUrl.protocol) {\n    attributes['url.scheme'] = parsedUrl.protocol.split(':').pop(); // the protocol returned by parseUrl includes a :, but OTEL spec does not, so we remove it.\n  }\n  if (parsedUrl.host) {\n    attributes['server.address'] = parsedUrl.host;\n  }\n  attributes['url.same_origin'] = resourceUrl.includes(WINDOW.location.origin);\n\n  // Checking for only `undefined` and `null` is intentional because it's\n  // valid for `nextHopProtocol` to be an empty string.\n  if (entry.nextHopProtocol != null) {\n    const {\n      name,\n      version\n    } = extractNetworkProtocol(entry.nextHopProtocol);\n    attributes['network.protocol.name'] = name;\n    attributes['network.protocol.version'] = version;\n  }\n  const startTimestamp = timeOrigin + startTime;\n  const endTimestamp = startTimestamp + duration;\n  startAndEndSpan(span, startTimestamp, endTimestamp, {\n    name: resourceUrl.replace(WINDOW.location.origin, ''),\n    op,\n    attributes\n  });\n}\n\n/**\n * Capture the information of the user agent.\n */\nfunction _trackNavigator(span) {\n  const navigator = WINDOW.navigator;\n  if (!navigator) {\n    return;\n  }\n\n  // track network connectivity\n  const connection = navigator.connection;\n  if (connection) {\n    if (connection.effectiveType) {\n      span.setAttribute('effectiveConnectionType', connection.effectiveType);\n    }\n    if (connection.type) {\n      span.setAttribute('connectionType', connection.type);\n    }\n    if (isMeasurementValue(connection.rtt)) {\n      _measurements['connection.rtt'] = {\n        value: connection.rtt,\n        unit: 'millisecond'\n      };\n    }\n  }\n  if (isMeasurementValue(navigator.deviceMemory)) {\n    span.setAttribute('deviceMemory', `${navigator.deviceMemory} GB`);\n  }\n  if (isMeasurementValue(navigator.hardwareConcurrency)) {\n    span.setAttribute('hardwareConcurrency', String(navigator.hardwareConcurrency));\n  }\n}\n\n/** Add LCP / CLS data to span to allow debugging */\nfunction _setWebVitalAttributes(span, options) {\n  // Only add LCP attributes if LCP is being recorded on the pageload span\n  if (_lcpEntry && options.recordLcpOnPageloadSpan) {\n    // Capture Properties of the LCP element that contributes to the LCP.\n\n    if (_lcpEntry.element) {\n      span.setAttribute('lcp.element', htmlTreeAsString(_lcpEntry.element));\n    }\n    if (_lcpEntry.id) {\n      span.setAttribute('lcp.id', _lcpEntry.id);\n    }\n    if (_lcpEntry.url) {\n      // Trim URL to the first 200 characters.\n      span.setAttribute('lcp.url', _lcpEntry.url.trim().slice(0, 200));\n    }\n    if (_lcpEntry.loadTime != null) {\n      // loadTime is the time of LCP that's related to receiving the LCP element response..\n      span.setAttribute('lcp.loadTime', _lcpEntry.loadTime);\n    }\n    if (_lcpEntry.renderTime != null) {\n      // renderTime is loadTime + rendering time\n      // it's 0 if the LCP element is loaded from a 3rd party origin that doesn't send the\n      // `Timing-Allow-Origin` header.\n      span.setAttribute('lcp.renderTime', _lcpEntry.renderTime);\n    }\n    span.setAttribute('lcp.size', _lcpEntry.size);\n  }\n\n  // Only add CLS attributes if CLS is being recorded on the pageload span\n  if (_clsEntry?.sources && options.recordClsOnPageloadSpan) {\n    _clsEntry.sources.forEach((source, index) => span.setAttribute(`cls.source.${index + 1}`, htmlTreeAsString(source.node)));\n  }\n}\nfunction setResourceEntrySizeData(attributes, entry, key, dataKey) {\n  const entryVal = entry[key];\n  if (entryVal != null && entryVal < MAX_INT_AS_BYTES) {\n    attributes[dataKey] = entryVal;\n  }\n}\n\n/**\n * Add ttfb request time information to measurements.\n *\n * ttfb information is added via vendored web vitals library.\n */\nfunction _addTtfbRequestTimeToMeasurements(_measurements) {\n  const navEntry = getNavigationEntry(false);\n  if (!navEntry) {\n    return;\n  }\n  const {\n    responseStart,\n    requestStart\n  } = navEntry;\n  if (requestStart <= responseStart) {\n    _measurements['ttfb.requestTime'] = {\n      value: responseStart - requestStart,\n      unit: 'millisecond'\n    };\n  }\n}\nexport { _addMeasureSpans, _addNavigationSpans, _addResourceSpans, addPerformanceEntries, startTrackingInteractions, startTrackingLongAnimationFrames, startTrackingLongTasks, startTrackingWebVitals };","map":{"version":3,"names":["MAX_INT_AS_BYTES","_performanceCursor","_measurements","_lcpEntry","_clsEntry","startTrackingWebVitals","recordClsStandaloneSpans","recordLcpStandaloneSpans","client","performance","getBrowserPerformanceAPI","browserPerformanceTimeOrigin","mark","WINDOW","fidCleanupCallback","_trackFID","lcpCleanupCallback","trackLcpAsStandaloneSpan","_trackLCP","ttfbCleanupCallback","_trackTtfb","clsCleanupCallback","trackClsAsStandaloneSpan","_trackCLS","undefined","startTrackingLongTasks","addPerformanceInstrumentationHandler","entries","parent","getActiveSpan","op","parentOp","start_timestamp","parentStartTimestamp","spanToJSON","entry","startTime","msToSec","duration","startAndEndSpan","name","attributes","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","startTrackingLongAnimationFrames","observer","PerformanceObserver","list","getEntries","scripts","initialScript","invoker","invokerType","sourceURL","sourceFunctionName","sourceCharPosition","observe","type","buffered","startTrackingInteractions","spanOptions","htmlTreeAsString","target","componentName","getComponentName","addClsInstrumentationHandler","metric","length","value","unit","addLcpInstrumentationHandler","addFidInstrumentationHandler","timeOrigin","addTtfbInstrumentationHandler","addPerformanceEntries","span","options","origin","performanceEntries","transactionStartTime","slice","forEach","Math","max","entryType","_addNavigationSpans","_addMeasureSpans","ignorePerformanceApiSpans","firstHidden","getVisibilityWatcher","shouldRecord","firstHiddenTime","_addResourceSpans","ignoreResourceSpans","_trackNavigator","_addTtfbRequestTimeToMeasurements","fidMark","recordClsOnPageloadSpan","cls","recordLcpOnPageloadSpan","lcp","Object","measurementName","measurement","setMeasurement","setAttribute","getActivationStart","_setWebVitalAttributes","includes","stringMatchesSomePattern","navEntry","getNavigationEntry","requestTime","requestStart","measureStartTimestamp","startTimeStamp","measureEndTimestamp","_addDetailToSpanAttributes","performanceMeasure","detail","key","isPrimitive","JSON","stringify","event","_addPerformanceNavigationTiming","_addRequest","eventEnd","_getEndPropertyNameForNavigationTiming","end","start","redirectCount","requestStartTimestamp","responseEndTimestamp","responseEnd","responseStartTimestamp","responseStart","resourceUrl","initiatorType","parsedUrl","parseUrl","setResourceEntrySizeData","deliveryType","renderBlockingStatus","protocol","split","pop","host","location","nextHopProtocol","version","extractNetworkProtocol","startTimestamp","endTimestamp","replace","navigator","connection","effectiveType","isMeasurementValue","rtt","deviceMemory","hardwareConcurrency","String","element","id","url","trim","loadTime","renderTime","size","sources","source","index","node","dataKey","entryVal"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry-internal/browser-utils/src/metrics/browserMetrics.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport type { Client, Measurements, Span, SpanAttributes, SpanAttributeValue, StartSpanOptions } from '@sentry/core';\nimport {\n  browserPerformanceTimeOrigin,\n  getActiveSpan,\n  getComponentName,\n  htmlTreeAsString,\n  isPrimitive,\n  parseUrl,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  setMeasurement,\n  spanToJSON,\n  stringMatchesSomePattern,\n} from '@sentry/core';\nimport { WINDOW } from '../types';\nimport { trackClsAsStandaloneSpan } from './cls';\nimport {\n  type PerformanceLongAnimationFrameTiming,\n  addClsInstrumentationHandler,\n  addFidInstrumentationHandler,\n  addLcpInstrumentationHandler,\n  addPerformanceInstrumentationHandler,\n  addTtfbInstrumentationHandler,\n} from './instrument';\nimport { trackLcpAsStandaloneSpan } from './lcp';\nimport {\n  extractNetworkProtocol,\n  getBrowserPerformanceAPI,\n  isMeasurementValue,\n  msToSec,\n  startAndEndSpan,\n} from './utils';\nimport { getActivationStart } from './web-vitals/lib/getActivationStart';\nimport { getNavigationEntry } from './web-vitals/lib/getNavigationEntry';\nimport { getVisibilityWatcher } from './web-vitals/lib/getVisibilityWatcher';\n\ninterface NavigatorNetworkInformation {\n  readonly connection?: NetworkInformation;\n}\n\n// http://wicg.github.io/netinfo/#connection-types\ntype ConnectionType = 'bluetooth' | 'cellular' | 'ethernet' | 'mixed' | 'none' | 'other' | 'unknown' | 'wifi' | 'wimax';\n\n// http://wicg.github.io/netinfo/#effectiveconnectiontype-enum\ntype EffectiveConnectionType = '2g' | '3g' | '4g' | 'slow-2g';\n\n// http://wicg.github.io/netinfo/#dom-megabit\ntype Megabit = number;\n// http://wicg.github.io/netinfo/#dom-millisecond\ntype Millisecond = number;\n\n// http://wicg.github.io/netinfo/#networkinformation-interface\ninterface NetworkInformation extends EventTarget {\n  // http://wicg.github.io/netinfo/#type-attribute\n  readonly type?: ConnectionType;\n  // http://wicg.github.io/netinfo/#effectivetype-attribute\n  readonly effectiveType?: EffectiveConnectionType;\n  // http://wicg.github.io/netinfo/#downlinkmax-attribute\n  readonly downlinkMax?: Megabit;\n  // http://wicg.github.io/netinfo/#downlink-attribute\n  readonly downlink?: Megabit;\n  // http://wicg.github.io/netinfo/#rtt-attribute\n  readonly rtt?: Millisecond;\n  // http://wicg.github.io/netinfo/#savedata-attribute\n  readonly saveData?: boolean;\n  // http://wicg.github.io/netinfo/#handling-changes-to-the-underlying-connection\n  onchange?: EventListener;\n}\n\n// https://w3c.github.io/device-memory/#sec-device-memory-js-api\ninterface NavigatorDeviceMemory {\n  readonly deviceMemory?: number;\n}\n\nconst MAX_INT_AS_BYTES = 2147483647;\n\nlet _performanceCursor: number = 0;\n\nlet _measurements: Measurements = {};\nlet _lcpEntry: LargestContentfulPaint | undefined;\nlet _clsEntry: LayoutShift | undefined;\n\ninterface StartTrackingWebVitalsOptions {\n  recordClsStandaloneSpans: boolean;\n  recordLcpStandaloneSpans: boolean;\n  client: Client;\n}\n\n/**\n * Start tracking web vitals.\n * The callback returned by this function can be used to stop tracking & ensure all measurements are final & captured.\n *\n * @returns A function that forces web vitals collection\n */\nexport function startTrackingWebVitals({\n  recordClsStandaloneSpans,\n  recordLcpStandaloneSpans,\n  client,\n}: StartTrackingWebVitalsOptions): () => void {\n  const performance = getBrowserPerformanceAPI();\n  if (performance && browserPerformanceTimeOrigin()) {\n    // @ts-expect-error we want to make sure all of these are available, even if TS is sure they are\n    if (performance.mark) {\n      WINDOW.performance.mark('sentry-tracing-init');\n    }\n    const fidCleanupCallback = _trackFID();\n    const lcpCleanupCallback = recordLcpStandaloneSpans ? trackLcpAsStandaloneSpan(client) : _trackLCP();\n    const ttfbCleanupCallback = _trackTtfb();\n    const clsCleanupCallback = recordClsStandaloneSpans ? trackClsAsStandaloneSpan(client) : _trackCLS();\n\n    return (): void => {\n      fidCleanupCallback();\n      lcpCleanupCallback?.();\n      ttfbCleanupCallback();\n      clsCleanupCallback?.();\n    };\n  }\n\n  return () => undefined;\n}\n\n/**\n * Start tracking long tasks.\n */\nexport function startTrackingLongTasks(): void {\n  addPerformanceInstrumentationHandler('longtask', ({ entries }) => {\n    const parent = getActiveSpan();\n    if (!parent) {\n      return;\n    }\n\n    const { op: parentOp, start_timestamp: parentStartTimestamp } = spanToJSON(parent);\n\n    for (const entry of entries) {\n      const startTime = msToSec((browserPerformanceTimeOrigin() as number) + entry.startTime);\n      const duration = msToSec(entry.duration);\n\n      if (parentOp === 'navigation' && parentStartTimestamp && startTime < parentStartTimestamp) {\n        // Skip adding a span if the long task started before the navigation started.\n        // `startAndEndSpan` will otherwise adjust the parent's start time to the span's start\n        // time, potentially skewing the duration of the actual navigation as reported via our\n        // routing instrumentations\n        continue;\n      }\n\n      startAndEndSpan(parent, startTime, startTime + duration, {\n        name: 'Main UI thread blocked',\n        op: 'ui.long-task',\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n        },\n      });\n    }\n  });\n}\n\n/**\n * Start tracking long animation frames.\n */\nexport function startTrackingLongAnimationFrames(): void {\n  // NOTE: the current web-vitals version (3.5.2) does not support long-animation-frame, so\n  // we directly observe `long-animation-frame` events instead of through the web-vitals\n  // `observe` helper function.\n  const observer = new PerformanceObserver(list => {\n    const parent = getActiveSpan();\n    if (!parent) {\n      return;\n    }\n    for (const entry of list.getEntries() as PerformanceLongAnimationFrameTiming[]) {\n      if (!entry.scripts[0]) {\n        continue;\n      }\n\n      const startTime = msToSec((browserPerformanceTimeOrigin() as number) + entry.startTime);\n\n      const { start_timestamp: parentStartTimestamp, op: parentOp } = spanToJSON(parent);\n\n      if (parentOp === 'navigation' && parentStartTimestamp && startTime < parentStartTimestamp) {\n        // Skip adding the span if the long animation frame started before the navigation started.\n        // `startAndEndSpan` will otherwise adjust the parent's start time to the span's start\n        // time, potentially skewing the duration of the actual navigation as reported via our\n        // routing instrumentations\n        continue;\n      }\n      const duration = msToSec(entry.duration);\n\n      const attributes: SpanAttributes = {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n      };\n\n      const initialScript = entry.scripts[0];\n      const { invoker, invokerType, sourceURL, sourceFunctionName, sourceCharPosition } = initialScript;\n      attributes['browser.script.invoker'] = invoker;\n      attributes['browser.script.invoker_type'] = invokerType;\n      if (sourceURL) {\n        attributes['code.filepath'] = sourceURL;\n      }\n      if (sourceFunctionName) {\n        attributes['code.function'] = sourceFunctionName;\n      }\n      if (sourceCharPosition !== -1) {\n        attributes['browser.script.source_char_position'] = sourceCharPosition;\n      }\n\n      startAndEndSpan(parent, startTime, startTime + duration, {\n        name: 'Main UI thread blocked',\n        op: 'ui.long-animation-frame',\n        attributes,\n      });\n    }\n  });\n\n  observer.observe({ type: 'long-animation-frame', buffered: true });\n}\n\n/**\n * Start tracking interaction events.\n */\nexport function startTrackingInteractions(): void {\n  addPerformanceInstrumentationHandler('event', ({ entries }) => {\n    const parent = getActiveSpan();\n    if (!parent) {\n      return;\n    }\n    for (const entry of entries) {\n      if (entry.name === 'click') {\n        const startTime = msToSec((browserPerformanceTimeOrigin() as number) + entry.startTime);\n        const duration = msToSec(entry.duration);\n\n        const spanOptions: StartSpanOptions & Required<Pick<StartSpanOptions, 'attributes'>> = {\n          name: htmlTreeAsString(entry.target),\n          op: `ui.interaction.${entry.name}`,\n          startTime: startTime,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n          },\n        };\n\n        const componentName = getComponentName(entry.target);\n        if (componentName) {\n          spanOptions.attributes['ui.component_name'] = componentName;\n        }\n\n        startAndEndSpan(parent, startTime, startTime + duration, spanOptions);\n      }\n    }\n  });\n}\n\nexport { registerInpInteractionListener, startTrackingINP } from './inp';\n\n/**\n * Starts tracking the Cumulative Layout Shift on the current page and collects the value and last entry\n * to the `_measurements` object which ultimately is applied to the pageload span's measurements.\n */\nfunction _trackCLS(): () => void {\n  return addClsInstrumentationHandler(({ metric }) => {\n    const entry = metric.entries[metric.entries.length - 1] as LayoutShift | undefined;\n    if (!entry) {\n      return;\n    }\n    _measurements['cls'] = { value: metric.value, unit: '' };\n    _clsEntry = entry;\n  }, true);\n}\n\n/** Starts tracking the Largest Contentful Paint on the current page. */\nfunction _trackLCP(): () => void {\n  return addLcpInstrumentationHandler(({ metric }) => {\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n\n    _measurements['lcp'] = { value: metric.value, unit: 'millisecond' };\n    _lcpEntry = entry as LargestContentfulPaint;\n  }, true);\n}\n\n/** Starts tracking the First Input Delay on the current page. */\nfunction _trackFID(): () => void {\n  return addFidInstrumentationHandler(({ metric }) => {\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n\n    const timeOrigin = msToSec(browserPerformanceTimeOrigin() as number);\n    const startTime = msToSec(entry.startTime);\n    _measurements['fid'] = { value: metric.value, unit: 'millisecond' };\n    _measurements['mark.fid'] = { value: timeOrigin + startTime, unit: 'second' };\n  });\n}\n\nfunction _trackTtfb(): () => void {\n  return addTtfbInstrumentationHandler(({ metric }) => {\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n\n    _measurements['ttfb'] = { value: metric.value, unit: 'millisecond' };\n  });\n}\n\ninterface AddPerformanceEntriesOptions {\n  /**\n   * Flag to determine if CLS should be recorded as a measurement on the pageload span or\n   * sent as a standalone span instead.\n   * Sending it as a standalone span will yield more accurate LCP values.\n   *\n   * Default: `false` for backwards compatibility.\n   */\n  recordClsOnPageloadSpan: boolean;\n\n  /**\n   * Flag to determine if LCP should be recorded as a measurement on the pageload span or\n   * sent as a standalone span instead.\n   * Sending it as a standalone span will yield more accurate LCP values.\n   *\n   * Default: `false` for backwards compatibility.\n   */\n  recordLcpOnPageloadSpan: boolean;\n\n  /**\n   * Resource spans with `op`s matching strings in the array will not be emitted.\n   *\n   * Default: []\n   */\n  ignoreResourceSpans: Array<'resouce.script' | 'resource.css' | 'resource.img' | 'resource.other' | string>;\n\n  /**\n   * Performance spans created from browser Performance APIs,\n   * `performance.mark(...)` nand `performance.measure(...)`\n   * with `name`s matching strings in the array will not be emitted.\n   *\n   * Default: []\n   */\n  ignorePerformanceApiSpans: Array<string | RegExp>;\n}\n\n/** Add performance related spans to a transaction */\nexport function addPerformanceEntries(span: Span, options: AddPerformanceEntriesOptions): void {\n  const performance = getBrowserPerformanceAPI();\n  const origin = browserPerformanceTimeOrigin();\n  if (!performance?.getEntries || !origin) {\n    // Gatekeeper if performance API not available\n    return;\n  }\n\n  const timeOrigin = msToSec(origin);\n\n  const performanceEntries = performance.getEntries();\n\n  const { op, start_timestamp: transactionStartTime } = spanToJSON(span);\n\n  performanceEntries.slice(_performanceCursor).forEach(entry => {\n    const startTime = msToSec(entry.startTime);\n    const duration = msToSec(\n      // Inexplicably, Chrome sometimes emits a negative duration. We need to work around this.\n      // There is a SO post attempting to explain this, but it leaves one with open questions: https://stackoverflow.com/questions/23191918/peformance-getentries-and-negative-duration-display\n      // The way we clamp the value is probably not accurate, since we have observed this happen for things that may take a while to load, like for example the replay worker.\n      // TODO: Investigate why this happens and how to properly mitigate. For now, this is a workaround to prevent transactions being dropped due to negative duration spans.\n      Math.max(0, entry.duration),\n    );\n\n    if (op === 'navigation' && transactionStartTime && timeOrigin + startTime < transactionStartTime) {\n      return;\n    }\n\n    switch (entry.entryType) {\n      case 'navigation': {\n        _addNavigationSpans(span, entry as PerformanceNavigationTiming, timeOrigin);\n        break;\n      }\n      case 'mark':\n      case 'paint':\n      case 'measure': {\n        _addMeasureSpans(span, entry, startTime, duration, timeOrigin, options.ignorePerformanceApiSpans);\n\n        // capture web vitals\n        const firstHidden = getVisibilityWatcher();\n        // Only report if the page wasn't hidden prior to the web vital.\n        const shouldRecord = entry.startTime < firstHidden.firstHiddenTime;\n\n        if (entry.name === 'first-paint' && shouldRecord) {\n          _measurements['fp'] = { value: entry.startTime, unit: 'millisecond' };\n        }\n        if (entry.name === 'first-contentful-paint' && shouldRecord) {\n          _measurements['fcp'] = { value: entry.startTime, unit: 'millisecond' };\n        }\n        break;\n      }\n      case 'resource': {\n        _addResourceSpans(\n          span,\n          entry as PerformanceResourceTiming,\n          entry.name,\n          startTime,\n          duration,\n          timeOrigin,\n          options.ignoreResourceSpans,\n        );\n        break;\n      }\n      // Ignore other entry types.\n    }\n  });\n\n  _performanceCursor = Math.max(performanceEntries.length - 1, 0);\n\n  _trackNavigator(span);\n\n  // Measurements are only available for pageload transactions\n  if (op === 'pageload') {\n    _addTtfbRequestTimeToMeasurements(_measurements);\n\n    const fidMark = _measurements['mark.fid'];\n    if (fidMark && _measurements['fid']) {\n      // create span for FID\n      startAndEndSpan(span, fidMark.value, fidMark.value + msToSec(_measurements['fid'].value), {\n        name: 'first input delay',\n        op: 'ui.action',\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n        },\n      });\n\n      // Delete mark.fid as we don't want it to be part of final payload\n      delete _measurements['mark.fid'];\n    }\n\n    // If FCP is not recorded we should not record the cls value\n    // according to the new definition of CLS.\n    // TODO: Check if the first condition is still necessary: `onCLS` already only fires once `onFCP` was called.\n    if (!('fcp' in _measurements) || !options.recordClsOnPageloadSpan) {\n      delete _measurements.cls;\n    }\n\n    // If LCP standalone spans are enabled, don't record LCP as a measurement\n    if (!options.recordLcpOnPageloadSpan) {\n      delete _measurements.lcp;\n    }\n\n    Object.entries(_measurements).forEach(([measurementName, measurement]) => {\n      setMeasurement(measurementName, measurement.value, measurement.unit);\n    });\n\n    // Set timeOrigin which denotes the timestamp which to base the LCP/FCP/FP/TTFB measurements on\n    span.setAttribute('performance.timeOrigin', timeOrigin);\n\n    // In prerendering scenarios, where a page might be prefetched and pre-rendered before the user clicks the link,\n    // the navigation starts earlier than when the user clicks it. Web Vitals should always be based on the\n    // user-perceived time, so they are not reported from the actual start of the navigation, but rather from the\n    // time where the user actively started the navigation, for example by clicking a link.\n    // This is user action is called \"activation\" and the time between navigation and activation is stored in\n    // the `activationStart` attribute of the \"navigation\" PerformanceEntry.\n    span.setAttribute('performance.activationStart', getActivationStart());\n\n    _setWebVitalAttributes(span, options);\n  }\n\n  _lcpEntry = undefined;\n  _clsEntry = undefined;\n  _measurements = {};\n}\n\n/**\n * Create measure related spans.\n * Exported only for tests.\n */\nexport function _addMeasureSpans(\n  span: Span,\n  entry: PerformanceEntry,\n  startTime: number,\n  duration: number,\n  timeOrigin: number,\n  ignorePerformanceApiSpans: AddPerformanceEntriesOptions['ignorePerformanceApiSpans'],\n): void {\n  if (\n    ['mark', 'measure'].includes(entry.entryType) &&\n    stringMatchesSomePattern(entry.name, ignorePerformanceApiSpans)\n  ) {\n    return;\n  }\n\n  const navEntry = getNavigationEntry(false);\n  const requestTime = msToSec(navEntry ? navEntry.requestStart : 0);\n  // Because performance.measure accepts arbitrary timestamps it can produce\n  // spans that happen before the browser even makes a request for the page.\n  //\n  // An example of this is the automatically generated Next.js-before-hydration\n  // spans created by the Next.js framework.\n  //\n  // To prevent this we will pin the start timestamp to the request start time\n  // This does make duration inaccurate, so if this does happen, we will add\n  // an attribute to the span\n  const measureStartTimestamp = timeOrigin + Math.max(startTime, requestTime);\n  const startTimeStamp = timeOrigin + startTime;\n  const measureEndTimestamp = startTimeStamp + duration;\n\n  const attributes: SpanAttributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.resource.browser.metrics',\n  };\n\n  if (measureStartTimestamp !== startTimeStamp) {\n    attributes['sentry.browser.measure_happened_before_request'] = true;\n    attributes['sentry.browser.measure_start_time'] = measureStartTimestamp;\n  }\n\n  _addDetailToSpanAttributes(attributes, entry as PerformanceMeasure);\n\n  // Measurements from third parties can be off, which would create invalid spans, dropping transactions in the process.\n  if (measureStartTimestamp <= measureEndTimestamp) {\n    startAndEndSpan(span, measureStartTimestamp, measureEndTimestamp, {\n      name: entry.name as string,\n      op: entry.entryType as string,\n      attributes,\n    });\n  }\n}\n\nfunction _addDetailToSpanAttributes(attributes: SpanAttributes, performanceMeasure: PerformanceMeasure): void {\n  try {\n    // Accessing detail might throw in some browsers (e.g., Firefox) due to security restrictions\n    const detail = performanceMeasure.detail;\n\n    if (!detail) {\n      return;\n    }\n\n    // Process detail based on its type\n    if (typeof detail === 'object') {\n      // Handle object details\n      for (const [key, value] of Object.entries(detail)) {\n        if (value && isPrimitive(value)) {\n          attributes[`sentry.browser.measure.detail.${key}`] = value as SpanAttributeValue;\n        } else if (value !== undefined) {\n          try {\n            // This is user defined so we can't guarantee it's serializable\n            attributes[`sentry.browser.measure.detail.${key}`] = JSON.stringify(value);\n          } catch {\n            // Skip values that can't be stringified\n          }\n        }\n      }\n      return;\n    }\n\n    if (isPrimitive(detail)) {\n      // Handle primitive details\n      attributes['sentry.browser.measure.detail'] = detail as SpanAttributeValue;\n      return;\n    }\n\n    try {\n      attributes['sentry.browser.measure.detail'] = JSON.stringify(detail);\n    } catch {\n      // Skip if stringification fails\n    }\n  } catch {\n    // Silently ignore any errors when accessing detail\n    // This handles the Firefox \"Permission denied to access object\" error\n  }\n}\n\n/**\n * Instrument navigation entries\n * exported only for tests\n */\nexport function _addNavigationSpans(span: Span, entry: PerformanceNavigationTiming, timeOrigin: number): void {\n  (['unloadEvent', 'redirect', 'domContentLoadedEvent', 'loadEvent', 'connect'] as const).forEach(event => {\n    _addPerformanceNavigationTiming(span, entry, event, timeOrigin);\n  });\n  _addPerformanceNavigationTiming(span, entry, 'secureConnection', timeOrigin, 'TLS/SSL');\n  _addPerformanceNavigationTiming(span, entry, 'fetch', timeOrigin, 'cache');\n  _addPerformanceNavigationTiming(span, entry, 'domainLookup', timeOrigin, 'DNS');\n\n  _addRequest(span, entry, timeOrigin);\n}\n\ntype StartEventName =\n  | 'secureConnection'\n  | 'fetch'\n  | 'domainLookup'\n  | 'unloadEvent'\n  | 'redirect'\n  | 'connect'\n  | 'domContentLoadedEvent'\n  | 'loadEvent';\n\ntype EndEventName =\n  | 'connectEnd'\n  | 'domainLookupStart'\n  | 'domainLookupEnd'\n  | 'unloadEventEnd'\n  | 'redirectEnd'\n  | 'connectEnd'\n  | 'domContentLoadedEventEnd'\n  | 'loadEventEnd';\n\n/** Create performance navigation related spans */\nfunction _addPerformanceNavigationTiming(\n  span: Span,\n  entry: PerformanceNavigationTiming,\n  event: StartEventName,\n  timeOrigin: number,\n  name: string = event,\n): void {\n  const eventEnd = _getEndPropertyNameForNavigationTiming(event) satisfies keyof PerformanceNavigationTiming;\n  const end = entry[eventEnd];\n  const start = entry[`${event}Start`];\n  if (!start || !end) {\n    return;\n  }\n  startAndEndSpan(span, timeOrigin + msToSec(start), timeOrigin + msToSec(end), {\n    op: `browser.${name}`,\n    name: entry.name,\n    attributes: {\n      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n      ...(event === 'redirect' && entry.redirectCount != null ? { 'http.redirect_count': entry.redirectCount } : {}),\n    },\n  });\n}\n\nfunction _getEndPropertyNameForNavigationTiming(event: StartEventName): EndEventName {\n  if (event === 'secureConnection') {\n    return 'connectEnd';\n  }\n  if (event === 'fetch') {\n    return 'domainLookupStart';\n  }\n  return `${event}End`;\n}\n\n/** Create request and response related spans */\nfunction _addRequest(span: Span, entry: PerformanceNavigationTiming, timeOrigin: number): void {\n  const requestStartTimestamp = timeOrigin + msToSec(entry.requestStart as number);\n  const responseEndTimestamp = timeOrigin + msToSec(entry.responseEnd as number);\n  const responseStartTimestamp = timeOrigin + msToSec(entry.responseStart as number);\n  if (entry.responseEnd) {\n    // It is possible that we are collecting these metrics when the page hasn't finished loading yet, for example when the HTML slowly streams in.\n    // In this case, ie. when the document request hasn't finished yet, `entry.responseEnd` will be 0.\n    // In order not to produce faulty spans, where the end timestamp is before the start timestamp, we will only collect\n    // these spans when the responseEnd value is available. The backend (Relay) would drop the entire span if it contained faulty spans.\n    startAndEndSpan(span, requestStartTimestamp, responseEndTimestamp, {\n      op: 'browser.request',\n      name: entry.name,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n      },\n    });\n\n    startAndEndSpan(span, responseStartTimestamp, responseEndTimestamp, {\n      op: 'browser.response',\n      name: entry.name,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n      },\n    });\n  }\n}\n\n/**\n * Create resource-related spans.\n * Exported only for tests.\n */\nexport function _addResourceSpans(\n  span: Span,\n  entry: PerformanceResourceTiming,\n  resourceUrl: string,\n  startTime: number,\n  duration: number,\n  timeOrigin: number,\n  ignoreResourceSpans?: Array<string>,\n): void {\n  // we already instrument based on fetch and xhr, so we don't need to\n  // duplicate spans here.\n  if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {\n    return;\n  }\n\n  const op = entry.initiatorType ? `resource.${entry.initiatorType}` : 'resource.other';\n  if (ignoreResourceSpans?.includes(op)) {\n    return;\n  }\n\n  const parsedUrl = parseUrl(resourceUrl);\n\n  const attributes: SpanAttributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.resource.browser.metrics',\n  };\n  setResourceEntrySizeData(attributes, entry, 'transferSize', 'http.response_transfer_size');\n  setResourceEntrySizeData(attributes, entry, 'encodedBodySize', 'http.response_content_length');\n  setResourceEntrySizeData(attributes, entry, 'decodedBodySize', 'http.decoded_response_content_length');\n\n  // `deliveryType` is experimental and does not exist everywhere\n  const deliveryType = (entry as { deliveryType?: 'cache' | 'navigational-prefetch' | '' }).deliveryType;\n  if (deliveryType != null) {\n    attributes['http.response_delivery_type'] = deliveryType;\n  }\n\n  // Types do not reflect this property yet\n  const renderBlockingStatus = (entry as { renderBlockingStatus?: 'render-blocking' | 'non-render-blocking' })\n    .renderBlockingStatus;\n  if (renderBlockingStatus) {\n    attributes['resource.render_blocking_status'] = renderBlockingStatus;\n  }\n\n  if (parsedUrl.protocol) {\n    attributes['url.scheme'] = parsedUrl.protocol.split(':').pop(); // the protocol returned by parseUrl includes a :, but OTEL spec does not, so we remove it.\n  }\n\n  if (parsedUrl.host) {\n    attributes['server.address'] = parsedUrl.host;\n  }\n\n  attributes['url.same_origin'] = resourceUrl.includes(WINDOW.location.origin);\n\n  // Checking for only `undefined` and `null` is intentional because it's\n  // valid for `nextHopProtocol` to be an empty string.\n  if (entry.nextHopProtocol != null) {\n    const { name, version } = extractNetworkProtocol(entry.nextHopProtocol);\n    attributes['network.protocol.name'] = name;\n    attributes['network.protocol.version'] = version;\n  }\n\n  const startTimestamp = timeOrigin + startTime;\n  const endTimestamp = startTimestamp + duration;\n\n  startAndEndSpan(span, startTimestamp, endTimestamp, {\n    name: resourceUrl.replace(WINDOW.location.origin, ''),\n    op,\n    attributes,\n  });\n}\n\n/**\n * Capture the information of the user agent.\n */\nfunction _trackNavigator(span: Span): void {\n  const navigator = WINDOW.navigator as null | (Navigator & NavigatorNetworkInformation & NavigatorDeviceMemory);\n  if (!navigator) {\n    return;\n  }\n\n  // track network connectivity\n  const connection = navigator.connection;\n  if (connection) {\n    if (connection.effectiveType) {\n      span.setAttribute('effectiveConnectionType', connection.effectiveType);\n    }\n\n    if (connection.type) {\n      span.setAttribute('connectionType', connection.type);\n    }\n\n    if (isMeasurementValue(connection.rtt)) {\n      _measurements['connection.rtt'] = { value: connection.rtt, unit: 'millisecond' };\n    }\n  }\n\n  if (isMeasurementValue(navigator.deviceMemory)) {\n    span.setAttribute('deviceMemory', `${navigator.deviceMemory} GB`);\n  }\n\n  if (isMeasurementValue(navigator.hardwareConcurrency)) {\n    span.setAttribute('hardwareConcurrency', String(navigator.hardwareConcurrency));\n  }\n}\n\n/** Add LCP / CLS data to span to allow debugging */\nfunction _setWebVitalAttributes(span: Span, options: AddPerformanceEntriesOptions): void {\n  // Only add LCP attributes if LCP is being recorded on the pageload span\n  if (_lcpEntry && options.recordLcpOnPageloadSpan) {\n    // Capture Properties of the LCP element that contributes to the LCP.\n\n    if (_lcpEntry.element) {\n      span.setAttribute('lcp.element', htmlTreeAsString(_lcpEntry.element));\n    }\n\n    if (_lcpEntry.id) {\n      span.setAttribute('lcp.id', _lcpEntry.id);\n    }\n\n    if (_lcpEntry.url) {\n      // Trim URL to the first 200 characters.\n      span.setAttribute('lcp.url', _lcpEntry.url.trim().slice(0, 200));\n    }\n\n    if (_lcpEntry.loadTime != null) {\n      // loadTime is the time of LCP that's related to receiving the LCP element response..\n      span.setAttribute('lcp.loadTime', _lcpEntry.loadTime);\n    }\n\n    if (_lcpEntry.renderTime != null) {\n      // renderTime is loadTime + rendering time\n      // it's 0 if the LCP element is loaded from a 3rd party origin that doesn't send the\n      // `Timing-Allow-Origin` header.\n      span.setAttribute('lcp.renderTime', _lcpEntry.renderTime);\n    }\n\n    span.setAttribute('lcp.size', _lcpEntry.size);\n  }\n\n  // Only add CLS attributes if CLS is being recorded on the pageload span\n  if (_clsEntry?.sources && options.recordClsOnPageloadSpan) {\n    _clsEntry.sources.forEach((source, index) =>\n      span.setAttribute(`cls.source.${index + 1}`, htmlTreeAsString(source.node)),\n    );\n  }\n}\n\nfunction setResourceEntrySizeData(\n  attributes: SpanAttributes,\n  entry: PerformanceResourceTiming,\n  key: keyof Pick<PerformanceResourceTiming, 'transferSize' | 'encodedBodySize' | 'decodedBodySize'>,\n  dataKey: 'http.response_transfer_size' | 'http.response_content_length' | 'http.decoded_response_content_length',\n): void {\n  const entryVal = entry[key];\n  if (entryVal != null && entryVal < MAX_INT_AS_BYTES) {\n    attributes[dataKey] = entryVal;\n  }\n}\n\n/**\n * Add ttfb request time information to measurements.\n *\n * ttfb information is added via vendored web vitals library.\n */\nfunction _addTtfbRequestTimeToMeasurements(_measurements: Measurements): void {\n  const navEntry = getNavigationEntry(false);\n  if (!navEntry) {\n    return;\n  }\n\n  const { responseStart, requestStart } = navEntry;\n\n  if (requestStart <= responseStart) {\n    _measurements['ttfb.requestTime'] = {\n      value: responseStart - requestStart,\n      unit: 'millisecond',\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}