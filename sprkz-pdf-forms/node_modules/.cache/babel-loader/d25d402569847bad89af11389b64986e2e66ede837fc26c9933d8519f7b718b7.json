{"ast":null,"code":"import { UnleashClient as H } from \"unleash-proxy-client\";\nimport { InMemoryStorageProvider as Z, LocalStorageProvider as $, UnleashClient as N } from \"unleash-proxy-client\";\nimport g, { useState as b, useEffect as p, useMemo as C, useContext as M, useRef as k } from \"react\";\nconst A = g.createContext(null),\n  _ = {\n    bootstrap: [],\n    disableRefresh: !0,\n    disableMetrics: !0,\n    url: \"http://localhost\",\n    appName: \"offline\",\n    clientKey: \"not-used\"\n  },\n  q = \"startTransition\",\n  I = g[q] || (e => e()),\n  K = _ref => {\n    let {\n      config: e,\n      children: r,\n      unleashClient: t,\n      startClient: a = !0,\n      stopClient: u = !0,\n      startTransition: s = I\n    } = _ref;\n    var h, m, R;\n    const l = e || _,\n      o = g.useRef(t || new H(l)),\n      [n, x] = g.useState(!!(t ? e != null && e.bootstrap && (e == null ? void 0 : e.bootstrapOverride) !== !1 || (h = t.isReady) != null && h.call(t) : l.bootstrap && l.bootstrapOverride !== !1)),\n      [E, y] = b(((R = (m = o.current).getError) == null ? void 0 : R.call(m)) || null);\n    p(() => {\n      !l && !t && console.error(`You must provide either a config or an unleash client to the flag provider.\n        If you are initializing the client in useEffect, you can avoid this warning\n        by checking if the client exists before rendering.`);\n      const c = v => {\n          s(() => {\n            y(U => U || v);\n          });\n        },\n        d = v => {\n          s(() => {\n            y(null);\n          });\n        };\n      let i = null;\n      const P = () => {\n        i = setTimeout(() => {\n          s(() => {\n            x(!0);\n          });\n        }, 0);\n      };\n      return o.current.on(\"ready\", P), o.current.on(\"error\", c), o.current.on(\"recovered\", d), a && (o.current.stop(), o.current.start()), function () {\n        o.current && (o.current.off(\"error\", c), o.current.off(\"ready\", P), o.current.off(\"recovered\", d), u && o.current.stop()), i && clearTimeout(i);\n      };\n    }, []);\n    const T = C(() => ({\n      on: (c, d, i) => o.current.on(c, d, i),\n      off: (c, d) => o.current.off(c, d),\n      updateContext: async c => await o.current.updateContext(c),\n      isEnabled: c => o.current.isEnabled(c),\n      getVariant: c => o.current.getVariant(c),\n      client: o.current,\n      flagsReady: n,\n      flagsError: E,\n      setFlagsReady: x,\n      setFlagsError: y\n    }), [n, E]);\n    return /* @__PURE__ */g.createElement(A.Provider, {\n      value: T\n    }, r);\n  },\n  S = {\n    on: (e, r, t) => (console.error(\"on() must be used within a FlagProvider\"), F),\n    off: (e, r) => (console.error(\"off() must be used within a FlagProvider\"), F),\n    updateContext: async () => {\n      console.error(\"updateContext() must be used within a FlagProvider\");\n    },\n    isEnabled: () => (console.error(\"isEnabled() must be used within a FlagProvider\"), !1),\n    getVariant: () => (console.error(\"getVariant() must be used within a FlagProvider\"), {\n      name: \"disabled\",\n      enabled: !1\n    })\n  },\n  F = {\n    ...S,\n    toggles: [],\n    impressionDataAll: {},\n    context: {},\n    storage: {},\n    start: () => {},\n    stop: () => {},\n    isReady: () => !1,\n    getError: () => null,\n    getAllToggles: () => []\n  },\n  O = {\n    ...S,\n    client: F,\n    flagsReady: !1,\n    setFlagsReady: () => {\n      console.error(\"setFlagsReady() must be used within a FlagProvider\");\n    },\n    flagsError: null,\n    setFlagsError: () => {\n      console.error(\"setFlagsError() must be used within a FlagProvider\");\n    }\n  };\nfunction f() {\n  const e = M(A);\n  return e || (console.error(\"useFlagContext() must be used within a FlagProvider\"), O);\n}\nconst L = e => {\n    const {\n        isEnabled: r,\n        client: t\n      } = f(),\n      [a, u] = b(!!r(e)),\n      s = k();\n    return s.current = a, p(() => {\n      if (!t) return;\n      const l = () => {\n          const n = r(e);\n          n !== s.current && (s.current = n, u(!!n));\n        },\n        o = () => {\n          const n = r(e);\n          s.current = n, u(n);\n        };\n      return t.on(\"update\", l), t.on(\"ready\", o), () => {\n        t.off(\"update\", l), t.off(\"ready\", o);\n      };\n    }, [t]), a;\n  },\n  Y = () => {\n    const {\n        client: e\n      } = f(),\n      [r, t] = b(e.getAllToggles());\n    return p(() => {\n      const a = () => {\n        t(e.getAllToggles());\n      };\n      return e.on(\"update\", a), () => {\n        e.off(\"update\", a);\n      };\n    }, []), r;\n  },\n  j = () => {\n    const {\n      flagsReady: e,\n      flagsError: r\n    } = f();\n    return {\n      flagsReady: e,\n      flagsError: r\n    };\n  },\n  z = (e, r) => {\n    var a, u, s, l;\n    return !(e.name === (r == null ? void 0 : r.name) && e.enabled === (r == null ? void 0 : r.enabled) && e.feature_enabled === (r == null ? void 0 : r.feature_enabled) && ((a = e.payload) == null ? void 0 : a.type) === ((u = r == null ? void 0 : r.payload) == null ? void 0 : u.type) && ((s = e.payload) == null ? void 0 : s.value) === ((l = r == null ? void 0 : r.payload) == null ? void 0 : l.value));\n  },\n  G = e => {\n    const {\n        getVariant: r,\n        client: t\n      } = f(),\n      [a, u] = b(r(e)),\n      s = k({\n        name: a.name,\n        enabled: a.enabled\n      });\n    return s.current = a, p(() => {\n      if (!t) return;\n      const l = () => {\n          const n = r(e);\n          z(s.current, n) && (u(n), s.current = n);\n        },\n        o = () => {\n          const n = r(e);\n          s.current.name = n == null ? void 0 : n.name, s.current.enabled = n == null ? void 0 : n.enabled, u(n);\n        };\n      return t.on(\"update\", l), t.on(\"ready\", o), () => {\n        t.off(\"update\", l), t.off(\"ready\", o);\n      };\n    }, [t]), a || {};\n  },\n  J = () => {\n    const {\n      updateContext: e\n    } = f();\n    return e;\n  },\n  Q = () => {\n    const {\n      client: e\n    } = f();\n    return e;\n  };\nexport { A as FlagContext, K as FlagProvider, Z as InMemoryStorageProvider, $ as LocalStorageProvider, N as UnleashClient, K as default, L as useFlag, Y as useFlags, j as useFlagsStatus, Q as useUnleashClient, J as useUnleashContext, G as useVariant };\n//# sourceMappingURL=unleash-react.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}