{"ast":null,"code":"import { DEBUG_BUILD } from './debug-build.js';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_OP } from './semanticAttributes.js';\nimport { debug } from './utils/debug-logger.js';\nimport { getActiveSpan } from './utils/spanUtils.js';\nimport { withActiveSpan, startSpan } from './tracing/trace.js';\nconst wrappedMcpServerInstances = new WeakSet();\n\n/**\n * Wraps a MCP Server instance from the `@modelcontextprotocol/sdk` package with Sentry instrumentation.\n *\n * Compatible with versions `^1.9.0` of the `@modelcontextprotocol/sdk` package.\n */\n// We are exposing this API for non-node runtimes that cannot rely on auto-instrumentation.\nfunction wrapMcpServerWithSentry(mcpServerInstance) {\n  if (wrappedMcpServerInstances.has(mcpServerInstance)) {\n    return mcpServerInstance;\n  }\n  if (!isMcpServerInstance(mcpServerInstance)) {\n    DEBUG_BUILD && debug.warn('Did not patch MCP server. Interface is incompatible.');\n    return mcpServerInstance;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  mcpServerInstance.connect = new Proxy(mcpServerInstance.connect, {\n    apply(target, thisArg, argArray) {\n      const [transport, ...restArgs] = argArray;\n      if (!transport.onclose) {\n        transport.onclose = () => {\n          if (transport.sessionId) {\n            handleTransportOnClose(transport.sessionId);\n          }\n        };\n      }\n      if (!transport.onmessage) {\n        transport.onmessage = jsonRpcMessage => {\n          if (transport.sessionId && isJsonRPCMessageWithRequestId(jsonRpcMessage)) {\n            handleTransportOnMessage(transport.sessionId, jsonRpcMessage.id);\n          }\n        };\n      }\n      const patchedTransport = new Proxy(transport, {\n        set(target, key, value) {\n          if (key === 'onmessage') {\n            target[key] = new Proxy(value, {\n              apply(onMessageTarget, onMessageThisArg, onMessageArgArray) {\n                const [jsonRpcMessage] = onMessageArgArray;\n                if (transport.sessionId && isJsonRPCMessageWithRequestId(jsonRpcMessage)) {\n                  handleTransportOnMessage(transport.sessionId, jsonRpcMessage.id);\n                }\n                return Reflect.apply(onMessageTarget, onMessageThisArg, onMessageArgArray);\n              }\n            });\n          } else if (key === 'onclose') {\n            target[key] = new Proxy(value, {\n              apply(onCloseTarget, onCloseThisArg, onCloseArgArray) {\n                if (transport.sessionId) {\n                  handleTransportOnClose(transport.sessionId);\n                }\n                return Reflect.apply(onCloseTarget, onCloseThisArg, onCloseArgArray);\n              }\n            });\n          } else {\n            target[key] = value;\n          }\n          return true;\n        }\n      });\n      return Reflect.apply(target, thisArg, [patchedTransport, ...restArgs]);\n    }\n  });\n  mcpServerInstance.resource = new Proxy(mcpServerInstance.resource, {\n    apply(target, thisArg, argArray) {\n      const resourceName = argArray[0];\n      const resourceHandler = argArray[argArray.length - 1];\n      if (typeof resourceName !== 'string' || typeof resourceHandler !== 'function') {\n        return target.apply(thisArg, argArray);\n      }\n      const wrappedResourceHandler = new Proxy(resourceHandler, {\n        apply(resourceHandlerTarget, resourceHandlerThisArg, resourceHandlerArgArray) {\n          const extraHandlerDataWithRequestId = resourceHandlerArgArray.find(isExtraHandlerDataWithRequestId);\n          return associateContextWithRequestSpan(extraHandlerDataWithRequestId, () => {\n            return startSpan({\n              name: `mcp-server/resource:${resourceName}`,\n              forceTransaction: true,\n              attributes: {\n                [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'auto.function.mcp-server',\n                [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.mcp-server',\n                [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n                'mcp_server.resource': resourceName\n              }\n            }, () => resourceHandlerTarget.apply(resourceHandlerThisArg, resourceHandlerArgArray));\n          });\n        }\n      });\n      return Reflect.apply(target, thisArg, [...argArray.slice(0, -1), wrappedResourceHandler]);\n    }\n  });\n  mcpServerInstance.tool = new Proxy(mcpServerInstance.tool, {\n    apply(target, thisArg, argArray) {\n      const toolName = argArray[0];\n      const toolHandler = argArray[argArray.length - 1];\n      if (typeof toolName !== 'string' || typeof toolHandler !== 'function') {\n        return target.apply(thisArg, argArray);\n      }\n      const wrappedToolHandler = new Proxy(toolHandler, {\n        apply(toolHandlerTarget, toolHandlerThisArg, toolHandlerArgArray) {\n          const extraHandlerDataWithRequestId = toolHandlerArgArray.find(isExtraHandlerDataWithRequestId);\n          return associateContextWithRequestSpan(extraHandlerDataWithRequestId, () => {\n            return startSpan({\n              name: `mcp-server/tool:${toolName}`,\n              forceTransaction: true,\n              attributes: {\n                [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'auto.function.mcp-server',\n                [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.mcp-server',\n                [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n                'mcp_server.tool': toolName\n              }\n            }, () => toolHandlerTarget.apply(toolHandlerThisArg, toolHandlerArgArray));\n          });\n        }\n      });\n      return Reflect.apply(target, thisArg, [...argArray.slice(0, -1), wrappedToolHandler]);\n    }\n  });\n  mcpServerInstance.prompt = new Proxy(mcpServerInstance.prompt, {\n    apply(target, thisArg, argArray) {\n      const promptName = argArray[0];\n      const promptHandler = argArray[argArray.length - 1];\n      if (typeof promptName !== 'string' || typeof promptHandler !== 'function') {\n        return target.apply(thisArg, argArray);\n      }\n      const wrappedPromptHandler = new Proxy(promptHandler, {\n        apply(promptHandlerTarget, promptHandlerThisArg, promptHandlerArgArray) {\n          const extraHandlerDataWithRequestId = promptHandlerArgArray.find(isExtraHandlerDataWithRequestId);\n          return associateContextWithRequestSpan(extraHandlerDataWithRequestId, () => {\n            return startSpan({\n              name: `mcp-server/prompt:${promptName}`,\n              forceTransaction: true,\n              attributes: {\n                [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'auto.function.mcp-server',\n                [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.mcp-server',\n                [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n                'mcp_server.prompt': promptName\n              }\n            }, () => promptHandlerTarget.apply(promptHandlerThisArg, promptHandlerArgArray));\n          });\n        }\n      });\n      return Reflect.apply(target, thisArg, [...argArray.slice(0, -1), wrappedPromptHandler]);\n    }\n  });\n  wrappedMcpServerInstances.add(mcpServerInstance);\n  return mcpServerInstance;\n}\nfunction isMcpServerInstance(mcpServerInstance) {\n  return typeof mcpServerInstance === 'object' && mcpServerInstance !== null && 'resource' in mcpServerInstance && typeof mcpServerInstance.resource === 'function' && 'tool' in mcpServerInstance && typeof mcpServerInstance.tool === 'function' && 'prompt' in mcpServerInstance && typeof mcpServerInstance.prompt === 'function' && 'connect' in mcpServerInstance && typeof mcpServerInstance.connect === 'function';\n}\nfunction isJsonRPCMessageWithRequestId(target) {\n  return typeof target === 'object' && target !== null && 'id' in target && (typeof target.id === 'number' || typeof target.id === 'string');\n}\n\n// Note that not all versions of the MCP library have `requestId` as a field on the extra data.\nfunction isExtraHandlerDataWithRequestId(target) {\n  return typeof target === 'object' && target !== null && 'sessionId' in target && typeof target.sessionId === 'string' && 'requestId' in target && (typeof target.requestId === 'number' || typeof target.requestId === 'string');\n}\nconst sessionAndRequestToRequestParentSpanMap = new Map();\nfunction handleTransportOnClose(sessionId) {\n  sessionAndRequestToRequestParentSpanMap.delete(sessionId);\n}\nfunction handleTransportOnMessage(sessionId, requestId) {\n  const activeSpan = getActiveSpan();\n  if (activeSpan) {\n    const requestIdToSpanMap = sessionAndRequestToRequestParentSpanMap.get(sessionId) ?? new Map();\n    requestIdToSpanMap.set(requestId, activeSpan);\n    sessionAndRequestToRequestParentSpanMap.set(sessionId, requestIdToSpanMap);\n  }\n}\nfunction associateContextWithRequestSpan(extraHandlerData, cb) {\n  if (extraHandlerData) {\n    const {\n      sessionId,\n      requestId\n    } = extraHandlerData;\n    const requestIdSpanMap = sessionAndRequestToRequestParentSpanMap.get(sessionId);\n    if (!requestIdSpanMap) {\n      return cb();\n    }\n    const span = requestIdSpanMap.get(requestId);\n    if (!span) {\n      return cb();\n    }\n\n    // remove the span from the map so it can be garbage collected\n    requestIdSpanMap.delete(requestId);\n    return withActiveSpan(span, () => {\n      return cb();\n    });\n  }\n  return cb();\n}\nexport { wrapMcpServerWithSentry };","map":{"version":3,"names":["wrappedMcpServerInstances","WeakSet","wrapMcpServerWithSentry","mcpServerInstance","has","isMcpServerInstance","DEBUG_BUILD","debug","warn","connect","Proxy","apply","target","thisArg","argArray","transport","restArgs","onclose","sessionId","handleTransportOnClose","onmessage","jsonRpcMessage","isJsonRPCMessageWithRequestId","handleTransportOnMessage","id","patchedTransport","set","key","value","onMessageTarget","onMessageThisArg","onMessageArgArray","Reflect","onCloseTarget","onCloseThisArg","onCloseArgArray","resource","resourceName","resourceHandler","length","wrappedResourceHandler","resourceHandlerTarget","resourceHandlerThisArg","resourceHandlerArgArray","extraHandlerDataWithRequestId","find","isExtraHandlerDataWithRequestId","associateContextWithRequestSpan","startSpan","name","forceTransaction","attributes","SEMANTIC_ATTRIBUTE_SENTRY_OP","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","slice","tool","toolName","toolHandler","wrappedToolHandler","toolHandlerTarget","toolHandlerThisArg","toolHandlerArgArray","prompt","promptName","promptHandler","wrappedPromptHandler","promptHandlerTarget","promptHandlerThisArg","promptHandlerArgArray","add","requestId","sessionAndRequestToRequestParentSpanMap","Map","delete","activeSpan","getActiveSpan","requestIdToSpanMap","get","extraHandlerData","cb","requestIdSpanMap","span","withActiveSpan"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/mcp-server.ts"],"sourcesContent":["import { DEBUG_BUILD } from './debug-build';\nimport {\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n} from './semanticAttributes';\nimport { startSpan, withActiveSpan } from './tracing';\nimport type { Span } from './types-hoist/span';\nimport { debug } from './utils/debug-logger';\nimport { getActiveSpan } from './utils/spanUtils';\n\ninterface MCPTransport {\n  // The first argument is a JSON RPC message\n  onmessage?: (...args: unknown[]) => void;\n  onclose?: (...args: unknown[]) => void;\n  sessionId?: string;\n}\n\ninterface MCPServerInstance {\n  // The first arg is always a name, the last arg should always be a callback function (ie a handler).\n  // TODO: We could also make use of the resource uri argument somehow.\n  resource: (name: string, ...args: unknown[]) => void;\n  // The first arg is always a name, the last arg should always be a callback function (ie a handler).\n  tool: (name: string, ...args: unknown[]) => void;\n  // The first arg is always a name, the last arg should always be a callback function (ie a handler).\n  prompt: (name: string, ...args: unknown[]) => void;\n  connect(transport: MCPTransport): Promise<void>;\n}\n\nconst wrappedMcpServerInstances = new WeakSet();\n\n/**\n * Wraps a MCP Server instance from the `@modelcontextprotocol/sdk` package with Sentry instrumentation.\n *\n * Compatible with versions `^1.9.0` of the `@modelcontextprotocol/sdk` package.\n */\n// We are exposing this API for non-node runtimes that cannot rely on auto-instrumentation.\nexport function wrapMcpServerWithSentry<S extends object>(mcpServerInstance: S): S {\n  if (wrappedMcpServerInstances.has(mcpServerInstance)) {\n    return mcpServerInstance;\n  }\n\n  if (!isMcpServerInstance(mcpServerInstance)) {\n    DEBUG_BUILD && debug.warn('Did not patch MCP server. Interface is incompatible.');\n    return mcpServerInstance;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  mcpServerInstance.connect = new Proxy(mcpServerInstance.connect, {\n    apply(target, thisArg, argArray) {\n      const [transport, ...restArgs] = argArray as [MCPTransport, ...unknown[]];\n\n      if (!transport.onclose) {\n        transport.onclose = () => {\n          if (transport.sessionId) {\n            handleTransportOnClose(transport.sessionId);\n          }\n        };\n      }\n\n      if (!transport.onmessage) {\n        transport.onmessage = jsonRpcMessage => {\n          if (transport.sessionId && isJsonRPCMessageWithRequestId(jsonRpcMessage)) {\n            handleTransportOnMessage(transport.sessionId, jsonRpcMessage.id);\n          }\n        };\n      }\n\n      const patchedTransport = new Proxy(transport, {\n        set(target, key, value) {\n          if (key === 'onmessage') {\n            target[key] = new Proxy(value, {\n              apply(onMessageTarget, onMessageThisArg, onMessageArgArray) {\n                const [jsonRpcMessage] = onMessageArgArray;\n                if (transport.sessionId && isJsonRPCMessageWithRequestId(jsonRpcMessage)) {\n                  handleTransportOnMessage(transport.sessionId, jsonRpcMessage.id);\n                }\n                return Reflect.apply(onMessageTarget, onMessageThisArg, onMessageArgArray);\n              },\n            });\n          } else if (key === 'onclose') {\n            target[key] = new Proxy(value, {\n              apply(onCloseTarget, onCloseThisArg, onCloseArgArray) {\n                if (transport.sessionId) {\n                  handleTransportOnClose(transport.sessionId);\n                }\n                return Reflect.apply(onCloseTarget, onCloseThisArg, onCloseArgArray);\n              },\n            });\n          } else {\n            target[key as keyof MCPTransport] = value;\n          }\n          return true;\n        },\n      });\n\n      return Reflect.apply(target, thisArg, [patchedTransport, ...restArgs]);\n    },\n  });\n\n  mcpServerInstance.resource = new Proxy(mcpServerInstance.resource, {\n    apply(target, thisArg, argArray) {\n      const resourceName: unknown = argArray[0];\n      const resourceHandler: unknown = argArray[argArray.length - 1];\n\n      if (typeof resourceName !== 'string' || typeof resourceHandler !== 'function') {\n        return target.apply(thisArg, argArray);\n      }\n\n      const wrappedResourceHandler = new Proxy(resourceHandler, {\n        apply(resourceHandlerTarget, resourceHandlerThisArg, resourceHandlerArgArray) {\n          const extraHandlerDataWithRequestId = resourceHandlerArgArray.find(isExtraHandlerDataWithRequestId);\n          return associateContextWithRequestSpan(extraHandlerDataWithRequestId, () => {\n            return startSpan(\n              {\n                name: `mcp-server/resource:${resourceName}`,\n                forceTransaction: true,\n                attributes: {\n                  [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'auto.function.mcp-server',\n                  [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.mcp-server',\n                  [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n                  'mcp_server.resource': resourceName,\n                },\n              },\n              () => resourceHandlerTarget.apply(resourceHandlerThisArg, resourceHandlerArgArray),\n            );\n          });\n        },\n      });\n\n      return Reflect.apply(target, thisArg, [...argArray.slice(0, -1), wrappedResourceHandler]);\n    },\n  });\n\n  mcpServerInstance.tool = new Proxy(mcpServerInstance.tool, {\n    apply(target, thisArg, argArray) {\n      const toolName: unknown = argArray[0];\n      const toolHandler: unknown = argArray[argArray.length - 1];\n\n      if (typeof toolName !== 'string' || typeof toolHandler !== 'function') {\n        return target.apply(thisArg, argArray);\n      }\n\n      const wrappedToolHandler = new Proxy(toolHandler, {\n        apply(toolHandlerTarget, toolHandlerThisArg, toolHandlerArgArray) {\n          const extraHandlerDataWithRequestId = toolHandlerArgArray.find(isExtraHandlerDataWithRequestId);\n          return associateContextWithRequestSpan(extraHandlerDataWithRequestId, () => {\n            return startSpan(\n              {\n                name: `mcp-server/tool:${toolName}`,\n                forceTransaction: true,\n                attributes: {\n                  [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'auto.function.mcp-server',\n                  [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.mcp-server',\n                  [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n                  'mcp_server.tool': toolName,\n                },\n              },\n              () => toolHandlerTarget.apply(toolHandlerThisArg, toolHandlerArgArray),\n            );\n          });\n        },\n      });\n\n      return Reflect.apply(target, thisArg, [...argArray.slice(0, -1), wrappedToolHandler]);\n    },\n  });\n\n  mcpServerInstance.prompt = new Proxy(mcpServerInstance.prompt, {\n    apply(target, thisArg, argArray) {\n      const promptName: unknown = argArray[0];\n      const promptHandler: unknown = argArray[argArray.length - 1];\n\n      if (typeof promptName !== 'string' || typeof promptHandler !== 'function') {\n        return target.apply(thisArg, argArray);\n      }\n\n      const wrappedPromptHandler = new Proxy(promptHandler, {\n        apply(promptHandlerTarget, promptHandlerThisArg, promptHandlerArgArray) {\n          const extraHandlerDataWithRequestId = promptHandlerArgArray.find(isExtraHandlerDataWithRequestId);\n          return associateContextWithRequestSpan(extraHandlerDataWithRequestId, () => {\n            return startSpan(\n              {\n                name: `mcp-server/prompt:${promptName}`,\n                forceTransaction: true,\n                attributes: {\n                  [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'auto.function.mcp-server',\n                  [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.mcp-server',\n                  [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n                  'mcp_server.prompt': promptName,\n                },\n              },\n              () => promptHandlerTarget.apply(promptHandlerThisArg, promptHandlerArgArray),\n            );\n          });\n        },\n      });\n\n      return Reflect.apply(target, thisArg, [...argArray.slice(0, -1), wrappedPromptHandler]);\n    },\n  });\n\n  wrappedMcpServerInstances.add(mcpServerInstance);\n\n  return mcpServerInstance as S;\n}\n\nfunction isMcpServerInstance(mcpServerInstance: unknown): mcpServerInstance is MCPServerInstance {\n  return (\n    typeof mcpServerInstance === 'object' &&\n    mcpServerInstance !== null &&\n    'resource' in mcpServerInstance &&\n    typeof mcpServerInstance.resource === 'function' &&\n    'tool' in mcpServerInstance &&\n    typeof mcpServerInstance.tool === 'function' &&\n    'prompt' in mcpServerInstance &&\n    typeof mcpServerInstance.prompt === 'function' &&\n    'connect' in mcpServerInstance &&\n    typeof mcpServerInstance.connect === 'function'\n  );\n}\n\nfunction isJsonRPCMessageWithRequestId(target: unknown): target is { id: RequestId } {\n  return (\n    typeof target === 'object' &&\n    target !== null &&\n    'id' in target &&\n    (typeof target.id === 'number' || typeof target.id === 'string')\n  );\n}\n\ninterface ExtraHandlerDataWithRequestId {\n  sessionId: SessionId;\n  requestId: RequestId;\n}\n\n// Note that not all versions of the MCP library have `requestId` as a field on the extra data.\nfunction isExtraHandlerDataWithRequestId(target: unknown): target is ExtraHandlerDataWithRequestId {\n  return (\n    typeof target === 'object' &&\n    target !== null &&\n    'sessionId' in target &&\n    typeof target.sessionId === 'string' &&\n    'requestId' in target &&\n    (typeof target.requestId === 'number' || typeof target.requestId === 'string')\n  );\n}\n\ntype SessionId = string;\ntype RequestId = string | number;\n\nconst sessionAndRequestToRequestParentSpanMap = new Map<SessionId, Map<RequestId, Span>>();\n\nfunction handleTransportOnClose(sessionId: SessionId): void {\n  sessionAndRequestToRequestParentSpanMap.delete(sessionId);\n}\n\nfunction handleTransportOnMessage(sessionId: SessionId, requestId: RequestId): void {\n  const activeSpan = getActiveSpan();\n  if (activeSpan) {\n    const requestIdToSpanMap = sessionAndRequestToRequestParentSpanMap.get(sessionId) ?? new Map();\n    requestIdToSpanMap.set(requestId, activeSpan);\n    sessionAndRequestToRequestParentSpanMap.set(sessionId, requestIdToSpanMap);\n  }\n}\n\nfunction associateContextWithRequestSpan<T>(\n  extraHandlerData: ExtraHandlerDataWithRequestId | undefined,\n  cb: () => T,\n): T {\n  if (extraHandlerData) {\n    const { sessionId, requestId } = extraHandlerData;\n    const requestIdSpanMap = sessionAndRequestToRequestParentSpanMap.get(sessionId);\n\n    if (!requestIdSpanMap) {\n      return cb();\n    }\n\n    const span = requestIdSpanMap.get(requestId);\n    if (!span) {\n      return cb();\n    }\n\n    // remove the span from the map so it can be garbage collected\n    requestIdSpanMap.delete(requestId);\n    return withActiveSpan(span, () => {\n      return cb();\n    });\n  }\n\n  return cb();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}