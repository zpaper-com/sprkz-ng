{"ast":null,"code":"import { browserTracingIntegration, WINDOW, startBrowserTracingPageLoadSpan, startBrowserTracingNavigationSpan } from '@sentry/browser';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_OP } from '@sentry/core';\n\n/**\n * A custom browser tracing integration for TanStack Router.\n *\n * The minimum compatible version of `@tanstack/react-router` is `1.64.0`.\n *\n * @param router A TanStack Router `Router` instance that should be used for routing instrumentation.\n * @param options Sentry browser tracing configuration.\n */\nfunction tanstackRouterBrowserTracingIntegration(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nrouter) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const castRouterInstance = router;\n  const browserTracingIntegrationInstance = browserTracingIntegration({\n    ...options,\n    instrumentNavigation: false,\n    instrumentPageLoad: false\n  });\n  const {\n    instrumentPageLoad = true,\n    instrumentNavigation = true\n  } = options;\n  return {\n    ...browserTracingIntegrationInstance,\n    afterAllSetup(client) {\n      browserTracingIntegrationInstance.afterAllSetup(client);\n      const initialWindowLocation = WINDOW.location;\n      if (instrumentPageLoad && initialWindowLocation) {\n        const matchedRoutes = castRouterInstance.matchRoutes(initialWindowLocation.pathname, castRouterInstance.options.parseSearch(initialWindowLocation.search), {\n          preload: false,\n          throwOnError: false\n        });\n        const lastMatch = matchedRoutes[matchedRoutes.length - 1];\n        startBrowserTracingPageLoadSpan(client, {\n          name: lastMatch ? lastMatch.routeId : initialWindowLocation.pathname,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'pageload',\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.pageload.react.tanstack_router',\n            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: lastMatch ? 'route' : 'url',\n            ...routeMatchToParamSpanAttributes(lastMatch)\n          }\n        });\n      }\n      if (instrumentNavigation) {\n        // The onBeforeNavigate hook is called at the very beginning of a navigation and is only called once per navigation, even when the user is redirected\n        castRouterInstance.subscribe('onBeforeNavigate', onBeforeNavigateArgs => {\n          // onBeforeNavigate is called during pageloads. We can avoid creating navigation spans by comparing the states of the to and from arguments.\n          if (onBeforeNavigateArgs.toLocation.state === onBeforeNavigateArgs.fromLocation?.state) {\n            return;\n          }\n          const onResolvedMatchedRoutes = castRouterInstance.matchRoutes(onBeforeNavigateArgs.toLocation.pathname, onBeforeNavigateArgs.toLocation.search, {\n            preload: false,\n            throwOnError: false\n          });\n          const onBeforeNavigateLastMatch = onResolvedMatchedRoutes[onResolvedMatchedRoutes.length - 1];\n          const navigationLocation = WINDOW.location;\n          const navigationSpan = startBrowserTracingNavigationSpan(client, {\n            name: onBeforeNavigateLastMatch ? onBeforeNavigateLastMatch.routeId : navigationLocation.pathname,\n            attributes: {\n              [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'navigation',\n              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.react.tanstack_router',\n              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: onBeforeNavigateLastMatch ? 'route' : 'url'\n            }\n          });\n\n          // In case the user is redirected during navigation we want to update the span with the right value.\n          const unsubscribeOnResolved = castRouterInstance.subscribe('onResolved', onResolvedArgs => {\n            unsubscribeOnResolved();\n            if (navigationSpan) {\n              const onResolvedMatchedRoutes = castRouterInstance.matchRoutes(onResolvedArgs.toLocation.pathname, onResolvedArgs.toLocation.search, {\n                preload: false,\n                throwOnError: false\n              });\n              const onResolvedLastMatch = onResolvedMatchedRoutes[onResolvedMatchedRoutes.length - 1];\n              if (onResolvedLastMatch) {\n                navigationSpan.updateName(onResolvedLastMatch.routeId);\n                navigationSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, 'route');\n                navigationSpan.setAttributes(routeMatchToParamSpanAttributes(onResolvedLastMatch));\n              }\n            }\n          });\n        });\n      }\n    }\n  };\n}\nfunction routeMatchToParamSpanAttributes(match) {\n  if (!match) {\n    return {};\n  }\n  const paramAttributes = {};\n  Object.entries(match.params).forEach(_ref => {\n    let [key, value] = _ref;\n    paramAttributes[`url.path.params.${key}`] = value; // todo(v10): remove attribute which does not adhere to Sentry's semantic convention\n    paramAttributes[`url.path.parameter.${key}`] = value;\n    paramAttributes[`params.${key}`] = value; // params.[key] is an alias\n  });\n  return paramAttributes;\n}\nexport { tanstackRouterBrowserTracingIntegration };\n//# sourceMappingURL=tanstackrouter.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}