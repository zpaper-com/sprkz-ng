{"ast":null,"code":"import { debug } from '@sentry/core';\nimport { DEBUG_BUILD } from './debug-build.js';\n\n/**\n * Serializes FormData.\n *\n * This is a bit simplified, but gives us a decent estimate.\n * This converts e.g. { name: 'Anne Smith', age: 13 } to 'name=Anne+Smith&age=13'.\n *\n */\nfunction serializeFormData(formData) {\n  // @ts-expect-error passing FormData to URLSearchParams actually works\n  return new URLSearchParams(formData).toString();\n}\n\n/** Get the string representation of a body. */\nfunction getBodyString(body) {\n  let _debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : debug;\n  try {\n    if (typeof body === 'string') {\n      return [body];\n    }\n    if (body instanceof URLSearchParams) {\n      return [body.toString()];\n    }\n    if (body instanceof FormData) {\n      return [serializeFormData(body)];\n    }\n    if (!body) {\n      return [undefined];\n    }\n  } catch (error) {\n    DEBUG_BUILD && _debug.error(error, 'Failed to serialize body', body);\n    return [undefined, 'BODY_PARSE_ERROR'];\n  }\n  DEBUG_BUILD && _debug.log('Skipping network body because of body type', body);\n  return [undefined, 'UNPARSEABLE_BODY_TYPE'];\n}\n\n/**\n * Parses the fetch arguments to extract the request payload.\n *\n * We only support getting the body from the fetch options.\n */\nfunction getFetchRequestArgBody() {\n  let fetchArgs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  if (fetchArgs.length !== 2 || typeof fetchArgs[1] !== 'object') {\n    return undefined;\n  }\n  return fetchArgs[1].body;\n}\nexport { getBodyString, getFetchRequestArgBody, serializeFormData };\n//# sourceMappingURL=networkUtils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}