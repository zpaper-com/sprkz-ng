{"ast":null,"code":"import { DEFAULT_ENVIRONMENT } from '../constants.js';\nimport { getGlobalScope } from '../currentScopes.js';\nimport { notifyEventProcessors } from '../eventProcessors.js';\nimport { Scope } from '../scope.js';\nimport { mergeScopeData, applyScopeDataToEvent } from './applyScopeDataToEvent.js';\nimport { getFilenameToDebugIdMap } from './debug-ids.js';\nimport { uuid4, addExceptionMechanism } from './misc.js';\nimport { normalize } from './normalize.js';\nimport { truncate } from './string.js';\nimport { dateTimestampInSeconds } from './time.js';\n\n/**\n * This type makes sure that we get either a CaptureContext, OR an EventHint.\n * It does not allow mixing them, which could lead to unexpected outcomes, e.g. this is disallowed:\n * { user: { id: '123' }, mechanism: { handled: false } }\n */\n\n/**\n * Adds common information to events.\n *\n * The information includes release and environment from `options`,\n * breadcrumbs and context (extra, tags and user) from the scope.\n *\n * Information that is already present in the event is never overwritten. For\n * nested objects, such as the context, keys are merged.\n *\n * @param event The original event.\n * @param hint May contain additional information about the original exception.\n * @param scope A scope containing event metadata.\n * @returns A new event with more information.\n * @hidden\n */\nfunction prepareEvent(options, event, hint, scope, client, isolationScope) {\n  const {\n    normalizeDepth = 3,\n    normalizeMaxBreadth = 1000\n  } = options;\n  const prepared = {\n    ...event,\n    event_id: event.event_id || hint.event_id || uuid4(),\n    timestamp: event.timestamp || dateTimestampInSeconds()\n  };\n  const integrations = hint.integrations || options.integrations.map(i => i.name);\n  applyClientOptions(prepared, options);\n  applyIntegrationsMetadata(prepared, integrations);\n  if (client) {\n    client.emit('applyFrameMetadata', event);\n  }\n\n  // Only put debug IDs onto frames for error events.\n  if (event.type === undefined) {\n    applyDebugIds(prepared, options.stackParser);\n  }\n\n  // If we have scope given to us, use it as the base for further modifications.\n  // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n  const finalScope = getFinalScope(scope, hint.captureContext);\n  if (hint.mechanism) {\n    addExceptionMechanism(prepared, hint.mechanism);\n  }\n  const clientEventProcessors = client ? client.getEventProcessors() : [];\n\n  // This should be the last thing called, since we want that\n  // {@link Scope.addEventProcessor} gets the finished prepared event.\n  // Merge scope data together\n  const data = getGlobalScope().getScopeData();\n  if (isolationScope) {\n    const isolationData = isolationScope.getScopeData();\n    mergeScopeData(data, isolationData);\n  }\n  if (finalScope) {\n    const finalScopeData = finalScope.getScopeData();\n    mergeScopeData(data, finalScopeData);\n  }\n  const attachments = [...(hint.attachments || []), ...data.attachments];\n  if (attachments.length) {\n    hint.attachments = attachments;\n  }\n  applyScopeDataToEvent(prepared, data);\n  const eventProcessors = [...clientEventProcessors,\n  // Run scope event processors _after_ all other processors\n  ...data.eventProcessors];\n  const result = notifyEventProcessors(eventProcessors, prepared, hint);\n  return result.then(evt => {\n    if (evt) {\n      // We apply the debug_meta field only after all event processors have ran, so that if any event processors modified\n      // file names (e.g.the RewriteFrames integration) the filename -> debug ID relationship isn't destroyed.\n      // This should not cause any PII issues, since we're only moving data that is already on the event and not adding\n      // any new data\n      applyDebugMeta(evt);\n    }\n    if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n      return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n    }\n    return evt;\n  });\n}\n\n/**\n * Enhances event using the client configuration.\n * It takes care of all \"static\" values like environment, release and `dist`,\n * as well as truncating overly long values.\n *\n * Only exported for tests.\n *\n * @param event event instance to be enhanced\n */\nfunction applyClientOptions(event, options) {\n  const {\n    environment,\n    release,\n    dist,\n    maxValueLength = 250\n  } = options;\n\n  // empty strings do not make sense for environment, release, and dist\n  // so we handle them the same as if they were not provided\n  event.environment = event.environment || environment || DEFAULT_ENVIRONMENT;\n  if (!event.release && release) {\n    event.release = release;\n  }\n  if (!event.dist && dist) {\n    event.dist = dist;\n  }\n  const request = event.request;\n  if (request?.url) {\n    request.url = truncate(request.url, maxValueLength);\n  }\n}\n\n/**\n * Puts debug IDs into the stack frames of an error event.\n */\nfunction applyDebugIds(event, stackParser) {\n  // Build a map of filename -> debug_id\n  const filenameDebugIdMap = getFilenameToDebugIdMap(stackParser);\n  event.exception?.values?.forEach(exception => {\n    exception.stacktrace?.frames?.forEach(frame => {\n      if (frame.filename) {\n        frame.debug_id = filenameDebugIdMap[frame.filename];\n      }\n    });\n  });\n}\n\n/**\n * Moves debug IDs from the stack frames of an error event into the debug_meta field.\n */\nfunction applyDebugMeta(event) {\n  // Extract debug IDs and filenames from the stack frames on the event.\n  const filenameDebugIdMap = {};\n  event.exception?.values?.forEach(exception => {\n    exception.stacktrace?.frames?.forEach(frame => {\n      if (frame.debug_id) {\n        if (frame.abs_path) {\n          filenameDebugIdMap[frame.abs_path] = frame.debug_id;\n        } else if (frame.filename) {\n          filenameDebugIdMap[frame.filename] = frame.debug_id;\n        }\n        delete frame.debug_id;\n      }\n    });\n  });\n  if (Object.keys(filenameDebugIdMap).length === 0) {\n    return;\n  }\n\n  // Fill debug_meta information\n  event.debug_meta = event.debug_meta || {};\n  event.debug_meta.images = event.debug_meta.images || [];\n  const images = event.debug_meta.images;\n  Object.entries(filenameDebugIdMap).forEach(([filename, debug_id]) => {\n    images.push({\n      type: 'sourcemap',\n      code_file: filename,\n      debug_id\n    });\n  });\n}\n\n/**\n * This function adds all used integrations to the SDK info in the event.\n * @param event The event that will be filled with all integrations.\n */\nfunction applyIntegrationsMetadata(event, integrationNames) {\n  if (integrationNames.length > 0) {\n    event.sdk = event.sdk || {};\n    event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationNames];\n  }\n}\n\n/**\n * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n * Normalized keys:\n * - `breadcrumbs.data`\n * - `user`\n * - `contexts`\n * - `extra`\n * @param event Event\n * @returns Normalized event\n */\nfunction normalizeEvent(event, depth, maxBreadth) {\n  if (!event) {\n    return null;\n  }\n  const normalized = {\n    ...event,\n    ...(event.breadcrumbs && {\n      breadcrumbs: event.breadcrumbs.map(b => ({\n        ...b,\n        ...(b.data && {\n          data: normalize(b.data, depth, maxBreadth)\n        })\n      }))\n    }),\n    ...(event.user && {\n      user: normalize(event.user, depth, maxBreadth)\n    }),\n    ...(event.contexts && {\n      contexts: normalize(event.contexts, depth, maxBreadth)\n    }),\n    ...(event.extra && {\n      extra: normalize(event.extra, depth, maxBreadth)\n    })\n  };\n\n  // event.contexts.trace stores information about a Transaction. Similarly,\n  // event.spans[] stores information about child Spans. Given that a\n  // Transaction is conceptually a Span, normalization should apply to both\n  // Transactions and Spans consistently.\n  // For now the decision is to skip normalization of Transactions and Spans,\n  // so this block overwrites the normalized event to add back the original\n  // Transaction information prior to normalization.\n  if (event.contexts?.trace && normalized.contexts) {\n    normalized.contexts.trace = event.contexts.trace;\n\n    // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it\n    if (event.contexts.trace.data) {\n      normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);\n    }\n  }\n\n  // event.spans[].data may contain circular/dangerous data so we need to normalize it\n  if (event.spans) {\n    normalized.spans = event.spans.map(span => {\n      return {\n        ...span,\n        ...(span.data && {\n          data: normalize(span.data, depth, maxBreadth)\n        })\n      };\n    });\n  }\n\n  // event.contexts.flags (FeatureFlagContext) stores context for our feature\n  // flag integrations. It has a greater nesting depth than our other typed\n  // Contexts, so we re-normalize with a fixed depth of 3 here. We do not want\n  // to skip this in case of conflicting, user-provided context.\n  if (event.contexts?.flags && normalized.contexts) {\n    normalized.contexts.flags = normalize(event.contexts.flags, 3, maxBreadth);\n  }\n  return normalized;\n}\nfunction getFinalScope(scope, captureContext) {\n  if (!captureContext) {\n    return scope;\n  }\n  const finalScope = scope ? scope.clone() : new Scope();\n  finalScope.update(captureContext);\n  return finalScope;\n}\n\n/**\n * Parse either an `EventHint` directly, or convert a `CaptureContext` to an `EventHint`.\n * This is used to allow to update method signatures that used to accept a `CaptureContext` but should now accept an `EventHint`.\n */\nfunction parseEventHintOrCaptureContext(hint) {\n  if (!hint) {\n    return undefined;\n  }\n\n  // If you pass a Scope or `() => Scope` as CaptureContext, we just return this as captureContext\n  if (hintIsScopeOrFunction(hint)) {\n    return {\n      captureContext: hint\n    };\n  }\n  if (hintIsScopeContext(hint)) {\n    return {\n      captureContext: hint\n    };\n  }\n  return hint;\n}\nfunction hintIsScopeOrFunction(hint) {\n  return hint instanceof Scope || typeof hint === 'function';\n}\nconst captureContextKeys = ['user', 'level', 'extra', 'contexts', 'tags', 'fingerprint', 'propagationContext'];\nfunction hintIsScopeContext(hint) {\n  return Object.keys(hint).some(key => captureContextKeys.includes(key));\n}\nexport { applyClientOptions, applyDebugIds, applyDebugMeta, parseEventHintOrCaptureContext, prepareEvent };","map":{"version":3,"names":["prepareEvent","options","event","hint","scope","client","isolationScope","normalizeDepth","normalizeMaxBreadth","prepared","event_id","uuid4","timestamp","dateTimestampInSeconds","integrations","map","i","name","applyClientOptions","applyIntegrationsMetadata","emit","type","undefined","applyDebugIds","stackParser","finalScope","getFinalScope","captureContext","mechanism","addExceptionMechanism","clientEventProcessors","getEventProcessors","data","getGlobalScope","getScopeData","isolationData","mergeScopeData","finalScopeData","attachments","length","applyScopeDataToEvent","eventProcessors","result","notifyEventProcessors","then","evt","applyDebugMeta","normalizeEvent","environment","release","dist","maxValueLength","DEFAULT_ENVIRONMENT","request","url","truncate","filenameDebugIdMap","getFilenameToDebugIdMap","exception","values","forEach","stacktrace","frames","frame","filename","debug_id","abs_path","Object","keys","debug_meta","images","entries","push","code_file","integrationNames","sdk","depth","maxBreadth","normalized","breadcrumbs","b","normalize","user","contexts","extra","trace","spans","span","flags","clone","Scope","update","parseEventHintOrCaptureContext","hintIsScopeOrFunction","hintIsScopeContext","captureContextKeys","some","key","includes"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/utils/prepareEvent.ts"],"sourcesContent":["import type { Client } from '../client';\nimport { DEFAULT_ENVIRONMENT } from '../constants';\nimport { getGlobalScope } from '../currentScopes';\nimport { notifyEventProcessors } from '../eventProcessors';\nimport type { CaptureContext, ScopeContext } from '../scope';\nimport { Scope } from '../scope';\nimport type { Event, EventHint } from '../types-hoist/event';\nimport type { ClientOptions } from '../types-hoist/options';\nimport type { StackParser } from '../types-hoist/stacktrace';\nimport { applyScopeDataToEvent, mergeScopeData } from './applyScopeDataToEvent';\nimport { getFilenameToDebugIdMap } from './debug-ids';\nimport { addExceptionMechanism, uuid4 } from './misc';\nimport { normalize } from './normalize';\nimport { truncate } from './string';\nimport { dateTimestampInSeconds } from './time';\n\n/**\n * This type makes sure that we get either a CaptureContext, OR an EventHint.\n * It does not allow mixing them, which could lead to unexpected outcomes, e.g. this is disallowed:\n * { user: { id: '123' }, mechanism: { handled: false } }\n */\nexport type ExclusiveEventHintOrCaptureContext =\n  | (CaptureContext & Partial<{ [key in keyof EventHint]: never }>)\n  | (EventHint & Partial<{ [key in keyof ScopeContext]: never }>);\n\n/**\n * Adds common information to events.\n *\n * The information includes release and environment from `options`,\n * breadcrumbs and context (extra, tags and user) from the scope.\n *\n * Information that is already present in the event is never overwritten. For\n * nested objects, such as the context, keys are merged.\n *\n * @param event The original event.\n * @param hint May contain additional information about the original exception.\n * @param scope A scope containing event metadata.\n * @returns A new event with more information.\n * @hidden\n */\nexport function prepareEvent(\n  options: ClientOptions,\n  event: Event,\n  hint: EventHint,\n  scope?: Scope,\n  client?: Client,\n  isolationScope?: Scope,\n): PromiseLike<Event | null> {\n  const { normalizeDepth = 3, normalizeMaxBreadth = 1_000 } = options;\n  const prepared: Event = {\n    ...event,\n    event_id: event.event_id || hint.event_id || uuid4(),\n    timestamp: event.timestamp || dateTimestampInSeconds(),\n  };\n  const integrations = hint.integrations || options.integrations.map(i => i.name);\n\n  applyClientOptions(prepared, options);\n  applyIntegrationsMetadata(prepared, integrations);\n\n  if (client) {\n    client.emit('applyFrameMetadata', event);\n  }\n\n  // Only put debug IDs onto frames for error events.\n  if (event.type === undefined) {\n    applyDebugIds(prepared, options.stackParser);\n  }\n\n  // If we have scope given to us, use it as the base for further modifications.\n  // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n  const finalScope = getFinalScope(scope, hint.captureContext);\n\n  if (hint.mechanism) {\n    addExceptionMechanism(prepared, hint.mechanism);\n  }\n\n  const clientEventProcessors = client ? client.getEventProcessors() : [];\n\n  // This should be the last thing called, since we want that\n  // {@link Scope.addEventProcessor} gets the finished prepared event.\n  // Merge scope data together\n  const data = getGlobalScope().getScopeData();\n\n  if (isolationScope) {\n    const isolationData = isolationScope.getScopeData();\n    mergeScopeData(data, isolationData);\n  }\n\n  if (finalScope) {\n    const finalScopeData = finalScope.getScopeData();\n    mergeScopeData(data, finalScopeData);\n  }\n\n  const attachments = [...(hint.attachments || []), ...data.attachments];\n  if (attachments.length) {\n    hint.attachments = attachments;\n  }\n\n  applyScopeDataToEvent(prepared, data);\n\n  const eventProcessors = [\n    ...clientEventProcessors,\n    // Run scope event processors _after_ all other processors\n    ...data.eventProcessors,\n  ];\n\n  const result = notifyEventProcessors(eventProcessors, prepared, hint);\n\n  return result.then(evt => {\n    if (evt) {\n      // We apply the debug_meta field only after all event processors have ran, so that if any event processors modified\n      // file names (e.g.the RewriteFrames integration) the filename -> debug ID relationship isn't destroyed.\n      // This should not cause any PII issues, since we're only moving data that is already on the event and not adding\n      // any new data\n      applyDebugMeta(evt);\n    }\n\n    if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n      return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n    }\n    return evt;\n  });\n}\n\n/**\n * Enhances event using the client configuration.\n * It takes care of all \"static\" values like environment, release and `dist`,\n * as well as truncating overly long values.\n *\n * Only exported for tests.\n *\n * @param event event instance to be enhanced\n */\nexport function applyClientOptions(event: Event, options: ClientOptions): void {\n  const { environment, release, dist, maxValueLength = 250 } = options;\n\n  // empty strings do not make sense for environment, release, and dist\n  // so we handle them the same as if they were not provided\n  event.environment = event.environment || environment || DEFAULT_ENVIRONMENT;\n\n  if (!event.release && release) {\n    event.release = release;\n  }\n\n  if (!event.dist && dist) {\n    event.dist = dist;\n  }\n\n  const request = event.request;\n  if (request?.url) {\n    request.url = truncate(request.url, maxValueLength);\n  }\n}\n\n/**\n * Puts debug IDs into the stack frames of an error event.\n */\nexport function applyDebugIds(event: Event, stackParser: StackParser): void {\n  // Build a map of filename -> debug_id\n  const filenameDebugIdMap = getFilenameToDebugIdMap(stackParser);\n\n  event.exception?.values?.forEach(exception => {\n    exception.stacktrace?.frames?.forEach(frame => {\n      if (frame.filename) {\n        frame.debug_id = filenameDebugIdMap[frame.filename];\n      }\n    });\n  });\n}\n\n/**\n * Moves debug IDs from the stack frames of an error event into the debug_meta field.\n */\nexport function applyDebugMeta(event: Event): void {\n  // Extract debug IDs and filenames from the stack frames on the event.\n  const filenameDebugIdMap: Record<string, string> = {};\n  event.exception?.values?.forEach(exception => {\n    exception.stacktrace?.frames?.forEach(frame => {\n      if (frame.debug_id) {\n        if (frame.abs_path) {\n          filenameDebugIdMap[frame.abs_path] = frame.debug_id;\n        } else if (frame.filename) {\n          filenameDebugIdMap[frame.filename] = frame.debug_id;\n        }\n        delete frame.debug_id;\n      }\n    });\n  });\n\n  if (Object.keys(filenameDebugIdMap).length === 0) {\n    return;\n  }\n\n  // Fill debug_meta information\n  event.debug_meta = event.debug_meta || {};\n  event.debug_meta.images = event.debug_meta.images || [];\n  const images = event.debug_meta.images;\n  Object.entries(filenameDebugIdMap).forEach(([filename, debug_id]) => {\n    images.push({\n      type: 'sourcemap',\n      code_file: filename,\n      debug_id,\n    });\n  });\n}\n\n/**\n * This function adds all used integrations to the SDK info in the event.\n * @param event The event that will be filled with all integrations.\n */\nfunction applyIntegrationsMetadata(event: Event, integrationNames: string[]): void {\n  if (integrationNames.length > 0) {\n    event.sdk = event.sdk || {};\n    event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationNames];\n  }\n}\n\n/**\n * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n * Normalized keys:\n * - `breadcrumbs.data`\n * - `user`\n * - `contexts`\n * - `extra`\n * @param event Event\n * @returns Normalized event\n */\nfunction normalizeEvent(event: Event | null, depth: number, maxBreadth: number): Event | null {\n  if (!event) {\n    return null;\n  }\n\n  const normalized: Event = {\n    ...event,\n    ...(event.breadcrumbs && {\n      breadcrumbs: event.breadcrumbs.map(b => ({\n        ...b,\n        ...(b.data && {\n          data: normalize(b.data, depth, maxBreadth),\n        }),\n      })),\n    }),\n    ...(event.user && {\n      user: normalize(event.user, depth, maxBreadth),\n    }),\n    ...(event.contexts && {\n      contexts: normalize(event.contexts, depth, maxBreadth),\n    }),\n    ...(event.extra && {\n      extra: normalize(event.extra, depth, maxBreadth),\n    }),\n  };\n\n  // event.contexts.trace stores information about a Transaction. Similarly,\n  // event.spans[] stores information about child Spans. Given that a\n  // Transaction is conceptually a Span, normalization should apply to both\n  // Transactions and Spans consistently.\n  // For now the decision is to skip normalization of Transactions and Spans,\n  // so this block overwrites the normalized event to add back the original\n  // Transaction information prior to normalization.\n  if (event.contexts?.trace && normalized.contexts) {\n    normalized.contexts.trace = event.contexts.trace;\n\n    // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it\n    if (event.contexts.trace.data) {\n      normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);\n    }\n  }\n\n  // event.spans[].data may contain circular/dangerous data so we need to normalize it\n  if (event.spans) {\n    normalized.spans = event.spans.map(span => {\n      return {\n        ...span,\n        ...(span.data && {\n          data: normalize(span.data, depth, maxBreadth),\n        }),\n      };\n    });\n  }\n\n  // event.contexts.flags (FeatureFlagContext) stores context for our feature\n  // flag integrations. It has a greater nesting depth than our other typed\n  // Contexts, so we re-normalize with a fixed depth of 3 here. We do not want\n  // to skip this in case of conflicting, user-provided context.\n  if (event.contexts?.flags && normalized.contexts) {\n    normalized.contexts.flags = normalize(event.contexts.flags, 3, maxBreadth);\n  }\n\n  return normalized;\n}\n\nfunction getFinalScope(scope: Scope | undefined, captureContext: CaptureContext | undefined): Scope | undefined {\n  if (!captureContext) {\n    return scope;\n  }\n\n  const finalScope = scope ? scope.clone() : new Scope();\n  finalScope.update(captureContext);\n  return finalScope;\n}\n\n/**\n * Parse either an `EventHint` directly, or convert a `CaptureContext` to an `EventHint`.\n * This is used to allow to update method signatures that used to accept a `CaptureContext` but should now accept an `EventHint`.\n */\nexport function parseEventHintOrCaptureContext(\n  hint: ExclusiveEventHintOrCaptureContext | undefined,\n): EventHint | undefined {\n  if (!hint) {\n    return undefined;\n  }\n\n  // If you pass a Scope or `() => Scope` as CaptureContext, we just return this as captureContext\n  if (hintIsScopeOrFunction(hint)) {\n    return { captureContext: hint };\n  }\n\n  if (hintIsScopeContext(hint)) {\n    return {\n      captureContext: hint,\n    };\n  }\n\n  return hint;\n}\n\nfunction hintIsScopeOrFunction(hint: CaptureContext | EventHint): hint is Scope | ((scope: Scope) => Scope) {\n  return hint instanceof Scope || typeof hint === 'function';\n}\n\ntype ScopeContextProperty = keyof ScopeContext;\nconst captureContextKeys: readonly ScopeContextProperty[] = [\n  'user',\n  'level',\n  'extra',\n  'contexts',\n  'tags',\n  'fingerprint',\n  'propagationContext',\n] as const;\n\nfunction hintIsScopeContext(hint: Partial<ScopeContext> | EventHint): hint is Partial<ScopeContext> {\n  return Object.keys(hint).some(key => captureContextKeys.includes(key as ScopeContextProperty));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}