{"ast":null,"code":"var _jsxFileName = \"/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/src/contexts/FeatureFlagsContext.tsx\";\nimport React, { createContext, useContext, useEffect, useState, useCallback, useRef } from 'react';\nimport { unleashService, DEFAULT_FEATURE_FLAGS, FEATURE_CATEGORIES } from '../services/unleashService';\n\n// Enhanced context interface with full feature flag support\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// Default context value\nconst defaultContext = {\n  isFeatureEnabled: () => false,\n  getFeatureVariant: () => null,\n  getAllFlags: () => DEFAULT_FEATURE_FLAGS,\n  getFlagsByCategory: () => ({}),\n  updateContext: () => {},\n  isReady: false,\n  isInitialized: false,\n  status: {\n    initialized: false,\n    clientReady: false,\n    flagCount: 0\n  },\n  refresh: () => {}\n};\nexport const FeatureFlagsContext = /*#__PURE__*/createContext(defaultContext);\nexport const FeatureFlagsProvider = ({\n  children,\n  config = {},\n  fallbackFlags = {},\n  enableLogging = process.env.NODE_ENV === 'development'\n}) => {\n  const [isReady, setIsReady] = useState(false);\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [flags, setFlags] = useState({\n    ...DEFAULT_FEATURE_FLAGS,\n    ...fallbackFlags\n  });\n  const [status, setStatus] = useState({\n    initialized: false,\n    clientReady: false,\n    flagCount: 0\n  });\n  const [currentContext, setCurrentContext] = useState(config.context || {});\n  const initializationRef = useRef(false);\n\n  // Initialize Unleash service\n  useEffect(() => {\n    if (initializationRef.current) return;\n    initializationRef.current = true;\n    const initializeUnleash = async () => {\n      try {\n        if (enableLogging) {\n          console.log('Initializing Unleash service with config:', config);\n        }\n\n        // Initialize with configuration\n        await unleashService.initialize({\n          userId: config.userId,\n          environment: config.environment,\n          ...config.context\n        });\n\n        // Update initial state\n        setIsInitialized(true);\n        setIsReady(true);\n        setFlags(unleashService.getAllFlags(currentContext));\n        setStatus(unleashService.getStatus());\n        if (enableLogging) {\n          console.log('Unleash service initialized successfully');\n          console.log('Initial flags:', unleashService.getAllFlags(currentContext));\n        }\n      } catch (error) {\n        console.error('Failed to initialize Unleash service:', error);\n        // Continue with fallback flags\n        setIsInitialized(false);\n        setIsReady(true); // Still ready, just using defaults\n        setFlags({\n          ...DEFAULT_FEATURE_FLAGS,\n          ...fallbackFlags\n        });\n      }\n    };\n    initializeUnleash();\n  }, []); // Run once on mount\n\n  // Subscribe to flag updates\n  useEffect(() => {\n    const unsubscribe = unleashService.subscribe(() => {\n      if (enableLogging) {\n        console.log('Feature flags updated');\n      }\n      setFlags(unleashService.getAllFlags(currentContext));\n      setStatus(unleashService.getStatus());\n    });\n    return unsubscribe;\n  }, [currentContext, enableLogging]);\n\n  // Memoized flag checking function\n  const isFeatureEnabled = useCallback((flagName, context) => {\n    const mergedContext = {\n      ...currentContext,\n      ...context\n    };\n    if (!isInitialized) {\n      var _fallbackFlags$flagNa;\n      const fallbackValue = (_fallbackFlags$flagNa = fallbackFlags[flagName]) !== null && _fallbackFlags$flagNa !== void 0 ? _fallbackFlags$flagNa : DEFAULT_FEATURE_FLAGS[flagName];\n      if (enableLogging) {\n        console.log(`Feature flag ${flagName} checked (fallback): ${fallbackValue}`);\n      }\n      return fallbackValue;\n    }\n    const isEnabled = unleashService.isEnabled(flagName, mergedContext);\n    if (enableLogging) {\n      console.log(`Feature flag ${flagName} checked: ${isEnabled}`);\n    }\n    return isEnabled;\n  }, [isInitialized, currentContext, fallbackFlags, enableLogging]);\n\n  // Memoized variant getting function\n  const getFeatureVariant = useCallback((flagName, context) => {\n    const mergedContext = {\n      ...currentContext,\n      ...context\n    };\n    if (!isInitialized) {\n      if (enableLogging) {\n        console.log(`Feature variant ${flagName} requested (fallback): null`);\n      }\n      return null;\n    }\n    const variant = unleashService.getVariant(flagName, mergedContext);\n    if (enableLogging) {\n      console.log(`Feature variant ${flagName} requested:`, variant);\n    }\n    return variant;\n  }, [isInitialized, currentContext, enableLogging]);\n\n  // Get all flags\n  const getAllFlags = useCallback(context => {\n    const mergedContext = {\n      ...currentContext,\n      ...context\n    };\n    if (!isInitialized) {\n      return {\n        ...DEFAULT_FEATURE_FLAGS,\n        ...fallbackFlags\n      };\n    }\n    return unleashService.getAllFlags(mergedContext);\n  }, [isInitialized, currentContext, fallbackFlags]);\n\n  // Get flags by category\n  const getFlagsByCategory = useCallback((category, context) => {\n    const mergedContext = {\n      ...currentContext,\n      ...context\n    };\n    if (!isInitialized) {\n      const categoryFlags = FEATURE_CATEGORIES[category];\n      const result = {};\n      categoryFlags.forEach(flagName => {\n        var _fallbackFlags$key;\n        const key = flagName;\n        result[key] = (_fallbackFlags$key = fallbackFlags[key]) !== null && _fallbackFlags$key !== void 0 ? _fallbackFlags$key : DEFAULT_FEATURE_FLAGS[key];\n      });\n      return result;\n    }\n    return unleashService.getFlagsByCategory(category, mergedContext);\n  }, [isInitialized, currentContext, fallbackFlags]);\n\n  // Update context\n  const updateContext = useCallback(newContext => {\n    setCurrentContext(prev => ({\n      ...prev,\n      ...newContext\n    }));\n    if (isInitialized) {\n      unleashService.updateContext(newContext);\n    }\n    if (enableLogging) {\n      console.log('Feature flags context updated:', newContext);\n    }\n  }, [isInitialized, enableLogging]);\n\n  // Refresh flags manually\n  const refresh = useCallback(() => {\n    if (isInitialized) {\n      setFlags(unleashService.getAllFlags(currentContext));\n      setStatus(unleashService.getStatus());\n    }\n    if (enableLogging) {\n      console.log('Feature flags refreshed manually');\n    }\n  }, [isInitialized, currentContext, enableLogging]);\n\n  // Context value\n  const contextValue = {\n    isFeatureEnabled,\n    getFeatureVariant,\n    getAllFlags,\n    getFlagsByCategory,\n    updateContext,\n    isReady,\n    isInitialized,\n    status,\n    refresh\n  };\n\n  // Log provider status changes\n  useEffect(() => {\n    if (enableLogging) {\n      console.log('FeatureFlagsProvider status:', {\n        isReady,\n        isInitialized,\n        flagCount: Object.keys(flags).length,\n        status\n      });\n    }\n  }, [isReady, isInitialized, flags, status, enableLogging]);\n  return /*#__PURE__*/_jsxDEV(FeatureFlagsContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 254,\n    columnNumber: 5\n  }, this);\n};\n\n// Enhanced hook with better error handling\nexport const useFeatureFlags = () => {\n  const context = useContext(FeatureFlagsContext);\n  if (context === undefined) {\n    throw new Error('useFeatureFlags must be used within a FeatureFlagsProvider');\n  }\n  return context;\n};\n\n// Convenience hooks for common patterns\nexport const useFeatureFlag = (flagName, context) => {\n  const {\n    isFeatureEnabled,\n    getFeatureVariant\n  } = useFeatureFlags();\n  return {\n    isEnabled: isFeatureEnabled(flagName, context),\n    variant: getFeatureVariant(flagName, context)\n  };\n};\nexport const useFeatureFlagWithFallback = (flagName, fallback = false, context) => {\n  const {\n    isFeatureEnabled,\n    isReady\n  } = useFeatureFlags();\n  if (!isReady) {\n    return fallback;\n  }\n  return isFeatureEnabled(flagName, context);\n};\n\n// Clean up on unmount\nexport const FeatureFlagsCleanup = () => {\n  useEffect(() => {\n    return () => {\n      unleashService.destroy();\n    };\n  }, []);\n  return null;\n};","map":{"version":3,"names":["React","createContext","useContext","useEffect","useState","useCallback","useRef","unleashService","DEFAULT_FEATURE_FLAGS","FEATURE_CATEGORIES","jsxDEV","_jsxDEV","defaultContext","isFeatureEnabled","getFeatureVariant","getAllFlags","getFlagsByCategory","updateContext","isReady","isInitialized","status","initialized","clientReady","flagCount","refresh","FeatureFlagsContext","FeatureFlagsProvider","children","config","fallbackFlags","enableLogging","process","env","NODE_ENV","setIsReady","setIsInitialized","flags","setFlags","setStatus","currentContext","setCurrentContext","context","initializationRef","current","initializeUnleash","console","log","initialize","userId","environment","getStatus","error","unsubscribe","subscribe","flagName","mergedContext","_fallbackFlags$flagNa","fallbackValue","isEnabled","variant","getVariant","category","categoryFlags","result","forEach","_fallbackFlags$key","key","newContext","prev","contextValue","Object","keys","length","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","useFeatureFlags","undefined","Error","useFeatureFlag","useFeatureFlagWithFallback","fallback","FeatureFlagsCleanup","destroy"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/src/contexts/FeatureFlagsContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useEffect, useState, useCallback, useRef } from 'react';\nimport { unleashService, FeatureFlags, DEFAULT_FEATURE_FLAGS, FEATURE_CATEGORIES } from '../services/unleashService';\n\n// Enhanced context interface with full feature flag support\ninterface FeatureFlagsContextType {\n  // Basic flag checking\n  isFeatureEnabled: (flagName: keyof FeatureFlags, context?: Record<string, string>) => boolean;\n  getFeatureVariant: (flagName: keyof FeatureFlags, context?: Record<string, string>) => any;\n  \n  // Bulk operations\n  getAllFlags: (context?: Record<string, string>) => FeatureFlags;\n  getFlagsByCategory: (category: keyof typeof FEATURE_CATEGORIES, context?: Record<string, string>) => Partial<FeatureFlags>;\n  \n  // Context management\n  updateContext: (context: Record<string, string>) => void;\n  \n  // Status and debugging\n  isReady: boolean;\n  isInitialized: boolean;\n  status: { initialized: boolean; clientReady: boolean; flagCount: number };\n  \n  // Refresh functionality\n  refresh: () => void;\n}\n\n// Default context value\nconst defaultContext: FeatureFlagsContextType = {\n  isFeatureEnabled: () => false,\n  getFeatureVariant: () => null,\n  getAllFlags: () => DEFAULT_FEATURE_FLAGS,\n  getFlagsByCategory: () => ({}),\n  updateContext: () => {},\n  isReady: false,\n  isInitialized: false,\n  status: { initialized: false, clientReady: false, flagCount: 0 },\n  refresh: () => {}\n};\n\nexport const FeatureFlagsContext = createContext<FeatureFlagsContextType>(defaultContext);\n\ninterface FeatureFlagsProviderProps {\n  children: React.ReactNode;\n  config?: {\n    url?: string;\n    clientKey?: string;\n    refreshInterval?: number;\n    context?: Record<string, string>;\n    userId?: string;\n    environment?: string;\n  };\n  fallbackFlags?: Partial<FeatureFlags>;\n  enableLogging?: boolean;\n}\n\nexport const FeatureFlagsProvider: React.FC<FeatureFlagsProviderProps> = ({ \n  children, \n  config = {},\n  fallbackFlags = {},\n  enableLogging = process.env.NODE_ENV === 'development'\n}) => {\n  const [isReady, setIsReady] = useState(false);\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [flags, setFlags] = useState<FeatureFlags>({ ...DEFAULT_FEATURE_FLAGS, ...fallbackFlags });\n  const [status, setStatus] = useState({ initialized: false, clientReady: false, flagCount: 0 });\n  const [currentContext, setCurrentContext] = useState<Record<string, string>>(config.context || {});\n  const initializationRef = useRef(false);\n\n  // Initialize Unleash service\n  useEffect(() => {\n    if (initializationRef.current) return;\n    initializationRef.current = true;\n\n    const initializeUnleash = async () => {\n      try {\n        if (enableLogging) {\n          console.log('Initializing Unleash service with config:', config);\n        }\n\n        // Initialize with configuration\n        await unleashService.initialize({\n          userId: config.userId,\n          environment: config.environment,\n          ...config.context\n        });\n\n        // Update initial state\n        setIsInitialized(true);\n        setIsReady(true);\n        setFlags(unleashService.getAllFlags(currentContext));\n        setStatus(unleashService.getStatus());\n\n        if (enableLogging) {\n          console.log('Unleash service initialized successfully');\n          console.log('Initial flags:', unleashService.getAllFlags(currentContext));\n        }\n\n      } catch (error) {\n        console.error('Failed to initialize Unleash service:', error);\n        // Continue with fallback flags\n        setIsInitialized(false);\n        setIsReady(true); // Still ready, just using defaults\n        setFlags({ ...DEFAULT_FEATURE_FLAGS, ...fallbackFlags });\n      }\n    };\n\n    initializeUnleash();\n  }, []); // Run once on mount\n\n  // Subscribe to flag updates\n  useEffect(() => {\n    const unsubscribe = unleashService.subscribe(() => {\n      if (enableLogging) {\n        console.log('Feature flags updated');\n      }\n      \n      setFlags(unleashService.getAllFlags(currentContext));\n      setStatus(unleashService.getStatus());\n    });\n\n    return unsubscribe;\n  }, [currentContext, enableLogging]);\n\n  // Memoized flag checking function\n  const isFeatureEnabled = useCallback((\n    flagName: keyof FeatureFlags, \n    context?: Record<string, string>\n  ): boolean => {\n    const mergedContext = { ...currentContext, ...context };\n    \n    if (!isInitialized) {\n      const fallbackValue = fallbackFlags[flagName] ?? DEFAULT_FEATURE_FLAGS[flagName];\n      if (enableLogging) {\n        console.log(`Feature flag ${flagName} checked (fallback): ${fallbackValue}`);\n      }\n      return fallbackValue;\n    }\n\n    const isEnabled = unleashService.isEnabled(flagName, mergedContext);\n    \n    if (enableLogging) {\n      console.log(`Feature flag ${flagName} checked: ${isEnabled}`);\n    }\n    \n    return isEnabled;\n  }, [isInitialized, currentContext, fallbackFlags, enableLogging]);\n\n  // Memoized variant getting function\n  const getFeatureVariant = useCallback((\n    flagName: keyof FeatureFlags, \n    context?: Record<string, string>\n  ): any => {\n    const mergedContext = { ...currentContext, ...context };\n    \n    if (!isInitialized) {\n      if (enableLogging) {\n        console.log(`Feature variant ${flagName} requested (fallback): null`);\n      }\n      return null;\n    }\n\n    const variant = unleashService.getVariant(flagName, mergedContext);\n    \n    if (enableLogging) {\n      console.log(`Feature variant ${flagName} requested:`, variant);\n    }\n    \n    return variant;\n  }, [isInitialized, currentContext, enableLogging]);\n\n  // Get all flags\n  const getAllFlags = useCallback((context?: Record<string, string>): FeatureFlags => {\n    const mergedContext = { ...currentContext, ...context };\n    \n    if (!isInitialized) {\n      return { ...DEFAULT_FEATURE_FLAGS, ...fallbackFlags };\n    }\n\n    return unleashService.getAllFlags(mergedContext);\n  }, [isInitialized, currentContext, fallbackFlags]);\n\n  // Get flags by category\n  const getFlagsByCategory = useCallback((\n    category: keyof typeof FEATURE_CATEGORIES, \n    context?: Record<string, string>\n  ): Partial<FeatureFlags> => {\n    const mergedContext = { ...currentContext, ...context };\n    \n    if (!isInitialized) {\n      const categoryFlags = FEATURE_CATEGORIES[category];\n      const result = {} as Partial<FeatureFlags>;\n      \n      categoryFlags.forEach(flagName => {\n        const key = flagName as keyof FeatureFlags;\n        result[key] = fallbackFlags[key] ?? DEFAULT_FEATURE_FLAGS[key];\n      });\n      \n      return result;\n    }\n\n    return unleashService.getFlagsByCategory(category, mergedContext);\n  }, [isInitialized, currentContext, fallbackFlags]);\n\n  // Update context\n  const updateContext = useCallback((newContext: Record<string, string>) => {\n    setCurrentContext(prev => ({ ...prev, ...newContext }));\n    \n    if (isInitialized) {\n      unleashService.updateContext(newContext);\n    }\n    \n    if (enableLogging) {\n      console.log('Feature flags context updated:', newContext);\n    }\n  }, [isInitialized, enableLogging]);\n\n  // Refresh flags manually\n  const refresh = useCallback(() => {\n    if (isInitialized) {\n      setFlags(unleashService.getAllFlags(currentContext));\n      setStatus(unleashService.getStatus());\n    }\n    \n    if (enableLogging) {\n      console.log('Feature flags refreshed manually');\n    }\n  }, [isInitialized, currentContext, enableLogging]);\n\n  // Context value\n  const contextValue: FeatureFlagsContextType = {\n    isFeatureEnabled,\n    getFeatureVariant,\n    getAllFlags,\n    getFlagsByCategory,\n    updateContext,\n    isReady,\n    isInitialized,\n    status,\n    refresh\n  };\n\n  // Log provider status changes\n  useEffect(() => {\n    if (enableLogging) {\n      console.log('FeatureFlagsProvider status:', {\n        isReady,\n        isInitialized,\n        flagCount: Object.keys(flags).length,\n        status\n      });\n    }\n  }, [isReady, isInitialized, flags, status, enableLogging]);\n\n  return (\n    <FeatureFlagsContext.Provider value={contextValue}>\n      {children}\n    </FeatureFlagsContext.Provider>\n  );\n};\n\n// Enhanced hook with better error handling\nexport const useFeatureFlags = () => {\n  const context = useContext(FeatureFlagsContext);\n  \n  if (context === undefined) {\n    throw new Error('useFeatureFlags must be used within a FeatureFlagsProvider');\n  }\n  \n  return context;\n};\n\n// Convenience hooks for common patterns\nexport const useFeatureFlag = (flagName: keyof FeatureFlags, context?: Record<string, string>) => {\n  const { isFeatureEnabled, getFeatureVariant } = useFeatureFlags();\n  \n  return {\n    isEnabled: isFeatureEnabled(flagName, context),\n    variant: getFeatureVariant(flagName, context)\n  };\n};\n\nexport const useFeatureFlagWithFallback = (\n  flagName: keyof FeatureFlags, \n  fallback: boolean = false,\n  context?: Record<string, string>\n) => {\n  const { isFeatureEnabled, isReady } = useFeatureFlags();\n  \n  if (!isReady) {\n    return fallback;\n  }\n  \n  return isFeatureEnabled(flagName, context);\n};\n\n// Clean up on unmount\nexport const FeatureFlagsCleanup: React.FC = () => {\n  useEffect(() => {\n    return () => {\n      unleashService.destroy();\n    };\n  }, []);\n  \n  return null;\n};"],"mappings":";AAAA,OAAOA,KAAK,IAAIC,aAAa,EAAEC,UAAU,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,WAAW,EAAEC,MAAM,QAAQ,OAAO;AAClG,SAASC,cAAc,EAAgBC,qBAAqB,EAAEC,kBAAkB,QAAQ,4BAA4B;;AAEpH;AAAA,SAAAC,MAAA,IAAAC,OAAA;AAsBA;AACA,MAAMC,cAAuC,GAAG;EAC9CC,gBAAgB,EAAEA,CAAA,KAAM,KAAK;EAC7BC,iBAAiB,EAAEA,CAAA,KAAM,IAAI;EAC7BC,WAAW,EAAEA,CAAA,KAAMP,qBAAqB;EACxCQ,kBAAkB,EAAEA,CAAA,MAAO,CAAC,CAAC,CAAC;EAC9BC,aAAa,EAAEA,CAAA,KAAM,CAAC,CAAC;EACvBC,OAAO,EAAE,KAAK;EACdC,aAAa,EAAE,KAAK;EACpBC,MAAM,EAAE;IAAEC,WAAW,EAAE,KAAK;IAAEC,WAAW,EAAE,KAAK;IAAEC,SAAS,EAAE;EAAE,CAAC;EAChEC,OAAO,EAAEA,CAAA,KAAM,CAAC;AAClB,CAAC;AAED,OAAO,MAAMC,mBAAmB,gBAAGxB,aAAa,CAA0BW,cAAc,CAAC;AAgBzF,OAAO,MAAMc,oBAAyD,GAAGA,CAAC;EACxEC,QAAQ;EACRC,MAAM,GAAG,CAAC,CAAC;EACXC,aAAa,GAAG,CAAC,CAAC;EAClBC,aAAa,GAAGC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK;AAC3C,CAAC,KAAK;EACJ,MAAM,CAACf,OAAO,EAAEgB,UAAU,CAAC,GAAG9B,QAAQ,CAAC,KAAK,CAAC;EAC7C,MAAM,CAACe,aAAa,EAAEgB,gBAAgB,CAAC,GAAG/B,QAAQ,CAAC,KAAK,CAAC;EACzD,MAAM,CAACgC,KAAK,EAAEC,QAAQ,CAAC,GAAGjC,QAAQ,CAAe;IAAE,GAAGI,qBAAqB;IAAE,GAAGqB;EAAc,CAAC,CAAC;EAChG,MAAM,CAACT,MAAM,EAAEkB,SAAS,CAAC,GAAGlC,QAAQ,CAAC;IAAEiB,WAAW,EAAE,KAAK;IAAEC,WAAW,EAAE,KAAK;IAAEC,SAAS,EAAE;EAAE,CAAC,CAAC;EAC9F,MAAM,CAACgB,cAAc,EAAEC,iBAAiB,CAAC,GAAGpC,QAAQ,CAAyBwB,MAAM,CAACa,OAAO,IAAI,CAAC,CAAC,CAAC;EAClG,MAAMC,iBAAiB,GAAGpC,MAAM,CAAC,KAAK,CAAC;;EAEvC;EACAH,SAAS,CAAC,MAAM;IACd,IAAIuC,iBAAiB,CAACC,OAAO,EAAE;IAC/BD,iBAAiB,CAACC,OAAO,GAAG,IAAI;IAEhC,MAAMC,iBAAiB,GAAG,MAAAA,CAAA,KAAY;MACpC,IAAI;QACF,IAAId,aAAa,EAAE;UACjBe,OAAO,CAACC,GAAG,CAAC,2CAA2C,EAAElB,MAAM,CAAC;QAClE;;QAEA;QACA,MAAMrB,cAAc,CAACwC,UAAU,CAAC;UAC9BC,MAAM,EAAEpB,MAAM,CAACoB,MAAM;UACrBC,WAAW,EAAErB,MAAM,CAACqB,WAAW;UAC/B,GAAGrB,MAAM,CAACa;QACZ,CAAC,CAAC;;QAEF;QACAN,gBAAgB,CAAC,IAAI,CAAC;QACtBD,UAAU,CAAC,IAAI,CAAC;QAChBG,QAAQ,CAAC9B,cAAc,CAACQ,WAAW,CAACwB,cAAc,CAAC,CAAC;QACpDD,SAAS,CAAC/B,cAAc,CAAC2C,SAAS,CAAC,CAAC,CAAC;QAErC,IAAIpB,aAAa,EAAE;UACjBe,OAAO,CAACC,GAAG,CAAC,0CAA0C,CAAC;UACvDD,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAEvC,cAAc,CAACQ,WAAW,CAACwB,cAAc,CAAC,CAAC;QAC3E;MAEF,CAAC,CAAC,OAAOY,KAAK,EAAE;QACdN,OAAO,CAACM,KAAK,CAAC,uCAAuC,EAAEA,KAAK,CAAC;QAC7D;QACAhB,gBAAgB,CAAC,KAAK,CAAC;QACvBD,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC;QAClBG,QAAQ,CAAC;UAAE,GAAG7B,qBAAqB;UAAE,GAAGqB;QAAc,CAAC,CAAC;MAC1D;IACF,CAAC;IAEDe,iBAAiB,CAAC,CAAC;EACrB,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;;EAER;EACAzC,SAAS,CAAC,MAAM;IACd,MAAMiD,WAAW,GAAG7C,cAAc,CAAC8C,SAAS,CAAC,MAAM;MACjD,IAAIvB,aAAa,EAAE;QACjBe,OAAO,CAACC,GAAG,CAAC,uBAAuB,CAAC;MACtC;MAEAT,QAAQ,CAAC9B,cAAc,CAACQ,WAAW,CAACwB,cAAc,CAAC,CAAC;MACpDD,SAAS,CAAC/B,cAAc,CAAC2C,SAAS,CAAC,CAAC,CAAC;IACvC,CAAC,CAAC;IAEF,OAAOE,WAAW;EACpB,CAAC,EAAE,CAACb,cAAc,EAAET,aAAa,CAAC,CAAC;;EAEnC;EACA,MAAMjB,gBAAgB,GAAGR,WAAW,CAAC,CACnCiD,QAA4B,EAC5Bb,OAAgC,KACpB;IACZ,MAAMc,aAAa,GAAG;MAAE,GAAGhB,cAAc;MAAE,GAAGE;IAAQ,CAAC;IAEvD,IAAI,CAACtB,aAAa,EAAE;MAAA,IAAAqC,qBAAA;MAClB,MAAMC,aAAa,IAAAD,qBAAA,GAAG3B,aAAa,CAACyB,QAAQ,CAAC,cAAAE,qBAAA,cAAAA,qBAAA,GAAIhD,qBAAqB,CAAC8C,QAAQ,CAAC;MAChF,IAAIxB,aAAa,EAAE;QACjBe,OAAO,CAACC,GAAG,CAAC,gBAAgBQ,QAAQ,wBAAwBG,aAAa,EAAE,CAAC;MAC9E;MACA,OAAOA,aAAa;IACtB;IAEA,MAAMC,SAAS,GAAGnD,cAAc,CAACmD,SAAS,CAACJ,QAAQ,EAAEC,aAAa,CAAC;IAEnE,IAAIzB,aAAa,EAAE;MACjBe,OAAO,CAACC,GAAG,CAAC,gBAAgBQ,QAAQ,aAAaI,SAAS,EAAE,CAAC;IAC/D;IAEA,OAAOA,SAAS;EAClB,CAAC,EAAE,CAACvC,aAAa,EAAEoB,cAAc,EAAEV,aAAa,EAAEC,aAAa,CAAC,CAAC;;EAEjE;EACA,MAAMhB,iBAAiB,GAAGT,WAAW,CAAC,CACpCiD,QAA4B,EAC5Bb,OAAgC,KACxB;IACR,MAAMc,aAAa,GAAG;MAAE,GAAGhB,cAAc;MAAE,GAAGE;IAAQ,CAAC;IAEvD,IAAI,CAACtB,aAAa,EAAE;MAClB,IAAIW,aAAa,EAAE;QACjBe,OAAO,CAACC,GAAG,CAAC,mBAAmBQ,QAAQ,6BAA6B,CAAC;MACvE;MACA,OAAO,IAAI;IACb;IAEA,MAAMK,OAAO,GAAGpD,cAAc,CAACqD,UAAU,CAACN,QAAQ,EAAEC,aAAa,CAAC;IAElE,IAAIzB,aAAa,EAAE;MACjBe,OAAO,CAACC,GAAG,CAAC,mBAAmBQ,QAAQ,aAAa,EAAEK,OAAO,CAAC;IAChE;IAEA,OAAOA,OAAO;EAChB,CAAC,EAAE,CAACxC,aAAa,EAAEoB,cAAc,EAAET,aAAa,CAAC,CAAC;;EAElD;EACA,MAAMf,WAAW,GAAGV,WAAW,CAAEoC,OAAgC,IAAmB;IAClF,MAAMc,aAAa,GAAG;MAAE,GAAGhB,cAAc;MAAE,GAAGE;IAAQ,CAAC;IAEvD,IAAI,CAACtB,aAAa,EAAE;MAClB,OAAO;QAAE,GAAGX,qBAAqB;QAAE,GAAGqB;MAAc,CAAC;IACvD;IAEA,OAAOtB,cAAc,CAACQ,WAAW,CAACwC,aAAa,CAAC;EAClD,CAAC,EAAE,CAACpC,aAAa,EAAEoB,cAAc,EAAEV,aAAa,CAAC,CAAC;;EAElD;EACA,MAAMb,kBAAkB,GAAGX,WAAW,CAAC,CACrCwD,QAAyC,EACzCpB,OAAgC,KACN;IAC1B,MAAMc,aAAa,GAAG;MAAE,GAAGhB,cAAc;MAAE,GAAGE;IAAQ,CAAC;IAEvD,IAAI,CAACtB,aAAa,EAAE;MAClB,MAAM2C,aAAa,GAAGrD,kBAAkB,CAACoD,QAAQ,CAAC;MAClD,MAAME,MAAM,GAAG,CAAC,CAA0B;MAE1CD,aAAa,CAACE,OAAO,CAACV,QAAQ,IAAI;QAAA,IAAAW,kBAAA;QAChC,MAAMC,GAAG,GAAGZ,QAA8B;QAC1CS,MAAM,CAACG,GAAG,CAAC,IAAAD,kBAAA,GAAGpC,aAAa,CAACqC,GAAG,CAAC,cAAAD,kBAAA,cAAAA,kBAAA,GAAIzD,qBAAqB,CAAC0D,GAAG,CAAC;MAChE,CAAC,CAAC;MAEF,OAAOH,MAAM;IACf;IAEA,OAAOxD,cAAc,CAACS,kBAAkB,CAAC6C,QAAQ,EAAEN,aAAa,CAAC;EACnE,CAAC,EAAE,CAACpC,aAAa,EAAEoB,cAAc,EAAEV,aAAa,CAAC,CAAC;;EAElD;EACA,MAAMZ,aAAa,GAAGZ,WAAW,CAAE8D,UAAkC,IAAK;IACxE3B,iBAAiB,CAAC4B,IAAI,KAAK;MAAE,GAAGA,IAAI;MAAE,GAAGD;IAAW,CAAC,CAAC,CAAC;IAEvD,IAAIhD,aAAa,EAAE;MACjBZ,cAAc,CAACU,aAAa,CAACkD,UAAU,CAAC;IAC1C;IAEA,IAAIrC,aAAa,EAAE;MACjBe,OAAO,CAACC,GAAG,CAAC,gCAAgC,EAAEqB,UAAU,CAAC;IAC3D;EACF,CAAC,EAAE,CAAChD,aAAa,EAAEW,aAAa,CAAC,CAAC;;EAElC;EACA,MAAMN,OAAO,GAAGnB,WAAW,CAAC,MAAM;IAChC,IAAIc,aAAa,EAAE;MACjBkB,QAAQ,CAAC9B,cAAc,CAACQ,WAAW,CAACwB,cAAc,CAAC,CAAC;MACpDD,SAAS,CAAC/B,cAAc,CAAC2C,SAAS,CAAC,CAAC,CAAC;IACvC;IAEA,IAAIpB,aAAa,EAAE;MACjBe,OAAO,CAACC,GAAG,CAAC,kCAAkC,CAAC;IACjD;EACF,CAAC,EAAE,CAAC3B,aAAa,EAAEoB,cAAc,EAAET,aAAa,CAAC,CAAC;;EAElD;EACA,MAAMuC,YAAqC,GAAG;IAC5CxD,gBAAgB;IAChBC,iBAAiB;IACjBC,WAAW;IACXC,kBAAkB;IAClBC,aAAa;IACbC,OAAO;IACPC,aAAa;IACbC,MAAM;IACNI;EACF,CAAC;;EAED;EACArB,SAAS,CAAC,MAAM;IACd,IAAI2B,aAAa,EAAE;MACjBe,OAAO,CAACC,GAAG,CAAC,8BAA8B,EAAE;QAC1C5B,OAAO;QACPC,aAAa;QACbI,SAAS,EAAE+C,MAAM,CAACC,IAAI,CAACnC,KAAK,CAAC,CAACoC,MAAM;QACpCpD;MACF,CAAC,CAAC;IACJ;EACF,CAAC,EAAE,CAACF,OAAO,EAAEC,aAAa,EAAEiB,KAAK,EAAEhB,MAAM,EAAEU,aAAa,CAAC,CAAC;EAE1D,oBACEnB,OAAA,CAACc,mBAAmB,CAACgD,QAAQ;IAACC,KAAK,EAAEL,YAAa;IAAA1C,QAAA,EAC/CA;EAAQ;IAAAgD,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACmB,CAAC;AAEnC,CAAC;;AAED;AACA,OAAO,MAAMC,eAAe,GAAGA,CAAA,KAAM;EACnC,MAAMtC,OAAO,GAAGvC,UAAU,CAACuB,mBAAmB,CAAC;EAE/C,IAAIgB,OAAO,KAAKuC,SAAS,EAAE;IACzB,MAAM,IAAIC,KAAK,CAAC,4DAA4D,CAAC;EAC/E;EAEA,OAAOxC,OAAO;AAChB,CAAC;;AAED;AACA,OAAO,MAAMyC,cAAc,GAAGA,CAAC5B,QAA4B,EAAEb,OAAgC,KAAK;EAChG,MAAM;IAAE5B,gBAAgB;IAAEC;EAAkB,CAAC,GAAGiE,eAAe,CAAC,CAAC;EAEjE,OAAO;IACLrB,SAAS,EAAE7C,gBAAgB,CAACyC,QAAQ,EAAEb,OAAO,CAAC;IAC9CkB,OAAO,EAAE7C,iBAAiB,CAACwC,QAAQ,EAAEb,OAAO;EAC9C,CAAC;AACH,CAAC;AAED,OAAO,MAAM0C,0BAA0B,GAAGA,CACxC7B,QAA4B,EAC5B8B,QAAiB,GAAG,KAAK,EACzB3C,OAAgC,KAC7B;EACH,MAAM;IAAE5B,gBAAgB;IAAEK;EAAQ,CAAC,GAAG6D,eAAe,CAAC,CAAC;EAEvD,IAAI,CAAC7D,OAAO,EAAE;IACZ,OAAOkE,QAAQ;EACjB;EAEA,OAAOvE,gBAAgB,CAACyC,QAAQ,EAAEb,OAAO,CAAC;AAC5C,CAAC;;AAED;AACA,OAAO,MAAM4C,mBAA6B,GAAGA,CAAA,KAAM;EACjDlF,SAAS,CAAC,MAAM;IACd,OAAO,MAAM;MACXI,cAAc,CAAC+E,OAAO,CAAC,CAAC;IAC1B,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;EAEN,OAAO,IAAI;AACb,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}