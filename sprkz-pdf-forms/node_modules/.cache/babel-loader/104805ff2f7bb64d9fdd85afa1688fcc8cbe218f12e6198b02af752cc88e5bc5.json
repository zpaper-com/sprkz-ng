{"ast":null,"code":"import { PDFService } from './pdfService';\nexport class FormFieldService {\n  /**\n   * Extract all form fields from a PDF document\n   */\n  static async extractAllFormFields(pdfDoc, options = {}) {\n    const {\n      excludeReadOnly = false,\n      includeSignatureFields = true,\n      validateFieldNames = true\n    } = options;\n    const documentId = pdfDoc.fingerprints[0];\n\n    // Check cache first\n    if (this.extractedFields.has(documentId)) {\n      let fields = this.extractedFields.get(documentId);\n\n      // Apply filters\n      if (excludeReadOnly) {\n        fields = fields.filter(field => !field.readOnly);\n      }\n      return fields;\n    }\n    const allFields = [];\n    const fieldNameCounts = new Map();\n    try {\n      for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {\n        const page = await PDFService.getPage(pdfDoc, pageNum);\n        const pageFields = await PDFService.extractFormFields(page);\n\n        // Process and enhance each field\n        const processedFields = pageFields.map(field => {\n          let fieldName = field.name;\n\n          // Handle duplicate field names by adding suffix\n          if (validateFieldNames && fieldNameCounts.has(fieldName)) {\n            const count = fieldNameCounts.get(fieldName) + 1;\n            fieldNameCounts.set(fieldName, count);\n            fieldName = `${fieldName}_${count}`;\n          } else {\n            fieldNameCounts.set(fieldName, 1);\n          }\n\n          // Determine field type based on annotation properties\n          const fieldType = this.determineFieldType(field);\n\n          // Enhanced form field object\n          const enhancedField = {\n            name: fieldName,\n            type: fieldType,\n            value: this.getInitialValue(field, fieldType),\n            required: this.isFieldRequired(field),\n            readOnly: field.readOnly || false,\n            page: pageNum,\n            rect: field.rect,\n            isComplete: false,\n            validationErrors: [],\n            options: field.options || undefined,\n            multiline: field.multiline || false,\n            maxLength: field.maxLength || undefined,\n            pattern: this.getValidationPattern(field, fieldType),\n            id: field.id,\n            subtype: field.subtype\n          };\n          return enhancedField;\n        });\n        allFields.push(...processedFields);\n      }\n\n      // Cache the results\n      this.extractedFields.set(documentId, allFields);\n      console.log(`Extracted ${allFields.length} form fields from ${pdfDoc.numPages} pages`);\n\n      // Apply final filters\n      let filteredFields = allFields;\n      if (excludeReadOnly) {\n        filteredFields = filteredFields.filter(field => !field.readOnly);\n      }\n      return filteredFields;\n    } catch (error) {\n      console.error('Error extracting form fields:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Categorize form fields by type and requirements\n   */\n  static categorizeFields(fields) {\n    // Create cache key based on field names and properties\n    const cacheKey = fields.map(f => `${f.name}-${f.type}-${f.required}`).sort().join('|');\n\n    // Check cache first\n    if (this.categorizedCache.has(cacheKey)) {\n      return this.categorizedCache.get(cacheKey);\n    }\n    const categories = {\n      required: [],\n      optional: [],\n      signature: [],\n      readOnly: []\n    };\n    fields.forEach(field => {\n      if (field.readOnly) {\n        categories.readOnly.push(field);\n      } else if (field.type === 'signature') {\n        categories.signature.push(field);\n      } else if (field.required) {\n        categories.required.push(field);\n      } else {\n        categories.optional.push(field);\n      }\n    });\n    console.log('Field categorization:', {\n      required: categories.required.length,\n      optional: categories.optional.length,\n      signature: categories.signature.length,\n      readOnly: categories.readOnly.length\n    });\n\n    // Cache the result\n    this.categorizedCache.set(cacheKey, categories);\n    return categories;\n  }\n\n  /**\n   * Get fields that still need completion\n   */\n  static getIncompleteFields(fields) {\n    return fields.filter(field => !field.isComplete && !field.readOnly);\n  }\n\n  /**\n   * Get required fields that still need completion\n   */\n  static getIncompleteRequiredFields(fields) {\n    return fields.filter(field => field.required && !field.isComplete && !field.readOnly);\n  }\n\n  /**\n   * Get signature fields\n   */\n  static getSignatureFields(fields) {\n    return fields.filter(field => field.type === 'signature' || field.name.toLowerCase().includes('signature') || field.name.toLowerCase().includes('sign'));\n  }\n\n  /**\n   * Calculate form completion percentage\n   */\n  static calculateCompletionPercentage(fields) {\n    const requiredFields = fields.filter(field => field.required && !field.readOnly);\n    if (requiredFields.length === 0) return 100;\n    const completedFields = requiredFields.filter(field => field.isComplete);\n    return Math.round(completedFields.length / requiredFields.length * 100);\n  }\n\n  /**\n   * Validate field value based on field type and constraints\n   */\n  static validateFieldValue(field, value) {\n    const errors = [];\n\n    // Required field validation\n    if (field.required && !field.readOnly) {\n      if (value === undefined || value === null || value === '') {\n        errors.push('This field is required');\n      }\n    }\n\n    // Skip further validation if empty and not required\n    if (!value && !field.required) {\n      return errors;\n    }\n\n    // Type-specific validation\n    switch (field.type) {\n      case 'text':\n        if (typeof value !== 'string') {\n          errors.push('Value must be text');\n          break;\n        }\n        if (field.maxLength && value.length > field.maxLength) {\n          errors.push(`Text must be ${field.maxLength} characters or less`);\n        }\n        if (field.pattern) {\n          const regex = new RegExp(field.pattern);\n          if (!regex.test(value)) {\n            errors.push('Invalid format');\n          }\n        }\n        break;\n      case 'checkbox':\n        if (typeof value !== 'boolean') {\n          errors.push('Value must be true or false');\n        }\n        break;\n      case 'radio':\n      case 'dropdown':\n        if (field.options && !field.options.includes(value)) {\n          errors.push('Invalid selection');\n        }\n        break;\n      case 'date':\n        if (typeof value === 'string') {\n          const date = new Date(value);\n          if (isNaN(date.getTime())) {\n            errors.push('Invalid date format');\n          }\n        }\n        break;\n    }\n    return errors;\n  }\n\n  /**\n   * Update field completion status\n   */\n  static updateFieldCompletion(field, value) {\n    const errors = this.validateFieldValue(field, value);\n    const isComplete = errors.length === 0 && this.hasValidValue(field, value);\n    return {\n      ...field,\n      value,\n      isComplete,\n      validationErrors: errors\n    };\n  }\n\n  /**\n   * Private helper methods\n   */\n  static determineFieldType(field) {\n    // Check field name for signature indicators\n    const fieldName = (field.name || '').toLowerCase();\n    if (fieldName.includes('signature') || fieldName.includes('sign')) {\n      return 'signature';\n    }\n\n    // Check annotation subtype and fieldType\n    switch (field.type || field.fieldType) {\n      case 'Tx':\n        // Text field\n        return 'text';\n      case 'Btn':\n        // Button field (could be checkbox or radio)\n        if (field.checkBox || field.radioButton === false) {\n          return 'checkbox';\n        } else {\n          return 'radio';\n        }\n      case 'Ch':\n        // Choice field (dropdown or listbox)\n        return 'dropdown';\n      case 'Sig':\n        // Signature field\n        return 'signature';\n      default:\n        // Fallback based on field properties\n        if (field.options && Array.isArray(field.options)) {\n          return 'dropdown';\n        }\n        if (field.checkBox !== undefined) {\n          return 'checkbox';\n        }\n        return 'text';\n    }\n  }\n  static getInitialValue(field, fieldType) {\n    var _field$options;\n    const existingValue = field.value || field.fieldValue;\n    if (existingValue !== undefined && existingValue !== null) {\n      return existingValue;\n    }\n\n    // Default values based on field type\n    switch (fieldType) {\n      case 'checkbox':\n        return false;\n      case 'radio':\n      case 'dropdown':\n        return ((_field$options = field.options) === null || _field$options === void 0 ? void 0 : _field$options[0]) || '';\n      default:\n        return '';\n    }\n  }\n  static isFieldRequired(field) {\n    // Explicit required flag\n    if (field.required === true) return true;\n    if (field.required === false) return false;\n\n    // Check field flags (PDF specification)\n    if (field.fieldFlags !== undefined) {\n      const REQUIRED_FLAG = 1 << 1; // Bit 2 in field flags\n      return (field.fieldFlags & REQUIRED_FLAG) !== 0;\n    }\n\n    // Heuristic: fields marked with asterisk or \"required\" in name\n    const fieldName = (field.name || '').toLowerCase();\n    return fieldName.includes('required') || fieldName.includes('*');\n  }\n  static getValidationPattern(field, fieldType) {\n    // Return existing pattern if available\n    if (field.pattern) return field.pattern;\n\n    // Common validation patterns based on field name\n    const fieldName = (field.name || '').toLowerCase();\n    if (fieldName.includes('email')) {\n      return '^[^\\\\s@]+@[^\\\\s@]+\\\\.[^\\\\s@]+$';\n    }\n    if (fieldName.includes('phone') || fieldName.includes('tel')) {\n      return '^[\\\\d\\\\s\\\\-\\\\(\\\\)\\\\+]{10,}$';\n    }\n    if (fieldName.includes('zip') || fieldName.includes('postal')) {\n      return '^\\\\d{5}(-\\\\d{4})?$';\n    }\n    if (fieldName.includes('date')) {\n      return '^\\\\d{1,2}/\\\\d{1,2}/\\\\d{4}$|^\\\\d{4}-\\\\d{2}-\\\\d{2}$';\n    }\n    return undefined;\n  }\n  static hasValidValue(field, value) {\n    if (value === undefined || value === null) return false;\n    switch (field.type) {\n      case 'text':\n        return typeof value === 'string' && value.trim().length > 0;\n      case 'checkbox':\n        return typeof value === 'boolean';\n      case 'radio':\n      case 'dropdown':\n        return typeof value === 'string' && value.length > 0;\n      case 'signature':\n        return typeof value === 'string' && value.length > 0;\n      default:\n        return true;\n    }\n  }\n\n  /**\n   * Clear cached form fields\n   */\n  static clearCache(documentId) {\n    if (documentId) {\n      this.extractedFields.delete(documentId);\n    } else {\n      this.extractedFields.clear();\n    }\n  }\n}\nFormFieldService.extractedFields = new Map();\nFormFieldService.categorizedCache = new Map();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}