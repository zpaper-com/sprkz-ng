{"ast":null,"code":"import { addHandler, maybeInstrument, timestampInSeconds, isString, triggerHandlers } from '@sentry/core';\nimport { WINDOW } from '../types.js';\nconst SENTRY_XHR_DATA_KEY = '__sentry_xhr_v3__';\n\n/**\n * Add an instrumentation handler for when an XHR request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addXhrInstrumentationHandler(handler) {\n  const type = 'xhr';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentXHR);\n}\n\n/** Exported only for tests. */\nfunction instrumentXHR() {\n  if (!WINDOW.XMLHttpRequest) {\n    return;\n  }\n  const xhrproto = XMLHttpRequest.prototype;\n\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  xhrproto.open = new Proxy(xhrproto.open, {\n    apply(originalOpen, xhrOpenThisArg, xhrOpenArgArray) {\n      // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n      //       it means the error, that was caused by your XHR call did not\n      //       have a stack trace. If you are using HttpClient integration,\n      //       this is the expected behavior, as we are using this virtual error to capture\n      //       the location of your XHR call, and group your HttpClient events accordingly.\n      const virtualError = new Error();\n      const startTimestamp = timestampInSeconds() * 1000;\n\n      // open() should always be called with two or more arguments\n      // But to be on the safe side, we actually validate this and bail out if we don't have a method & url\n      const method = isString(xhrOpenArgArray[0]) ? xhrOpenArgArray[0].toUpperCase() : undefined;\n      const url = parseXhrUrlArg(xhrOpenArgArray[1]);\n      if (!method || !url) {\n        return originalOpen.apply(xhrOpenThisArg, xhrOpenArgArray);\n      }\n      xhrOpenThisArg[SENTRY_XHR_DATA_KEY] = {\n        method,\n        url,\n        request_headers: {}\n      };\n\n      // if Sentry key appears in URL, don't capture it as a request\n      if (method === 'POST' && url.match(/sentry_key/)) {\n        xhrOpenThisArg.__sentry_own_request__ = true;\n      }\n      const onreadystatechangeHandler = () => {\n        // For whatever reason, this is not the same instance here as from the outer method\n        const xhrInfo = xhrOpenThisArg[SENTRY_XHR_DATA_KEY];\n        if (!xhrInfo) {\n          return;\n        }\n        if (xhrOpenThisArg.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            xhrInfo.status_code = xhrOpenThisArg.status;\n          } catch {\n            /* do nothing */\n          }\n          const handlerData = {\n            endTimestamp: timestampInSeconds() * 1000,\n            startTimestamp,\n            xhr: xhrOpenThisArg,\n            virtualError\n          };\n          triggerHandlers('xhr', handlerData);\n        }\n      };\n      if ('onreadystatechange' in xhrOpenThisArg && typeof xhrOpenThisArg.onreadystatechange === 'function') {\n        xhrOpenThisArg.onreadystatechange = new Proxy(xhrOpenThisArg.onreadystatechange, {\n          apply(originalOnreadystatechange, onreadystatechangeThisArg, onreadystatechangeArgArray) {\n            onreadystatechangeHandler();\n            return originalOnreadystatechange.apply(onreadystatechangeThisArg, onreadystatechangeArgArray);\n          }\n        });\n      } else {\n        xhrOpenThisArg.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      // Intercepting `setRequestHeader` to access the request headers of XHR instance.\n      // This will only work for user/library defined headers, not for the default/browser-assigned headers.\n      // Request cookies are also unavailable for XHR, as `Cookie` header can't be defined by `setRequestHeader`.\n      xhrOpenThisArg.setRequestHeader = new Proxy(xhrOpenThisArg.setRequestHeader, {\n        apply(originalSetRequestHeader, setRequestHeaderThisArg, setRequestHeaderArgArray) {\n          const [header, value] = setRequestHeaderArgArray;\n          const xhrInfo = setRequestHeaderThisArg[SENTRY_XHR_DATA_KEY];\n          if (xhrInfo && isString(header) && isString(value)) {\n            xhrInfo.request_headers[header.toLowerCase()] = value;\n          }\n          return originalSetRequestHeader.apply(setRequestHeaderThisArg, setRequestHeaderArgArray);\n        }\n      });\n      return originalOpen.apply(xhrOpenThisArg, xhrOpenArgArray);\n    }\n  });\n\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  xhrproto.send = new Proxy(xhrproto.send, {\n    apply(originalSend, sendThisArg, sendArgArray) {\n      const sentryXhrData = sendThisArg[SENTRY_XHR_DATA_KEY];\n      if (!sentryXhrData) {\n        return originalSend.apply(sendThisArg, sendArgArray);\n      }\n      if (sendArgArray[0] !== undefined) {\n        sentryXhrData.body = sendArgArray[0];\n      }\n      const handlerData = {\n        startTimestamp: timestampInSeconds() * 1000,\n        xhr: sendThisArg\n      };\n      triggerHandlers('xhr', handlerData);\n      return originalSend.apply(sendThisArg, sendArgArray);\n    }\n  });\n}\n\n/**\n * Parses the URL argument of a XHR method to a string.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/open#url\n * url: A string or any other object with a stringifier — including a URL object — that provides the URL of the resource to send the request to.\n *\n * @param url - The URL argument of an XHR method\n * @returns The parsed URL string or undefined if the URL is invalid\n */\nfunction parseXhrUrlArg(url) {\n  if (isString(url)) {\n    return url;\n  }\n  try {\n    // If the passed in argument is not a string, it should have a `toString` method as a stringifier.\n    // If that fails, we just return undefined (like in IE11 where URL is not available)\n    return url.toString();\n  } catch {} // eslint-disable-line no-empty\n\n  return undefined;\n}\nexport { SENTRY_XHR_DATA_KEY, addXhrInstrumentationHandler, instrumentXHR };","map":{"version":3,"names":["SENTRY_XHR_DATA_KEY","addXhrInstrumentationHandler","handler","type","addHandler","maybeInstrument","instrumentXHR","WINDOW","XMLHttpRequest","xhrproto","prototype","open","Proxy","apply","originalOpen","xhrOpenThisArg","xhrOpenArgArray","virtualError","Error","startTimestamp","timestampInSeconds","method","isString","toUpperCase","undefined","url","parseXhrUrlArg","request_headers","match","__sentry_own_request__","onreadystatechangeHandler","xhrInfo","readyState","status_code","status","handlerData","endTimestamp","xhr","triggerHandlers","onreadystatechange","originalOnreadystatechange","onreadystatechangeThisArg","onreadystatechangeArgArray","addEventListener","setRequestHeader","originalSetRequestHeader","setRequestHeaderThisArg","setRequestHeaderArgArray","header","value","toLowerCase","send","originalSend","sendThisArg","sendArgArray","sentryXhrData","body","toString"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry-internal/browser-utils/src/instrument/xhr.ts"],"sourcesContent":["import type { HandlerDataXhr, SentryWrappedXMLHttpRequest } from '@sentry/core';\nimport { addHandler, isString, maybeInstrument, timestampInSeconds, triggerHandlers } from '@sentry/core';\nimport { WINDOW } from '../types';\n\nexport const SENTRY_XHR_DATA_KEY = '__sentry_xhr_v3__';\n\ntype WindowWithXhr = Window & { XMLHttpRequest?: typeof XMLHttpRequest };\n\n/**\n * Add an instrumentation handler for when an XHR request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addXhrInstrumentationHandler(handler: (data: HandlerDataXhr) => void): void {\n  const type = 'xhr';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentXHR);\n}\n\n/** Exported only for tests. */\nexport function instrumentXHR(): void {\n  if (!(WINDOW as WindowWithXhr).XMLHttpRequest) {\n    return;\n  }\n\n  const xhrproto = XMLHttpRequest.prototype;\n\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  xhrproto.open = new Proxy(xhrproto.open, {\n    apply(\n      originalOpen,\n      xhrOpenThisArg: XMLHttpRequest & SentryWrappedXMLHttpRequest,\n      xhrOpenArgArray:\n        | [method: string, url: string | URL]\n        | [method: string, url: string | URL, async: boolean, username?: string | null, password?: string | null],\n    ) {\n      // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n      //       it means the error, that was caused by your XHR call did not\n      //       have a stack trace. If you are using HttpClient integration,\n      //       this is the expected behavior, as we are using this virtual error to capture\n      //       the location of your XHR call, and group your HttpClient events accordingly.\n      const virtualError = new Error();\n\n      const startTimestamp = timestampInSeconds() * 1000;\n\n      // open() should always be called with two or more arguments\n      // But to be on the safe side, we actually validate this and bail out if we don't have a method & url\n      const method = isString(xhrOpenArgArray[0]) ? xhrOpenArgArray[0].toUpperCase() : undefined;\n      const url = parseXhrUrlArg(xhrOpenArgArray[1]);\n\n      if (!method || !url) {\n        return originalOpen.apply(xhrOpenThisArg, xhrOpenArgArray);\n      }\n\n      xhrOpenThisArg[SENTRY_XHR_DATA_KEY] = {\n        method,\n        url,\n        request_headers: {},\n      };\n\n      // if Sentry key appears in URL, don't capture it as a request\n      if (method === 'POST' && url.match(/sentry_key/)) {\n        xhrOpenThisArg.__sentry_own_request__ = true;\n      }\n\n      const onreadystatechangeHandler: () => void = () => {\n        // For whatever reason, this is not the same instance here as from the outer method\n        const xhrInfo = xhrOpenThisArg[SENTRY_XHR_DATA_KEY];\n\n        if (!xhrInfo) {\n          return;\n        }\n\n        if (xhrOpenThisArg.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            xhrInfo.status_code = xhrOpenThisArg.status;\n          } catch {\n            /* do nothing */\n          }\n\n          const handlerData: HandlerDataXhr = {\n            endTimestamp: timestampInSeconds() * 1000,\n            startTimestamp,\n            xhr: xhrOpenThisArg,\n            virtualError,\n          };\n          triggerHandlers('xhr', handlerData);\n        }\n      };\n\n      if ('onreadystatechange' in xhrOpenThisArg && typeof xhrOpenThisArg.onreadystatechange === 'function') {\n        xhrOpenThisArg.onreadystatechange = new Proxy(xhrOpenThisArg.onreadystatechange, {\n          apply(originalOnreadystatechange, onreadystatechangeThisArg, onreadystatechangeArgArray: unknown[]) {\n            onreadystatechangeHandler();\n            return originalOnreadystatechange.apply(onreadystatechangeThisArg, onreadystatechangeArgArray);\n          },\n        });\n      } else {\n        xhrOpenThisArg.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      // Intercepting `setRequestHeader` to access the request headers of XHR instance.\n      // This will only work for user/library defined headers, not for the default/browser-assigned headers.\n      // Request cookies are also unavailable for XHR, as `Cookie` header can't be defined by `setRequestHeader`.\n      xhrOpenThisArg.setRequestHeader = new Proxy(xhrOpenThisArg.setRequestHeader, {\n        apply(\n          originalSetRequestHeader,\n          setRequestHeaderThisArg: SentryWrappedXMLHttpRequest,\n          setRequestHeaderArgArray: unknown[],\n        ) {\n          const [header, value] = setRequestHeaderArgArray;\n\n          const xhrInfo = setRequestHeaderThisArg[SENTRY_XHR_DATA_KEY];\n\n          if (xhrInfo && isString(header) && isString(value)) {\n            xhrInfo.request_headers[header.toLowerCase()] = value;\n          }\n\n          return originalSetRequestHeader.apply(setRequestHeaderThisArg, setRequestHeaderArgArray);\n        },\n      });\n\n      return originalOpen.apply(xhrOpenThisArg, xhrOpenArgArray);\n    },\n  });\n\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  xhrproto.send = new Proxy(xhrproto.send, {\n    apply(originalSend, sendThisArg: XMLHttpRequest & SentryWrappedXMLHttpRequest, sendArgArray: unknown[]) {\n      const sentryXhrData = sendThisArg[SENTRY_XHR_DATA_KEY];\n\n      if (!sentryXhrData) {\n        return originalSend.apply(sendThisArg, sendArgArray);\n      }\n\n      if (sendArgArray[0] !== undefined) {\n        sentryXhrData.body = sendArgArray[0];\n      }\n\n      const handlerData: HandlerDataXhr = {\n        startTimestamp: timestampInSeconds() * 1000,\n        xhr: sendThisArg,\n      };\n      triggerHandlers('xhr', handlerData);\n\n      return originalSend.apply(sendThisArg, sendArgArray);\n    },\n  });\n}\n\n/**\n * Parses the URL argument of a XHR method to a string.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/open#url\n * url: A string or any other object with a stringifier — including a URL object — that provides the URL of the resource to send the request to.\n *\n * @param url - The URL argument of an XHR method\n * @returns The parsed URL string or undefined if the URL is invalid\n */\nfunction parseXhrUrlArg(url: unknown): string | undefined {\n  if (isString(url)) {\n    return url;\n  }\n\n  try {\n    // If the passed in argument is not a string, it should have a `toString` method as a stringifier.\n    // If that fails, we just return undefined (like in IE11 where URL is not available)\n    return (url as URL).toString();\n  } catch {} // eslint-disable-line no-empty\n\n  return undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}