{"ast":null,"code":"var _jsxFileName = \"/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/src/contexts/FormContext.tsx\";\nimport React, { createContext, useContext, useReducer, useCallback, useEffect } from 'react';\nimport { FormFieldService } from '../services/formFieldService';\nimport { ValidationService } from '../services/validationService';\n\n// Form Actions\n\n// Form State Context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst FormContext = /*#__PURE__*/createContext(undefined);\n\n// Initial state\nconst initialState = {\n  fields: new Map(),\n  currentFieldIndex: -1,\n  completedFields: [],\n  requiredFields: [],\n  totalRequiredFields: 0,\n  completionPercentage: 0,\n  isValid: false,\n  validationResults: new Map()\n};\n\n// Form reducer\nfunction formReducer(state, action) {\n  switch (action.type) {\n    case 'INITIALIZE_FIELDS':\n      {\n        const fields = action.payload;\n        const fieldMap = new Map();\n        const requiredFields = [];\n        fields.forEach(field => {\n          fieldMap.set(field.name, {\n            fieldName: field.name,\n            value: field.value,\n            page: field.page,\n            isValid: !field.required || field.isComplete,\n            errors: field.validationErrors\n          });\n          if (field.required && !field.readOnly) {\n            requiredFields.push(field.name);\n          }\n        });\n        return {\n          ...state,\n          fields: fieldMap,\n          requiredFields,\n          totalRequiredFields: requiredFields.length,\n          completedFields: fields.filter(f => f.isComplete).map(f => f.name),\n          completionPercentage: FormFieldService.calculateCompletionPercentage(fields),\n          currentFieldIndex: 0\n        };\n      }\n    case 'UPDATE_FIELD_VALUE':\n      {\n        const {\n          fieldName,\n          value,\n          page\n        } = action.payload;\n        const newFields = new Map(state.fields);\n        const existingField = newFields.get(fieldName);\n        if (existingField) {\n          const updatedField = {\n            ...existingField,\n            value,\n            page,\n            isValid: true,\n            // Will be validated separately\n            errors: []\n          };\n          newFields.set(fieldName, updatedField);\n        }\n        return {\n          ...state,\n          fields: newFields\n        };\n      }\n    case 'SET_CURRENT_FIELD':\n      {\n        return {\n          ...state,\n          currentFieldIndex: action.payload\n        };\n      }\n    case 'MARK_FIELD_COMPLETE':\n      {\n        const fieldName = action.payload;\n        const completedFields = [...state.completedFields];\n        if (!completedFields.includes(fieldName)) {\n          completedFields.push(fieldName);\n        }\n        return {\n          ...state,\n          completedFields,\n          completionPercentage: Math.round(completedFields.length / Math.max(state.totalRequiredFields, 1) * 100)\n        };\n      }\n    case 'SET_FIELD_ERRORS':\n      {\n        const {\n          fieldName,\n          errors\n        } = action.payload;\n        const newFields = new Map(state.fields);\n        const field = newFields.get(fieldName);\n        if (field) {\n          newFields.set(fieldName, {\n            ...field,\n            errors,\n            isValid: errors.length === 0\n          });\n        }\n        return {\n          ...state,\n          fields: newFields\n        };\n      }\n    case 'SET_FIELD_VALIDATION':\n      {\n        const {\n          fieldName,\n          validation\n        } = action.payload;\n        const newValidationResults = new Map(state.validationResults);\n        const newFields = new Map(state.fields);\n        const field = newFields.get(fieldName);\n        newValidationResults.set(fieldName, validation);\n        if (field) {\n          newFields.set(fieldName, {\n            ...field,\n            errors: validation.errors,\n            isValid: validation.isValid\n          });\n        }\n        return {\n          ...state,\n          fields: newFields,\n          validationResults: newValidationResults\n        };\n      }\n    case 'CALCULATE_PROGRESS':\n      {\n        const completedRequiredFields = state.completedFields.filter(fieldName => state.requiredFields.includes(fieldName));\n        return {\n          ...state,\n          completionPercentage: Math.round(completedRequiredFields.length / Math.max(state.totalRequiredFields, 1) * 100)\n        };\n      }\n    case 'RESET_FORM':\n      {\n        return {\n          ...initialState,\n          fields: new Map(Array.from(state.fields.entries()).map(([key, field]) => [key, {\n            ...field,\n            value: field.fieldName.includes('checkbox') ? false : '',\n            isValid: !state.requiredFields.includes(field.fieldName),\n            errors: []\n          }])),\n          requiredFields: state.requiredFields,\n          totalRequiredFields: state.totalRequiredFields\n        };\n      }\n    default:\n      return state;\n  }\n}\n\n// Form Provider\nexport const FormProvider = ({\n  children\n}) => {\n  const [state, dispatch] = useReducer(formReducer, initialState);\n\n  // Initialize fields\n  const initializeFields = useCallback(fields => {\n    dispatch({\n      type: 'INITIALIZE_FIELDS',\n      payload: fields\n    });\n  }, []);\n\n  // Update field value\n  const updateFieldValue = useCallback((fieldName, value, page) => {\n    dispatch({\n      type: 'UPDATE_FIELD_VALUE',\n      payload: {\n        fieldName,\n        value,\n        page\n      }\n    });\n\n    // Auto-validate the field after a short delay\n    setTimeout(async () => {\n      await validateField(fieldName);\n    }, 100);\n  }, []);\n\n  // Set current field\n  const setCurrentField = useCallback(index => {\n    dispatch({\n      type: 'SET_CURRENT_FIELD',\n      payload: index\n    });\n  }, []);\n\n  // Mark field as complete\n  const markFieldComplete = useCallback(fieldName => {\n    dispatch({\n      type: 'MARK_FIELD_COMPLETE',\n      payload: fieldName\n    });\n    dispatch({\n      type: 'CALCULATE_PROGRESS'\n    });\n  }, []);\n\n  // Validate field using ValidationService\n  const validateField = useCallback(async fieldName => {\n    const fieldValue = state.fields.get(fieldName);\n    if (!fieldValue) {\n      const emptyResult = {\n        isValid: false,\n        errors: ['Field not found'],\n        warnings: [],\n        fieldName,\n        validatedAt: Date.now()\n      };\n      return emptyResult;\n    }\n\n    // Create a temporary FormField for validation\n    const tempField = {\n      name: fieldName,\n      type: 'text',\n      // Default type, should be enhanced based on field analysis\n      value: fieldValue.value,\n      required: state.requiredFields.includes(fieldName),\n      readOnly: false,\n      page: fieldValue.page,\n      rect: [0, 0, 0, 0],\n      isComplete: state.completedFields.includes(fieldName),\n      validationErrors: [],\n      id: fieldName,\n      subtype: ''\n    };\n\n    // Get all fields for dependency validation\n    const allFields = Array.from(state.fields.entries()).map(([name, value]) => ({\n      name,\n      type: 'text',\n      value: value.value,\n      required: state.requiredFields.includes(name),\n      readOnly: false,\n      page: value.page,\n      rect: [0, 0, 0, 0],\n      isComplete: state.completedFields.includes(name),\n      validationErrors: value.errors,\n      id: name,\n      subtype: ''\n    }));\n    try {\n      const validationResult = await ValidationService.validateField(tempField, fieldValue.value, allFields, {\n        validateRequired: true,\n        validateFormat: true,\n        validateDependencies: true,\n        excludeReadOnly: true\n      });\n\n      // Update state with validation result\n      dispatch({\n        type: 'SET_FIELD_VALIDATION',\n        payload: {\n          fieldName,\n          validation: validationResult\n        }\n      });\n\n      // Mark field as complete if valid\n      if (validationResult.isValid && !state.completedFields.includes(fieldName)) {\n        markFieldComplete(fieldName);\n      }\n      return validationResult;\n    } catch (error) {\n      console.error(`Validation failed for field \"${fieldName}\":`, error);\n      const errorResult = {\n        isValid: false,\n        errors: ['Validation error occurred'],\n        warnings: [],\n        fieldName,\n        validatedAt: Date.now()\n      };\n      dispatch({\n        type: 'SET_FIELD_VALIDATION',\n        payload: {\n          fieldName,\n          validation: errorResult\n        }\n      });\n      return errorResult;\n    }\n  }, [state.fields, state.requiredFields, state.completedFields, markFieldComplete]);\n\n  // Validate all fields\n  const validateAllFields = useCallback(async () => {\n    const allFields = Array.from(state.fields.entries()).map(([name, value]) => ({\n      name,\n      type: 'text',\n      value: value.value,\n      required: state.requiredFields.includes(name),\n      readOnly: false,\n      page: value.page,\n      rect: [0, 0, 0, 0],\n      isComplete: state.completedFields.includes(name),\n      validationErrors: value.errors,\n      id: name,\n      subtype: ''\n    }));\n    const fieldValues = {};\n    state.fields.forEach((value, name) => {\n      fieldValues[name] = value.value;\n    });\n    try {\n      const validationResults = await ValidationService.validateFields(allFields, fieldValues, {\n        validateRequired: true,\n        validateFormat: true,\n        validateDependencies: true,\n        excludeReadOnly: true\n      });\n\n      // Update all validation results in state\n      Object.entries(validationResults).forEach(([fieldName, result]) => {\n        dispatch({\n          type: 'SET_FIELD_VALIDATION',\n          payload: {\n            fieldName,\n            validation: result\n          }\n        });\n      });\n      return validationResults;\n    } catch (error) {\n      console.error('Bulk validation failed:', error);\n      return {};\n    }\n  }, [state.fields, state.requiredFields, state.completedFields]);\n\n  // Get next incomplete field\n  const getNextIncompleteField = useCallback(() => {\n    const incompleteFields = Array.from(state.fields.entries()).filter(([fieldName]) => !state.completedFields.includes(fieldName) && state.requiredFields.includes(fieldName));\n    if (incompleteFields.length === 0) return null;\n    return {\n      name: incompleteFields[0][0],\n      type: 'text',\n      value: incompleteFields[0][1].value,\n      required: true,\n      readOnly: false,\n      page: incompleteFields[0][1].page,\n      rect: [0, 0, 0, 0],\n      isComplete: false,\n      validationErrors: incompleteFields[0][1].errors,\n      id: incompleteFields[0][0],\n      subtype: ''\n    };\n  }, [state.fields, state.completedFields, state.requiredFields]);\n\n  // Get current field\n  const getCurrentField = useCallback(() => {\n    const fieldsArray = Array.from(state.fields.keys());\n    if (state.currentFieldIndex < 0 || state.currentFieldIndex >= fieldsArray.length) {\n      return null;\n    }\n    const fieldName = fieldsArray[state.currentFieldIndex];\n    const fieldValue = state.fields.get(fieldName);\n    if (!fieldValue) return null;\n    return {\n      name: fieldName,\n      type: 'text',\n      value: fieldValue.value,\n      required: state.requiredFields.includes(fieldName),\n      readOnly: false,\n      page: fieldValue.page,\n      rect: [0, 0, 0, 0],\n      isComplete: state.completedFields.includes(fieldName),\n      validationErrors: fieldValue.errors,\n      id: fieldName,\n      subtype: ''\n    };\n  }, [state.fields, state.currentFieldIndex, state.requiredFields, state.completedFields]);\n\n  // Get field by name\n  const getFieldByName = useCallback(fieldName => {\n    const fieldValue = state.fields.get(fieldName);\n    if (!fieldValue) return null;\n    return {\n      name: fieldName,\n      type: 'text',\n      value: fieldValue.value,\n      required: state.requiredFields.includes(fieldName),\n      readOnly: false,\n      page: fieldValue.page,\n      rect: [0, 0, 0, 0],\n      isComplete: state.completedFields.includes(fieldName),\n      validationErrors: fieldValue.errors,\n      id: fieldName,\n      subtype: ''\n    };\n  }, [state.fields, state.requiredFields, state.completedFields]);\n\n  // Get completion percentage\n  const getCompletionPercentage = useCallback(() => {\n    return state.completionPercentage;\n  }, [state.completionPercentage]);\n\n  // Get required fields status\n  const getRequiredFieldsStatus = useCallback(() => {\n    const completedRequired = state.completedFields.filter(fieldName => state.requiredFields.includes(fieldName));\n    return {\n      completed: completedRequired.length,\n      total: state.totalRequiredFields\n    };\n  }, [state.completedFields, state.requiredFields, state.totalRequiredFields]);\n\n  // Check if form is valid\n  const isFormValid = useCallback(() => {\n    const allRequiredCompleted = state.requiredFields.every(fieldName => state.completedFields.includes(fieldName));\n    const noErrors = Array.from(state.fields.values()).every(field => field.errors.length === 0);\n    return allRequiredCompleted && noErrors;\n  }, [state.requiredFields, state.completedFields, state.fields]);\n\n  // Get all form errors\n  const getFormErrors = useCallback(() => {\n    const errors = {};\n    state.fields.forEach((field, fieldName) => {\n      if (field.errors.length > 0) {\n        errors[fieldName] = field.errors;\n      }\n    });\n    return errors;\n  }, [state.fields]);\n\n  // Get field validation result\n  const getFieldValidation = useCallback(fieldName => {\n    return state.validationResults.get(fieldName) || null;\n  }, [state.validationResults]);\n\n  // Reset form\n  const resetForm = useCallback(() => {\n    dispatch({\n      type: 'RESET_FORM'\n    });\n    ValidationService.clearValidationCache();\n    console.log('Form has been reset to initial state');\n  }, []);\n\n  // Reset form after successful submission\n  const resetAfterSubmission = useCallback(() => {\n    resetForm();\n\n    // Additional cleanup for post-submission reset\n    setTimeout(() => {\n      // Clear any temporary data\n      sessionStorage.removeItem('sprkz-form-draft');\n      console.log('Post-submission cleanup completed');\n    }, 100);\n  }, [resetForm]);\n\n  // Update isValid when state changes\n  useEffect(() => {\n    const formValid = isFormValid();\n    if (state.isValid !== formValid) {\n      // Update state.isValid if needed (would require additional action)\n    }\n  }, [state.fields, state.completedFields, state.requiredFields, isFormValid, state.isValid]);\n  const contextValue = {\n    state,\n    updateFieldValue,\n    setCurrentField,\n    markFieldComplete,\n    validateField,\n    validateAllFields,\n    getNextIncompleteField,\n    getCurrentField,\n    getFieldByName,\n    getCompletionPercentage,\n    getRequiredFieldsStatus,\n    isFormValid,\n    getFormErrors,\n    getFieldValidation,\n    resetForm,\n    resetAfterSubmission,\n    initializeFields\n  };\n  return /*#__PURE__*/_jsxDEV(FormContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 546,\n    columnNumber: 5\n  }, this);\n};\n\n// Hook to use form context\nexport const useForm = () => {\n  const context = useContext(FormContext);\n  if (context === undefined) {\n    throw new Error('useForm must be used within a FormProvider');\n  }\n  return context;\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}