{"ast":null,"code":"import { browserPerformanceTimeOrigin, getActiveSpan, getRootSpan, spanToJSON, getCurrentScope, htmlTreeAsString, SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME, SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE, SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT, SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '@sentry/core';\nimport { addPerformanceInstrumentationHandler, addInpInstrumentationHandler, isPerformanceEventTiming } from './instrument.js';\nimport { getBrowserPerformanceAPI, msToSec, startStandaloneWebVitalSpan } from './utils.js';\nconst LAST_INTERACTIONS = [];\nconst INTERACTIONS_SPAN_MAP = new Map();\n\n/**\n * 60 seconds is the maximum for a plausible INP value\n * (source: Me)\n */\nconst MAX_PLAUSIBLE_INP_DURATION = 60;\n/**\n * Start tracking INP webvital events.\n */\nfunction startTrackingINP() {\n  const performance = getBrowserPerformanceAPI();\n  if (performance && browserPerformanceTimeOrigin()) {\n    const inpCallback = _trackINP();\n    return () => {\n      inpCallback();\n    };\n  }\n  return () => undefined;\n}\nconst INP_ENTRY_MAP = {\n  click: 'click',\n  pointerdown: 'click',\n  pointerup: 'click',\n  mousedown: 'click',\n  mouseup: 'click',\n  touchstart: 'click',\n  touchend: 'click',\n  mouseover: 'hover',\n  mouseout: 'hover',\n  mouseenter: 'hover',\n  mouseleave: 'hover',\n  pointerover: 'hover',\n  pointerout: 'hover',\n  pointerenter: 'hover',\n  pointerleave: 'hover',\n  dragstart: 'drag',\n  dragend: 'drag',\n  drag: 'drag',\n  dragenter: 'drag',\n  dragleave: 'drag',\n  dragover: 'drag',\n  drop: 'drag',\n  keydown: 'press',\n  keyup: 'press',\n  keypress: 'press',\n  input: 'press'\n};\n\n/** Starts tracking the Interaction to Next Paint on the current page. #\n * exported only for testing\n */\nfunction _trackINP() {\n  return addInpInstrumentationHandler(_onInp);\n}\n\n/**\n * exported only for testing\n */\nconst _onInp = ({\n  metric\n}) => {\n  if (metric.value == undefined) {\n    return;\n  }\n  const duration = msToSec(metric.value);\n\n  // We received occasional reports of hour-long INP values.\n  // Therefore, we add a sanity check to avoid creating spans for\n  // unrealistically long INP durations.\n  if (duration > MAX_PLAUSIBLE_INP_DURATION) {\n    return;\n  }\n  const entry = metric.entries.find(entry => entry.duration === metric.value && INP_ENTRY_MAP[entry.name]);\n  if (!entry) {\n    return;\n  }\n  const {\n    interactionId\n  } = entry;\n  const interactionType = INP_ENTRY_MAP[entry.name];\n\n  /** Build the INP span, create an envelope from the span, and then send the envelope */\n  const startTime = msToSec(browserPerformanceTimeOrigin() + entry.startTime);\n  const activeSpan = getActiveSpan();\n  const rootSpan = activeSpan ? getRootSpan(activeSpan) : undefined;\n\n  // We first try to lookup the span from our INTERACTIONS_SPAN_MAP,\n  // where we cache the route per interactionId\n  const cachedSpan = interactionId != null ? INTERACTIONS_SPAN_MAP.get(interactionId) : undefined;\n  const spanToUse = cachedSpan || rootSpan;\n\n  // Else, we try to use the active span.\n  // Finally, we fall back to look at the transactionName on the scope\n  const routeName = spanToUse ? spanToJSON(spanToUse).description : getCurrentScope().getScopeData().transactionName;\n  const name = htmlTreeAsString(entry.target);\n  const attributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.browser.inp',\n    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: `ui.interaction.${interactionType}`,\n    [SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME]: entry.duration\n  };\n  const span = startStandaloneWebVitalSpan({\n    name,\n    transaction: routeName,\n    attributes,\n    startTime\n  });\n  if (span) {\n    span.addEvent('inp', {\n      [SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT]: 'millisecond',\n      [SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE]: metric.value\n    });\n    span.end(startTime + duration);\n  }\n};\n\n/**\n * Register a listener to cache route information for INP interactions.\n */\nfunction registerInpInteractionListener() {\n  const handleEntries = ({\n    entries\n  }) => {\n    const activeSpan = getActiveSpan();\n    const activeRootSpan = activeSpan && getRootSpan(activeSpan);\n    entries.forEach(entry => {\n      if (!isPerformanceEventTiming(entry) || !activeRootSpan) {\n        return;\n      }\n      const interactionId = entry.interactionId;\n      if (interactionId == null) {\n        return;\n      }\n\n      // If the interaction was already recorded before, nothing more to do\n      if (INTERACTIONS_SPAN_MAP.has(interactionId)) {\n        return;\n      }\n\n      // We keep max. 10 interactions in the list, then remove the oldest one & clean up\n      if (LAST_INTERACTIONS.length > 10) {\n        const last = LAST_INTERACTIONS.shift();\n        INTERACTIONS_SPAN_MAP.delete(last);\n      }\n\n      // We add the interaction to the list of recorded interactions\n      // and store the span for this interaction\n      LAST_INTERACTIONS.push(interactionId);\n      INTERACTIONS_SPAN_MAP.set(interactionId, activeRootSpan);\n    });\n  };\n  addPerformanceInstrumentationHandler('event', handleEntries);\n  addPerformanceInstrumentationHandler('first-input', handleEntries);\n}\nexport { _onInp, _trackINP, registerInpInteractionListener, startTrackingINP };","map":{"version":3,"names":["LAST_INTERACTIONS","INTERACTIONS_SPAN_MAP","Map","MAX_PLAUSIBLE_INP_DURATION","startTrackingINP","performance","getBrowserPerformanceAPI","browserPerformanceTimeOrigin","inpCallback","_trackINP","undefined","INP_ENTRY_MAP","click","pointerdown","pointerup","mousedown","mouseup","touchstart","touchend","mouseover","mouseout","mouseenter","mouseleave","pointerover","pointerout","pointerenter","pointerleave","dragstart","dragend","drag","dragenter","dragleave","dragover","drop","keydown","keyup","keypress","input","addInpInstrumentationHandler","_onInp","metric","value","duration","msToSec","entry","entries","find","name","interactionId","interactionType","startTime","activeSpan","getActiveSpan","rootSpan","getRootSpan","cachedSpan","get","spanToUse","routeName","spanToJSON","description","getCurrentScope","getScopeData","transactionName","htmlTreeAsString","target","attributes","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMANTIC_ATTRIBUTE_SENTRY_OP","SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME","span","startStandaloneWebVitalSpan","transaction","addEvent","SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT","SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE","end","registerInpInteractionListener","handleEntries","activeRootSpan","forEach","isPerformanceEventTiming","has","length","last","shift","delete","push","set","addPerformanceInstrumentationHandler"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry-internal/browser-utils/src/metrics/inp.ts"],"sourcesContent":["import type { Span, SpanAttributes } from '@sentry/core';\nimport {\n  browserPerformanceTimeOrigin,\n  getActiveSpan,\n  getCurrentScope,\n  getRootSpan,\n  htmlTreeAsString,\n  SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME,\n  SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT,\n  SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  spanToJSON,\n} from '@sentry/core';\nimport type { InstrumentationHandlerCallback } from './instrument';\nimport {\n  addInpInstrumentationHandler,\n  addPerformanceInstrumentationHandler,\n  isPerformanceEventTiming,\n} from './instrument';\nimport { getBrowserPerformanceAPI, msToSec, startStandaloneWebVitalSpan } from './utils';\n\nconst LAST_INTERACTIONS: number[] = [];\nconst INTERACTIONS_SPAN_MAP = new Map<number, Span>();\n\n/**\n * 60 seconds is the maximum for a plausible INP value\n * (source: Me)\n */\nconst MAX_PLAUSIBLE_INP_DURATION = 60;\n/**\n * Start tracking INP webvital events.\n */\nexport function startTrackingINP(): () => void {\n  const performance = getBrowserPerformanceAPI();\n  if (performance && browserPerformanceTimeOrigin()) {\n    const inpCallback = _trackINP();\n\n    return (): void => {\n      inpCallback();\n    };\n  }\n\n  return () => undefined;\n}\n\nconst INP_ENTRY_MAP: Record<string, 'click' | 'hover' | 'drag' | 'press'> = {\n  click: 'click',\n  pointerdown: 'click',\n  pointerup: 'click',\n  mousedown: 'click',\n  mouseup: 'click',\n  touchstart: 'click',\n  touchend: 'click',\n  mouseover: 'hover',\n  mouseout: 'hover',\n  mouseenter: 'hover',\n  mouseleave: 'hover',\n  pointerover: 'hover',\n  pointerout: 'hover',\n  pointerenter: 'hover',\n  pointerleave: 'hover',\n  dragstart: 'drag',\n  dragend: 'drag',\n  drag: 'drag',\n  dragenter: 'drag',\n  dragleave: 'drag',\n  dragover: 'drag',\n  drop: 'drag',\n  keydown: 'press',\n  keyup: 'press',\n  keypress: 'press',\n  input: 'press',\n};\n\n/** Starts tracking the Interaction to Next Paint on the current page. #\n * exported only for testing\n */\nexport function _trackINP(): () => void {\n  return addInpInstrumentationHandler(_onInp);\n}\n\n/**\n * exported only for testing\n */\nexport const _onInp: InstrumentationHandlerCallback = ({ metric }) => {\n  if (metric.value == undefined) {\n    return;\n  }\n\n  const duration = msToSec(metric.value);\n\n  // We received occasional reports of hour-long INP values.\n  // Therefore, we add a sanity check to avoid creating spans for\n  // unrealistically long INP durations.\n  if (duration > MAX_PLAUSIBLE_INP_DURATION) {\n    return;\n  }\n\n  const entry = metric.entries.find(entry => entry.duration === metric.value && INP_ENTRY_MAP[entry.name]);\n\n  if (!entry) {\n    return;\n  }\n\n  const { interactionId } = entry;\n  const interactionType = INP_ENTRY_MAP[entry.name];\n\n  /** Build the INP span, create an envelope from the span, and then send the envelope */\n  const startTime = msToSec((browserPerformanceTimeOrigin() as number) + entry.startTime);\n  const activeSpan = getActiveSpan();\n  const rootSpan = activeSpan ? getRootSpan(activeSpan) : undefined;\n\n  // We first try to lookup the span from our INTERACTIONS_SPAN_MAP,\n  // where we cache the route per interactionId\n  const cachedSpan = interactionId != null ? INTERACTIONS_SPAN_MAP.get(interactionId) : undefined;\n\n  const spanToUse = cachedSpan || rootSpan;\n\n  // Else, we try to use the active span.\n  // Finally, we fall back to look at the transactionName on the scope\n  const routeName = spanToUse ? spanToJSON(spanToUse).description : getCurrentScope().getScopeData().transactionName;\n\n  const name = htmlTreeAsString(entry.target);\n  const attributes: SpanAttributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.browser.inp',\n    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: `ui.interaction.${interactionType}`,\n    [SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME]: entry.duration,\n  };\n\n  const span = startStandaloneWebVitalSpan({\n    name,\n    transaction: routeName,\n    attributes,\n    startTime,\n  });\n\n  if (span) {\n    span.addEvent('inp', {\n      [SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT]: 'millisecond',\n      [SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE]: metric.value,\n    });\n\n    span.end(startTime + duration);\n  }\n};\n\n/**\n * Register a listener to cache route information for INP interactions.\n */\nexport function registerInpInteractionListener(): void {\n  const handleEntries = ({ entries }: { entries: PerformanceEntry[] }): void => {\n    const activeSpan = getActiveSpan();\n    const activeRootSpan = activeSpan && getRootSpan(activeSpan);\n\n    entries.forEach(entry => {\n      if (!isPerformanceEventTiming(entry) || !activeRootSpan) {\n        return;\n      }\n\n      const interactionId = entry.interactionId;\n      if (interactionId == null) {\n        return;\n      }\n\n      // If the interaction was already recorded before, nothing more to do\n      if (INTERACTIONS_SPAN_MAP.has(interactionId)) {\n        return;\n      }\n\n      // We keep max. 10 interactions in the list, then remove the oldest one & clean up\n      if (LAST_INTERACTIONS.length > 10) {\n        const last = LAST_INTERACTIONS.shift() as number;\n        INTERACTIONS_SPAN_MAP.delete(last);\n      }\n\n      // We add the interaction to the list of recorded interactions\n      // and store the span for this interaction\n      LAST_INTERACTIONS.push(interactionId);\n      INTERACTIONS_SPAN_MAP.set(interactionId, activeRootSpan);\n    });\n  };\n\n  addPerformanceInstrumentationHandler('event', handleEntries);\n  addPerformanceInstrumentationHandler('first-input', handleEntries);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}