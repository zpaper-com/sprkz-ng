{"ast":null,"code":"import { getCurrentScope, getClient, withIsolationScope, getIsolationScope } from './currentScopes.js';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { makeSession, updateSession, closeSession } from './session.js';\nimport { debug } from './utils/debug-logger.js';\nimport { isThenable } from './utils/is.js';\nimport { uuid4 } from './utils/misc.js';\nimport { parseEventHintOrCaptureContext } from './utils/prepareEvent.js';\nimport { timestampInSeconds } from './utils/time.js';\nimport { GLOBAL_OBJ } from './utils/worldwide.js';\n\n/**\n * Captures an exception event and sends it to Sentry.\n *\n * @param exception The exception to capture.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured Sentry event.\n */\nfunction captureException(exception, hint) {\n  return getCurrentScope().captureException(exception, parseEventHintOrCaptureContext(hint));\n}\n\n/**\n * Captures a message event and sends it to Sentry.\n *\n * @param message The message to send to Sentry.\n * @param captureContext Define the level of the message or pass in additional data to attach to the message.\n * @returns the id of the captured message.\n */\nfunction captureMessage(message, captureContext) {\n  // This is necessary to provide explicit scopes upgrade, without changing the original\n  // arity of the `captureMessage(message, level)` method.\n  const level = typeof captureContext === 'string' ? captureContext : undefined;\n  const context = typeof captureContext !== 'string' ? {\n    captureContext\n  } : undefined;\n  return getCurrentScope().captureMessage(message, level, context);\n}\n\n/**\n * Captures a manually created event and sends it to Sentry.\n *\n * @param event The event to send to Sentry.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured event.\n */\nfunction captureEvent(event, hint) {\n  return getCurrentScope().captureEvent(event, hint);\n}\n\n/**\n * Sets context data with the given name.\n * @param name of the context\n * @param context Any kind of data. This data will be normalized.\n */\nfunction setContext(name, context) {\n  getIsolationScope().setContext(name, context);\n}\n\n/**\n * Set an object that will be merged sent as extra data with the event.\n * @param extras Extras object to merge into current context.\n */\nfunction setExtras(extras) {\n  getIsolationScope().setExtras(extras);\n}\n\n/**\n * Set key:value that will be sent as extra data with the event.\n * @param key String of extra\n * @param extra Any kind of data. This data will be normalized.\n */\nfunction setExtra(key, extra) {\n  getIsolationScope().setExtra(key, extra);\n}\n\n/**\n * Set an object that will be merged sent as tags data with the event.\n * @param tags Tags context object to merge into current context.\n */\nfunction setTags(tags) {\n  getIsolationScope().setTags(tags);\n}\n\n/**\n * Set key:value that will be sent as tags data with the event.\n *\n * Can also be used to unset a tag, by passing `undefined`.\n *\n * @param key String key of tag\n * @param value Value of tag\n */\nfunction setTag(key, value) {\n  getIsolationScope().setTag(key, value);\n}\n\n/**\n * Updates user context information for future events.\n *\n * @param user User context object to be set in the current context. Pass `null` to unset the user.\n */\nfunction setUser(user) {\n  getIsolationScope().setUser(user);\n}\n\n/**\n * The last error event id of the isolation scope.\n *\n * Warning: This function really returns the last recorded error event id on the current\n * isolation scope. If you call this function after handling a certain error and another error\n * is captured in between, the last one is returned instead of the one you might expect.\n * Also, ids of events that were never sent to Sentry (for example because\n * they were dropped in `beforeSend`) could be returned.\n *\n * @returns The last event id of the isolation scope.\n */\nfunction lastEventId() {\n  return getIsolationScope().lastEventId();\n}\n\n/**\n * Create a cron monitor check in and send it to Sentry.\n *\n * @param checkIn An object that describes a check in.\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */\nfunction captureCheckIn(checkIn, upsertMonitorConfig) {\n  const scope = getCurrentScope();\n  const client = getClient();\n  if (!client) {\n    DEBUG_BUILD && debug.warn('Cannot capture check-in. No client defined.');\n  } else if (!client.captureCheckIn) {\n    DEBUG_BUILD && debug.warn('Cannot capture check-in. Client does not support sending check-ins.');\n  } else {\n    return client.captureCheckIn(checkIn, upsertMonitorConfig, scope);\n  }\n  return uuid4();\n}\n\n/**\n * Wraps a callback with a cron monitor check in. The check in will be sent to Sentry when the callback finishes.\n *\n * @param monitorSlug The distinct slug of the monitor.\n * @param callback Callback to be monitored\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */\nfunction withMonitor(monitorSlug, callback, upsertMonitorConfig) {\n  const checkInId = captureCheckIn({\n    monitorSlug,\n    status: 'in_progress'\n  }, upsertMonitorConfig);\n  const now = timestampInSeconds();\n  function finishCheckIn(status) {\n    captureCheckIn({\n      monitorSlug,\n      status,\n      checkInId,\n      duration: timestampInSeconds() - now\n    });\n  }\n  return withIsolationScope(() => {\n    let maybePromiseResult;\n    try {\n      maybePromiseResult = callback();\n    } catch (e) {\n      finishCheckIn('error');\n      throw e;\n    }\n    if (isThenable(maybePromiseResult)) {\n      return maybePromiseResult.then(r => {\n        finishCheckIn('ok');\n        return r;\n      }, e => {\n        finishCheckIn('error');\n        throw e;\n      });\n    }\n    finishCheckIn('ok');\n    return maybePromiseResult;\n  });\n}\n\n/**\n * Call `flush()` on the current client, if there is one. See {@link Client.flush}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause\n * the client to wait until all events are sent before resolving the promise.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nasync function flush(timeout) {\n  const client = getClient();\n  if (client) {\n    return client.flush(timeout);\n  }\n  DEBUG_BUILD && debug.warn('Cannot flush events. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Call `close()` on the current client, if there is one. See {@link Client.close}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this\n * parameter will cause the client to wait until all events are sent before disabling itself.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nasync function close(timeout) {\n  const client = getClient();\n  if (client) {\n    return client.close(timeout);\n  }\n  DEBUG_BUILD && debug.warn('Cannot flush events and disable SDK. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Returns true if Sentry has been properly initialized.\n */\nfunction isInitialized() {\n  return !!getClient();\n}\n\n/** If the SDK is initialized & enabled. */\nfunction isEnabled() {\n  const client = getClient();\n  return client?.getOptions().enabled !== false && !!client?.getTransport();\n}\n\n/**\n * Add an event processor.\n * This will be added to the current isolation scope, ensuring any event that is processed in the current execution\n * context will have the processor applied.\n */\nfunction addEventProcessor(callback) {\n  getIsolationScope().addEventProcessor(callback);\n}\n\n/**\n * Start a session on the current isolation scope.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns the new active session\n */\nfunction startSession(context) {\n  const isolationScope = getIsolationScope();\n  const currentScope = getCurrentScope();\n\n  // Will fetch userAgent if called from browser sdk\n  const {\n    userAgent\n  } = GLOBAL_OBJ.navigator || {};\n  const session = makeSession({\n    user: currentScope.getUser() || isolationScope.getUser(),\n    ...(userAgent && {\n      userAgent\n    }),\n    ...context\n  });\n\n  // End existing session if there's one\n  const currentSession = isolationScope.getSession();\n  if (currentSession?.status === 'ok') {\n    updateSession(currentSession, {\n      status: 'exited'\n    });\n  }\n  endSession();\n\n  // Afterwards we set the new session on the scope\n  isolationScope.setSession(session);\n  return session;\n}\n\n/**\n * End the session on the current isolation scope.\n */\nfunction endSession() {\n  const isolationScope = getIsolationScope();\n  const currentScope = getCurrentScope();\n  const session = currentScope.getSession() || isolationScope.getSession();\n  if (session) {\n    closeSession(session);\n  }\n  _sendSessionUpdate();\n\n  // the session is over; take it off of the scope\n  isolationScope.setSession();\n}\n\n/**\n * Sends the current Session on the scope\n */\nfunction _sendSessionUpdate() {\n  const isolationScope = getIsolationScope();\n  const client = getClient();\n  const session = isolationScope.getSession();\n  if (session && client) {\n    client.captureSession(session);\n  }\n}\n\n/**\n * Sends the current session on the scope to Sentry\n *\n * @param end If set the session will be marked as exited and removed from the scope.\n *            Defaults to `false`.\n */\nfunction captureSession(end = false) {\n  // both send the update and pull the session from the scope\n  if (end) {\n    endSession();\n    return;\n  }\n\n  // only send the update\n  _sendSessionUpdate();\n}\nexport { addEventProcessor, captureCheckIn, captureEvent, captureException, captureMessage, captureSession, close, endSession, flush, isEnabled, isInitialized, lastEventId, setContext, setExtra, setExtras, setTag, setTags, setUser, startSession, withMonitor };","map":{"version":3,"names":["captureException","exception","hint","getCurrentScope","parseEventHintOrCaptureContext","captureMessage","message","captureContext","level","undefined","context","captureEvent","event","setContext","name","getIsolationScope","setExtras","extras","setExtra","key","extra","setTags","tags","setTag","value","setUser","user","lastEventId","captureCheckIn","checkIn","upsertMonitorConfig","scope","client","getClient","DEBUG_BUILD","debug","warn","uuid4","withMonitor","monitorSlug","callback","checkInId","status","now","timestampInSeconds","finishCheckIn","duration","withIsolationScope","maybePromiseResult","e","isThenable","then","r","flush","timeout","Promise","resolve","close","isInitialized","isEnabled","getOptions","enabled","getTransport","addEventProcessor","startSession","isolationScope","currentScope","userAgent","GLOBAL_OBJ","navigator","session","makeSession","getUser","currentSession","getSession","updateSession","endSession","setSession","closeSession","_sendSessionUpdate","captureSession","end"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/exports.ts"],"sourcesContent":["import { getClient, getCurrentScope, getIsolationScope, withIsolationScope } from './currentScopes';\nimport { DEBUG_BUILD } from './debug-build';\nimport type { CaptureContext } from './scope';\nimport { closeSession, makeSession, updateSession } from './session';\nimport type { CheckIn, FinishedCheckIn, MonitorConfig } from './types-hoist/checkin';\nimport type { Event, EventHint } from './types-hoist/event';\nimport type { EventProcessor } from './types-hoist/eventprocessor';\nimport type { Extra, Extras } from './types-hoist/extra';\nimport type { Primitive } from './types-hoist/misc';\nimport type { Session, SessionContext } from './types-hoist/session';\nimport type { SeverityLevel } from './types-hoist/severity';\nimport type { User } from './types-hoist/user';\nimport { debug } from './utils/debug-logger';\nimport { isThenable } from './utils/is';\nimport { uuid4 } from './utils/misc';\nimport type { ExclusiveEventHintOrCaptureContext } from './utils/prepareEvent';\nimport { parseEventHintOrCaptureContext } from './utils/prepareEvent';\nimport { timestampInSeconds } from './utils/time';\nimport { GLOBAL_OBJ } from './utils/worldwide';\n\n/**\n * Captures an exception event and sends it to Sentry.\n *\n * @param exception The exception to capture.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured Sentry event.\n */\nexport function captureException(exception: unknown, hint?: ExclusiveEventHintOrCaptureContext): string {\n  return getCurrentScope().captureException(exception, parseEventHintOrCaptureContext(hint));\n}\n\n/**\n * Captures a message event and sends it to Sentry.\n *\n * @param message The message to send to Sentry.\n * @param captureContext Define the level of the message or pass in additional data to attach to the message.\n * @returns the id of the captured message.\n */\nexport function captureMessage(message: string, captureContext?: CaptureContext | SeverityLevel): string {\n  // This is necessary to provide explicit scopes upgrade, without changing the original\n  // arity of the `captureMessage(message, level)` method.\n  const level = typeof captureContext === 'string' ? captureContext : undefined;\n  const context = typeof captureContext !== 'string' ? { captureContext } : undefined;\n  return getCurrentScope().captureMessage(message, level, context);\n}\n\n/**\n * Captures a manually created event and sends it to Sentry.\n *\n * @param event The event to send to Sentry.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured event.\n */\nexport function captureEvent(event: Event, hint?: EventHint): string {\n  return getCurrentScope().captureEvent(event, hint);\n}\n\n/**\n * Sets context data with the given name.\n * @param name of the context\n * @param context Any kind of data. This data will be normalized.\n */\nexport function setContext(name: string, context: { [key: string]: unknown } | null): void {\n  getIsolationScope().setContext(name, context);\n}\n\n/**\n * Set an object that will be merged sent as extra data with the event.\n * @param extras Extras object to merge into current context.\n */\nexport function setExtras(extras: Extras): void {\n  getIsolationScope().setExtras(extras);\n}\n\n/**\n * Set key:value that will be sent as extra data with the event.\n * @param key String of extra\n * @param extra Any kind of data. This data will be normalized.\n */\nexport function setExtra(key: string, extra: Extra): void {\n  getIsolationScope().setExtra(key, extra);\n}\n\n/**\n * Set an object that will be merged sent as tags data with the event.\n * @param tags Tags context object to merge into current context.\n */\nexport function setTags(tags: { [key: string]: Primitive }): void {\n  getIsolationScope().setTags(tags);\n}\n\n/**\n * Set key:value that will be sent as tags data with the event.\n *\n * Can also be used to unset a tag, by passing `undefined`.\n *\n * @param key String key of tag\n * @param value Value of tag\n */\nexport function setTag(key: string, value: Primitive): void {\n  getIsolationScope().setTag(key, value);\n}\n\n/**\n * Updates user context information for future events.\n *\n * @param user User context object to be set in the current context. Pass `null` to unset the user.\n */\nexport function setUser(user: User | null): void {\n  getIsolationScope().setUser(user);\n}\n\n/**\n * The last error event id of the isolation scope.\n *\n * Warning: This function really returns the last recorded error event id on the current\n * isolation scope. If you call this function after handling a certain error and another error\n * is captured in between, the last one is returned instead of the one you might expect.\n * Also, ids of events that were never sent to Sentry (for example because\n * they were dropped in `beforeSend`) could be returned.\n *\n * @returns The last event id of the isolation scope.\n */\nexport function lastEventId(): string | undefined {\n  return getIsolationScope().lastEventId();\n}\n\n/**\n * Create a cron monitor check in and send it to Sentry.\n *\n * @param checkIn An object that describes a check in.\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */\nexport function captureCheckIn(checkIn: CheckIn, upsertMonitorConfig?: MonitorConfig): string {\n  const scope = getCurrentScope();\n  const client = getClient();\n  if (!client) {\n    DEBUG_BUILD && debug.warn('Cannot capture check-in. No client defined.');\n  } else if (!client.captureCheckIn) {\n    DEBUG_BUILD && debug.warn('Cannot capture check-in. Client does not support sending check-ins.');\n  } else {\n    return client.captureCheckIn(checkIn, upsertMonitorConfig, scope);\n  }\n\n  return uuid4();\n}\n\n/**\n * Wraps a callback with a cron monitor check in. The check in will be sent to Sentry when the callback finishes.\n *\n * @param monitorSlug The distinct slug of the monitor.\n * @param callback Callback to be monitored\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */\nexport function withMonitor<T>(\n  monitorSlug: CheckIn['monitorSlug'],\n  callback: () => T,\n  upsertMonitorConfig?: MonitorConfig,\n): T {\n  const checkInId = captureCheckIn({ monitorSlug, status: 'in_progress' }, upsertMonitorConfig);\n  const now = timestampInSeconds();\n\n  function finishCheckIn(status: FinishedCheckIn['status']): void {\n    captureCheckIn({ monitorSlug, status, checkInId, duration: timestampInSeconds() - now });\n  }\n\n  return withIsolationScope(() => {\n    let maybePromiseResult: T;\n    try {\n      maybePromiseResult = callback();\n    } catch (e) {\n      finishCheckIn('error');\n      throw e;\n    }\n\n    if (isThenable(maybePromiseResult)) {\n      return maybePromiseResult.then(\n        r => {\n          finishCheckIn('ok');\n          return r;\n        },\n        e => {\n          finishCheckIn('error');\n          throw e;\n        },\n      ) as T;\n    }\n    finishCheckIn('ok');\n\n    return maybePromiseResult;\n  });\n}\n\n/**\n * Call `flush()` on the current client, if there is one. See {@link Client.flush}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause\n * the client to wait until all events are sent before resolving the promise.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nexport async function flush(timeout?: number): Promise<boolean> {\n  const client = getClient();\n  if (client) {\n    return client.flush(timeout);\n  }\n  DEBUG_BUILD && debug.warn('Cannot flush events. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Call `close()` on the current client, if there is one. See {@link Client.close}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this\n * parameter will cause the client to wait until all events are sent before disabling itself.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nexport async function close(timeout?: number): Promise<boolean> {\n  const client = getClient();\n  if (client) {\n    return client.close(timeout);\n  }\n  DEBUG_BUILD && debug.warn('Cannot flush events and disable SDK. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Returns true if Sentry has been properly initialized.\n */\nexport function isInitialized(): boolean {\n  return !!getClient();\n}\n\n/** If the SDK is initialized & enabled. */\nexport function isEnabled(): boolean {\n  const client = getClient();\n  return client?.getOptions().enabled !== false && !!client?.getTransport();\n}\n\n/**\n * Add an event processor.\n * This will be added to the current isolation scope, ensuring any event that is processed in the current execution\n * context will have the processor applied.\n */\nexport function addEventProcessor(callback: EventProcessor): void {\n  getIsolationScope().addEventProcessor(callback);\n}\n\n/**\n * Start a session on the current isolation scope.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns the new active session\n */\nexport function startSession(context?: SessionContext): Session {\n  const isolationScope = getIsolationScope();\n  const currentScope = getCurrentScope();\n\n  // Will fetch userAgent if called from browser sdk\n  const { userAgent } = GLOBAL_OBJ.navigator || {};\n\n  const session = makeSession({\n    user: currentScope.getUser() || isolationScope.getUser(),\n    ...(userAgent && { userAgent }),\n    ...context,\n  });\n\n  // End existing session if there's one\n  const currentSession = isolationScope.getSession();\n  if (currentSession?.status === 'ok') {\n    updateSession(currentSession, { status: 'exited' });\n  }\n\n  endSession();\n\n  // Afterwards we set the new session on the scope\n  isolationScope.setSession(session);\n\n  return session;\n}\n\n/**\n * End the session on the current isolation scope.\n */\nexport function endSession(): void {\n  const isolationScope = getIsolationScope();\n  const currentScope = getCurrentScope();\n\n  const session = currentScope.getSession() || isolationScope.getSession();\n  if (session) {\n    closeSession(session);\n  }\n  _sendSessionUpdate();\n\n  // the session is over; take it off of the scope\n  isolationScope.setSession();\n}\n\n/**\n * Sends the current Session on the scope\n */\nfunction _sendSessionUpdate(): void {\n  const isolationScope = getIsolationScope();\n  const client = getClient();\n  const session = isolationScope.getSession();\n  if (session && client) {\n    client.captureSession(session);\n  }\n}\n\n/**\n * Sends the current session on the scope to Sentry\n *\n * @param end If set the session will be marked as exited and removed from the scope.\n *            Defaults to `false`.\n */\nexport function captureSession(end: boolean = false): void {\n  // both send the update and pull the session from the scope\n  if (end) {\n    endSession();\n    return;\n  }\n\n  // only send the update\n  _sendSessionUpdate();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}