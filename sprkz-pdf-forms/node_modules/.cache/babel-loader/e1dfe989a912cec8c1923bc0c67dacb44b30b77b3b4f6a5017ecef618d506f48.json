{"ast":null,"code":"import { addFetchEndInstrumentationHandler, addFetchInstrumentationHandler, instrumentFetchRequest, parseUrl, getLocationHref, stringMatchesSomePattern, spanToJSON, hasSpansEnabled, setHttpStatus, stripUrlQueryAndFragment, getActiveSpan, startInactiveSpan, SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SentryNonRecordingSpan, getClient, getTraceData } from '@sentry/core';\nimport { addXhrInstrumentationHandler, addPerformanceInstrumentationHandler, SENTRY_XHR_DATA_KEY } from '@sentry-internal/browser-utils';\nimport { WINDOW } from '../helpers.js';\nimport { resourceTimingToSpanAttributes } from './resource-timing.js';\n\n/** Options for Request Instrumentation */\n\nconst responseToSpanId = new WeakMap();\nconst spanIdToEndTimestamp = new Map();\nconst defaultRequestInstrumentationOptions = {\n  traceFetch: true,\n  traceXHR: true,\n  enableHTTPTimings: true,\n  trackFetchStreamPerformance: false\n};\n\n/** Registers span creators for xhr and fetch requests  */\nfunction instrumentOutgoingRequests(client, _options) {\n  const {\n    traceFetch,\n    traceXHR,\n    trackFetchStreamPerformance,\n    shouldCreateSpanForRequest,\n    enableHTTPTimings,\n    tracePropagationTargets,\n    onRequestSpanStart\n  } = {\n    ...defaultRequestInstrumentationOptions,\n    ..._options\n  };\n  const shouldCreateSpan = typeof shouldCreateSpanForRequest === 'function' ? shouldCreateSpanForRequest : _ => true;\n  const shouldAttachHeadersWithTargets = url => shouldAttachHeaders(url, tracePropagationTargets);\n  const spans = {};\n  if (traceFetch) {\n    // Keeping track of http requests, whose body payloads resolved later than the initial resolved request\n    // e.g. streaming using server sent events (SSE)\n    client.addEventProcessor(event => {\n      if (event.type === 'transaction' && event.spans) {\n        event.spans.forEach(span => {\n          if (span.op === 'http.client') {\n            const updatedTimestamp = spanIdToEndTimestamp.get(span.span_id);\n            if (updatedTimestamp) {\n              span.timestamp = updatedTimestamp / 1000;\n              spanIdToEndTimestamp.delete(span.span_id);\n            }\n          }\n        });\n      }\n      return event;\n    });\n    if (trackFetchStreamPerformance) {\n      addFetchEndInstrumentationHandler(handlerData => {\n        if (handlerData.response) {\n          const span = responseToSpanId.get(handlerData.response);\n          if (span && handlerData.endTimestamp) {\n            spanIdToEndTimestamp.set(span, handlerData.endTimestamp);\n          }\n        }\n      });\n    }\n    addFetchInstrumentationHandler(handlerData => {\n      const createdSpan = instrumentFetchRequest(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n      if (handlerData.response && handlerData.fetchData.__span) {\n        responseToSpanId.set(handlerData.response, handlerData.fetchData.__span);\n      }\n\n      // We cannot use `window.location` in the generic fetch instrumentation,\n      // but we need it for reliable `server.address` attribute.\n      // so we extend this in here\n      if (createdSpan) {\n        const fullUrl = getFullURL(handlerData.fetchData.url);\n        const host = fullUrl ? parseUrl(fullUrl).host : undefined;\n        createdSpan.setAttributes({\n          'http.url': fullUrl,\n          'server.address': host\n        });\n        if (enableHTTPTimings) {\n          addHTTPTimings(createdSpan);\n        }\n        onRequestSpanStart?.(createdSpan, {\n          headers: handlerData.headers\n        });\n      }\n    });\n  }\n  if (traceXHR) {\n    addXhrInstrumentationHandler(handlerData => {\n      const createdSpan = xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n      if (createdSpan) {\n        if (enableHTTPTimings) {\n          addHTTPTimings(createdSpan);\n        }\n        let headers;\n        try {\n          headers = new Headers(handlerData.xhr.__sentry_xhr_v3__?.request_headers);\n        } catch {\n          // noop\n        }\n        onRequestSpanStart?.(createdSpan, {\n          headers\n        });\n      }\n    });\n  }\n}\nfunction isPerformanceResourceTiming(entry) {\n  return entry.entryType === 'resource' && 'initiatorType' in entry && typeof entry.nextHopProtocol === 'string' && (entry.initiatorType === 'fetch' || entry.initiatorType === 'xmlhttprequest');\n}\n\n/**\n * Creates a temporary observer to listen to the next fetch/xhr resourcing timings,\n * so that when timings hit their per-browser limit they don't need to be removed.\n *\n * @param span A span that has yet to be finished, must contain `url` on data.\n */\nfunction addHTTPTimings(span) {\n  const {\n    url\n  } = spanToJSON(span).data;\n  if (!url || typeof url !== 'string') {\n    return;\n  }\n  const cleanup = addPerformanceInstrumentationHandler('resource', ({\n    entries\n  }) => {\n    entries.forEach(entry => {\n      if (isPerformanceResourceTiming(entry) && entry.name.endsWith(url)) {\n        const spanAttributes = resourceTimingToSpanAttributes(entry);\n        spanAttributes.forEach(attributeArray => span.setAttribute(...attributeArray));\n        // In the next tick, clean this handler up\n        // We have to wait here because otherwise this cleans itself up before it is fully done\n        setTimeout(cleanup);\n      }\n    });\n  });\n}\n\n/**\n * A function that determines whether to attach tracing headers to a request.\n * We only export this function for testing purposes.\n */\nfunction shouldAttachHeaders(targetUrl, tracePropagationTargets) {\n  // window.location.href not being defined is an edge case in the browser but we need to handle it.\n  // Potentially dangerous situations where it may not be defined: Browser Extensions, Web Workers, patching of the location obj\n  const href = getLocationHref();\n  if (!href) {\n    // If there is no window.location.origin, we default to only attaching tracing headers to relative requests, i.e. ones that start with `/`\n    // BIG DISCLAIMER: Users can call URLs with a double slash (fetch(\"//example.com/api\")), this is a shorthand for \"send to the same protocol\",\n    // so we need a to exclude those requests, because they might be cross origin.\n    const isRelativeSameOriginRequest = !!targetUrl.match(/^\\/(?!\\/)/);\n    if (!tracePropagationTargets) {\n      return isRelativeSameOriginRequest;\n    } else {\n      return stringMatchesSomePattern(targetUrl, tracePropagationTargets);\n    }\n  } else {\n    let resolvedUrl;\n    let currentOrigin;\n\n    // URL parsing may fail, we default to not attaching trace headers in that case.\n    try {\n      resolvedUrl = new URL(targetUrl, href);\n      currentOrigin = new URL(href).origin;\n    } catch {\n      return false;\n    }\n    const isSameOriginRequest = resolvedUrl.origin === currentOrigin;\n    if (!tracePropagationTargets) {\n      return isSameOriginRequest;\n    } else {\n      return stringMatchesSomePattern(resolvedUrl.toString(), tracePropagationTargets) || isSameOriginRequest && stringMatchesSomePattern(resolvedUrl.pathname, tracePropagationTargets);\n    }\n  }\n}\n\n/**\n * Create and track xhr request spans\n *\n * @returns Span if a span was created, otherwise void.\n */\nfunction xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeaders, spans) {\n  const xhr = handlerData.xhr;\n  const sentryXhrData = xhr?.[SENTRY_XHR_DATA_KEY];\n  if (!xhr || xhr.__sentry_own_request__ || !sentryXhrData) {\n    return undefined;\n  }\n  const {\n    url,\n    method\n  } = sentryXhrData;\n  const shouldCreateSpanResult = hasSpansEnabled() && shouldCreateSpan(url);\n\n  // check first if the request has finished and is tracked by an existing span which should now end\n  if (handlerData.endTimestamp && shouldCreateSpanResult) {\n    const spanId = xhr.__sentry_xhr_span_id__;\n    if (!spanId) return;\n    const span = spans[spanId];\n    if (span && sentryXhrData.status_code !== undefined) {\n      setHttpStatus(span, sentryXhrData.status_code);\n      span.end();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return undefined;\n  }\n  const fullUrl = getFullURL(url);\n  const parsedUrl = fullUrl ? parseUrl(fullUrl) : parseUrl(url);\n  const urlForSpanName = stripUrlQueryAndFragment(url);\n  const hasParent = !!getActiveSpan();\n  const span = shouldCreateSpanResult && hasParent ? startInactiveSpan({\n    name: `${method} ${urlForSpanName}`,\n    attributes: {\n      url,\n      type: 'xhr',\n      'http.method': method,\n      'http.url': fullUrl,\n      'server.address': parsedUrl?.host,\n      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.browser',\n      [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.client',\n      ...(parsedUrl?.search && {\n        'http.query': parsedUrl?.search\n      }),\n      ...(parsedUrl?.hash && {\n        'http.fragment': parsedUrl?.hash\n      })\n    }\n  }) : new SentryNonRecordingSpan();\n  xhr.__sentry_xhr_span_id__ = span.spanContext().spanId;\n  spans[xhr.__sentry_xhr_span_id__] = span;\n  if (shouldAttachHeaders(url)) {\n    addTracingHeadersToXhrRequest(xhr,\n    // If performance is disabled (TWP) or there's no active root span (pageload/navigation/interaction),\n    // we do not want to use the span as base for the trace headers,\n    // which means that the headers will be generated from the scope and the sampling decision is deferred\n    hasSpansEnabled() && hasParent ? span : undefined);\n  }\n  const client = getClient();\n  if (client) {\n    client.emit('beforeOutgoingRequestSpan', span, handlerData);\n  }\n  return span;\n}\nfunction addTracingHeadersToXhrRequest(xhr, span) {\n  const {\n    'sentry-trace': sentryTrace,\n    baggage\n  } = getTraceData({\n    span\n  });\n  if (sentryTrace) {\n    setHeaderOnXhr(xhr, sentryTrace, baggage);\n  }\n}\nfunction setHeaderOnXhr(xhr, sentryTraceHeader, sentryBaggageHeader) {\n  const originalHeaders = xhr.__sentry_xhr_v3__?.request_headers;\n  if (originalHeaders?.['sentry-trace']) {\n    // bail if a sentry-trace header is already set\n    return;\n  }\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    xhr.setRequestHeader('sentry-trace', sentryTraceHeader);\n    if (sentryBaggageHeader) {\n      // only add our headers if\n      // - no pre-existing baggage header exists\n      // - or it is set and doesn't yet contain sentry values\n      const originalBaggageHeader = originalHeaders?.['baggage'];\n      if (!originalBaggageHeader || !baggageHeaderHasSentryValues(originalBaggageHeader)) {\n        // From MDN: \"If this method is called several times with the same header, the values are merged into one single request header.\"\n        // We can therefore simply set a baggage header without checking what was there before\n        // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        xhr.setRequestHeader('baggage', sentryBaggageHeader);\n      }\n    }\n  } catch {\n    // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n  }\n}\nfunction baggageHeaderHasSentryValues(baggageHeader) {\n  return baggageHeader.split(',').some(value => value.trim().startsWith('sentry-'));\n}\nfunction getFullURL(url) {\n  try {\n    // By adding a base URL to new URL(), this will also work for relative urls\n    // If `url` is a full URL, the base URL is ignored anyhow\n    const parsed = new URL(url, WINDOW.location.origin);\n    return parsed.href;\n  } catch {\n    return undefined;\n  }\n}\nexport { defaultRequestInstrumentationOptions, instrumentOutgoingRequests, shouldAttachHeaders, xhrCallback };","map":{"version":3,"names":["responseToSpanId","WeakMap","spanIdToEndTimestamp","Map","defaultRequestInstrumentationOptions","traceFetch","traceXHR","enableHTTPTimings","trackFetchStreamPerformance","instrumentOutgoingRequests","client","_options","shouldCreateSpanForRequest","tracePropagationTargets","onRequestSpanStart","shouldCreateSpan","_","shouldAttachHeadersWithTargets","url","shouldAttachHeaders","spans","addEventProcessor","event","type","forEach","span","op","updatedTimestamp","get","span_id","timestamp","delete","addFetchEndInstrumentationHandler","handlerData","response","endTimestamp","set","addFetchInstrumentationHandler","createdSpan","instrumentFetchRequest","fetchData","__span","fullUrl","getFullURL","host","parseUrl","undefined","setAttributes","addHTTPTimings","headers","addXhrInstrumentationHandler","xhrCallback","Headers","xhr","__sentry_xhr_v3__","request_headers","isPerformanceResourceTiming","entry","entryType","nextHopProtocol","initiatorType","spanToJSON","data","cleanup","addPerformanceInstrumentationHandler","entries","name","endsWith","spanAttributes","resourceTimingToSpanAttributes","attributeArray","setAttribute","setTimeout","targetUrl","href","getLocationHref","isRelativeSameOriginRequest","match","stringMatchesSomePattern","resolvedUrl","currentOrigin","URL","origin","isSameOriginRequest","toString","pathname","sentryXhrData","SENTRY_XHR_DATA_KEY","__sentry_own_request__","method","shouldCreateSpanResult","hasSpansEnabled","spanId","__sentry_xhr_span_id__","status_code","setHttpStatus","end","parsedUrl","urlForSpanName","stripUrlQueryAndFragment","hasParent","getActiveSpan","startInactiveSpan","attributes","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMANTIC_ATTRIBUTE_SENTRY_OP","search","hash","SentryNonRecordingSpan","spanContext","addTracingHeadersToXhrRequest","getClient","emit","sentryTrace","baggage","getTraceData","setHeaderOnXhr","sentryTraceHeader","sentryBaggageHeader","originalHeaders","setRequestHeader","originalBaggageHeader","baggageHeaderHasSentryValues","baggageHeader","split","some","value","trim","startsWith","parsed","WINDOW","location"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/browser/src/tracing/request.ts"],"sourcesContent":["import type { Client, HandlerDataXhr, SentryWrappedXMLHttpRequest, Span, WebFetchHeaders } from '@sentry/core';\nimport {\n  addFetchEndInstrumentationHandler,\n  addFetchInstrumentationHandler,\n  getActiveSpan,\n  getClient,\n  getLocationHref,\n  getTraceData,\n  hasSpansEnabled,\n  instrumentFetchRequest,\n  parseUrl,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SentryNonRecordingSpan,\n  setHttpStatus,\n  spanToJSON,\n  startInactiveSpan,\n  stringMatchesSomePattern,\n  stripUrlQueryAndFragment,\n} from '@sentry/core';\nimport type { XhrHint } from '@sentry-internal/browser-utils';\nimport {\n  addPerformanceInstrumentationHandler,\n  addXhrInstrumentationHandler,\n  SENTRY_XHR_DATA_KEY,\n} from '@sentry-internal/browser-utils';\nimport { WINDOW } from '../helpers';\nimport { resourceTimingToSpanAttributes } from './resource-timing';\n\n/** Options for Request Instrumentation */\nexport interface RequestInstrumentationOptions {\n  /**\n   * List of strings and/or Regular Expressions used to determine which outgoing requests will have `sentry-trace` and `baggage`\n   * headers attached.\n   *\n   * **Default:** If this option is not provided, tracing headers will be attached to all outgoing requests.\n   * If you are using a browser SDK, by default, tracing headers will only be attached to outgoing requests to the same origin.\n   *\n   * **Disclaimer:** Carelessly setting this option in browser environments may result into CORS errors!\n   * Only attach tracing headers to requests to the same origin, or to requests to services you can control CORS headers of.\n   * Cross-origin requests, meaning requests to a different domain, for example a request to `https://api.example.com/` while you're on `https://example.com/`, take special care.\n   * If you are attaching headers to cross-origin requests, make sure the backend handling the request returns a `\"Access-Control-Allow-Headers: sentry-trace, baggage\"` header to ensure your requests aren't blocked.\n   *\n   * If you provide a `tracePropagationTargets` array, the entries you provide will be matched against the entire URL of the outgoing request.\n   * If you are using a browser SDK, the entries will also be matched against the pathname of the outgoing requests.\n   * This is so you can have matchers for relative requests, for example, `/^\\/api/` if you want to trace requests to your `/api` routes on the same domain.\n   *\n   * If any of the two match any of the provided values, tracing headers will be attached to the outgoing request.\n   * Both, the string values, and the RegExes you provide in the array will match if they partially match the URL or pathname.\n   *\n   * Examples:\n   * - `tracePropagationTargets: [/^\\/api/]` and request to `https://same-origin.com/api/posts`:\n   *   - Tracing headers will be attached because the request is sent to the same origin and the regex matches the pathname \"/api/posts\".\n   * - `tracePropagationTargets: [/^\\/api/]` and request to `https://different-origin.com/api/posts`:\n   *   - Tracing headers will not be attached because the pathname will only be compared when the request target lives on the same origin.\n   * - `tracePropagationTargets: [/^\\/api/, 'https://external-api.com']` and request to `https://external-api.com/v1/data`:\n   *   - Tracing headers will be attached because the request URL matches the string `'https://external-api.com'`.\n   */\n  tracePropagationTargets?: Array<string | RegExp>;\n\n  /**\n   * Flag to disable patching all together for fetch requests.\n   *\n   * Default: true\n   */\n  traceFetch: boolean;\n\n  /**\n   * Flag to disable patching all together for xhr requests.\n   *\n   * Default: true\n   */\n  traceXHR: boolean;\n\n  /**\n   * Flag to disable tracking of long-lived streams, like server-sent events (SSE) via fetch.\n   * Do not enable this in case you have live streams or very long running streams.\n   *\n   * Disabled by default since it can lead to issues with streams using the `cancel()` api\n   * (https://github.com/getsentry/sentry-javascript/issues/13950)\n   *\n   * Default: false\n   */\n  trackFetchStreamPerformance: boolean;\n\n  /**\n   * If true, Sentry will capture http timings and add them to the corresponding http spans.\n   *\n   * Default: true\n   */\n  enableHTTPTimings: boolean;\n\n  /**\n   * This function will be called before creating a span for a request with the given url.\n   * Return false if you don't want a span for the given url.\n   *\n   * Default: (url: string) => true\n   */\n  shouldCreateSpanForRequest?(this: void, url: string): boolean;\n\n  /**\n   * Is called when spans are started for outgoing requests.\n   */\n  onRequestSpanStart?(span: Span, requestInformation: { headers?: WebFetchHeaders }): void;\n}\n\nconst responseToSpanId = new WeakMap<object, string>();\nconst spanIdToEndTimestamp = new Map<string, number>();\n\nexport const defaultRequestInstrumentationOptions: RequestInstrumentationOptions = {\n  traceFetch: true,\n  traceXHR: true,\n  enableHTTPTimings: true,\n  trackFetchStreamPerformance: false,\n};\n\n/** Registers span creators for xhr and fetch requests  */\nexport function instrumentOutgoingRequests(client: Client, _options?: Partial<RequestInstrumentationOptions>): void {\n  const {\n    traceFetch,\n    traceXHR,\n    trackFetchStreamPerformance,\n    shouldCreateSpanForRequest,\n    enableHTTPTimings,\n    tracePropagationTargets,\n    onRequestSpanStart,\n  } = {\n    ...defaultRequestInstrumentationOptions,\n    ..._options,\n  };\n\n  const shouldCreateSpan =\n    typeof shouldCreateSpanForRequest === 'function' ? shouldCreateSpanForRequest : (_: string) => true;\n\n  const shouldAttachHeadersWithTargets = (url: string): boolean => shouldAttachHeaders(url, tracePropagationTargets);\n\n  const spans: Record<string, Span> = {};\n\n  if (traceFetch) {\n    // Keeping track of http requests, whose body payloads resolved later than the initial resolved request\n    // e.g. streaming using server sent events (SSE)\n    client.addEventProcessor(event => {\n      if (event.type === 'transaction' && event.spans) {\n        event.spans.forEach(span => {\n          if (span.op === 'http.client') {\n            const updatedTimestamp = spanIdToEndTimestamp.get(span.span_id);\n            if (updatedTimestamp) {\n              span.timestamp = updatedTimestamp / 1000;\n              spanIdToEndTimestamp.delete(span.span_id);\n            }\n          }\n        });\n      }\n      return event;\n    });\n\n    if (trackFetchStreamPerformance) {\n      addFetchEndInstrumentationHandler(handlerData => {\n        if (handlerData.response) {\n          const span = responseToSpanId.get(handlerData.response);\n          if (span && handlerData.endTimestamp) {\n            spanIdToEndTimestamp.set(span, handlerData.endTimestamp);\n          }\n        }\n      });\n    }\n\n    addFetchInstrumentationHandler(handlerData => {\n      const createdSpan = instrumentFetchRequest(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n\n      if (handlerData.response && handlerData.fetchData.__span) {\n        responseToSpanId.set(handlerData.response, handlerData.fetchData.__span);\n      }\n\n      // We cannot use `window.location` in the generic fetch instrumentation,\n      // but we need it for reliable `server.address` attribute.\n      // so we extend this in here\n      if (createdSpan) {\n        const fullUrl = getFullURL(handlerData.fetchData.url);\n        const host = fullUrl ? parseUrl(fullUrl).host : undefined;\n        createdSpan.setAttributes({\n          'http.url': fullUrl,\n          'server.address': host,\n        });\n\n        if (enableHTTPTimings) {\n          addHTTPTimings(createdSpan);\n        }\n\n        onRequestSpanStart?.(createdSpan, { headers: handlerData.headers });\n      }\n    });\n  }\n\n  if (traceXHR) {\n    addXhrInstrumentationHandler(handlerData => {\n      const createdSpan = xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n      if (createdSpan) {\n        if (enableHTTPTimings) {\n          addHTTPTimings(createdSpan);\n        }\n\n        let headers;\n        try {\n          headers = new Headers(handlerData.xhr.__sentry_xhr_v3__?.request_headers);\n        } catch {\n          // noop\n        }\n        onRequestSpanStart?.(createdSpan, { headers });\n      }\n    });\n  }\n}\n\nfunction isPerformanceResourceTiming(entry: PerformanceEntry): entry is PerformanceResourceTiming {\n  return (\n    entry.entryType === 'resource' &&\n    'initiatorType' in entry &&\n    typeof (entry as PerformanceResourceTiming).nextHopProtocol === 'string' &&\n    (entry.initiatorType === 'fetch' || entry.initiatorType === 'xmlhttprequest')\n  );\n}\n\n/**\n * Creates a temporary observer to listen to the next fetch/xhr resourcing timings,\n * so that when timings hit their per-browser limit they don't need to be removed.\n *\n * @param span A span that has yet to be finished, must contain `url` on data.\n */\nfunction addHTTPTimings(span: Span): void {\n  const { url } = spanToJSON(span).data;\n\n  if (!url || typeof url !== 'string') {\n    return;\n  }\n\n  const cleanup = addPerformanceInstrumentationHandler('resource', ({ entries }) => {\n    entries.forEach(entry => {\n      if (isPerformanceResourceTiming(entry) && entry.name.endsWith(url)) {\n        const spanAttributes = resourceTimingToSpanAttributes(entry);\n        spanAttributes.forEach(attributeArray => span.setAttribute(...attributeArray));\n        // In the next tick, clean this handler up\n        // We have to wait here because otherwise this cleans itself up before it is fully done\n        setTimeout(cleanup);\n      }\n    });\n  });\n}\n\n/**\n * A function that determines whether to attach tracing headers to a request.\n * We only export this function for testing purposes.\n */\nexport function shouldAttachHeaders(\n  targetUrl: string,\n  tracePropagationTargets: (string | RegExp)[] | undefined,\n): boolean {\n  // window.location.href not being defined is an edge case in the browser but we need to handle it.\n  // Potentially dangerous situations where it may not be defined: Browser Extensions, Web Workers, patching of the location obj\n  const href = getLocationHref();\n\n  if (!href) {\n    // If there is no window.location.origin, we default to only attaching tracing headers to relative requests, i.e. ones that start with `/`\n    // BIG DISCLAIMER: Users can call URLs with a double slash (fetch(\"//example.com/api\")), this is a shorthand for \"send to the same protocol\",\n    // so we need a to exclude those requests, because they might be cross origin.\n    const isRelativeSameOriginRequest = !!targetUrl.match(/^\\/(?!\\/)/);\n    if (!tracePropagationTargets) {\n      return isRelativeSameOriginRequest;\n    } else {\n      return stringMatchesSomePattern(targetUrl, tracePropagationTargets);\n    }\n  } else {\n    let resolvedUrl;\n    let currentOrigin;\n\n    // URL parsing may fail, we default to not attaching trace headers in that case.\n    try {\n      resolvedUrl = new URL(targetUrl, href);\n      currentOrigin = new URL(href).origin;\n    } catch {\n      return false;\n    }\n\n    const isSameOriginRequest = resolvedUrl.origin === currentOrigin;\n    if (!tracePropagationTargets) {\n      return isSameOriginRequest;\n    } else {\n      return (\n        stringMatchesSomePattern(resolvedUrl.toString(), tracePropagationTargets) ||\n        (isSameOriginRequest && stringMatchesSomePattern(resolvedUrl.pathname, tracePropagationTargets))\n      );\n    }\n  }\n}\n\n/**\n * Create and track xhr request spans\n *\n * @returns Span if a span was created, otherwise void.\n */\nexport function xhrCallback(\n  handlerData: HandlerDataXhr,\n  shouldCreateSpan: (url: string) => boolean,\n  shouldAttachHeaders: (url: string) => boolean,\n  spans: Record<string, Span>,\n): Span | undefined {\n  const xhr = handlerData.xhr;\n  const sentryXhrData = xhr?.[SENTRY_XHR_DATA_KEY];\n\n  if (!xhr || xhr.__sentry_own_request__ || !sentryXhrData) {\n    return undefined;\n  }\n\n  const { url, method } = sentryXhrData;\n\n  const shouldCreateSpanResult = hasSpansEnabled() && shouldCreateSpan(url);\n\n  // check first if the request has finished and is tracked by an existing span which should now end\n  if (handlerData.endTimestamp && shouldCreateSpanResult) {\n    const spanId = xhr.__sentry_xhr_span_id__;\n    if (!spanId) return;\n\n    const span = spans[spanId];\n    if (span && sentryXhrData.status_code !== undefined) {\n      setHttpStatus(span, sentryXhrData.status_code);\n      span.end();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return undefined;\n  }\n\n  const fullUrl = getFullURL(url);\n  const parsedUrl = fullUrl ? parseUrl(fullUrl) : parseUrl(url);\n\n  const urlForSpanName = stripUrlQueryAndFragment(url);\n\n  const hasParent = !!getActiveSpan();\n\n  const span =\n    shouldCreateSpanResult && hasParent\n      ? startInactiveSpan({\n          name: `${method} ${urlForSpanName}`,\n          attributes: {\n            url,\n            type: 'xhr',\n            'http.method': method,\n            'http.url': fullUrl,\n            'server.address': parsedUrl?.host,\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.browser',\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.client',\n            ...(parsedUrl?.search && { 'http.query': parsedUrl?.search }),\n            ...(parsedUrl?.hash && { 'http.fragment': parsedUrl?.hash }),\n          },\n        })\n      : new SentryNonRecordingSpan();\n\n  xhr.__sentry_xhr_span_id__ = span.spanContext().spanId;\n  spans[xhr.__sentry_xhr_span_id__] = span;\n\n  if (shouldAttachHeaders(url)) {\n    addTracingHeadersToXhrRequest(\n      xhr,\n      // If performance is disabled (TWP) or there's no active root span (pageload/navigation/interaction),\n      // we do not want to use the span as base for the trace headers,\n      // which means that the headers will be generated from the scope and the sampling decision is deferred\n      hasSpansEnabled() && hasParent ? span : undefined,\n    );\n  }\n\n  const client = getClient();\n  if (client) {\n    client.emit('beforeOutgoingRequestSpan', span, handlerData as XhrHint);\n  }\n\n  return span;\n}\n\nfunction addTracingHeadersToXhrRequest(xhr: SentryWrappedXMLHttpRequest, span?: Span): void {\n  const { 'sentry-trace': sentryTrace, baggage } = getTraceData({ span });\n\n  if (sentryTrace) {\n    setHeaderOnXhr(xhr, sentryTrace, baggage);\n  }\n}\n\nfunction setHeaderOnXhr(\n  xhr: SentryWrappedXMLHttpRequest,\n  sentryTraceHeader: string,\n  sentryBaggageHeader: string | undefined,\n): void {\n  const originalHeaders = xhr.__sentry_xhr_v3__?.request_headers;\n\n  if (originalHeaders?.['sentry-trace']) {\n    // bail if a sentry-trace header is already set\n    return;\n  }\n\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    xhr.setRequestHeader!('sentry-trace', sentryTraceHeader);\n    if (sentryBaggageHeader) {\n      // only add our headers if\n      // - no pre-existing baggage header exists\n      // - or it is set and doesn't yet contain sentry values\n      const originalBaggageHeader = originalHeaders?.['baggage'];\n      if (!originalBaggageHeader || !baggageHeaderHasSentryValues(originalBaggageHeader)) {\n        // From MDN: \"If this method is called several times with the same header, the values are merged into one single request header.\"\n        // We can therefore simply set a baggage header without checking what was there before\n        // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        xhr.setRequestHeader!('baggage', sentryBaggageHeader);\n      }\n    }\n  } catch {\n    // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n  }\n}\n\nfunction baggageHeaderHasSentryValues(baggageHeader: string): boolean {\n  return baggageHeader.split(',').some(value => value.trim().startsWith('sentry-'));\n}\n\nfunction getFullURL(url: string): string | undefined {\n  try {\n    // By adding a base URL to new URL(), this will also work for relative urls\n    // If `url` is a full URL, the base URL is ignored anyhow\n    const parsed = new URL(url, WINDOW.location.origin);\n    return parsed.href;\n  } catch {\n    return undefined;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}