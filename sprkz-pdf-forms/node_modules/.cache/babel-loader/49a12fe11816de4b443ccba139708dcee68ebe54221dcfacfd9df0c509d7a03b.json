{"ast":null,"code":"import { getAsyncContextStrategy } from '../asyncContext/index.js';\nimport { getMainCarrier } from '../carrier.js';\nimport { getClient, getCurrentScope } from '../currentScopes.js';\nimport { isEnabled } from '../exports.js';\nimport { debug } from './debug-logger.js';\nimport { getActiveSpan, spanToTraceHeader } from './spanUtils.js';\nimport { getDynamicSamplingContextFromSpan, getDynamicSamplingContextFromScope } from '../tracing/dynamicSamplingContext.js';\nimport { TRACEPARENT_REGEXP, generateSentryTraceHeader } from './tracing.js';\nimport { dynamicSamplingContextToSentryBaggageHeader } from './baggage.js';\n\n/**\n * Extracts trace propagation data from the current span or from the client's scope (via transaction or propagation\n * context) and serializes it to `sentry-trace` and `baggage` values to strings. These values can be used to propagate\n * a trace via our tracing Http headers or Html `<meta>` tags.\n *\n * This function also applies some validation to the generated sentry-trace and baggage values to ensure that\n * only valid strings are returned.\n *\n * @returns an object with the tracing data values. The object keys are the name of the tracing key to be used as header\n * or meta tag name.\n */\nfunction getTraceData(options = {}) {\n  const client = options.client || getClient();\n  if (!isEnabled() || !client) {\n    return {};\n  }\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  if (acs.getTraceData) {\n    return acs.getTraceData(options);\n  }\n  const scope = options.scope || getCurrentScope();\n  const span = options.span || getActiveSpan();\n  const sentryTrace = span ? spanToTraceHeader(span) : scopeToTraceHeader(scope);\n  const dsc = span ? getDynamicSamplingContextFromSpan(span) : getDynamicSamplingContextFromScope(client, scope);\n  const baggage = dynamicSamplingContextToSentryBaggageHeader(dsc);\n  const isValidSentryTraceHeader = TRACEPARENT_REGEXP.test(sentryTrace);\n  if (!isValidSentryTraceHeader) {\n    debug.warn('Invalid sentry-trace data. Cannot generate trace data');\n    return {};\n  }\n  return {\n    'sentry-trace': sentryTrace,\n    baggage\n  };\n}\n\n/**\n * Get a sentry-trace header value for the given scope.\n */\nfunction scopeToTraceHeader(scope) {\n  const {\n    traceId,\n    sampled,\n    propagationSpanId\n  } = scope.getPropagationContext();\n  return generateSentryTraceHeader(traceId, propagationSpanId, sampled);\n}\nexport { getTraceData };","map":{"version":3,"names":["getTraceData","options","client","getClient","isEnabled","carrier","getMainCarrier","acs","getAsyncContextStrategy","scope","getCurrentScope","span","getActiveSpan","sentryTrace","spanToTraceHeader","scopeToTraceHeader","dsc","getDynamicSamplingContextFromSpan","getDynamicSamplingContextFromScope","baggage","dynamicSamplingContextToSentryBaggageHeader","isValidSentryTraceHeader","TRACEPARENT_REGEXP","test","debug","warn","traceId","sampled","propagationSpanId","getPropagationContext","generateSentryTraceHeader"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/utils/traceData.ts"],"sourcesContent":["import { getAsyncContextStrategy } from '../asyncContext';\nimport { getMainCarrier } from '../carrier';\nimport type { Client } from '../client';\nimport { getClient, getCurrentScope } from '../currentScopes';\nimport { isEnabled } from '../exports';\nimport type { Scope } from '../scope';\nimport { getDynamicSamplingContextFromScope, getDynamicSamplingContextFromSpan } from '../tracing';\nimport type { Span } from '../types-hoist/span';\nimport type { SerializedTraceData } from '../types-hoist/tracing';\nimport { dynamicSamplingContextToSentryBaggageHeader } from './baggage';\nimport { debug } from './debug-logger';\nimport { getActiveSpan, spanToTraceHeader } from './spanUtils';\nimport { generateSentryTraceHeader, TRACEPARENT_REGEXP } from './tracing';\n\n/**\n * Extracts trace propagation data from the current span or from the client's scope (via transaction or propagation\n * context) and serializes it to `sentry-trace` and `baggage` values to strings. These values can be used to propagate\n * a trace via our tracing Http headers or Html `<meta>` tags.\n *\n * This function also applies some validation to the generated sentry-trace and baggage values to ensure that\n * only valid strings are returned.\n *\n * @returns an object with the tracing data values. The object keys are the name of the tracing key to be used as header\n * or meta tag name.\n */\nexport function getTraceData(options: { span?: Span; scope?: Scope; client?: Client } = {}): SerializedTraceData {\n  const client = options.client || getClient();\n  if (!isEnabled() || !client) {\n    return {};\n  }\n\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  if (acs.getTraceData) {\n    return acs.getTraceData(options);\n  }\n\n  const scope = options.scope || getCurrentScope();\n  const span = options.span || getActiveSpan();\n  const sentryTrace = span ? spanToTraceHeader(span) : scopeToTraceHeader(scope);\n  const dsc = span ? getDynamicSamplingContextFromSpan(span) : getDynamicSamplingContextFromScope(client, scope);\n  const baggage = dynamicSamplingContextToSentryBaggageHeader(dsc);\n\n  const isValidSentryTraceHeader = TRACEPARENT_REGEXP.test(sentryTrace);\n  if (!isValidSentryTraceHeader) {\n    debug.warn('Invalid sentry-trace data. Cannot generate trace data');\n    return {};\n  }\n\n  return {\n    'sentry-trace': sentryTrace,\n    baggage,\n  };\n}\n\n/**\n * Get a sentry-trace header value for the given scope.\n */\nfunction scopeToTraceHeader(scope: Scope): string {\n  const { traceId, sampled, propagationSpanId } = scope.getPropagationContext();\n  return generateSentryTraceHeader(traceId, propagationSpanId, sampled);\n}\n"],"mappings":";;;;;;;;;;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,YAAYA,CAACC,OAAO,GAAoD,EAAE,EAAuB;EAC/G,MAAMC,MAAA,GAASD,OAAO,CAACC,MAAA,IAAUC,SAAS,EAAE;EAC5C,IAAI,CAACC,SAAS,EAAC,IAAK,CAACF,MAAM,EAAE;IAC3B,OAAO,EAAE;EACb;EAEE,MAAMG,OAAA,GAAUC,cAAc,EAAE;EAChC,MAAMC,GAAA,GAAMC,uBAAuB,CAACH,OAAO,CAAC;EAC5C,IAAIE,GAAG,CAACP,YAAY,EAAE;IACpB,OAAOO,GAAG,CAACP,YAAY,CAACC,OAAO,CAAC;EACpC;EAEE,MAAMQ,KAAA,GAAQR,OAAO,CAACQ,KAAA,IAASC,eAAe,EAAE;EAChD,MAAMC,IAAA,GAAOV,OAAO,CAACU,IAAA,IAAQC,aAAa,EAAE;EAC5C,MAAMC,WAAA,GAAcF,IAAA,GAAOG,iBAAiB,CAACH,IAAI,IAAII,kBAAkB,CAACN,KAAK,CAAC;EAC9E,MAAMO,GAAA,GAAML,IAAA,GAAOM,iCAAiC,CAACN,IAAI,IAAIO,kCAAkC,CAAChB,MAAM,EAAEO,KAAK,CAAC;EAC9G,MAAMU,OAAA,GAAUC,2CAA2C,CAACJ,GAAG,CAAC;EAEhE,MAAMK,wBAAA,GAA2BC,kBAAkB,CAACC,IAAI,CAACV,WAAW,CAAC;EACrE,IAAI,CAACQ,wBAAwB,EAAE;IAC7BG,KAAK,CAACC,IAAI,CAAC,uDAAuD,CAAC;IACnE,OAAO,EAAE;EACb;EAEE,OAAO;IACL,cAAc,EAAEZ,WAAW;IAC3BM;EACJ,CAAG;AACH;;AAEA;AACA;AACA;AACA,SAASJ,kBAAkBA,CAACN,KAAK,EAAiB;EAChD,MAAM;IAAEiB,OAAO;IAAEC,OAAO;IAAEC;EAAA,CAAkB,GAAInB,KAAK,CAACoB,qBAAqB,EAAE;EAC7E,OAAOC,yBAAyB,CAACJ,OAAO,EAAEE,iBAAiB,EAAED,OAAO,CAAC;AACvE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}