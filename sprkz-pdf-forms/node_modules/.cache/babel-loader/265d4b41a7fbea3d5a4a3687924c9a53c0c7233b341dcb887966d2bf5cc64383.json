{"ast":null,"code":"import { getClient } from './currentScopes.js';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from './semanticAttributes.js';\nimport { getActiveSpan } from './utils/spanUtils.js';\nimport { setHttpStatus, SPAN_STATUS_ERROR } from './tracing/spanstatus.js';\nimport { isRequest, isInstanceOf } from './utils/is.js';\nimport { hasSpansEnabled } from './utils/hasSpansEnabled.js';\nimport { SENTRY_BAGGAGE_KEY_PREFIX } from './utils/baggage.js';\nimport { SentryNonRecordingSpan } from './tracing/sentryNonRecordingSpan.js';\nimport { startInactiveSpan } from './tracing/trace.js';\nimport { getTraceData } from './utils/traceData.js';\nimport { parseStringToURLObject, getSanitizedUrlStringFromUrlObject, isURLObjectRelative } from './utils/url.js';\n\n/**\n * Create and track fetch request spans for usage in combination with `addFetchInstrumentationHandler`.\n *\n * @returns Span if a span was created, otherwise void.\n */\nfunction instrumentFetchRequest(handlerData, shouldCreateSpan, shouldAttachHeaders, spans) {\n  let spanOrigin = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'auto.http.browser';\n  if (!handlerData.fetchData) {\n    return undefined;\n  }\n  const {\n    method,\n    url\n  } = handlerData.fetchData;\n  const shouldCreateSpanResult = hasSpansEnabled() && shouldCreateSpan(url);\n  if (handlerData.endTimestamp && shouldCreateSpanResult) {\n    const spanId = handlerData.fetchData.__span;\n    if (!spanId) return;\n    const span = spans[spanId];\n    if (span) {\n      endSpan(span, handlerData);\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return undefined;\n  }\n  const hasParent = !!getActiveSpan();\n  const span = shouldCreateSpanResult && hasParent ? startInactiveSpan(getSpanStartOptions(url, method, spanOrigin)) : new SentryNonRecordingSpan();\n  handlerData.fetchData.__span = span.spanContext().spanId;\n  spans[span.spanContext().spanId] = span;\n  if (shouldAttachHeaders(handlerData.fetchData.url)) {\n    const request = handlerData.args[0];\n    const options = handlerData.args[1] || {};\n    const headers = _addTracingHeadersToFetchRequest(request, options,\n    // If performance is disabled (TWP) or there's no active root span (pageload/navigation/interaction),\n    // we do not want to use the span as base for the trace headers,\n    // which means that the headers will be generated from the scope and the sampling decision is deferred\n    hasSpansEnabled() && hasParent ? span : undefined);\n    if (headers) {\n      // Ensure this is actually set, if no options have been passed previously\n      handlerData.args[1] = options;\n      options.headers = headers;\n    }\n  }\n  const client = getClient();\n  if (client) {\n    const fetchHint = {\n      input: handlerData.args,\n      response: handlerData.response,\n      startTimestamp: handlerData.startTimestamp,\n      endTimestamp: handlerData.endTimestamp\n    };\n    client.emit('beforeOutgoingRequestSpan', span, fetchHint);\n  }\n  return span;\n}\n\n/**\n * Adds sentry-trace and baggage headers to the various forms of fetch headers.\n * exported only for testing purposes\n *\n * When we determine if we should add a baggage header, there are 3 cases:\n * 1. No previous baggage header -> add baggage\n * 2. Previous baggage header has no sentry baggage values -> add our baggage\n * 3. Previous baggage header has sentry baggage values -> do nothing (might have been added manually by users)\n */\n// eslint-disable-next-line complexity -- yup it's this complicated :(\nfunction _addTracingHeadersToFetchRequest(request, fetchOptionsObj, span) {\n  const traceHeaders = getTraceData({\n    span\n  });\n  const sentryTrace = traceHeaders['sentry-trace'];\n  const baggage = traceHeaders.baggage;\n\n  // Nothing to do, when we return undefined here, the original headers will be used\n  if (!sentryTrace) {\n    return undefined;\n  }\n  const originalHeaders = fetchOptionsObj.headers || (isRequest(request) ? request.headers : undefined);\n  if (!originalHeaders) {\n    return {\n      ...traceHeaders\n    };\n  } else if (isHeaders(originalHeaders)) {\n    const newHeaders = new Headers(originalHeaders);\n\n    // We don't want to override manually added sentry headers\n    if (!newHeaders.get('sentry-trace')) {\n      newHeaders.set('sentry-trace', sentryTrace);\n    }\n    if (baggage) {\n      const prevBaggageHeader = newHeaders.get('baggage');\n      if (!prevBaggageHeader) {\n        newHeaders.set('baggage', baggage);\n      } else if (!baggageHeaderHasSentryBaggageValues(prevBaggageHeader)) {\n        newHeaders.set('baggage', `${prevBaggageHeader},${baggage}`);\n      }\n    }\n    return newHeaders;\n  } else if (Array.isArray(originalHeaders)) {\n    const newHeaders = [...originalHeaders];\n    if (!originalHeaders.find(header => header[0] === 'sentry-trace')) {\n      newHeaders.push(['sentry-trace', sentryTrace]);\n    }\n    const prevBaggageHeaderWithSentryValues = originalHeaders.find(header => header[0] === 'baggage' && baggageHeaderHasSentryBaggageValues(header[1]));\n    if (baggage && !prevBaggageHeaderWithSentryValues) {\n      // If there are multiple entries with the same key, the browser will merge the values into a single request header.\n      // Its therefore safe to simply push a \"baggage\" entry, even though there might already be another baggage header.\n      newHeaders.push(['baggage', baggage]);\n    }\n    return newHeaders;\n  } else {\n    const existingSentryTraceHeader = 'sentry-trace' in originalHeaders ? originalHeaders['sentry-trace'] : undefined;\n    const existingBaggageHeader = 'baggage' in originalHeaders ? originalHeaders.baggage : undefined;\n    const newBaggageHeaders = existingBaggageHeader ? Array.isArray(existingBaggageHeader) ? [...existingBaggageHeader] : [existingBaggageHeader] : [];\n    const prevBaggageHeaderWithSentryValues = existingBaggageHeader && (Array.isArray(existingBaggageHeader) ? existingBaggageHeader.find(headerItem => baggageHeaderHasSentryBaggageValues(headerItem)) : baggageHeaderHasSentryBaggageValues(existingBaggageHeader));\n    if (baggage && !prevBaggageHeaderWithSentryValues) {\n      newBaggageHeaders.push(baggage);\n    }\n    return {\n      ...originalHeaders,\n      'sentry-trace': existingSentryTraceHeader ?? sentryTrace,\n      baggage: newBaggageHeaders.length > 0 ? newBaggageHeaders.join(',') : undefined\n    };\n  }\n}\nfunction endSpan(span, handlerData) {\n  if (handlerData.response) {\n    setHttpStatus(span, handlerData.response.status);\n    const contentLength = handlerData.response?.headers?.get('content-length');\n    if (contentLength) {\n      const contentLengthNum = parseInt(contentLength);\n      if (contentLengthNum > 0) {\n        span.setAttribute('http.response_content_length', contentLengthNum);\n      }\n    }\n  } else if (handlerData.error) {\n    span.setStatus({\n      code: SPAN_STATUS_ERROR,\n      message: 'internal_error'\n    });\n  }\n  span.end();\n}\nfunction baggageHeaderHasSentryBaggageValues(baggageHeader) {\n  return baggageHeader.split(',').some(baggageEntry => baggageEntry.trim().startsWith(SENTRY_BAGGAGE_KEY_PREFIX));\n}\nfunction isHeaders(headers) {\n  return typeof Headers !== 'undefined' && isInstanceOf(headers, Headers);\n}\nfunction getSpanStartOptions(url, method, spanOrigin) {\n  const parsedUrl = parseStringToURLObject(url);\n  return {\n    name: parsedUrl ? `${method} ${getSanitizedUrlStringFromUrlObject(parsedUrl)}` : method,\n    attributes: getFetchSpanAttributes(url, parsedUrl, method, spanOrigin)\n  };\n}\nfunction getFetchSpanAttributes(url, parsedUrl, method, spanOrigin) {\n  const attributes = {\n    url,\n    type: 'fetch',\n    'http.method': method,\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: spanOrigin,\n    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.client'\n  };\n  if (parsedUrl) {\n    if (!isURLObjectRelative(parsedUrl)) {\n      attributes['http.url'] = parsedUrl.href;\n      attributes['server.address'] = parsedUrl.host;\n    }\n    if (parsedUrl.search) {\n      attributes['http.query'] = parsedUrl.search;\n    }\n    if (parsedUrl.hash) {\n      attributes['http.fragment'] = parsedUrl.hash;\n    }\n  }\n  return attributes;\n}\nexport { _addTracingHeadersToFetchRequest, instrumentFetchRequest };\n//# sourceMappingURL=fetch.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}