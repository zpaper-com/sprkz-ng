{"ast":null,"code":"import * as Sentry from '@sentry/react';\nexport class ValidationService {\n  /**\n   * Validate a single form field\n   */\n  static async validateField(field, value, allFields = [], options = {}) {\n    const startTime = performance.now();\n\n    // Check feature flags\n    const enhancedValidation = isFeatureEnabled('ENHANCED_FIELD_VALIDATION');\n    const performanceMonitoring = isFeatureEnabled('PERFORMANCE_MONITORING');\n    const securityAuditLogging = isFeatureEnabled('SECURITY_AUDIT_LOGGING');\n    try {\n      // Use enhanced validation options if feature is enabled\n      const {\n        validateRequired = enhancedValidation ? true : true,\n        validateFormat = enhancedValidation ? true : false,\n        validateDependencies = enhancedValidation ? true : false,\n        excludeReadOnly = true,\n        performanceMode = performanceMonitoring ? false : true\n      } = options;\n\n      // Security audit logging\n      if (securityAuditLogging) {\n        console.log(`Validating field: ${field.name}, type: ${field.type}, value length: ${(value === null || value === void 0 ? void 0 : value.toString().length) || 0}`);\n      }\n\n      // Create cache key\n      const cacheKey = `${field.name}_${JSON.stringify(value)}_${field.type}`;\n\n      // Check cache in performance mode\n      if (performanceMode && this.validationCache.has(cacheKey)) {\n        const cached = this.validationCache.get(cacheKey);\n        // Use cached result if less than 1 minute old\n        if (Date.now() - cached.validatedAt < 60000) {\n          return cached;\n        }\n      }\n      const errors = [];\n      const warnings = [];\n\n      // Skip validation for read-only fields if requested\n      if (excludeReadOnly && field.readOnly) {\n        const result = {\n          isValid: true,\n          errors: [],\n          warnings: [],\n          fieldName: field.name,\n          validatedAt: Date.now()\n        };\n        return result;\n      }\n\n      // Get validation rules for field type\n      const fieldType = this.getFieldValidationType(field);\n      const rules = this.FIELD_VALIDATION_RULES[fieldType] || [];\n\n      // Apply validation rules\n      for (const rule of rules) {\n        // Skip certain validations based on options\n        if (!validateRequired && rule.type === 'required') continue;\n        if (!validateFormat && rule.type === 'format') continue;\n        if (!validateDependencies && rule.type === 'dependency') continue;\n        const ruleValid = await this.applyValidationRule(rule, value, field, allFields);\n        if (!ruleValid) {\n          if (rule.type === 'required' && !field.required) {\n            warnings.push(rule.message);\n          } else {\n            errors.push(rule.message);\n          }\n        }\n      }\n\n      // Additional field-specific validations\n      if (validateDependencies) {\n        const dependencyErrors = await this.validateFieldDependencies(field, value, allFields);\n        errors.push(...dependencyErrors);\n      }\n\n      // Custom business logic validations\n      const customErrors = await this.validateCustomBusinessRules(field, value, allFields);\n      errors.push(...customErrors);\n      const result = {\n        isValid: errors.length === 0,\n        errors,\n        warnings,\n        fieldName: field.name,\n        validatedAt: Date.now()\n      };\n\n      // Cache result\n      this.validationCache.set(cacheKey, result);\n\n      // Performance monitoring\n      const duration = performance.now() - startTime;\n      if (duration > this.performanceTarget) {\n        console.warn(`Validation for field \"${field.name}\" took ${duration.toFixed(2)}ms (target: ${this.performanceTarget}ms)`);\n\n        // Report to Sentry if performance is very poor\n        if (duration > this.performanceTarget * 3) {\n          Sentry.addBreadcrumb({\n            message: 'Slow field validation detected',\n            data: {\n              fieldName: field.name,\n              fieldType: field.type,\n              duration: duration,\n              target: this.performanceTarget\n            },\n            level: 'warning'\n          });\n        }\n      }\n      return result;\n    } catch (error) {\n      console.error(`Validation error for field \"${field.name}\":`, error);\n      Sentry.captureException(error, {\n        tags: {\n          component: 'ValidationService',\n          fieldName: field.name,\n          fieldType: field.type\n        }\n      });\n      return {\n        isValid: false,\n        errors: ['An error occurred while validating this field'],\n        warnings: [],\n        fieldName: field.name,\n        validatedAt: Date.now()\n      };\n    }\n  }\n\n  /**\n   * Validate multiple fields\n   */\n  static async validateFields(fields, values, options = {}) {\n    const results = {};\n\n    // Validate fields in parallel for better performance\n    const validationPromises = fields.map(async field => {\n      const value = values[field.name];\n      const result = await this.validateField(field, value, fields, options);\n      results[field.name] = result;\n    });\n    await Promise.all(validationPromises);\n    return results;\n  }\n\n  /**\n   * Validate all required fields are completed\n   */\n  static validateRequiredFieldsCompletion(fields, values) {\n    const requiredFields = fields.filter(field => field.required && !field.readOnly);\n    const missingFields = [];\n    let completedCount = 0;\n    for (const field of requiredFields) {\n      const value = values[field.name];\n      const hasValue = this.hasValidValue(field, value);\n      if (hasValue) {\n        completedCount++;\n      } else {\n        missingFields.push(field.name);\n      }\n    }\n    const completionPercentage = requiredFields.length > 0 ? Math.round(completedCount / requiredFields.length * 100) : 100;\n    return {\n      isComplete: missingFields.length === 0,\n      missingFields,\n      completionPercentage\n    };\n  }\n\n  /**\n   * Apply a single validation rule\n   */\n  static async applyValidationRule(rule, value, field, allFields) {\n    var _rule$params;\n    switch (rule.type) {\n      case 'required':\n        return this.hasValidValue(field, value);\n      case 'format':\n        if (!value) return true; // Format validation only applies to non-empty values\n        const pattern = (_rule$params = rule.params) === null || _rule$params === void 0 ? void 0 : _rule$params.pattern;\n        if (pattern instanceof RegExp) {\n          return pattern.test(String(value));\n        }\n        return true;\n      case 'length':\n        if (!value) return true;\n        const str = String(value);\n        const {\n          min,\n          max\n        } = rule.params || {};\n        if (min !== undefined && str.length < min) return false;\n        if (max !== undefined && str.length > max) return false;\n        return true;\n      case 'custom':\n        if (rule.validator) {\n          return rule.validator(value, field, allFields);\n        }\n        return true;\n      case 'dependency':\n        return this.validateFieldDependencies(field, value, allFields).then(errors => errors.length === 0);\n      default:\n        return true;\n    }\n  }\n\n  /**\n   * Check if field has a valid value\n   */\n  static hasValidValue(field, value) {\n    if (value === null || value === undefined || value === '') {\n      return false;\n    }\n    switch (field.type) {\n      case 'checkbox':\n        return value === true || value === 'true' || value === 'on';\n      case 'signature':\n        return typeof value === 'string' && value.startsWith('data:image/') && value.length > 100;\n      case 'radio':\n      case 'dropdown':\n        return value !== null && value !== undefined && value !== '';\n      default:\n        return String(value).trim().length > 0;\n    }\n  }\n\n  /**\n   * Get validation type based on field properties\n   */\n  static getFieldValidationType(field) {\n    // Check field name patterns for common types\n    const fieldName = field.name.toLowerCase();\n    if (fieldName.includes('email')) return 'email';\n    if (fieldName.includes('phone') || fieldName.includes('tel')) return 'phone';\n    if (fieldName.includes('date')) return 'date';\n    if (fieldName.includes('number') || fieldName.includes('amount')) return 'number';\n\n    // Use field type\n    return field.type || 'text';\n  }\n\n  /**\n   * Validate field dependencies\n   */\n  static async validateFieldDependencies(field, value, allFields) {\n    const errors = [];\n\n    // Example dependency validation logic\n    // This can be extended based on specific business requirements\n\n    // Check for conditional required fields\n    // Example: If field A is filled, then field B becomes required\n    const fieldName = field.name.toLowerCase();\n    if (fieldName.includes('spouse') && fieldName.includes('name')) {\n      // If marital status is married, spouse name is required\n      const maritalField = allFields.find(f => f.name.toLowerCase().includes('marital') || f.name.toLowerCase().includes('status'));\n      if (maritalField) {\n        const maritalValue = String(value || '').toLowerCase();\n        if ((maritalValue.includes('married') || maritalValue.includes('spouse')) && !value) {\n          errors.push('Spouse name is required when married');\n        }\n      }\n    }\n    return errors;\n  }\n\n  /**\n   * Custom business rule validation\n   */\n  static async validateCustomBusinessRules(field, value, allFields) {\n    const errors = [];\n    try {\n      // Age validation example\n      if (field.name.toLowerCase().includes('age') && value) {\n        const age = parseInt(String(value), 10);\n        if (!isNaN(age)) {\n          if (age < 0 || age > 150) {\n            errors.push('Please enter a valid age');\n          }\n          if (age < 18) {\n            errors.push('Must be 18 or older');\n          }\n        }\n      }\n\n      // Date range validation example\n      if (field.name.toLowerCase().includes('start') && field.name.toLowerCase().includes('date')) {\n        const endDateField = allFields.find(f => f.name.toLowerCase().includes('end') && f.name.toLowerCase().includes('date'));\n        if (endDateField && value) {\n          const startDate = new Date(value);\n          // This would need the end date value from the form state\n          // For now, just validate the start date is not in the far future\n          const oneYearFromNow = new Date();\n          oneYearFromNow.setFullYear(oneYearFromNow.getFullYear() + 1);\n          if (startDate > oneYearFromNow) {\n            errors.push('Start date cannot be more than one year in the future');\n          }\n        }\n      }\n    } catch (error) {\n      console.warn(`Error in custom business rule validation for field \"${field.name}\":`, error);\n    }\n    return errors;\n  }\n\n  /**\n   * Clear validation cache\n   */\n  static clearValidationCache() {\n    this.validationCache.clear();\n  }\n\n  /**\n   * Get validation cache statistics\n   */\n  static getValidationCacheStats() {\n    return {\n      size: this.validationCache.size,\n      entries: Array.from(this.validationCache.keys())\n    };\n  }\n\n  /**\n   * Validate form submission readiness\n   */\n  static async validateFormSubmission(fields, values) {\n    const validationResults = await this.validateFields(fields, values, {\n      validateRequired: true,\n      validateFormat: true,\n      validateDependencies: true,\n      excludeReadOnly: true\n    });\n    const requiredCompletion = this.validateRequiredFieldsCompletion(fields, values);\n    const errors = {};\n    const warnings = {};\n    let validFields = 0;\n    let invalidFields = 0;\n    Object.entries(validationResults).forEach(([fieldName, result]) => {\n      if (result.errors.length > 0) {\n        errors[fieldName] = result.errors;\n        invalidFields++;\n      } else {\n        validFields++;\n      }\n      if (result.warnings.length > 0) {\n        warnings[fieldName] = result.warnings;\n      }\n    });\n    const requiredFields = fields.filter(f => f.required && !f.readOnly);\n    return {\n      canSubmit: requiredCompletion.isComplete && invalidFields === 0,\n      errors,\n      warnings,\n      summary: {\n        totalFields: fields.length,\n        validFields,\n        invalidFields,\n        requiredFields: requiredFields.length,\n        completedRequiredFields: requiredFields.length - requiredCompletion.missingFields.length\n      }\n    };\n  }\n}\nValidationService.validationCache = new Map();\nValidationService.performanceTarget = 10;\n// milliseconds per field\n/**\n * Validation rules for different field types\n */\nValidationService.FIELD_VALIDATION_RULES = {\n  text: [{\n    type: 'required',\n    message: 'This field is required'\n  }, {\n    type: 'length',\n    message: 'Text is too long',\n    params: {\n      max: 1000\n    }\n  }],\n  email: [{\n    type: 'required',\n    message: 'Email address is required'\n  }, {\n    type: 'format',\n    message: 'Please enter a valid email address',\n    params: {\n      pattern: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/\n    }\n  }],\n  phone: [{\n    type: 'required',\n    message: 'Phone number is required'\n  }, {\n    type: 'format',\n    message: 'Please enter a valid phone number',\n    params: {\n      pattern: /^[\\+]?[1-9][\\d]{0,15}$/\n    }\n  }],\n  date: [{\n    type: 'required',\n    message: 'Date is required'\n  }, {\n    type: 'format',\n    message: 'Please enter a valid date',\n    params: {\n      pattern: /^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$|^\\d{4}-\\d{2}-\\d{2}$/\n    }\n  }, {\n    type: 'custom',\n    message: 'Date cannot be in the future',\n    validator: value => {\n      if (!value) return true;\n      const date = new Date(String(value));\n      return !isNaN(date.getTime()) && date <= new Date();\n    }\n  }],\n  number: [{\n    type: 'format',\n    message: 'Please enter a valid number',\n    params: {\n      pattern: /^-?\\d+(\\.\\d+)?$/\n    }\n  }],\n  checkbox: [{\n    type: 'custom',\n    message: 'This checkbox must be checked',\n    validator: value => {\n      return value === true || value === 'true' || value === 'on';\n    }\n  }],\n  radio: [{\n    type: 'required',\n    message: 'Please select an option'\n  }],\n  dropdown: [{\n    type: 'required',\n    message: 'Please select an option'\n  }],\n  signature: [{\n    type: 'required',\n    message: 'Signature is required'\n  }, {\n    type: 'custom',\n    message: 'Please provide a valid signature',\n    validator: value => {\n      return Boolean(value && typeof value === 'string' && value.startsWith('data:image/') && value.length > 100);\n    }\n  }]\n};","map":{"version":3,"names":["Sentry","ValidationService","validateField","field","value","allFields","options","startTime","performance","now","enhancedValidation","isFeatureEnabled","performanceMonitoring","securityAuditLogging","validateRequired","validateFormat","validateDependencies","excludeReadOnly","performanceMode","console","log","name","type","toString","length","cacheKey","JSON","stringify","validationCache","has","cached","get","Date","validatedAt","errors","warnings","readOnly","result","isValid","fieldName","fieldType","getFieldValidationType","rules","FIELD_VALIDATION_RULES","rule","ruleValid","applyValidationRule","required","push","message","dependencyErrors","validateFieldDependencies","customErrors","validateCustomBusinessRules","set","duration","performanceTarget","warn","toFixed","addBreadcrumb","data","target","level","error","captureException","tags","component","validateFields","fields","values","results","validationPromises","map","Promise","all","validateRequiredFieldsCompletion","requiredFields","filter","missingFields","completedCount","hasValue","hasValidValue","completionPercentage","Math","round","isComplete","_rule$params","pattern","params","RegExp","test","String","str","min","max","undefined","validator","then","startsWith","trim","toLowerCase","includes","maritalField","find","f","maritalValue","age","parseInt","isNaN","endDateField","startDate","oneYearFromNow","setFullYear","getFullYear","clearValidationCache","clear","getValidationCacheStats","size","entries","Array","from","keys","validateFormSubmission","validationResults","requiredCompletion","validFields","invalidFields","Object","forEach","canSubmit","summary","totalFields","completedRequiredFields","Map","text","email","phone","date","getTime","number","checkbox","radio","dropdown","signature","Boolean"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/src/services/validationService.ts"],"sourcesContent":["import * as Sentry from '@sentry/react';\nimport type { FormField } from '../types/pdf';\n\nexport interface ValidationRule {\n  type: 'required' | 'format' | 'length' | 'custom' | 'dependency';\n  message: string;\n  params?: any;\n  validator?: (value: any, field: FormField, allFields: FormField[]) => boolean;\n}\n\nexport interface ValidationResult {\n  isValid: boolean;\n  errors: string[];\n  warnings: string[];\n  fieldName: string;\n  validatedAt: number;\n}\n\nexport interface ValidationOptions {\n  validateRequired?: boolean;\n  validateFormat?: boolean;\n  validateDependencies?: boolean;\n  excludeReadOnly?: boolean;\n  performanceMode?: boolean; // Skip expensive validations\n}\n\nexport class ValidationService {\n  private static validationCache = new Map<string, ValidationResult>();\n  private static performanceTarget = 10; // milliseconds per field\n\n  /**\n   * Validation rules for different field types\n   */\n  private static readonly FIELD_VALIDATION_RULES: Record<string, ValidationRule[]> = {\n    text: [\n      {\n        type: 'required',\n        message: 'This field is required',\n      },\n      {\n        type: 'length',\n        message: 'Text is too long',\n        params: { max: 1000 }\n      }\n    ],\n    \n    email: [\n      {\n        type: 'required',\n        message: 'Email address is required',\n      },\n      {\n        type: 'format',\n        message: 'Please enter a valid email address',\n        params: { \n          pattern: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/\n        }\n      }\n    ],\n    \n    phone: [\n      {\n        type: 'required',\n        message: 'Phone number is required',\n      },\n      {\n        type: 'format',\n        message: 'Please enter a valid phone number',\n        params: { \n          pattern: /^[\\+]?[1-9][\\d]{0,15}$/\n        }\n      }\n    ],\n    \n    date: [\n      {\n        type: 'required',\n        message: 'Date is required',\n      },\n      {\n        type: 'format',\n        message: 'Please enter a valid date',\n        params: { \n          pattern: /^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$|^\\d{4}-\\d{2}-\\d{2}$/\n        }\n      },\n      {\n        type: 'custom',\n        message: 'Date cannot be in the future',\n        validator: (value: any) => {\n          if (!value) return true;\n          const date = new Date(String(value));\n          return !isNaN(date.getTime()) && date <= new Date();\n        }\n      }\n    ],\n    \n    number: [\n      {\n        type: 'format',\n        message: 'Please enter a valid number',\n        params: { \n          pattern: /^-?\\d+(\\.\\d+)?$/\n        }\n      }\n    ],\n    \n    checkbox: [\n      {\n        type: 'custom',\n        message: 'This checkbox must be checked',\n        validator: (value: any) => {\n          return value === true || value === 'true' || value === 'on';\n        }\n      }\n    ],\n    \n    radio: [\n      {\n        type: 'required',\n        message: 'Please select an option',\n      }\n    ],\n    \n    dropdown: [\n      {\n        type: 'required',\n        message: 'Please select an option',\n      }\n    ],\n    \n    signature: [\n      {\n        type: 'required',\n        message: 'Signature is required',\n      },\n      {\n        type: 'custom',\n        message: 'Please provide a valid signature',\n        validator: (value: any) => {\n          return Boolean(value && typeof value === 'string' && value.startsWith('data:image/') && value.length > 100);\n        }\n      }\n    ]\n  };\n\n  /**\n   * Validate a single form field\n   */\n  static async validateField(\n    field: FormField,\n    value: any,\n    allFields: FormField[] = [],\n    options: ValidationOptions = {}\n  ): Promise<ValidationResult> {\n    const startTime = performance.now();\n    \n    // Check feature flags\n    const enhancedValidation = isFeatureEnabled('ENHANCED_FIELD_VALIDATION');\n    const performanceMonitoring = isFeatureEnabled('PERFORMANCE_MONITORING');\n    const securityAuditLogging = isFeatureEnabled('SECURITY_AUDIT_LOGGING');\n    \n    try {\n      // Use enhanced validation options if feature is enabled\n      const {\n        validateRequired = enhancedValidation ? true : true,\n        validateFormat = enhancedValidation ? true : false,\n        validateDependencies = enhancedValidation ? true : false,\n        excludeReadOnly = true,\n        performanceMode = performanceMonitoring ? false : true\n      } = options;\n      \n      // Security audit logging\n      if (securityAuditLogging) {\n        console.log(`Validating field: ${field.name}, type: ${field.type}, value length: ${value?.toString().length || 0}`);\n      }\n\n      // Create cache key\n      const cacheKey = `${field.name}_${JSON.stringify(value)}_${field.type}`;\n      \n      // Check cache in performance mode\n      if (performanceMode && this.validationCache.has(cacheKey)) {\n        const cached = this.validationCache.get(cacheKey)!;\n        // Use cached result if less than 1 minute old\n        if (Date.now() - cached.validatedAt < 60000) {\n          return cached;\n        }\n      }\n\n      const errors: string[] = [];\n      const warnings: string[] = [];\n\n      // Skip validation for read-only fields if requested\n      if (excludeReadOnly && field.readOnly) {\n        const result: ValidationResult = {\n          isValid: true,\n          errors: [],\n          warnings: [],\n          fieldName: field.name,\n          validatedAt: Date.now()\n        };\n        return result;\n      }\n\n      // Get validation rules for field type\n      const fieldType = this.getFieldValidationType(field);\n      const rules = this.FIELD_VALIDATION_RULES[fieldType] || [];\n\n      // Apply validation rules\n      for (const rule of rules) {\n        // Skip certain validations based on options\n        if (!validateRequired && rule.type === 'required') continue;\n        if (!validateFormat && rule.type === 'format') continue;\n        if (!validateDependencies && rule.type === 'dependency') continue;\n\n        const ruleValid = await this.applyValidationRule(rule, value, field, allFields);\n        if (!ruleValid) {\n          if (rule.type === 'required' && !field.required) {\n            warnings.push(rule.message);\n          } else {\n            errors.push(rule.message);\n          }\n        }\n      }\n\n      // Additional field-specific validations\n      if (validateDependencies) {\n        const dependencyErrors = await this.validateFieldDependencies(field, value, allFields);\n        errors.push(...dependencyErrors);\n      }\n\n      // Custom business logic validations\n      const customErrors = await this.validateCustomBusinessRules(field, value, allFields);\n      errors.push(...customErrors);\n\n      const result: ValidationResult = {\n        isValid: errors.length === 0,\n        errors,\n        warnings,\n        fieldName: field.name,\n        validatedAt: Date.now()\n      };\n\n      // Cache result\n      this.validationCache.set(cacheKey, result);\n\n      // Performance monitoring\n      const duration = performance.now() - startTime;\n      if (duration > this.performanceTarget) {\n        console.warn(`Validation for field \"${field.name}\" took ${duration.toFixed(2)}ms (target: ${this.performanceTarget}ms)`);\n        \n        // Report to Sentry if performance is very poor\n        if (duration > this.performanceTarget * 3) {\n          Sentry.addBreadcrumb({\n            message: 'Slow field validation detected',\n            data: {\n              fieldName: field.name,\n              fieldType: field.type,\n              duration: duration,\n              target: this.performanceTarget\n            },\n            level: 'warning'\n          });\n        }\n      }\n\n      return result;\n\n    } catch (error) {\n      console.error(`Validation error for field \"${field.name}\":`, error);\n      \n      Sentry.captureException(error, {\n        tags: {\n          component: 'ValidationService',\n          fieldName: field.name,\n          fieldType: field.type\n        }\n      });\n\n      return {\n        isValid: false,\n        errors: ['An error occurred while validating this field'],\n        warnings: [],\n        fieldName: field.name,\n        validatedAt: Date.now()\n      };\n    }\n  }\n\n  /**\n   * Validate multiple fields\n   */\n  static async validateFields(\n    fields: FormField[],\n    values: Record<string, any>,\n    options: ValidationOptions = {}\n  ): Promise<Record<string, ValidationResult>> {\n    const results: Record<string, ValidationResult> = {};\n    \n    // Validate fields in parallel for better performance\n    const validationPromises = fields.map(async (field) => {\n      const value = values[field.name];\n      const result = await this.validateField(field, value, fields, options);\n      results[field.name] = result;\n    });\n\n    await Promise.all(validationPromises);\n    return results;\n  }\n\n  /**\n   * Validate all required fields are completed\n   */\n  static validateRequiredFieldsCompletion(\n    fields: FormField[],\n    values: Record<string, any>\n  ): { isComplete: boolean; missingFields: string[]; completionPercentage: number } {\n    const requiredFields = fields.filter(field => \n      field.required && !field.readOnly\n    );\n    \n    const missingFields: string[] = [];\n    let completedCount = 0;\n\n    for (const field of requiredFields) {\n      const value = values[field.name];\n      const hasValue = this.hasValidValue(field, value);\n      \n      if (hasValue) {\n        completedCount++;\n      } else {\n        missingFields.push(field.name);\n      }\n    }\n\n    const completionPercentage = requiredFields.length > 0 \n      ? Math.round((completedCount / requiredFields.length) * 100)\n      : 100;\n\n    return {\n      isComplete: missingFields.length === 0,\n      missingFields,\n      completionPercentage\n    };\n  }\n\n  /**\n   * Apply a single validation rule\n   */\n  private static async applyValidationRule(\n    rule: ValidationRule,\n    value: any,\n    field: FormField,\n    allFields: FormField[]\n  ): Promise<boolean> {\n    switch (rule.type) {\n      case 'required':\n        return this.hasValidValue(field, value);\n\n      case 'format':\n        if (!value) return true; // Format validation only applies to non-empty values\n        const pattern = rule.params?.pattern;\n        if (pattern instanceof RegExp) {\n          return pattern.test(String(value));\n        }\n        return true;\n\n      case 'length':\n        if (!value) return true;\n        const str = String(value);\n        const { min, max } = rule.params || {};\n        \n        if (min !== undefined && str.length < min) return false;\n        if (max !== undefined && str.length > max) return false;\n        return true;\n\n      case 'custom':\n        if (rule.validator) {\n          return rule.validator(value, field, allFields);\n        }\n        return true;\n\n      case 'dependency':\n        return this.validateFieldDependencies(field, value, allFields).then(errors => errors.length === 0);\n\n      default:\n        return true;\n    }\n  }\n\n  /**\n   * Check if field has a valid value\n   */\n  private static hasValidValue(field: FormField, value: any): boolean {\n    if (value === null || value === undefined || value === '') {\n      return false;\n    }\n\n    switch (field.type) {\n      case 'checkbox':\n        return value === true || value === 'true' || value === 'on';\n      \n      case 'signature':\n        return typeof value === 'string' && value.startsWith('data:image/') && value.length > 100;\n      \n      case 'radio':\n      case 'dropdown':\n        return value !== null && value !== undefined && value !== '';\n      \n      default:\n        return String(value).trim().length > 0;\n    }\n  }\n\n  /**\n   * Get validation type based on field properties\n   */\n  private static getFieldValidationType(field: FormField): string {\n    // Check field name patterns for common types\n    const fieldName = field.name.toLowerCase();\n    \n    if (fieldName.includes('email')) return 'email';\n    if (fieldName.includes('phone') || fieldName.includes('tel')) return 'phone';\n    if (fieldName.includes('date')) return 'date';\n    if (fieldName.includes('number') || fieldName.includes('amount')) return 'number';\n    \n    // Use field type\n    return field.type || 'text';\n  }\n\n  /**\n   * Validate field dependencies\n   */\n  private static async validateFieldDependencies(\n    field: FormField,\n    value: any,\n    allFields: FormField[]\n  ): Promise<string[]> {\n    const errors: string[] = [];\n\n    // Example dependency validation logic\n    // This can be extended based on specific business requirements\n    \n    // Check for conditional required fields\n    // Example: If field A is filled, then field B becomes required\n    const fieldName = field.name.toLowerCase();\n    \n    if (fieldName.includes('spouse') && fieldName.includes('name')) {\n      // If marital status is married, spouse name is required\n      const maritalField = allFields.find(f => \n        f.name.toLowerCase().includes('marital') || f.name.toLowerCase().includes('status')\n      );\n      \n      if (maritalField) {\n        const maritalValue = String(value || '').toLowerCase();\n        if ((maritalValue.includes('married') || maritalValue.includes('spouse')) && !value) {\n          errors.push('Spouse name is required when married');\n        }\n      }\n    }\n\n    return errors;\n  }\n\n  /**\n   * Custom business rule validation\n   */\n  private static async validateCustomBusinessRules(\n    field: FormField,\n    value: any,\n    allFields: FormField[]\n  ): Promise<string[]> {\n    const errors: string[] = [];\n\n    try {\n      // Age validation example\n      if (field.name.toLowerCase().includes('age') && value) {\n        const age = parseInt(String(value), 10);\n        if (!isNaN(age)) {\n          if (age < 0 || age > 150) {\n            errors.push('Please enter a valid age');\n          }\n          if (age < 18) {\n            errors.push('Must be 18 or older');\n          }\n        }\n      }\n\n      // Date range validation example\n      if (field.name.toLowerCase().includes('start') && field.name.toLowerCase().includes('date')) {\n        const endDateField = allFields.find(f => \n          f.name.toLowerCase().includes('end') && f.name.toLowerCase().includes('date')\n        );\n        \n        if (endDateField && value) {\n          const startDate = new Date(value);\n          // This would need the end date value from the form state\n          // For now, just validate the start date is not in the far future\n          const oneYearFromNow = new Date();\n          oneYearFromNow.setFullYear(oneYearFromNow.getFullYear() + 1);\n          \n          if (startDate > oneYearFromNow) {\n            errors.push('Start date cannot be more than one year in the future');\n          }\n        }\n      }\n\n    } catch (error) {\n      console.warn(`Error in custom business rule validation for field \"${field.name}\":`, error);\n    }\n\n    return errors;\n  }\n\n  /**\n   * Clear validation cache\n   */\n  static clearValidationCache(): void {\n    this.validationCache.clear();\n  }\n\n  /**\n   * Get validation cache statistics\n   */\n  static getValidationCacheStats(): { size: number; entries: string[] } {\n    return {\n      size: this.validationCache.size,\n      entries: Array.from(this.validationCache.keys())\n    };\n  }\n\n  /**\n   * Validate form submission readiness\n   */\n  static async validateFormSubmission(\n    fields: FormField[],\n    values: Record<string, any>\n  ): Promise<{\n    canSubmit: boolean;\n    errors: Record<string, string[]>;\n    warnings: Record<string, string[]>;\n    summary: {\n      totalFields: number;\n      validFields: number;\n      invalidFields: number;\n      requiredFields: number;\n      completedRequiredFields: number;\n    }\n  }> {\n    const validationResults = await this.validateFields(fields, values, {\n      validateRequired: true,\n      validateFormat: true,\n      validateDependencies: true,\n      excludeReadOnly: true\n    });\n\n    const requiredCompletion = this.validateRequiredFieldsCompletion(fields, values);\n    \n    const errors: Record<string, string[]> = {};\n    const warnings: Record<string, string[]> = {};\n    \n    let validFields = 0;\n    let invalidFields = 0;\n\n    Object.entries(validationResults).forEach(([fieldName, result]) => {\n      if (result.errors.length > 0) {\n        errors[fieldName] = result.errors;\n        invalidFields++;\n      } else {\n        validFields++;\n      }\n      \n      if (result.warnings.length > 0) {\n        warnings[fieldName] = result.warnings;\n      }\n    });\n\n    const requiredFields = fields.filter(f => f.required && !f.readOnly);\n\n    return {\n      canSubmit: requiredCompletion.isComplete && invalidFields === 0,\n      errors,\n      warnings,\n      summary: {\n        totalFields: fields.length,\n        validFields,\n        invalidFields,\n        requiredFields: requiredFields.length,\n        completedRequiredFields: requiredFields.length - requiredCompletion.missingFields.length\n      }\n    };\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}