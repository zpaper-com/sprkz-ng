{"ast":null,"code":"import { createCheckInEnvelope } from './checkin.js';\nimport { Client, _getTraceInfoFromScope } from './client.js';\nimport { getIsolationScope } from './currentScopes.js';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { _INTERNAL_flushLogsBuffer } from './logs/exports.js';\nimport { registerSpanErrorInstrumentation } from './tracing/errors.js';\nimport { isPrimitive } from './utils/is.js';\nimport { debug } from './utils/debug-logger.js';\nimport { uuid4 } from './utils/misc.js';\nimport { eventFromUnknownInput, eventFromMessage } from './utils/eventbuilder.js';\nimport { resolvedSyncPromise } from './utils/syncpromise.js';\n\n// TODO: Make this configurable\nconst DEFAULT_LOG_FLUSH_INTERVAL = 5000;\n\n/**\n * The Sentry Server Runtime Client SDK.\n */\nclass ServerRuntimeClient extends Client {\n  /**\n   * Creates a new Edge SDK instance.\n   * @param options Configuration options for this SDK.\n   */\n  constructor(options) {\n    // Server clients always support tracing\n    registerSpanErrorInstrumentation();\n    super(options);\n    this._logWeight = 0;\n    if (this._options._experiments?.enableLogs) {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const client = this;\n      client.on('flushLogs', () => {\n        client._logWeight = 0;\n        clearTimeout(client._logFlushIdleTimeout);\n      });\n      client.on('afterCaptureLog', log => {\n        client._logWeight += estimateLogSizeInBytes(log);\n\n        // We flush the logs buffer if it exceeds 0.8 MB\n        // The log weight is a rough estimate, so we flush way before\n        // the payload gets too big.\n        if (client._logWeight >= 800000) {\n          _INTERNAL_flushLogsBuffer(client);\n        } else {\n          // start an idle timeout to flush the logs buffer if no logs are captured for a while\n          client._logFlushIdleTimeout = setTimeout(() => {\n            _INTERNAL_flushLogsBuffer(client);\n          }, DEFAULT_LOG_FLUSH_INTERVAL);\n        }\n      });\n      client.on('flush', () => {\n        _INTERNAL_flushLogsBuffer(client);\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  eventFromException(exception, hint) {\n    const event = eventFromUnknownInput(this, this._options.stackParser, exception, hint);\n    event.level = 'error';\n    return resolvedSyncPromise(event);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  eventFromMessage(message) {\n    let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'info';\n    let hint = arguments.length > 2 ? arguments[2] : undefined;\n    return resolvedSyncPromise(eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace));\n  }\n\n  /**\n   * @inheritDoc\n   */\n  captureException(exception, hint, scope) {\n    setCurrentRequestSessionErroredOrCrashed(hint);\n    return super.captureException(exception, hint, scope);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  captureEvent(event, hint, scope) {\n    // If the event is of type Exception, then a request session should be captured\n    const isException = !event.type && event.exception?.values && event.exception.values.length > 0;\n    if (isException) {\n      setCurrentRequestSessionErroredOrCrashed(hint);\n    }\n    return super.captureEvent(event, hint, scope);\n  }\n\n  /**\n   * Create a cron monitor check in and send it to Sentry.\n   *\n   * @param checkIn An object that describes a check in.\n   * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n   * to create a monitor automatically when sending a check in.\n   */\n  captureCheckIn(checkIn, monitorConfig, scope) {\n    const id = 'checkInId' in checkIn && checkIn.checkInId ? checkIn.checkInId : uuid4();\n    if (!this._isEnabled()) {\n      DEBUG_BUILD && debug.warn('SDK not enabled, will not capture check-in.');\n      return id;\n    }\n    const options = this.getOptions();\n    const {\n      release,\n      environment,\n      tunnel\n    } = options;\n    const serializedCheckIn = {\n      check_in_id: id,\n      monitor_slug: checkIn.monitorSlug,\n      status: checkIn.status,\n      release,\n      environment\n    };\n    if ('duration' in checkIn) {\n      serializedCheckIn.duration = checkIn.duration;\n    }\n    if (monitorConfig) {\n      serializedCheckIn.monitor_config = {\n        schedule: monitorConfig.schedule,\n        checkin_margin: monitorConfig.checkinMargin,\n        max_runtime: monitorConfig.maxRuntime,\n        timezone: monitorConfig.timezone,\n        failure_issue_threshold: monitorConfig.failureIssueThreshold,\n        recovery_threshold: monitorConfig.recoveryThreshold\n      };\n    }\n    const [dynamicSamplingContext, traceContext] = _getTraceInfoFromScope(this, scope);\n    if (traceContext) {\n      serializedCheckIn.contexts = {\n        trace: traceContext\n      };\n    }\n    const envelope = createCheckInEnvelope(serializedCheckIn, dynamicSamplingContext, this.getSdkMetadata(), tunnel, this.getDsn());\n    DEBUG_BUILD && debug.log('Sending checkin:', checkIn.monitorSlug, checkIn.status);\n\n    // sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.sendEnvelope(envelope);\n    return id;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  _prepareEvent(event, hint, currentScope, isolationScope) {\n    if (this._options.platform) {\n      event.platform = event.platform || this._options.platform;\n    }\n    if (this._options.runtime) {\n      event.contexts = {\n        ...event.contexts,\n        runtime: event.contexts?.runtime || this._options.runtime\n      };\n    }\n    if (this._options.serverName) {\n      event.server_name = event.server_name || this._options.serverName;\n    }\n    return super._prepareEvent(event, hint, currentScope, isolationScope);\n  }\n}\nfunction setCurrentRequestSessionErroredOrCrashed(eventHint) {\n  const requestSession = getIsolationScope().getScopeData().sdkProcessingMetadata.requestSession;\n  if (requestSession) {\n    // We mutate instead of doing `setSdkProcessingMetadata` because the http integration stores away a particular\n    // isolationScope. If that isolation scope is forked, setting the processing metadata here will not mutate the\n    // original isolation scope that the http integration stored away.\n    const isHandledException = eventHint?.mechanism?.handled ?? true;\n    // A request session can go from \"errored\" -> \"crashed\" but not \"crashed\" -> \"errored\".\n    // Crashed (unhandled exception) is worse than errored (handled exception).\n    if (isHandledException && requestSession.status !== 'crashed') {\n      requestSession.status = 'errored';\n    } else if (!isHandledException) {\n      requestSession.status = 'crashed';\n    }\n  }\n}\n\n/**\n * Estimate the size of a log in bytes.\n *\n * @param log - The log to estimate the size of.\n * @returns The estimated size of the log in bytes.\n */\nfunction estimateLogSizeInBytes(log) {\n  let weight = 0;\n\n  // Estimate byte size of 2 bytes per character. This is a rough estimate JS strings are stored as UTF-16.\n  if (log.message) {\n    weight += log.message.length * 2;\n  }\n  if (log.attributes) {\n    Object.values(log.attributes).forEach(value => {\n      if (Array.isArray(value)) {\n        weight += value.length * estimatePrimitiveSizeInBytes(value[0]);\n      } else if (isPrimitive(value)) {\n        weight += estimatePrimitiveSizeInBytes(value);\n      } else {\n        // For objects values, we estimate the size of the object as 100 bytes\n        weight += 100;\n      }\n    });\n  }\n  return weight;\n}\nfunction estimatePrimitiveSizeInBytes(value) {\n  if (typeof value === 'string') {\n    return value.length * 2;\n  } else if (typeof value === 'number') {\n    return 8;\n  } else if (typeof value === 'boolean') {\n    return 4;\n  }\n  return 0;\n}\nexport { ServerRuntimeClient };\n//# sourceMappingURL=server-runtime-client.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}