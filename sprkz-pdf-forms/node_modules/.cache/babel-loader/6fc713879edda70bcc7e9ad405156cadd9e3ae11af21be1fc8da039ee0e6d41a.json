{"ast":null,"code":"import { spanToJSON, withActiveSpan, startInactiveSpan, getClient, getCurrentScope } from '@sentry/core';\nimport { WINDOW } from '../types.js';\nimport { onHidden } from './web-vitals/lib/onHidden.js';\n\n/**\n * Checks if a given value is a valid measurement value.\n */\nfunction isMeasurementValue(value) {\n  return typeof value === 'number' && isFinite(value);\n}\n\n/**\n * Helper function to start child on transactions. This function will make sure that the transaction will\n * use the start timestamp of the created child span if it is earlier than the transactions actual\n * start timestamp.\n */\nfunction startAndEndSpan(parentSpan, startTimeInSeconds, endTime, {\n  ...ctx\n}) {\n  const parentStartTime = spanToJSON(parentSpan).start_timestamp;\n  if (parentStartTime && parentStartTime > startTimeInSeconds) {\n    // We can only do this for SentrySpans...\n    if (typeof parentSpan.updateStartTime === 'function') {\n      parentSpan.updateStartTime(startTimeInSeconds);\n    }\n  }\n\n  // The return value only exists for tests\n  return withActiveSpan(parentSpan, () => {\n    const span = startInactiveSpan({\n      startTime: startTimeInSeconds,\n      ...ctx\n    });\n    if (span) {\n      span.end(endTime);\n    }\n    return span;\n  });\n}\n\n/**\n * Starts an inactive, standalone span used to send web vital values to Sentry.\n * DO NOT use this for arbitrary spans, as these spans require special handling\n * during ingestion to extract metrics.\n *\n * This function adds a bunch of attributes and data to the span that's shared\n * by all web vital standalone spans. However, you need to take care of adding\n * the actual web vital value as an event to the span. Also, you need to assign\n * a transaction name and some other values that are specific to the web vital.\n *\n * Ultimately, you also need to take care of ending the span to send it off.\n *\n * @param options\n *\n * @returns an inactive, standalone and NOT YET ended span\n */\nfunction startStandaloneWebVitalSpan(options) {\n  const client = getClient();\n  if (!client) {\n    return;\n  }\n  const {\n    name,\n    transaction,\n    attributes: passedAttributes,\n    startTime\n  } = options;\n  const {\n    release,\n    environment,\n    sendDefaultPii\n  } = client.getOptions();\n  // We need to get the replay, user, and activeTransaction from the current scope\n  // so that we can associate replay id, profile id, and a user display to the span\n  const replay = client.getIntegrationByName('Replay');\n  const replayId = replay?.getReplayId();\n  const scope = getCurrentScope();\n  const user = scope.getUser();\n  const userDisplay = user !== undefined ? user.email || user.id || user.ip_address : undefined;\n  let profileId;\n  try {\n    // @ts-expect-error skip optional chaining to save bundle size with try catch\n    profileId = scope.getScopeData().contexts.profile.profile_id;\n  } catch {\n    // do nothing\n  }\n  const attributes = {\n    release,\n    environment,\n    user: userDisplay || undefined,\n    profile_id: profileId || undefined,\n    replay_id: replayId || undefined,\n    transaction,\n    // Web vital score calculation relies on the user agent to account for different\n    // browsers setting different thresholds for what is considered a good/meh/bad value.\n    // For example: Chrome vs. Chrome Mobile\n    'user_agent.original': WINDOW.navigator?.userAgent,\n    // This tells Sentry to infer the IP address from the request\n    'client.address': sendDefaultPii ? '{{auto}}' : undefined,\n    ...passedAttributes\n  };\n  return startInactiveSpan({\n    name,\n    attributes,\n    startTime,\n    experimental: {\n      standalone: true\n    }\n  });\n}\n\n/** Get the browser performance API. */\nfunction getBrowserPerformanceAPI() {\n  // @ts-expect-error we want to make sure all of these are available, even if TS is sure they are\n  return WINDOW.addEventListener && WINDOW.performance;\n}\n\n/**\n * Converts from milliseconds to seconds\n * @param time time in ms\n */\nfunction msToSec(time) {\n  return time / 1000;\n}\n\n/**\n * Converts ALPN protocol ids to name and version.\n *\n * (https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)\n * @param nextHopProtocol PerformanceResourceTiming.nextHopProtocol\n */\nfunction extractNetworkProtocol(nextHopProtocol) {\n  let name = 'unknown';\n  let version = 'unknown';\n  let _name = '';\n  for (const char of nextHopProtocol) {\n    // http/1.1 etc.\n    if (char === '/') {\n      [name, version] = nextHopProtocol.split('/');\n      break;\n    }\n    // h2, h3 etc.\n    if (!isNaN(Number(char))) {\n      name = _name === 'h' ? 'http' : _name;\n      version = nextHopProtocol.split(_name)[1];\n      break;\n    }\n    _name += char;\n  }\n  if (_name === nextHopProtocol) {\n    // webrtc, ftp, etc.\n    name = _name;\n  }\n  return {\n    name,\n    version\n  };\n}\n\n/**\n * Generic support check for web vitals\n */\nfunction supportsWebVital(entryType) {\n  try {\n    return PerformanceObserver.supportedEntryTypes.includes(entryType);\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Listens for events on which we want to collect a previously accumulated web vital value.\n * Currently, this includes:\n *\n * - pagehide (i.e. user minimizes browser window, hides tab, etc)\n * - soft navigation (we only care about the vital of the initially loaded route)\n *\n * As a \"side-effect\", this function will also collect the span id of the pageload span.\n *\n * @param collectorCallback the callback to be called when the first of these events is triggered. Parameters:\n * - event: the event that triggered the reporting of the web vital value.\n * - pageloadSpanId: the span id of the pageload span. This is used to link the web vital span to the pageload span.\n */\nfunction listenForWebVitalReportEvents(client, collectorCallback) {\n  let pageloadSpanId;\n  let collected = false;\n  function _runCollectorCallbackOnce(event) {\n    if (!collected && pageloadSpanId) {\n      collectorCallback(event, pageloadSpanId);\n    }\n    collected = true;\n  }\n  onHidden(() => {\n    _runCollectorCallbackOnce('pagehide');\n  });\n  const unsubscribeStartNavigation = client.on('beforeStartNavigationSpan', (_, options) => {\n    // we only want to collect LCP if we actually navigate. Redirects should be ignored.\n    if (!options?.isRedirect) {\n      _runCollectorCallbackOnce('navigation');\n      unsubscribeStartNavigation?.();\n      unsubscribeAfterStartPageLoadSpan?.();\n    }\n  });\n  const unsubscribeAfterStartPageLoadSpan = client.on('afterStartPageLoadSpan', span => {\n    pageloadSpanId = span.spanContext().spanId;\n    unsubscribeAfterStartPageLoadSpan?.();\n  });\n}\nexport { extractNetworkProtocol, getBrowserPerformanceAPI, isMeasurementValue, listenForWebVitalReportEvents, msToSec, startAndEndSpan, startStandaloneWebVitalSpan, supportsWebVital };","map":{"version":3,"names":["isMeasurementValue","value","isFinite","startAndEndSpan","parentSpan","startTimeInSeconds","endTime","ctx","parentStartTime","spanToJSON","start_timestamp","updateStartTime","withActiveSpan","span","startInactiveSpan","startTime","end","startStandaloneWebVitalSpan","options","client","getClient","name","transaction","attributes","passedAttributes","release","environment","sendDefaultPii","getOptions","replay","getIntegrationByName","replayId","getReplayId","scope","getCurrentScope","user","getUser","userDisplay","undefined","email","id","ip_address","profileId","getScopeData","contexts","profile","profile_id","replay_id","WINDOW","navigator","userAgent","experimental","standalone","getBrowserPerformanceAPI","addEventListener","performance","msToSec","time","extractNetworkProtocol","nextHopProtocol","version","_name","char","split","isNaN","Number","supportsWebVital","entryType","PerformanceObserver","supportedEntryTypes","includes","listenForWebVitalReportEvents","collectorCallback","pageloadSpanId","collected","_runCollectorCallbackOnce","event","onHidden","unsubscribeStartNavigation","on","_","isRedirect","unsubscribeAfterStartPageLoadSpan","spanContext","spanId"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry-internal/browser-utils/src/metrics/utils.ts"],"sourcesContent":["import type {\n  Client,\n  Integration,\n  SentrySpan,\n  Span,\n  SpanAttributes,\n  SpanTimeInput,\n  StartSpanOptions,\n} from '@sentry/core';\nimport { getClient, getCurrentScope, spanToJSON, startInactiveSpan, withActiveSpan } from '@sentry/core';\nimport { WINDOW } from '../types';\nimport { onHidden } from './web-vitals/lib/onHidden';\n\nexport type WebVitalReportEvent = 'pagehide' | 'navigation';\n\n/**\n * Checks if a given value is a valid measurement value.\n */\nexport function isMeasurementValue(value: unknown): value is number {\n  return typeof value === 'number' && isFinite(value);\n}\n\n/**\n * Helper function to start child on transactions. This function will make sure that the transaction will\n * use the start timestamp of the created child span if it is earlier than the transactions actual\n * start timestamp.\n */\nexport function startAndEndSpan(\n  parentSpan: Span,\n  startTimeInSeconds: number,\n  endTime: SpanTimeInput,\n  { ...ctx }: StartSpanOptions,\n): Span | undefined {\n  const parentStartTime = spanToJSON(parentSpan).start_timestamp;\n  if (parentStartTime && parentStartTime > startTimeInSeconds) {\n    // We can only do this for SentrySpans...\n    if (typeof (parentSpan as Partial<SentrySpan>).updateStartTime === 'function') {\n      (parentSpan as SentrySpan).updateStartTime(startTimeInSeconds);\n    }\n  }\n\n  // The return value only exists for tests\n  return withActiveSpan(parentSpan, () => {\n    const span = startInactiveSpan({\n      startTime: startTimeInSeconds,\n      ...ctx,\n    });\n\n    if (span) {\n      span.end(endTime);\n    }\n\n    return span;\n  });\n}\n\ninterface StandaloneWebVitalSpanOptions {\n  name: string;\n  transaction?: string;\n  attributes: SpanAttributes;\n  startTime: number;\n}\n\n/**\n * Starts an inactive, standalone span used to send web vital values to Sentry.\n * DO NOT use this for arbitrary spans, as these spans require special handling\n * during ingestion to extract metrics.\n *\n * This function adds a bunch of attributes and data to the span that's shared\n * by all web vital standalone spans. However, you need to take care of adding\n * the actual web vital value as an event to the span. Also, you need to assign\n * a transaction name and some other values that are specific to the web vital.\n *\n * Ultimately, you also need to take care of ending the span to send it off.\n *\n * @param options\n *\n * @returns an inactive, standalone and NOT YET ended span\n */\nexport function startStandaloneWebVitalSpan(options: StandaloneWebVitalSpanOptions): Span | undefined {\n  const client = getClient();\n  if (!client) {\n    return;\n  }\n\n  const { name, transaction, attributes: passedAttributes, startTime } = options;\n\n  const { release, environment, sendDefaultPii } = client.getOptions();\n  // We need to get the replay, user, and activeTransaction from the current scope\n  // so that we can associate replay id, profile id, and a user display to the span\n  const replay = client.getIntegrationByName<Integration & { getReplayId: () => string }>('Replay');\n  const replayId = replay?.getReplayId();\n\n  const scope = getCurrentScope();\n\n  const user = scope.getUser();\n  const userDisplay = user !== undefined ? user.email || user.id || user.ip_address : undefined;\n\n  let profileId: string | undefined;\n  try {\n    // @ts-expect-error skip optional chaining to save bundle size with try catch\n    profileId = scope.getScopeData().contexts.profile.profile_id;\n  } catch {\n    // do nothing\n  }\n\n  const attributes: SpanAttributes = {\n    release,\n    environment,\n\n    user: userDisplay || undefined,\n    profile_id: profileId || undefined,\n    replay_id: replayId || undefined,\n\n    transaction,\n\n    // Web vital score calculation relies on the user agent to account for different\n    // browsers setting different thresholds for what is considered a good/meh/bad value.\n    // For example: Chrome vs. Chrome Mobile\n    'user_agent.original': WINDOW.navigator?.userAgent,\n\n    // This tells Sentry to infer the IP address from the request\n    'client.address': sendDefaultPii ? '{{auto}}' : undefined,\n\n    ...passedAttributes,\n  };\n\n  return startInactiveSpan({\n    name,\n    attributes,\n    startTime,\n    experimental: {\n      standalone: true,\n    },\n  });\n}\n\n/** Get the browser performance API. */\nexport function getBrowserPerformanceAPI(): Performance | undefined {\n  // @ts-expect-error we want to make sure all of these are available, even if TS is sure they are\n  return WINDOW.addEventListener && WINDOW.performance;\n}\n\n/**\n * Converts from milliseconds to seconds\n * @param time time in ms\n */\nexport function msToSec(time: number): number {\n  return time / 1000;\n}\n\n/**\n * Converts ALPN protocol ids to name and version.\n *\n * (https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)\n * @param nextHopProtocol PerformanceResourceTiming.nextHopProtocol\n */\nexport function extractNetworkProtocol(nextHopProtocol: string): { name: string; version: string } {\n  let name = 'unknown';\n  let version = 'unknown';\n  let _name = '';\n  for (const char of nextHopProtocol) {\n    // http/1.1 etc.\n    if (char === '/') {\n      [name, version] = nextHopProtocol.split('/') as [string, string];\n      break;\n    }\n    // h2, h3 etc.\n    if (!isNaN(Number(char))) {\n      name = _name === 'h' ? 'http' : _name;\n      version = nextHopProtocol.split(_name)[1] as string;\n      break;\n    }\n    _name += char;\n  }\n  if (_name === nextHopProtocol) {\n    // webrtc, ftp, etc.\n    name = _name;\n  }\n  return { name, version };\n}\n\n/**\n * Generic support check for web vitals\n */\nexport function supportsWebVital(entryType: 'layout-shift' | 'largest-contentful-paint'): boolean {\n  try {\n    return PerformanceObserver.supportedEntryTypes.includes(entryType);\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Listens for events on which we want to collect a previously accumulated web vital value.\n * Currently, this includes:\n *\n * - pagehide (i.e. user minimizes browser window, hides tab, etc)\n * - soft navigation (we only care about the vital of the initially loaded route)\n *\n * As a \"side-effect\", this function will also collect the span id of the pageload span.\n *\n * @param collectorCallback the callback to be called when the first of these events is triggered. Parameters:\n * - event: the event that triggered the reporting of the web vital value.\n * - pageloadSpanId: the span id of the pageload span. This is used to link the web vital span to the pageload span.\n */\nexport function listenForWebVitalReportEvents(\n  client: Client,\n  collectorCallback: (event: WebVitalReportEvent, pageloadSpanId: string) => void,\n) {\n  let pageloadSpanId: string | undefined;\n\n  let collected = false;\n  function _runCollectorCallbackOnce(event: WebVitalReportEvent) {\n    if (!collected && pageloadSpanId) {\n      collectorCallback(event, pageloadSpanId);\n    }\n    collected = true;\n  }\n\n  onHidden(() => {\n    _runCollectorCallbackOnce('pagehide');\n  });\n\n  const unsubscribeStartNavigation = client.on('beforeStartNavigationSpan', (_, options) => {\n    // we only want to collect LCP if we actually navigate. Redirects should be ignored.\n    if (!options?.isRedirect) {\n      _runCollectorCallbackOnce('navigation');\n      unsubscribeStartNavigation?.();\n      unsubscribeAfterStartPageLoadSpan?.();\n    }\n  });\n\n  const unsubscribeAfterStartPageLoadSpan = client.on('afterStartPageLoadSpan', span => {\n    pageloadSpanId = span.spanContext().spanId;\n    unsubscribeAfterStartPageLoadSpan?.();\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}