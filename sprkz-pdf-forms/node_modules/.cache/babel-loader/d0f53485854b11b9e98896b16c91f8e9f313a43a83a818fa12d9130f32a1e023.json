{"ast":null,"code":"import { DEBUG_BUILD } from '../debug-build.js';\nimport { defineIntegration } from '../integration.js';\nimport { debug } from '../utils/debug-logger.js';\nimport { getFramesFromEvent } from '../utils/stacktrace.js';\nconst INTEGRATION_NAME = 'Dedupe';\nconst _dedupeIntegration = () => {\n  let previousEvent;\n  return {\n    name: INTEGRATION_NAME,\n    processEvent(currentEvent) {\n      // We want to ignore any non-error type events, e.g. transactions or replays\n      // These should never be deduped, and also not be compared against as _previousEvent.\n      if (currentEvent.type) {\n        return currentEvent;\n      }\n\n      // Juuust in case something goes wrong\n      try {\n        if (_shouldDropEvent(currentEvent, previousEvent)) {\n          DEBUG_BUILD && debug.warn('Event dropped due to being a duplicate of previously captured event.');\n          return null;\n        }\n      } catch {} // eslint-disable-line no-empty\n\n      return previousEvent = currentEvent;\n    }\n  };\n};\n\n/**\n * Deduplication filter.\n */\nconst dedupeIntegration = defineIntegration(_dedupeIntegration);\n\n/** only exported for tests. */\nfunction _shouldDropEvent(currentEvent, previousEvent) {\n  if (!previousEvent) {\n    return false;\n  }\n  if (_isSameMessageEvent(currentEvent, previousEvent)) {\n    return true;\n  }\n  if (_isSameExceptionEvent(currentEvent, previousEvent)) {\n    return true;\n  }\n  return false;\n}\nfunction _isSameMessageEvent(currentEvent, previousEvent) {\n  const currentMessage = currentEvent.message;\n  const previousMessage = previousEvent.message;\n\n  // If neither event has a message property, they were both exceptions, so bail out\n  if (!currentMessage && !previousMessage) {\n    return false;\n  }\n\n  // If only one event has a stacktrace, but not the other one, they are not the same\n  if (currentMessage && !previousMessage || !currentMessage && previousMessage) {\n    return false;\n  }\n  if (currentMessage !== previousMessage) {\n    return false;\n  }\n  if (!_isSameFingerprint(currentEvent, previousEvent)) {\n    return false;\n  }\n  if (!_isSameStacktrace(currentEvent, previousEvent)) {\n    return false;\n  }\n  return true;\n}\nfunction _isSameExceptionEvent(currentEvent, previousEvent) {\n  const previousException = _getExceptionFromEvent(previousEvent);\n  const currentException = _getExceptionFromEvent(currentEvent);\n  if (!previousException || !currentException) {\n    return false;\n  }\n  if (previousException.type !== currentException.type || previousException.value !== currentException.value) {\n    return false;\n  }\n  if (!_isSameFingerprint(currentEvent, previousEvent)) {\n    return false;\n  }\n  if (!_isSameStacktrace(currentEvent, previousEvent)) {\n    return false;\n  }\n  return true;\n}\nfunction _isSameStacktrace(currentEvent, previousEvent) {\n  let currentFrames = getFramesFromEvent(currentEvent);\n  let previousFrames = getFramesFromEvent(previousEvent);\n\n  // If neither event has a stacktrace, they are assumed to be the same\n  if (!currentFrames && !previousFrames) {\n    return true;\n  }\n\n  // If only one event has a stacktrace, but not the other one, they are not the same\n  if (currentFrames && !previousFrames || !currentFrames && previousFrames) {\n    return false;\n  }\n  currentFrames = currentFrames;\n  previousFrames = previousFrames;\n\n  // If number of frames differ, they are not the same\n  if (previousFrames.length !== currentFrames.length) {\n    return false;\n  }\n\n  // Otherwise, compare the two\n  for (let i = 0; i < previousFrames.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const frameA = previousFrames[i];\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const frameB = currentFrames[i];\n    if (frameA.filename !== frameB.filename || frameA.lineno !== frameB.lineno || frameA.colno !== frameB.colno || frameA.function !== frameB.function) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction _isSameFingerprint(currentEvent, previousEvent) {\n  let currentFingerprint = currentEvent.fingerprint;\n  let previousFingerprint = previousEvent.fingerprint;\n\n  // If neither event has a fingerprint, they are assumed to be the same\n  if (!currentFingerprint && !previousFingerprint) {\n    return true;\n  }\n\n  // If only one event has a fingerprint, but not the other one, they are not the same\n  if (currentFingerprint && !previousFingerprint || !currentFingerprint && previousFingerprint) {\n    return false;\n  }\n  currentFingerprint = currentFingerprint;\n  previousFingerprint = previousFingerprint;\n\n  // Otherwise, compare the two\n  try {\n    return !!(currentFingerprint.join('') === previousFingerprint.join(''));\n  } catch {\n    return false;\n  }\n}\nfunction _getExceptionFromEvent(event) {\n  return event.exception?.values?.[0];\n}\nexport { _shouldDropEvent, dedupeIntegration };\n//# sourceMappingURL=dedupe.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}