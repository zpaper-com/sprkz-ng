{"ast":null,"code":"import { DEBUG_BUILD } from '../debug-build.js';\nimport { debug } from '../utils/debug-logger.js';\nimport { hasSpansEnabled } from '../utils/hasSpansEnabled.js';\nimport { parseSampleRate } from '../utils/parseSampleRate.js';\n\n/**\n * Makes a sampling decision for the given options.\n *\n * Called every time a root span is created. Only root spans which emerge with a `sampled` value of `true` will be\n * sent to Sentry.\n */\nfunction sampleSpan(options, samplingContext, sampleRand) {\n  // nothing to do if span recording is not enabled\n  if (!hasSpansEnabled(options)) {\n    return [false];\n  }\n  let localSampleRateWasApplied = undefined;\n\n  // we would have bailed already if neither `tracesSampler` nor `tracesSampleRate` were defined, so one of these should\n  // work; prefer the hook if so\n  let sampleRate;\n  if (typeof options.tracesSampler === 'function') {\n    sampleRate = options.tracesSampler({\n      ...samplingContext,\n      inheritOrSampleWith: fallbackSampleRate => {\n        // If we have an incoming parent sample rate, we'll just use that one.\n        // The sampling decision will be inherited because of the sample_rand that was generated when the trace reached the incoming boundaries of the SDK.\n        if (typeof samplingContext.parentSampleRate === 'number') {\n          return samplingContext.parentSampleRate;\n        }\n\n        // Fallback if parent sample rate is not on the incoming trace (e.g. if there is no baggage)\n        // This is to provide backwards compatibility if there are incoming traces from older SDKs that don't send a parent sample rate or a sample rand. In these cases we just want to force either a sampling decision on the downstream traces via the sample rate.\n        if (typeof samplingContext.parentSampled === 'boolean') {\n          return Number(samplingContext.parentSampled);\n        }\n        return fallbackSampleRate;\n      }\n    });\n    localSampleRateWasApplied = true;\n  } else if (samplingContext.parentSampled !== undefined) {\n    sampleRate = samplingContext.parentSampled;\n  } else if (typeof options.tracesSampleRate !== 'undefined') {\n    sampleRate = options.tracesSampleRate;\n    localSampleRateWasApplied = true;\n  }\n\n  // Since this is coming from the user (or from a function provided by the user), who knows what we might get.\n  // (The only valid values are booleans or numbers between 0 and 1.)\n  const parsedSampleRate = parseSampleRate(sampleRate);\n  if (parsedSampleRate === undefined) {\n    DEBUG_BUILD && debug.warn(`[Tracing] Discarding root span because of invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(sampleRate)} of type ${JSON.stringify(typeof sampleRate)}.`);\n    return [false];\n  }\n\n  // if the function returned 0 (or false), or if `tracesSampleRate` is 0, it's a sign the transaction should be dropped\n  if (!parsedSampleRate) {\n    DEBUG_BUILD && debug.log(`[Tracing] Discarding transaction because ${typeof options.tracesSampler === 'function' ? 'tracesSampler returned 0 or false' : 'a negative sampling decision was inherited or tracesSampleRate is set to 0'}`);\n    return [false, parsedSampleRate, localSampleRateWasApplied];\n  }\n\n  // We always compare the sample rand for the current execution context against the chosen sample rate.\n  // Read more: https://develop.sentry.dev/sdk/telemetry/traces/#propagated-random-value\n  const shouldSample = sampleRand < parsedSampleRate;\n\n  // if we're not going to keep it, we're done\n  if (!shouldSample) {\n    DEBUG_BUILD && debug.log(`[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(sampleRate)})`);\n  }\n  return [shouldSample, parsedSampleRate, localSampleRateWasApplied];\n}\nexport { sampleSpan };","map":{"version":3,"names":["sampleSpan","options","samplingContext","sampleRand","hasSpansEnabled","localSampleRateWasApplied","undefined","sampleRate","tracesSampler","inheritOrSampleWith","fallbackSampleRate","parentSampleRate","parentSampled","Number","tracesSampleRate","parsedSampleRate","parseSampleRate","DEBUG_BUILD","debug","warn","JSON","stringify","log","shouldSample"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/tracing/sampling.ts"],"sourcesContent":["import { DEBUG_BUILD } from '../debug-build';\nimport type { Options } from '../types-hoist/options';\nimport type { SamplingContext } from '../types-hoist/samplingcontext';\nimport { debug } from '../utils/debug-logger';\nimport { hasSpansEnabled } from '../utils/hasSpansEnabled';\nimport { parseSampleRate } from '../utils/parseSampleRate';\n\n/**\n * Makes a sampling decision for the given options.\n *\n * Called every time a root span is created. Only root spans which emerge with a `sampled` value of `true` will be\n * sent to Sentry.\n */\nexport function sampleSpan(\n  options: Pick<Options, 'tracesSampleRate' | 'tracesSampler'>,\n  samplingContext: SamplingContext,\n  sampleRand: number,\n): [sampled: boolean, sampleRate?: number, localSampleRateWasApplied?: boolean] {\n  // nothing to do if span recording is not enabled\n  if (!hasSpansEnabled(options)) {\n    return [false];\n  }\n\n  let localSampleRateWasApplied = undefined;\n\n  // we would have bailed already if neither `tracesSampler` nor `tracesSampleRate` were defined, so one of these should\n  // work; prefer the hook if so\n  let sampleRate;\n  if (typeof options.tracesSampler === 'function') {\n    sampleRate = options.tracesSampler({\n      ...samplingContext,\n      inheritOrSampleWith: fallbackSampleRate => {\n        // If we have an incoming parent sample rate, we'll just use that one.\n        // The sampling decision will be inherited because of the sample_rand that was generated when the trace reached the incoming boundaries of the SDK.\n        if (typeof samplingContext.parentSampleRate === 'number') {\n          return samplingContext.parentSampleRate;\n        }\n\n        // Fallback if parent sample rate is not on the incoming trace (e.g. if there is no baggage)\n        // This is to provide backwards compatibility if there are incoming traces from older SDKs that don't send a parent sample rate or a sample rand. In these cases we just want to force either a sampling decision on the downstream traces via the sample rate.\n        if (typeof samplingContext.parentSampled === 'boolean') {\n          return Number(samplingContext.parentSampled);\n        }\n\n        return fallbackSampleRate;\n      },\n    });\n    localSampleRateWasApplied = true;\n  } else if (samplingContext.parentSampled !== undefined) {\n    sampleRate = samplingContext.parentSampled;\n  } else if (typeof options.tracesSampleRate !== 'undefined') {\n    sampleRate = options.tracesSampleRate;\n    localSampleRateWasApplied = true;\n  }\n\n  // Since this is coming from the user (or from a function provided by the user), who knows what we might get.\n  // (The only valid values are booleans or numbers between 0 and 1.)\n  const parsedSampleRate = parseSampleRate(sampleRate);\n\n  if (parsedSampleRate === undefined) {\n    DEBUG_BUILD &&\n      debug.warn(\n        `[Tracing] Discarding root span because of invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(\n          sampleRate,\n        )} of type ${JSON.stringify(typeof sampleRate)}.`,\n      );\n    return [false];\n  }\n\n  // if the function returned 0 (or false), or if `tracesSampleRate` is 0, it's a sign the transaction should be dropped\n  if (!parsedSampleRate) {\n    DEBUG_BUILD &&\n      debug.log(\n        `[Tracing] Discarding transaction because ${\n          typeof options.tracesSampler === 'function'\n            ? 'tracesSampler returned 0 or false'\n            : 'a negative sampling decision was inherited or tracesSampleRate is set to 0'\n        }`,\n      );\n    return [false, parsedSampleRate, localSampleRateWasApplied];\n  }\n\n  // We always compare the sample rand for the current execution context against the chosen sample rate.\n  // Read more: https://develop.sentry.dev/sdk/telemetry/traces/#propagated-random-value\n  const shouldSample = sampleRand < parsedSampleRate;\n\n  // if we're not going to keep it, we're done\n  if (!shouldSample) {\n    DEBUG_BUILD &&\n      debug.log(\n        `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(\n          sampleRate,\n        )})`,\n      );\n  }\n\n  return [shouldSample, parsedSampleRate, localSampleRateWasApplied];\n}\n"],"mappings":";;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,UAAUA,CACxBC,OAAO,EACPC,eAAe,EACfC,UAAU,EACoE;EAChF;EACE,IAAI,CAACC,eAAe,CAACH,OAAO,CAAC,EAAE;IAC7B,OAAO,CAAC,KAAK,CAAC;EAClB;EAEE,IAAII,yBAAA,GAA4BC,SAAS;;EAE3C;EACA;EACE,IAAIC,UAAU;EACd,IAAI,OAAON,OAAO,CAACO,aAAA,KAAkB,UAAU,EAAE;IAC/CD,UAAA,GAAaN,OAAO,CAACO,aAAa,CAAC;MACjC,GAAGN,eAAe;MAClBO,mBAAmB,EAAEC,kBAAA,IAAsB;QACjD;QACA;QACQ,IAAI,OAAOR,eAAe,CAACS,gBAAA,KAAqB,QAAQ,EAAE;UACxD,OAAOT,eAAe,CAACS,gBAAgB;QACjD;;QAEA;QACA;QACQ,IAAI,OAAOT,eAAe,CAACU,aAAA,KAAkB,SAAS,EAAE;UACtD,OAAOC,MAAM,CAACX,eAAe,CAACU,aAAa,CAAC;QACtD;QAEQ,OAAOF,kBAAkB;MACjC;IACA,CAAK,CAAC;IACFL,yBAAA,GAA4B,IAAI;EACpC,CAAE,MAAO,IAAIH,eAAe,CAACU,aAAA,KAAkBN,SAAS,EAAE;IACtDC,UAAA,GAAaL,eAAe,CAACU,aAAa;EAC9C,CAAE,MAAO,IAAI,OAAOX,OAAO,CAACa,gBAAA,KAAqB,WAAW,EAAE;IAC1DP,UAAA,GAAaN,OAAO,CAACa,gBAAgB;IACrCT,yBAAA,GAA4B,IAAI;EACpC;;EAEA;EACA;EACE,MAAMU,gBAAA,GAAmBC,eAAe,CAACT,UAAU,CAAC;EAEpD,IAAIQ,gBAAA,KAAqBT,SAAS,EAAE;IAClCW,WAAA,IACEC,KAAK,CAACC,IAAI,CACR,iIAAiIC,IAAI,CAACC,SAAS,CAC7Id,UACV,CAAS,YAAYa,IAAI,CAACC,SAAS,CAAC,OAAOd,UAAU,CAAC,GACtD,CAAO;IACH,OAAO,CAAC,KAAK,CAAC;EAClB;;EAEA;EACE,IAAI,CAACQ,gBAAgB,EAAE;IACrBE,WAAA,IACEC,KAAK,CAACI,GAAG,CACP,4CACE,OAAOrB,OAAO,CAACO,aAAA,KAAkB,aAC7B,sCACA,8EAEL;IACA,eAAAO,gBAAA,EAAAV,yBAAA;EACA;;EAEA;EACA;EACA,MAAAkB,YAAA,GAAApB,UAAA,GAAAY,gBAAA;;EAEA;EACA,KAAAQ,YAAA;IACAN,WAAA,IACAC,KAAA,CAAAI,GAAA,CACA,oGAAAT,MAAA,CACAN,UACA,IACA;EACA;EAEA,QAAAgB,YAAA,EAAAR,gBAAA,EAAAV,yBAAA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}