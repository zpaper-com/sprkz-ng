{"ast":null,"code":"import { GLOBAL_OBJ } from './worldwide.js';\nconst ONE_SECOND_IN_MS = 1000;\n\n/**\n * A partial definition of the [Performance Web API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance}\n * for accessing a high-resolution monotonic clock.\n */\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using the Date API.\n */\nfunction dateTimestampInSeconds() {\n  return Date.now() / ONE_SECOND_IN_MS;\n}\n\n/**\n * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not\n * support the API.\n *\n * Wrapping the native API works around differences in behavior from different browsers.\n */\nfunction createUnixTimestampInSecondsFunc() {\n  const {\n    performance\n  } = GLOBAL_OBJ;\n  // Some browser and environments don't have a performance or timeOrigin, so we fallback to\n  // using Date.now() to compute the starting time.\n  if (!performance?.now || !performance.timeOrigin) {\n    return dateTimestampInSeconds;\n  }\n  const timeOrigin = performance.timeOrigin;\n\n  // performance.now() is a monotonic clock, which means it starts at 0 when the process begins. To get the current\n  // wall clock time (actual UNIX timestamp), we need to add the starting time origin and the current time elapsed.\n  //\n  // TODO: This does not account for the case where the monotonic clock that powers performance.now() drifts from the\n  // wall clock time, which causes the returned timestamp to be inaccurate. We should investigate how to detect and\n  // correct for this.\n  // See: https://github.com/getsentry/sentry-javascript/issues/2590\n  // See: https://github.com/mdn/content/issues/4713\n  // See: https://dev.to/noamr/when-a-millisecond-is-not-a-millisecond-3h6\n  return () => {\n    return (timeOrigin + performance.now()) / ONE_SECOND_IN_MS;\n  };\n}\nlet _cachedTimestampInSeconds;\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the\n * availability of the Performance API.\n *\n * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is\n * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The\n * skew can grow to arbitrary amounts like days, weeks or months.\n * See https://github.com/getsentry/sentry-javascript/issues/2590.\n */\nfunction timestampInSeconds() {\n  // We store this in a closure so that we don't have to create a new function every time this is called.\n  const func = _cachedTimestampInSeconds ?? (_cachedTimestampInSeconds = createUnixTimestampInSecondsFunc());\n  return func();\n}\n\n/**\n * Cached result of getBrowserTimeOrigin.\n */\nlet cachedTimeOrigin;\n\n/**\n * Gets the time origin and the mode used to determine it.\n */\nfunction getBrowserTimeOrigin() {\n  // Unfortunately browsers may report an inaccurate time origin data, through either performance.timeOrigin or\n  // performance.timing.navigationStart, which results in poor results in performance data. We only treat time origin\n  // data as reliable if they are within a reasonable threshold of the current time.\n\n  const {\n    performance\n  } = GLOBAL_OBJ;\n  if (!performance?.now) {\n    return [undefined, 'none'];\n  }\n  const threshold = 3600 * 1000;\n  const performanceNow = performance.now();\n  const dateNow = Date.now();\n\n  // if timeOrigin isn't available set delta to threshold so it isn't used\n  const timeOriginDelta = performance.timeOrigin ? Math.abs(performance.timeOrigin + performanceNow - dateNow) : threshold;\n  const timeOriginIsReliable = timeOriginDelta < threshold;\n\n  // While performance.timing.navigationStart is deprecated in favor of performance.timeOrigin, performance.timeOrigin\n  // is not as widely supported. Namely, performance.timeOrigin is undefined in Safari as of writing.\n  // Also as of writing, performance.timing is not available in Web Workers in mainstream browsers, so it is not always\n  // a valid fallback. In the absence of an initial time provided by the browser, fallback to the current time from the\n  // Date API.\n  // eslint-disable-next-line deprecation/deprecation\n  const navigationStart = performance.timing?.navigationStart;\n  const hasNavigationStart = typeof navigationStart === 'number';\n  // if navigationStart isn't available set delta to threshold so it isn't used\n  const navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;\n  const navigationStartIsReliable = navigationStartDelta < threshold;\n  if (timeOriginIsReliable || navigationStartIsReliable) {\n    // Use the more reliable time origin\n    if (timeOriginDelta <= navigationStartDelta) {\n      return [performance.timeOrigin, 'timeOrigin'];\n    } else {\n      return [navigationStart, 'navigationStart'];\n    }\n  }\n\n  // Either both timeOrigin and navigationStart are skewed or neither is available, fallback to Date.\n  return [dateNow, 'dateNow'];\n}\n\n/**\n * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the\n * performance API is available.\n */\nfunction browserPerformanceTimeOrigin() {\n  if (!cachedTimeOrigin) {\n    cachedTimeOrigin = getBrowserTimeOrigin();\n  }\n  return cachedTimeOrigin[0];\n}\nexport { browserPerformanceTimeOrigin, dateTimestampInSeconds, timestampInSeconds };","map":{"version":3,"names":["ONE_SECOND_IN_MS","dateTimestampInSeconds","Date","now","createUnixTimestampInSecondsFunc","performance","GLOBAL_OBJ","timeOrigin","_cachedTimestampInSeconds","timestampInSeconds","func","cachedTimeOrigin","getBrowserTimeOrigin","undefined","threshold","performanceNow","dateNow","timeOriginDelta","Math","abs","timeOriginIsReliable","navigationStart","timing","hasNavigationStart","navigationStartDelta","navigationStartIsReliable","browserPerformanceTimeOrigin"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/utils/time.ts"],"sourcesContent":["import { GLOBAL_OBJ } from './worldwide';\n\nconst ONE_SECOND_IN_MS = 1000;\n\n/**\n * A partial definition of the [Performance Web API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance}\n * for accessing a high-resolution monotonic clock.\n */\ninterface Performance {\n  /**\n   * The millisecond timestamp at which measurement began, measured in Unix time.\n   */\n  timeOrigin: number;\n  /**\n   * Returns the current millisecond timestamp, where 0 represents the start of measurement.\n   */\n  now(): number;\n}\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using the Date API.\n */\nexport function dateTimestampInSeconds(): number {\n  return Date.now() / ONE_SECOND_IN_MS;\n}\n\n/**\n * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not\n * support the API.\n *\n * Wrapping the native API works around differences in behavior from different browsers.\n */\nfunction createUnixTimestampInSecondsFunc(): () => number {\n  const { performance } = GLOBAL_OBJ as typeof GLOBAL_OBJ & { performance?: Performance };\n  // Some browser and environments don't have a performance or timeOrigin, so we fallback to\n  // using Date.now() to compute the starting time.\n  if (!performance?.now || !performance.timeOrigin) {\n    return dateTimestampInSeconds;\n  }\n\n  const timeOrigin = performance.timeOrigin;\n\n  // performance.now() is a monotonic clock, which means it starts at 0 when the process begins. To get the current\n  // wall clock time (actual UNIX timestamp), we need to add the starting time origin and the current time elapsed.\n  //\n  // TODO: This does not account for the case where the monotonic clock that powers performance.now() drifts from the\n  // wall clock time, which causes the returned timestamp to be inaccurate. We should investigate how to detect and\n  // correct for this.\n  // See: https://github.com/getsentry/sentry-javascript/issues/2590\n  // See: https://github.com/mdn/content/issues/4713\n  // See: https://dev.to/noamr/when-a-millisecond-is-not-a-millisecond-3h6\n  return () => {\n    return (timeOrigin + performance.now()) / ONE_SECOND_IN_MS;\n  };\n}\n\nlet _cachedTimestampInSeconds: (() => number) | undefined;\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the\n * availability of the Performance API.\n *\n * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is\n * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The\n * skew can grow to arbitrary amounts like days, weeks or months.\n * See https://github.com/getsentry/sentry-javascript/issues/2590.\n */\nexport function timestampInSeconds(): number {\n  // We store this in a closure so that we don't have to create a new function every time this is called.\n  const func = _cachedTimestampInSeconds ?? (_cachedTimestampInSeconds = createUnixTimestampInSecondsFunc());\n  return func();\n}\n\n/**\n * Cached result of getBrowserTimeOrigin.\n */\nlet cachedTimeOrigin: [number | undefined, string] | undefined;\n\n/**\n * Gets the time origin and the mode used to determine it.\n */\nfunction getBrowserTimeOrigin(): [number | undefined, string] {\n  // Unfortunately browsers may report an inaccurate time origin data, through either performance.timeOrigin or\n  // performance.timing.navigationStart, which results in poor results in performance data. We only treat time origin\n  // data as reliable if they are within a reasonable threshold of the current time.\n\n  const { performance } = GLOBAL_OBJ as typeof GLOBAL_OBJ & Window;\n  if (!performance?.now) {\n    return [undefined, 'none'];\n  }\n\n  const threshold = 3600 * 1000;\n  const performanceNow = performance.now();\n  const dateNow = Date.now();\n\n  // if timeOrigin isn't available set delta to threshold so it isn't used\n  const timeOriginDelta = performance.timeOrigin\n    ? Math.abs(performance.timeOrigin + performanceNow - dateNow)\n    : threshold;\n  const timeOriginIsReliable = timeOriginDelta < threshold;\n\n  // While performance.timing.navigationStart is deprecated in favor of performance.timeOrigin, performance.timeOrigin\n  // is not as widely supported. Namely, performance.timeOrigin is undefined in Safari as of writing.\n  // Also as of writing, performance.timing is not available in Web Workers in mainstream browsers, so it is not always\n  // a valid fallback. In the absence of an initial time provided by the browser, fallback to the current time from the\n  // Date API.\n  // eslint-disable-next-line deprecation/deprecation\n  const navigationStart = performance.timing?.navigationStart;\n  const hasNavigationStart = typeof navigationStart === 'number';\n  // if navigationStart isn't available set delta to threshold so it isn't used\n  const navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;\n  const navigationStartIsReliable = navigationStartDelta < threshold;\n\n  if (timeOriginIsReliable || navigationStartIsReliable) {\n    // Use the more reliable time origin\n    if (timeOriginDelta <= navigationStartDelta) {\n      return [performance.timeOrigin, 'timeOrigin'];\n    } else {\n      return [navigationStart, 'navigationStart'];\n    }\n  }\n\n  // Either both timeOrigin and navigationStart are skewed or neither is available, fallback to Date.\n  return [dateNow, 'dateNow'];\n}\n\n/**\n * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the\n * performance API is available.\n */\nexport function browserPerformanceTimeOrigin(): number | undefined {\n  if (!cachedTimeOrigin) {\n    cachedTimeOrigin = getBrowserTimeOrigin();\n  }\n\n  return cachedTimeOrigin[0];\n}\n"],"mappings":";AAEA,MAAMA,gBAAA,GAAmB,IAAI;;AAE7B;AACA;AACA;AACA;;AAYA;AACA;AACA;AACO,SAASC,sBAAsBA,CAAA,EAAW;EAC/C,OAAOC,IAAI,CAACC,GAAG,EAAC,GAAIH,gBAAgB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASI,gCAAgCA,CAAA,EAAiB;EACxD,MAAM;IAAEC;EAAA,CAAY,GAAIC,UAAA;EAC1B;EACA;EACE,IAAI,CAACD,WAAW,EAAEF,GAAA,IAAO,CAACE,WAAW,CAACE,UAAU,EAAE;IAChD,OAAON,sBAAsB;EACjC;EAEE,MAAMM,UAAA,GAAaF,WAAW,CAACE,UAAU;;EAE3C;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACE,OAAO,MAAM;IACX,OAAO,CAACA,UAAA,GAAaF,WAAW,CAACF,GAAG,EAAE,IAAIH,gBAAgB;EAC9D,CAAG;AACH;AAEA,IAAIQ,yBAAyB;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,kBAAkBA,CAAA,EAAW;EAC7C;EACE,MAAMC,IAAA,GAAOF,yBAAA,KAA8BA,yBAAA,GAA4BJ,gCAAgC,EAAE,CAAC;EAC1G,OAAOM,IAAI,EAAE;AACf;;AAEA;AACA;AACA;AACA,IAAIC,gBAAgB;;AAEpB;AACA;AACA;AACA,SAASC,oBAAoBA,CAAA,EAAiC;EAC9D;EACA;EACA;;EAEE,MAAM;IAAEP;EAAA,CAAY,GAAIC,UAAA;EACxB,IAAI,CAACD,WAAW,EAAEF,GAAG,EAAE;IACrB,OAAO,CAACU,SAAS,EAAE,MAAM,CAAC;EAC9B;EAEE,MAAMC,SAAA,GAAY,OAAO,IAAI;EAC7B,MAAMC,cAAA,GAAiBV,WAAW,CAACF,GAAG,EAAE;EACxC,MAAMa,OAAA,GAAUd,IAAI,CAACC,GAAG,EAAE;;EAE5B;EACE,MAAMc,eAAA,GAAkBZ,WAAW,CAACE,UAAA,GAChCW,IAAI,CAACC,GAAG,CAACd,WAAW,CAACE,UAAA,GAAaQ,cAAA,GAAiBC,OAAO,IAC1DF,SAAS;EACb,MAAMM,oBAAA,GAAuBH,eAAA,GAAkBH,SAAS;;EAE1D;EACA;EACA;EACA;EACA;EACA;EACE,MAAMO,eAAA,GAAkBhB,WAAW,CAACiB,MAAM,EAAED,eAAe;EAC3D,MAAME,kBAAA,GAAqB,OAAOF,eAAA,KAAoB,QAAQ;EAChE;EACE,MAAMG,oBAAA,GAAuBD,kBAAA,GAAqBL,IAAI,CAACC,GAAG,CAACE,eAAA,GAAkBN,cAAA,GAAiBC,OAAO,IAAIF,SAAS;EAClH,MAAMW,yBAAA,GAA4BD,oBAAA,GAAuBV,SAAS;EAElE,IAAIM,oBAAA,IAAwBK,yBAAyB,EAAE;IACzD;IACI,IAAIR,eAAA,IAAmBO,oBAAoB,EAAE;MAC3C,OAAO,CAACnB,WAAW,CAACE,UAAU,EAAE,YAAY,CAAC;IACnD,OAAW;MACL,OAAO,CAACc,eAAe,EAAE,iBAAiB,CAAC;IACjD;EACA;;EAEA;EACE,OAAO,CAACL,OAAO,EAAE,SAAS,CAAC;AAC7B;;AAEA;AACA;AACA;AACA;AACO,SAASU,4BAA4BA,CAAA,EAAuB;EACjE,IAAI,CAACf,gBAAgB,EAAE;IACrBA,gBAAA,GAAmBC,oBAAoB,EAAE;EAC7C;EAEE,OAAOD,gBAAgB,CAAC,CAAC,CAAC;AAC5B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}