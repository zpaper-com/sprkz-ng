{"ast":null,"code":"import { DEFAULT_ENVIRONMENT } from '../constants.js';\nimport { getClient } from '../currentScopes.js';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE } from '../semanticAttributes.js';\nimport { baggageHeaderToDynamicSamplingContext, dynamicSamplingContextToSentryBaggageHeader } from '../utils/baggage.js';\nimport { extractOrgIdFromDsnHost } from '../utils/dsn.js';\nimport { hasSpansEnabled } from '../utils/hasSpansEnabled.js';\nimport { addNonEnumerableProperty } from '../utils/object.js';\nimport { getRootSpan, spanToJSON, spanIsSampled } from '../utils/spanUtils.js';\nimport { getCapturedScopesOnSpan } from './utils.js';\n\n/**\n * If you change this value, also update the terser plugin config to\n * avoid minification of the object property!\n */\nconst FROZEN_DSC_FIELD = '_frozenDsc';\n\n/**\n * Freeze the given DSC on the given span.\n */\nfunction freezeDscOnSpan(span, dsc) {\n  const spanWithMaybeDsc = span;\n  addNonEnumerableProperty(spanWithMaybeDsc, FROZEN_DSC_FIELD, dsc);\n}\n\n/**\n * Creates a dynamic sampling context from a client.\n *\n * Dispatches the `createDsc` lifecycle hook as a side effect.\n */\nfunction getDynamicSamplingContextFromClient(trace_id, client) {\n  const options = client.getOptions();\n  const {\n    publicKey: public_key,\n    host\n  } = client.getDsn() || {};\n  let org_id;\n  if (options.orgId) {\n    org_id = String(options.orgId);\n  } else if (host) {\n    org_id = extractOrgIdFromDsnHost(host);\n  }\n\n  // Instead of conditionally adding non-undefined values, we add them and then remove them if needed\n  // otherwise, the order of baggage entries changes, which \"breaks\" a bunch of tests etc.\n  const dsc = {\n    environment: options.environment || DEFAULT_ENVIRONMENT,\n    release: options.release,\n    public_key,\n    trace_id,\n    org_id\n  };\n  client.emit('createDsc', dsc);\n  return dsc;\n}\n\n/**\n * Get the dynamic sampling context for the currently active scopes.\n */\nfunction getDynamicSamplingContextFromScope(client, scope) {\n  const propagationContext = scope.getPropagationContext();\n  return propagationContext.dsc || getDynamicSamplingContextFromClient(propagationContext.traceId, client);\n}\n\n/**\n * Creates a dynamic sampling context from a span (and client and scope)\n *\n * @param span the span from which a few values like the root span name and sample rate are extracted.\n *\n * @returns a dynamic sampling context\n */\nfunction getDynamicSamplingContextFromSpan(span) {\n  const client = getClient();\n  if (!client) {\n    return {};\n  }\n  const rootSpan = getRootSpan(span);\n  const rootSpanJson = spanToJSON(rootSpan);\n  const rootSpanAttributes = rootSpanJson.data;\n  const traceState = rootSpan.spanContext().traceState;\n\n  // The span sample rate that was locally applied to the root span should also always be applied to the DSC, even if the DSC is frozen.\n  // This is so that the downstream traces/services can use parentSampleRate in their `tracesSampler` to make consistent sampling decisions across the entire trace.\n  const rootSpanSampleRate = traceState?.get('sentry.sample_rate') ?? rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE] ?? rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE];\n  function applyLocalSampleRateToDsc(dsc) {\n    if (typeof rootSpanSampleRate === 'number' || typeof rootSpanSampleRate === 'string') {\n      dsc.sample_rate = `${rootSpanSampleRate}`;\n    }\n    return dsc;\n  }\n\n  // For core implementation, we freeze the DSC onto the span as a non-enumerable property\n  const frozenDsc = rootSpan[FROZEN_DSC_FIELD];\n  if (frozenDsc) {\n    return applyLocalSampleRateToDsc(frozenDsc);\n  }\n\n  // For OpenTelemetry, we freeze the DSC on the trace state\n  const traceStateDsc = traceState?.get('sentry.dsc');\n\n  // If the span has a DSC, we want it to take precedence\n  const dscOnTraceState = traceStateDsc && baggageHeaderToDynamicSamplingContext(traceStateDsc);\n  if (dscOnTraceState) {\n    return applyLocalSampleRateToDsc(dscOnTraceState);\n  }\n\n  // Else, we generate it from the span\n  const dsc = getDynamicSamplingContextFromClient(span.spanContext().traceId, client);\n\n  // We don't want to have a transaction name in the DSC if the source is \"url\" because URLs might contain PII\n  const source = rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n\n  // after JSON conversion, txn.name becomes jsonSpan.description\n  const name = rootSpanJson.description;\n  if (source !== 'url' && name) {\n    dsc.transaction = name;\n  }\n\n  // How can we even land here with hasSpansEnabled() returning false?\n  // Otel creates a Non-recording span in Tracing Without Performance mode when handling incoming requests\n  // So we end up with an active span that is not sampled (neither positively nor negatively)\n  if (hasSpansEnabled()) {\n    dsc.sampled = String(spanIsSampled(rootSpan));\n    dsc.sample_rand =\n    // In OTEL we store the sample rand on the trace state because we cannot access scopes for NonRecordingSpans\n    // The Sentry OTEL SpanSampler takes care of writing the sample rand on the root span\n    traceState?.get('sentry.sample_rand') ??\n    // On all other platforms we can actually get the scopes from a root span (we use this as a fallback)\n    getCapturedScopesOnSpan(rootSpan).scope?.getPropagationContext().sampleRand.toString();\n  }\n  applyLocalSampleRateToDsc(dsc);\n  client.emit('createDsc', dsc, rootSpan);\n  return dsc;\n}\n\n/**\n * Convert a Span to a baggage header.\n */\nfunction spanToBaggageHeader(span) {\n  const dsc = getDynamicSamplingContextFromSpan(span);\n  return dynamicSamplingContextToSentryBaggageHeader(dsc);\n}\nexport { freezeDscOnSpan, getDynamicSamplingContextFromClient, getDynamicSamplingContextFromScope, getDynamicSamplingContextFromSpan, spanToBaggageHeader };","map":{"version":3,"names":["FROZEN_DSC_FIELD","freezeDscOnSpan","span","dsc","spanWithMaybeDsc","addNonEnumerableProperty","getDynamicSamplingContextFromClient","trace_id","client","options","getOptions","publicKey","public_key","host","getDsn","org_id","orgId","String","extractOrgIdFromDsnHost","environment","DEFAULT_ENVIRONMENT","release","emit","getDynamicSamplingContextFromScope","scope","propagationContext","getPropagationContext","traceId","getDynamicSamplingContextFromSpan","getClient","rootSpan","getRootSpan","rootSpanJson","spanToJSON","rootSpanAttributes","data","traceState","spanContext","rootSpanSampleRate","get","SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE","SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE","applyLocalSampleRateToDsc","sample_rate","frozenDsc","traceStateDsc","dscOnTraceState","baggageHeaderToDynamicSamplingContext","source","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","name","description","transaction","hasSpansEnabled","sampled","spanIsSampled","sample_rand","getCapturedScopesOnSpan","sampleRand","toString","spanToBaggageHeader","dynamicSamplingContextToSentryBaggageHeader"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/tracing/dynamicSamplingContext.ts"],"sourcesContent":["import type { Client } from '../client';\nimport { DEFAULT_ENVIRONMENT } from '../constants';\nimport { getClient } from '../currentScopes';\nimport type { Scope } from '../scope';\nimport {\n  SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE,\n  SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n} from '../semanticAttributes';\nimport type { DynamicSamplingContext } from '../types-hoist/envelope';\nimport type { Span } from '../types-hoist/span';\nimport { baggageHeaderToDynamicSamplingContext, dynamicSamplingContextToSentryBaggageHeader } from '../utils/baggage';\nimport { extractOrgIdFromDsnHost } from '../utils/dsn';\nimport { hasSpansEnabled } from '../utils/hasSpansEnabled';\nimport { addNonEnumerableProperty } from '../utils/object';\nimport { getRootSpan, spanIsSampled, spanToJSON } from '../utils/spanUtils';\nimport { getCapturedScopesOnSpan } from './utils';\n\n/**\n * If you change this value, also update the terser plugin config to\n * avoid minification of the object property!\n */\nconst FROZEN_DSC_FIELD = '_frozenDsc';\n\ntype SpanWithMaybeDsc = Span & {\n  [FROZEN_DSC_FIELD]?: Partial<DynamicSamplingContext> | undefined;\n};\n\n/**\n * Freeze the given DSC on the given span.\n */\nexport function freezeDscOnSpan(span: Span, dsc: Partial<DynamicSamplingContext>): void {\n  const spanWithMaybeDsc = span as SpanWithMaybeDsc;\n  addNonEnumerableProperty(spanWithMaybeDsc, FROZEN_DSC_FIELD, dsc);\n}\n\n/**\n * Creates a dynamic sampling context from a client.\n *\n * Dispatches the `createDsc` lifecycle hook as a side effect.\n */\nexport function getDynamicSamplingContextFromClient(trace_id: string, client: Client): DynamicSamplingContext {\n  const options = client.getOptions();\n\n  const { publicKey: public_key, host } = client.getDsn() || {};\n\n  let org_id: string | undefined;\n  if (options.orgId) {\n    org_id = String(options.orgId);\n  } else if (host) {\n    org_id = extractOrgIdFromDsnHost(host);\n  }\n\n  // Instead of conditionally adding non-undefined values, we add them and then remove them if needed\n  // otherwise, the order of baggage entries changes, which \"breaks\" a bunch of tests etc.\n  const dsc: DynamicSamplingContext = {\n    environment: options.environment || DEFAULT_ENVIRONMENT,\n    release: options.release,\n    public_key,\n    trace_id,\n    org_id,\n  };\n\n  client.emit('createDsc', dsc);\n\n  return dsc;\n}\n\n/**\n * Get the dynamic sampling context for the currently active scopes.\n */\nexport function getDynamicSamplingContextFromScope(client: Client, scope: Scope): Partial<DynamicSamplingContext> {\n  const propagationContext = scope.getPropagationContext();\n  return propagationContext.dsc || getDynamicSamplingContextFromClient(propagationContext.traceId, client);\n}\n\n/**\n * Creates a dynamic sampling context from a span (and client and scope)\n *\n * @param span the span from which a few values like the root span name and sample rate are extracted.\n *\n * @returns a dynamic sampling context\n */\nexport function getDynamicSamplingContextFromSpan(span: Span): Readonly<Partial<DynamicSamplingContext>> {\n  const client = getClient();\n  if (!client) {\n    return {};\n  }\n\n  const rootSpan = getRootSpan(span);\n  const rootSpanJson = spanToJSON(rootSpan);\n  const rootSpanAttributes = rootSpanJson.data;\n  const traceState = rootSpan.spanContext().traceState;\n\n  // The span sample rate that was locally applied to the root span should also always be applied to the DSC, even if the DSC is frozen.\n  // This is so that the downstream traces/services can use parentSampleRate in their `tracesSampler` to make consistent sampling decisions across the entire trace.\n  const rootSpanSampleRate =\n    traceState?.get('sentry.sample_rate') ??\n    rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE] ??\n    rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE];\n\n  function applyLocalSampleRateToDsc(dsc: Partial<DynamicSamplingContext>): Partial<DynamicSamplingContext> {\n    if (typeof rootSpanSampleRate === 'number' || typeof rootSpanSampleRate === 'string') {\n      dsc.sample_rate = `${rootSpanSampleRate}`;\n    }\n    return dsc;\n  }\n\n  // For core implementation, we freeze the DSC onto the span as a non-enumerable property\n  const frozenDsc = (rootSpan as SpanWithMaybeDsc)[FROZEN_DSC_FIELD];\n  if (frozenDsc) {\n    return applyLocalSampleRateToDsc(frozenDsc);\n  }\n\n  // For OpenTelemetry, we freeze the DSC on the trace state\n  const traceStateDsc = traceState?.get('sentry.dsc');\n\n  // If the span has a DSC, we want it to take precedence\n  const dscOnTraceState = traceStateDsc && baggageHeaderToDynamicSamplingContext(traceStateDsc);\n\n  if (dscOnTraceState) {\n    return applyLocalSampleRateToDsc(dscOnTraceState);\n  }\n\n  // Else, we generate it from the span\n  const dsc = getDynamicSamplingContextFromClient(span.spanContext().traceId, client);\n\n  // We don't want to have a transaction name in the DSC if the source is \"url\" because URLs might contain PII\n  const source = rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n\n  // after JSON conversion, txn.name becomes jsonSpan.description\n  const name = rootSpanJson.description;\n  if (source !== 'url' && name) {\n    dsc.transaction = name;\n  }\n\n  // How can we even land here with hasSpansEnabled() returning false?\n  // Otel creates a Non-recording span in Tracing Without Performance mode when handling incoming requests\n  // So we end up with an active span that is not sampled (neither positively nor negatively)\n  if (hasSpansEnabled()) {\n    dsc.sampled = String(spanIsSampled(rootSpan));\n    dsc.sample_rand =\n      // In OTEL we store the sample rand on the trace state because we cannot access scopes for NonRecordingSpans\n      // The Sentry OTEL SpanSampler takes care of writing the sample rand on the root span\n      traceState?.get('sentry.sample_rand') ??\n      // On all other platforms we can actually get the scopes from a root span (we use this as a fallback)\n      getCapturedScopesOnSpan(rootSpan).scope?.getPropagationContext().sampleRand.toString();\n  }\n\n  applyLocalSampleRateToDsc(dsc);\n\n  client.emit('createDsc', dsc, rootSpan);\n\n  return dsc;\n}\n\n/**\n * Convert a Span to a baggage header.\n */\nexport function spanToBaggageHeader(span: Span): string | undefined {\n  const dsc = getDynamicSamplingContextFromSpan(span);\n  return dynamicSamplingContextToSentryBaggageHeader(dsc);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}