{"ast":null,"code":"import { DEBUG_BUILD } from './debug-build.js';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_OP } from './semanticAttributes.js';\nimport { debug } from './utils/debug-logger.js';\nimport { getActiveSpan } from './utils/spanUtils.js';\nimport { withActiveSpan, startSpan } from './tracing/trace.js';\nconst wrappedMcpServerInstances = new WeakSet();\n\n/**\n * Wraps a MCP Server instance from the `@modelcontextprotocol/sdk` package with Sentry instrumentation.\n *\n * Compatible with versions `^1.9.0` of the `@modelcontextprotocol/sdk` package.\n */\n// We are exposing this API for non-node runtimes that cannot rely on auto-instrumentation.\nfunction wrapMcpServerWithSentry(mcpServerInstance) {\n  if (wrappedMcpServerInstances.has(mcpServerInstance)) {\n    return mcpServerInstance;\n  }\n  if (!isMcpServerInstance(mcpServerInstance)) {\n    DEBUG_BUILD && debug.warn('Did not patch MCP server. Interface is incompatible.');\n    return mcpServerInstance;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  mcpServerInstance.connect = new Proxy(mcpServerInstance.connect, {\n    apply(target, thisArg, argArray) {\n      const [transport, ...restArgs] = argArray;\n      if (!transport.onclose) {\n        transport.onclose = () => {\n          if (transport.sessionId) {\n            handleTransportOnClose(transport.sessionId);\n          }\n        };\n      }\n      if (!transport.onmessage) {\n        transport.onmessage = jsonRpcMessage => {\n          if (transport.sessionId && isJsonRPCMessageWithRequestId(jsonRpcMessage)) {\n            handleTransportOnMessage(transport.sessionId, jsonRpcMessage.id);\n          }\n        };\n      }\n      const patchedTransport = new Proxy(transport, {\n        set(target, key, value) {\n          if (key === 'onmessage') {\n            target[key] = new Proxy(value, {\n              apply(onMessageTarget, onMessageThisArg, onMessageArgArray) {\n                const [jsonRpcMessage] = onMessageArgArray;\n                if (transport.sessionId && isJsonRPCMessageWithRequestId(jsonRpcMessage)) {\n                  handleTransportOnMessage(transport.sessionId, jsonRpcMessage.id);\n                }\n                return Reflect.apply(onMessageTarget, onMessageThisArg, onMessageArgArray);\n              }\n            });\n          } else if (key === 'onclose') {\n            target[key] = new Proxy(value, {\n              apply(onCloseTarget, onCloseThisArg, onCloseArgArray) {\n                if (transport.sessionId) {\n                  handleTransportOnClose(transport.sessionId);\n                }\n                return Reflect.apply(onCloseTarget, onCloseThisArg, onCloseArgArray);\n              }\n            });\n          } else {\n            target[key] = value;\n          }\n          return true;\n        }\n      });\n      return Reflect.apply(target, thisArg, [patchedTransport, ...restArgs]);\n    }\n  });\n  mcpServerInstance.resource = new Proxy(mcpServerInstance.resource, {\n    apply(target, thisArg, argArray) {\n      const resourceName = argArray[0];\n      const resourceHandler = argArray[argArray.length - 1];\n      if (typeof resourceName !== 'string' || typeof resourceHandler !== 'function') {\n        return target.apply(thisArg, argArray);\n      }\n      const wrappedResourceHandler = new Proxy(resourceHandler, {\n        apply(resourceHandlerTarget, resourceHandlerThisArg, resourceHandlerArgArray) {\n          const extraHandlerDataWithRequestId = resourceHandlerArgArray.find(isExtraHandlerDataWithRequestId);\n          return associateContextWithRequestSpan(extraHandlerDataWithRequestId, () => {\n            return startSpan({\n              name: `mcp-server/resource:${resourceName}`,\n              forceTransaction: true,\n              attributes: {\n                [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'auto.function.mcp-server',\n                [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.mcp-server',\n                [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n                'mcp_server.resource': resourceName\n              }\n            }, () => resourceHandlerTarget.apply(resourceHandlerThisArg, resourceHandlerArgArray));\n          });\n        }\n      });\n      return Reflect.apply(target, thisArg, [...argArray.slice(0, -1), wrappedResourceHandler]);\n    }\n  });\n  mcpServerInstance.tool = new Proxy(mcpServerInstance.tool, {\n    apply(target, thisArg, argArray) {\n      const toolName = argArray[0];\n      const toolHandler = argArray[argArray.length - 1];\n      if (typeof toolName !== 'string' || typeof toolHandler !== 'function') {\n        return target.apply(thisArg, argArray);\n      }\n      const wrappedToolHandler = new Proxy(toolHandler, {\n        apply(toolHandlerTarget, toolHandlerThisArg, toolHandlerArgArray) {\n          const extraHandlerDataWithRequestId = toolHandlerArgArray.find(isExtraHandlerDataWithRequestId);\n          return associateContextWithRequestSpan(extraHandlerDataWithRequestId, () => {\n            return startSpan({\n              name: `mcp-server/tool:${toolName}`,\n              forceTransaction: true,\n              attributes: {\n                [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'auto.function.mcp-server',\n                [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.mcp-server',\n                [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n                'mcp_server.tool': toolName\n              }\n            }, () => toolHandlerTarget.apply(toolHandlerThisArg, toolHandlerArgArray));\n          });\n        }\n      });\n      return Reflect.apply(target, thisArg, [...argArray.slice(0, -1), wrappedToolHandler]);\n    }\n  });\n  mcpServerInstance.prompt = new Proxy(mcpServerInstance.prompt, {\n    apply(target, thisArg, argArray) {\n      const promptName = argArray[0];\n      const promptHandler = argArray[argArray.length - 1];\n      if (typeof promptName !== 'string' || typeof promptHandler !== 'function') {\n        return target.apply(thisArg, argArray);\n      }\n      const wrappedPromptHandler = new Proxy(promptHandler, {\n        apply(promptHandlerTarget, promptHandlerThisArg, promptHandlerArgArray) {\n          const extraHandlerDataWithRequestId = promptHandlerArgArray.find(isExtraHandlerDataWithRequestId);\n          return associateContextWithRequestSpan(extraHandlerDataWithRequestId, () => {\n            return startSpan({\n              name: `mcp-server/prompt:${promptName}`,\n              forceTransaction: true,\n              attributes: {\n                [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'auto.function.mcp-server',\n                [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.mcp-server',\n                [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n                'mcp_server.prompt': promptName\n              }\n            }, () => promptHandlerTarget.apply(promptHandlerThisArg, promptHandlerArgArray));\n          });\n        }\n      });\n      return Reflect.apply(target, thisArg, [...argArray.slice(0, -1), wrappedPromptHandler]);\n    }\n  });\n  wrappedMcpServerInstances.add(mcpServerInstance);\n  return mcpServerInstance;\n}\nfunction isMcpServerInstance(mcpServerInstance) {\n  return typeof mcpServerInstance === 'object' && mcpServerInstance !== null && 'resource' in mcpServerInstance && typeof mcpServerInstance.resource === 'function' && 'tool' in mcpServerInstance && typeof mcpServerInstance.tool === 'function' && 'prompt' in mcpServerInstance && typeof mcpServerInstance.prompt === 'function' && 'connect' in mcpServerInstance && typeof mcpServerInstance.connect === 'function';\n}\nfunction isJsonRPCMessageWithRequestId(target) {\n  return typeof target === 'object' && target !== null && 'id' in target && (typeof target.id === 'number' || typeof target.id === 'string');\n}\n\n// Note that not all versions of the MCP library have `requestId` as a field on the extra data.\nfunction isExtraHandlerDataWithRequestId(target) {\n  return typeof target === 'object' && target !== null && 'sessionId' in target && typeof target.sessionId === 'string' && 'requestId' in target && (typeof target.requestId === 'number' || typeof target.requestId === 'string');\n}\nconst sessionAndRequestToRequestParentSpanMap = new Map();\nfunction handleTransportOnClose(sessionId) {\n  sessionAndRequestToRequestParentSpanMap.delete(sessionId);\n}\nfunction handleTransportOnMessage(sessionId, requestId) {\n  const activeSpan = getActiveSpan();\n  if (activeSpan) {\n    const requestIdToSpanMap = sessionAndRequestToRequestParentSpanMap.get(sessionId) ?? new Map();\n    requestIdToSpanMap.set(requestId, activeSpan);\n    sessionAndRequestToRequestParentSpanMap.set(sessionId, requestIdToSpanMap);\n  }\n}\nfunction associateContextWithRequestSpan(extraHandlerData, cb) {\n  if (extraHandlerData) {\n    const {\n      sessionId,\n      requestId\n    } = extraHandlerData;\n    const requestIdSpanMap = sessionAndRequestToRequestParentSpanMap.get(sessionId);\n    if (!requestIdSpanMap) {\n      return cb();\n    }\n    const span = requestIdSpanMap.get(requestId);\n    if (!span) {\n      return cb();\n    }\n\n    // remove the span from the map so it can be garbage collected\n    requestIdSpanMap.delete(requestId);\n    return withActiveSpan(span, () => {\n      return cb();\n    });\n  }\n  return cb();\n}\nexport { wrapMcpServerWithSentry };\n//# sourceMappingURL=mcp-server.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}