{"ast":null,"code":"import { defineIntegration, supportsNativeFetch, addFetchInstrumentationHandler, getClient, GLOBAL_OBJ, debug, captureEvent, isSentryRequestUrl, addExceptionMechanism } from '@sentry/core';\nimport { addXhrInstrumentationHandler, SENTRY_XHR_DATA_KEY } from '@sentry-internal/browser-utils';\nimport { DEBUG_BUILD } from '../debug-build.js';\nconst INTEGRATION_NAME = 'HttpClient';\nconst _httpClientIntegration = function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const _options = {\n    failedRequestStatusCodes: [[500, 599]],\n    failedRequestTargets: [/.*/],\n    ...options\n  };\n  return {\n    name: INTEGRATION_NAME,\n    setup(client) {\n      _wrapFetch(client, _options);\n      _wrapXHR(client, _options);\n    }\n  };\n};\n\n/**\n * Create events for failed client side HTTP requests.\n */\nconst httpClientIntegration = defineIntegration(_httpClientIntegration);\n\n/**\n * Interceptor function for fetch requests\n *\n * @param requestInfo The Fetch API request info\n * @param response The Fetch API response\n * @param requestInit The request init object\n */\nfunction _fetchResponseHandler(options, requestInfo, response, requestInit, error) {\n  if (_shouldCaptureResponse(options, response.status, response.url)) {\n    const request = _getRequest(requestInfo, requestInit);\n    let requestHeaders, responseHeaders, requestCookies, responseCookies;\n    if (_shouldSendDefaultPii()) {\n      [requestHeaders, requestCookies] = _parseCookieHeaders('Cookie', request);\n      [responseHeaders, responseCookies] = _parseCookieHeaders('Set-Cookie', response);\n    }\n    const event = _createEvent({\n      url: request.url,\n      method: request.method,\n      status: response.status,\n      requestHeaders,\n      responseHeaders,\n      requestCookies,\n      responseCookies,\n      error\n    });\n    captureEvent(event);\n  }\n}\nfunction _parseCookieHeaders(cookieHeader, obj) {\n  const headers = _extractFetchHeaders(obj.headers);\n  let cookies;\n  try {\n    const cookieString = headers[cookieHeader] || headers[cookieHeader.toLowerCase()] || undefined;\n    if (cookieString) {\n      cookies = _parseCookieString(cookieString);\n    }\n  } catch {\n    // ignore it if parsing fails\n  }\n  return [headers, cookies];\n}\n\n/**\n * Interceptor function for XHR requests\n *\n * @param xhr The XHR request\n * @param method The HTTP method\n * @param headers The HTTP headers\n */\nfunction _xhrResponseHandler(options, xhr, method, headers, error) {\n  if (_shouldCaptureResponse(options, xhr.status, xhr.responseURL)) {\n    let requestHeaders, responseCookies, responseHeaders;\n    if (_shouldSendDefaultPii()) {\n      try {\n        const cookieString = xhr.getResponseHeader('Set-Cookie') || xhr.getResponseHeader('set-cookie') || undefined;\n        if (cookieString) {\n          responseCookies = _parseCookieString(cookieString);\n        }\n      } catch {\n        // ignore it if parsing fails\n      }\n      try {\n        responseHeaders = _getXHRResponseHeaders(xhr);\n      } catch {\n        // ignore it if parsing fails\n      }\n      requestHeaders = headers;\n    }\n    const event = _createEvent({\n      url: xhr.responseURL,\n      method,\n      status: xhr.status,\n      requestHeaders,\n      // Can't access request cookies from XHR\n      responseHeaders,\n      responseCookies,\n      error\n    });\n    captureEvent(event);\n  }\n}\n\n/**\n * Extracts response size from `Content-Length` header when possible\n *\n * @param headers\n * @returns The response size in bytes or undefined\n */\nfunction _getResponseSizeFromHeaders(headers) {\n  if (headers) {\n    const contentLength = headers['Content-Length'] || headers['content-length'];\n    if (contentLength) {\n      return parseInt(contentLength, 10);\n    }\n  }\n  return undefined;\n}\n\n/**\n * Creates an object containing cookies from the given cookie string\n *\n * @param cookieString The cookie string to parse\n * @returns The parsed cookies\n */\nfunction _parseCookieString(cookieString) {\n  return cookieString.split('; ').reduce((acc, cookie) => {\n    const [key, value] = cookie.split('=');\n    if (key && value) {\n      acc[key] = value;\n    }\n    return acc;\n  }, {});\n}\n\n/**\n * Extracts the headers as an object from the given Fetch API request or response object\n *\n * @param headers The headers to extract\n * @returns The extracted headers as an object\n */\nfunction _extractFetchHeaders(headers) {\n  const result = {};\n  headers.forEach((value, key) => {\n    result[key] = value;\n  });\n  return result;\n}\n\n/**\n * Extracts the response headers as an object from the given XHR object\n *\n * @param xhr The XHR object to extract the response headers from\n * @returns The response headers as an object\n */\nfunction _getXHRResponseHeaders(xhr) {\n  const headers = xhr.getAllResponseHeaders();\n  if (!headers) {\n    return {};\n  }\n  return headers.split('\\r\\n').reduce((acc, line) => {\n    const [key, value] = line.split(': ');\n    if (key && value) {\n      acc[key] = value;\n    }\n    return acc;\n  }, {});\n}\n\n/**\n * Checks if the given target url is in the given list of targets\n *\n * @param target The target url to check\n * @returns true if the target url is in the given list of targets, false otherwise\n */\nfunction _isInGivenRequestTargets(failedRequestTargets, target) {\n  return failedRequestTargets.some(givenRequestTarget => {\n    if (typeof givenRequestTarget === 'string') {\n      return target.includes(givenRequestTarget);\n    }\n    return givenRequestTarget.test(target);\n  });\n}\n\n/**\n * Checks if the given status code is in the given range\n *\n * @param status The status code to check\n * @returns true if the status code is in the given range, false otherwise\n */\nfunction _isInGivenStatusRanges(failedRequestStatusCodes, status) {\n  return failedRequestStatusCodes.some(range => {\n    if (typeof range === 'number') {\n      return range === status;\n    }\n    return status >= range[0] && status <= range[1];\n  });\n}\n\n/**\n * Wraps `fetch` function to capture request and response data\n */\nfunction _wrapFetch(client, options) {\n  if (!supportsNativeFetch()) {\n    return;\n  }\n  addFetchInstrumentationHandler(handlerData => {\n    if (getClient() !== client) {\n      return;\n    }\n    const {\n      response,\n      args,\n      error,\n      virtualError\n    } = handlerData;\n    const [requestInfo, requestInit] = args;\n    if (!response) {\n      return;\n    }\n    _fetchResponseHandler(options, requestInfo, response, requestInit, error || virtualError);\n  }, false);\n}\n\n/**\n * Wraps XMLHttpRequest to capture request and response data\n */\nfunction _wrapXHR(client, options) {\n  if (!('XMLHttpRequest' in GLOBAL_OBJ)) {\n    return;\n  }\n  addXhrInstrumentationHandler(handlerData => {\n    if (getClient() !== client) {\n      return;\n    }\n    const {\n      error,\n      virtualError\n    } = handlerData;\n    const xhr = handlerData.xhr;\n    const sentryXhrData = xhr[SENTRY_XHR_DATA_KEY];\n    if (!sentryXhrData) {\n      return;\n    }\n    const {\n      method,\n      request_headers: headers\n    } = sentryXhrData;\n    try {\n      _xhrResponseHandler(options, xhr, method, headers, error || virtualError);\n    } catch (e) {\n      DEBUG_BUILD && debug.warn('Error while extracting response event form XHR response', e);\n    }\n  });\n}\n\n/**\n * Checks whether to capture given response as an event\n *\n * @param status response status code\n * @param url response url\n */\nfunction _shouldCaptureResponse(options, status, url) {\n  return _isInGivenStatusRanges(options.failedRequestStatusCodes, status) && _isInGivenRequestTargets(options.failedRequestTargets, url) && !isSentryRequestUrl(url, getClient());\n}\n\n/**\n * Creates a synthetic Sentry event from given response data\n *\n * @param data response data\n * @returns event\n */\nfunction _createEvent(data) {\n  const client = getClient();\n  const virtualStackTrace = client && data.error && data.error instanceof Error ? data.error.stack : undefined;\n  // Remove the first frame from the stack as it's the HttpClient call\n  const stack = virtualStackTrace && client ? client.getOptions().stackParser(virtualStackTrace, 0, 1) : undefined;\n  const message = `HTTP Client Error with status code: ${data.status}`;\n  const event = {\n    message,\n    exception: {\n      values: [{\n        type: 'Error',\n        value: message,\n        stacktrace: stack ? {\n          frames: stack\n        } : undefined\n      }]\n    },\n    request: {\n      url: data.url,\n      method: data.method,\n      headers: data.requestHeaders,\n      cookies: data.requestCookies\n    },\n    contexts: {\n      response: {\n        status_code: data.status,\n        headers: data.responseHeaders,\n        cookies: data.responseCookies,\n        body_size: _getResponseSizeFromHeaders(data.responseHeaders)\n      }\n    }\n  };\n  addExceptionMechanism(event, {\n    type: 'http.client',\n    handled: false\n  });\n  return event;\n}\nfunction _getRequest(requestInfo, requestInit) {\n  if (!requestInit && requestInfo instanceof Request) {\n    return requestInfo;\n  }\n\n  // If both are set, we try to construct a new Request with the given arguments\n  // However, if e.g. the original request has a `body`, this will throw an error because it was already accessed\n  // In this case, as a fallback, we just use the original request - using both is rather an edge case\n  if (requestInfo instanceof Request && requestInfo.bodyUsed) {\n    return requestInfo;\n  }\n  return new Request(requestInfo, requestInit);\n}\nfunction _shouldSendDefaultPii() {\n  const client = getClient();\n  return client ? Boolean(client.getOptions().sendDefaultPii) : false;\n}\nexport { httpClientIntegration };\n//# sourceMappingURL=httpclient.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}