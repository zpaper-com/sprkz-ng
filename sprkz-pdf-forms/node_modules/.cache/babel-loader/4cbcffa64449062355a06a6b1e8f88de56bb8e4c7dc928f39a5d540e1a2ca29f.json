{"ast":null,"code":"import { defineIntegration, addGlobalErrorInstrumentationHandler, getClient, captureEvent, debug, addGlobalUnhandledRejectionInstrumentationHandler, isPrimitive, isString, getLocationHref, UNKNOWN_FUNCTION } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { eventFromUnknownInput } from '../eventbuilder.js';\nimport { shouldIgnoreOnError } from '../helpers.js';\nconst INTEGRATION_NAME = 'GlobalHandlers';\nconst _globalHandlersIntegration = (options = {}) => {\n  const _options = {\n    onerror: true,\n    onunhandledrejection: true,\n    ...options\n  };\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      Error.stackTraceLimit = 50;\n    },\n    setup(client) {\n      if (_options.onerror) {\n        _installGlobalOnErrorHandler(client);\n        globalHandlerLog('onerror');\n      }\n      if (_options.onunhandledrejection) {\n        _installGlobalOnUnhandledRejectionHandler(client);\n        globalHandlerLog('onunhandledrejection');\n      }\n    }\n  };\n};\nconst globalHandlersIntegration = defineIntegration(_globalHandlersIntegration);\nfunction _installGlobalOnErrorHandler(client) {\n  addGlobalErrorInstrumentationHandler(data => {\n    const {\n      stackParser,\n      attachStacktrace\n    } = getOptions();\n    if (getClient() !== client || shouldIgnoreOnError()) {\n      return;\n    }\n    const {\n      msg,\n      url,\n      line,\n      column,\n      error\n    } = data;\n    const event = _enhanceEventWithInitialFrame(eventFromUnknownInput(stackParser, error || msg, undefined, attachStacktrace, false), url, line, column);\n    event.level = 'error';\n    captureEvent(event, {\n      originalException: error,\n      mechanism: {\n        handled: false,\n        type: 'onerror'\n      }\n    });\n  });\n}\nfunction _installGlobalOnUnhandledRejectionHandler(client) {\n  addGlobalUnhandledRejectionInstrumentationHandler(e => {\n    const {\n      stackParser,\n      attachStacktrace\n    } = getOptions();\n    if (getClient() !== client || shouldIgnoreOnError()) {\n      return;\n    }\n    const error = _getUnhandledRejectionError(e);\n    const event = isPrimitive(error) ? _eventFromRejectionWithPrimitive(error) : eventFromUnknownInput(stackParser, error, undefined, attachStacktrace, true);\n    event.level = 'error';\n    captureEvent(event, {\n      originalException: error,\n      mechanism: {\n        handled: false,\n        type: 'onunhandledrejection'\n      }\n    });\n  });\n}\nfunction _getUnhandledRejectionError(error) {\n  if (isPrimitive(error)) {\n    return error;\n  }\n\n  // dig the object of the rejection out of known event types\n  try {\n    // PromiseRejectionEvents store the object of the rejection under 'reason'\n    // see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent\n    if ('reason' in error) {\n      return error.reason;\n    }\n\n    // something, somewhere, (likely a browser extension) effectively casts PromiseRejectionEvents\n    // to CustomEvents, moving the `promise` and `reason` attributes of the PRE into\n    // the CustomEvent's `detail` attribute, since they're not part of CustomEvent's spec\n    // see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent and\n    // https://github.com/getsentry/sentry-javascript/issues/2380\n    if ('detail' in error && 'reason' in error.detail) {\n      return error.detail.reason;\n    }\n  } catch {} // eslint-disable-line no-empty\n\n  return error;\n}\n\n/**\n * Create an event from a promise rejection where the `reason` is a primitive.\n *\n * @param reason: The `reason` property of the promise rejection\n * @returns An Event object with an appropriate `exception` value\n */\nfunction _eventFromRejectionWithPrimitive(reason) {\n  return {\n    exception: {\n      values: [{\n        type: 'UnhandledRejection',\n        // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)\n        value: `Non-Error promise rejection captured with value: ${String(reason)}`\n      }]\n    }\n  };\n}\nfunction _enhanceEventWithInitialFrame(event, url, line, column) {\n  // event.exception\n  const e = event.exception = event.exception || {};\n  // event.exception.values\n  const ev = e.values = e.values || [];\n  // event.exception.values[0]\n  const ev0 = ev[0] = ev[0] || {};\n  // event.exception.values[0].stacktrace\n  const ev0s = ev0.stacktrace = ev0.stacktrace || {};\n  // event.exception.values[0].stacktrace.frames\n  const ev0sf = ev0s.frames = ev0s.frames || [];\n  const colno = column;\n  const lineno = line;\n  const filename = isString(url) && url.length > 0 ? url : getLocationHref();\n\n  // event.exception.values[0].stacktrace.frames\n  if (ev0sf.length === 0) {\n    ev0sf.push({\n      colno,\n      filename,\n      function: UNKNOWN_FUNCTION,\n      in_app: true,\n      lineno\n    });\n  }\n  return event;\n}\nfunction globalHandlerLog(type) {\n  DEBUG_BUILD && debug.log(`Global Handler attached: ${type}`);\n}\nfunction getOptions() {\n  const client = getClient();\n  const options = client?.getOptions() || {\n    stackParser: () => [],\n    attachStacktrace: false\n  };\n  return options;\n}\nexport { globalHandlersIntegration };\n//# sourceMappingURL=globalhandlers.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}