{"ast":null,"code":"import { defineIntegration } from '../integration.js';\nimport { isError } from '../utils/is.js';\nimport { truncate } from '../utils/string.js';\nconst DEFAULT_LIMIT = 10;\nconst INTEGRATION_NAME = 'ZodErrors';\n\n/**\n * Simplified ZodIssue type definition\n */\n\nfunction originalExceptionIsZodError(originalException) {\n  return isError(originalException) && originalException.name === 'ZodError' && Array.isArray(originalException.issues);\n}\n\n/**\n * Formats child objects or arrays to a string\n * that is preserved when sent to Sentry.\n *\n * Without this, we end up with something like this in Sentry:\n *\n * [\n *  [Object],\n *  [Object],\n *  [Object],\n *  [Object]\n * ]\n */\nfunction flattenIssue(issue) {\n  return {\n    ...issue,\n    path: 'path' in issue && Array.isArray(issue.path) ? issue.path.join('.') : undefined,\n    keys: 'keys' in issue ? JSON.stringify(issue.keys) : undefined,\n    unionErrors: 'unionErrors' in issue ? JSON.stringify(issue.unionErrors) : undefined\n  };\n}\n\n/**\n * Takes ZodError issue path array and returns a flattened version as a string.\n * This makes it easier to display paths within a Sentry error message.\n *\n * Array indexes are normalized to reduce duplicate entries\n *\n * @param path ZodError issue path\n * @returns flattened path\n *\n * @example\n * flattenIssuePath([0, 'foo', 1, 'bar']) // -> '<array>.foo.<array>.bar'\n */\nfunction flattenIssuePath(path) {\n  return path.map(p => {\n    if (typeof p === 'number') {\n      return '<array>';\n    } else {\n      return p;\n    }\n  }).join('.');\n}\n\n/**\n * Zod error message is a stringified version of ZodError.issues\n * This doesn't display well in the Sentry UI. Replace it with something shorter.\n */\nfunction formatIssueMessage(zodError) {\n  const errorKeyMap = new Set();\n  for (const iss of zodError.issues) {\n    const issuePath = flattenIssuePath(iss.path);\n    if (issuePath.length > 0) {\n      errorKeyMap.add(issuePath);\n    }\n  }\n  const errorKeys = Array.from(errorKeyMap);\n  if (errorKeys.length === 0) {\n    // If there are no keys, then we're likely validating the root\n    // variable rather than a key within an object. This attempts\n    // to extract what type it was that failed to validate.\n    // For example, z.string().parse(123) would return \"string\" here.\n    let rootExpectedType = 'variable';\n    if (zodError.issues.length > 0) {\n      const iss = zodError.issues[0];\n      if (iss !== undefined && 'expected' in iss && typeof iss.expected === 'string') {\n        rootExpectedType = iss.expected;\n      }\n    }\n    return `Failed to validate ${rootExpectedType}`;\n  }\n  return `Failed to validate keys: ${truncate(errorKeys.join(', '), 100)}`;\n}\n\n/**\n * Applies ZodError issues to an event extra and replaces the error message\n */\nfunction applyZodErrorsToEvent(limit, saveZodIssuesAsAttachment = false, event, hint) {\n  if (!event.exception?.values || !hint.originalException || !originalExceptionIsZodError(hint.originalException) || hint.originalException.issues.length === 0) {\n    return event;\n  }\n  try {\n    const issuesToFlatten = saveZodIssuesAsAttachment ? hint.originalException.issues : hint.originalException.issues.slice(0, limit);\n    const flattenedIssues = issuesToFlatten.map(flattenIssue);\n    if (saveZodIssuesAsAttachment) {\n      // Sometimes having the full error details can be helpful.\n      // Attachments have much higher limits, so we can include the full list of issues.\n      if (!Array.isArray(hint.attachments)) {\n        hint.attachments = [];\n      }\n      hint.attachments.push({\n        filename: 'zod_issues.json',\n        data: JSON.stringify({\n          issues: flattenedIssues\n        })\n      });\n    }\n    return {\n      ...event,\n      exception: {\n        ...event.exception,\n        values: [{\n          ...event.exception.values[0],\n          value: formatIssueMessage(hint.originalException)\n        }, ...event.exception.values.slice(1)]\n      },\n      extra: {\n        ...event.extra,\n        'zoderror.issues': flattenedIssues.slice(0, limit)\n      }\n    };\n  } catch (e) {\n    // Hopefully we never throw errors here, but record it\n    // with the event just in case.\n    return {\n      ...event,\n      extra: {\n        ...event.extra,\n        'zoderrors sentry integration parse error': {\n          message: 'an exception was thrown while processing ZodError within applyZodErrorsToEvent()',\n          error: e instanceof Error ? `${e.name}: ${e.message}\\n${e.stack}` : 'unknown'\n        }\n      }\n    };\n  }\n}\nconst _zodErrorsIntegration = (options = {}) => {\n  const limit = options.limit ?? DEFAULT_LIMIT;\n  return {\n    name: INTEGRATION_NAME,\n    processEvent(originalEvent, hint) {\n      const processedEvent = applyZodErrorsToEvent(limit, options.saveZodIssuesAsAttachment, originalEvent, hint);\n      return processedEvent;\n    }\n  };\n};\n\n/**\n * Sentry integration to process Zod errors, making them easier to work with in Sentry.\n */\nconst zodErrorsIntegration = defineIntegration(_zodErrorsIntegration);\nexport { applyZodErrorsToEvent, flattenIssue, flattenIssuePath, formatIssueMessage, zodErrorsIntegration };","map":{"version":3,"names":["DEFAULT_LIMIT","INTEGRATION_NAME","originalExceptionIsZodError","originalException","isError","name","Array","isArray","issues","flattenIssue","issue","path","join","undefined","keys","JSON","stringify","unionErrors","flattenIssuePath","map","p","formatIssueMessage","zodError","errorKeyMap","Set","iss","issuePath","length","add","errorKeys","from","rootExpectedType","expected","truncate","applyZodErrorsToEvent","limit","saveZodIssuesAsAttachment","event","hint","exception","values","issuesToFlatten","slice","flattenedIssues","attachments","push","filename","data","value","extra","e","message","error","Error","stack","_zodErrorsIntegration","options","processEvent","originalEvent","processedEvent","zodErrorsIntegration","defineIntegration"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/integrations/zoderrors.ts"],"sourcesContent":["import { defineIntegration } from '../integration';\nimport type { Event, EventHint } from '../types-hoist/event';\nimport type { IntegrationFn } from '../types-hoist/integration';\nimport { isError } from '../utils/is';\nimport { truncate } from '../utils/string';\n\ninterface ZodErrorsOptions {\n  key?: string;\n  /**\n   * Limits the number of Zod errors inlined in each Sentry event.\n   *\n   * @default 10\n   */\n  limit?: number;\n  /**\n   * Save full list of Zod issues as an attachment in Sentry\n   *\n   * @default false\n   */\n  saveZodIssuesAsAttachment?: boolean;\n}\n\nconst DEFAULT_LIMIT = 10;\nconst INTEGRATION_NAME = 'ZodErrors';\n\n/**\n * Simplified ZodIssue type definition\n */\ninterface ZodIssue {\n  path: (string | number)[];\n  message?: string;\n  expected?: unknown;\n  received?: unknown;\n  unionErrors?: unknown[];\n  keys?: unknown[];\n  invalid_literal?: unknown;\n}\n\ninterface ZodError extends Error {\n  issues: ZodIssue[];\n}\n\nfunction originalExceptionIsZodError(originalException: unknown): originalException is ZodError {\n  return (\n    isError(originalException) &&\n    originalException.name === 'ZodError' &&\n    Array.isArray((originalException as ZodError).issues)\n  );\n}\n\ntype SingleLevelZodIssue<T extends ZodIssue> = {\n  [P in keyof T]: T[P] extends string | number | undefined\n    ? T[P]\n    : T[P] extends unknown[]\n      ? string | undefined\n      : unknown;\n};\n\n/**\n * Formats child objects or arrays to a string\n * that is preserved when sent to Sentry.\n *\n * Without this, we end up with something like this in Sentry:\n *\n * [\n *  [Object],\n *  [Object],\n *  [Object],\n *  [Object]\n * ]\n */\nexport function flattenIssue(issue: ZodIssue): SingleLevelZodIssue<ZodIssue> {\n  return {\n    ...issue,\n    path: 'path' in issue && Array.isArray(issue.path) ? issue.path.join('.') : undefined,\n    keys: 'keys' in issue ? JSON.stringify(issue.keys) : undefined,\n    unionErrors: 'unionErrors' in issue ? JSON.stringify(issue.unionErrors) : undefined,\n  };\n}\n\n/**\n * Takes ZodError issue path array and returns a flattened version as a string.\n * This makes it easier to display paths within a Sentry error message.\n *\n * Array indexes are normalized to reduce duplicate entries\n *\n * @param path ZodError issue path\n * @returns flattened path\n *\n * @example\n * flattenIssuePath([0, 'foo', 1, 'bar']) // -> '<array>.foo.<array>.bar'\n */\nexport function flattenIssuePath(path: Array<string | number>): string {\n  return path\n    .map(p => {\n      if (typeof p === 'number') {\n        return '<array>';\n      } else {\n        return p;\n      }\n    })\n    .join('.');\n}\n\n/**\n * Zod error message is a stringified version of ZodError.issues\n * This doesn't display well in the Sentry UI. Replace it with something shorter.\n */\nexport function formatIssueMessage(zodError: ZodError): string {\n  const errorKeyMap = new Set<string | number | symbol>();\n  for (const iss of zodError.issues) {\n    const issuePath = flattenIssuePath(iss.path);\n    if (issuePath.length > 0) {\n      errorKeyMap.add(issuePath);\n    }\n  }\n\n  const errorKeys = Array.from(errorKeyMap);\n  if (errorKeys.length === 0) {\n    // If there are no keys, then we're likely validating the root\n    // variable rather than a key within an object. This attempts\n    // to extract what type it was that failed to validate.\n    // For example, z.string().parse(123) would return \"string\" here.\n    let rootExpectedType = 'variable';\n    if (zodError.issues.length > 0) {\n      const iss = zodError.issues[0];\n      if (iss !== undefined && 'expected' in iss && typeof iss.expected === 'string') {\n        rootExpectedType = iss.expected;\n      }\n    }\n    return `Failed to validate ${rootExpectedType}`;\n  }\n  return `Failed to validate keys: ${truncate(errorKeys.join(', '), 100)}`;\n}\n\n/**\n * Applies ZodError issues to an event extra and replaces the error message\n */\nexport function applyZodErrorsToEvent(\n  limit: number,\n  saveZodIssuesAsAttachment: boolean = false,\n  event: Event,\n  hint: EventHint,\n): Event {\n  if (\n    !event.exception?.values ||\n    !hint.originalException ||\n    !originalExceptionIsZodError(hint.originalException) ||\n    hint.originalException.issues.length === 0\n  ) {\n    return event;\n  }\n\n  try {\n    const issuesToFlatten = saveZodIssuesAsAttachment\n      ? hint.originalException.issues\n      : hint.originalException.issues.slice(0, limit);\n    const flattenedIssues = issuesToFlatten.map(flattenIssue);\n\n    if (saveZodIssuesAsAttachment) {\n      // Sometimes having the full error details can be helpful.\n      // Attachments have much higher limits, so we can include the full list of issues.\n      if (!Array.isArray(hint.attachments)) {\n        hint.attachments = [];\n      }\n      hint.attachments.push({\n        filename: 'zod_issues.json',\n        data: JSON.stringify({\n          issues: flattenedIssues,\n        }),\n      });\n    }\n\n    return {\n      ...event,\n      exception: {\n        ...event.exception,\n        values: [\n          {\n            ...event.exception.values[0],\n            value: formatIssueMessage(hint.originalException),\n          },\n          ...event.exception.values.slice(1),\n        ],\n      },\n      extra: {\n        ...event.extra,\n        'zoderror.issues': flattenedIssues.slice(0, limit),\n      },\n    };\n  } catch (e) {\n    // Hopefully we never throw errors here, but record it\n    // with the event just in case.\n    return {\n      ...event,\n      extra: {\n        ...event.extra,\n        'zoderrors sentry integration parse error': {\n          message: 'an exception was thrown while processing ZodError within applyZodErrorsToEvent()',\n          error: e instanceof Error ? `${e.name}: ${e.message}\\n${e.stack}` : 'unknown',\n        },\n      },\n    };\n  }\n}\n\nconst _zodErrorsIntegration = ((options: ZodErrorsOptions = {}) => {\n  const limit = options.limit ?? DEFAULT_LIMIT;\n\n  return {\n    name: INTEGRATION_NAME,\n    processEvent(originalEvent, hint): Event {\n      const processedEvent = applyZodErrorsToEvent(limit, options.saveZodIssuesAsAttachment, originalEvent, hint);\n      return processedEvent;\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Sentry integration to process Zod errors, making them easier to work with in Sentry.\n */\nexport const zodErrorsIntegration = defineIntegration(_zodErrorsIntegration);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}