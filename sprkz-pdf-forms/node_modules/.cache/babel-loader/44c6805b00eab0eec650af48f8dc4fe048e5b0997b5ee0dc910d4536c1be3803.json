{"ast":null,"code":"var _jsxFileName = \"/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/src/contexts/FeatureFlagsContext.tsx\";\nimport React, { createContext, useContext, useEffect, useState, useCallback, useRef } from 'react';\nimport { unleashService, DEFAULT_FEATURE_FLAGS, FEATURE_CATEGORIES } from '../services/unleashService';\n\n// Enhanced context interface with full feature flag support\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// Default context value\nconst defaultContext = {\n  isFeatureEnabled: () => false,\n  getFeatureVariant: () => null,\n  getAllFlags: () => DEFAULT_FEATURE_FLAGS,\n  getFlagsByCategory: () => ({}),\n  updateContext: () => {},\n  isReady: false,\n  isInitialized: false,\n  status: {\n    initialized: false,\n    clientReady: false,\n    flagCount: 0\n  },\n  refresh: () => {}\n};\nexport const FeatureFlagsContext = /*#__PURE__*/createContext(defaultContext);\nexport const FeatureFlagsProvider = ({\n  children,\n  config = {},\n  fallbackFlags = {},\n  enableLogging = process.env.NODE_ENV === 'development'\n}) => {\n  const [isReady, setIsReady] = useState(false);\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [flags, setFlags] = useState({\n    ...DEFAULT_FEATURE_FLAGS,\n    ...fallbackFlags\n  });\n  const [status, setStatus] = useState({\n    initialized: false,\n    clientReady: false,\n    flagCount: 0\n  });\n  const [currentContext, setCurrentContext] = useState(config.context || {});\n  const initializationRef = useRef(false);\n\n  // Initialize Unleash service\n  useEffect(() => {\n    if (initializationRef.current) return;\n    initializationRef.current = true;\n    const initializeUnleash = async () => {\n      try {\n        if (enableLogging) {\n          console.log('Initializing Unleash service with config:', config);\n        }\n\n        // Initialize with configuration\n        await unleashService.initialize({\n          userId: config.userId,\n          environment: config.environment,\n          ...config.context\n        });\n\n        // Update initial state\n        setIsInitialized(true);\n        setIsReady(true);\n        setFlags(unleashService.getAllFlags(currentContext));\n        setStatus(unleashService.getStatus());\n        if (enableLogging) {\n          console.log('Unleash service initialized successfully');\n          console.log('Initial flags:', unleashService.getAllFlags(currentContext));\n        }\n      } catch (error) {\n        console.error('Failed to initialize Unleash service:', error);\n        // Continue with fallback flags\n        setIsInitialized(false);\n        setIsReady(true); // Still ready, just using defaults\n        setFlags({\n          ...DEFAULT_FEATURE_FLAGS,\n          ...fallbackFlags\n        });\n      }\n    };\n    initializeUnleash();\n  }, []); // Run once on mount\n\n  // Subscribe to flag updates\n  useEffect(() => {\n    const unsubscribe = unleashService.subscribe(() => {\n      if (enableLogging) {\n        console.log('Feature flags updated');\n      }\n      setFlags(unleashService.getAllFlags(currentContext));\n      setStatus(unleashService.getStatus());\n    });\n    return unsubscribe;\n  }, [currentContext, enableLogging]);\n\n  // Memoized flag checking function\n  const isFeatureEnabled = useCallback((flagName, context) => {\n    const mergedContext = {\n      ...currentContext,\n      ...context\n    };\n    if (!isInitialized) {\n      var _fallbackFlags$flagNa;\n      const fallbackValue = (_fallbackFlags$flagNa = fallbackFlags[flagName]) !== null && _fallbackFlags$flagNa !== void 0 ? _fallbackFlags$flagNa : DEFAULT_FEATURE_FLAGS[flagName];\n      if (enableLogging) {\n        console.log(`Feature flag ${flagName} checked (fallback): ${fallbackValue}`);\n      }\n      return fallbackValue;\n    }\n    const isEnabled = unleashService.isEnabled(flagName, mergedContext);\n    if (enableLogging) {\n      console.log(`Feature flag ${flagName} checked: ${isEnabled}`);\n    }\n    return isEnabled;\n  }, [isInitialized, currentContext, fallbackFlags, enableLogging]);\n\n  // Memoized variant getting function\n  const getFeatureVariant = useCallback((flagName, context) => {\n    const mergedContext = {\n      ...currentContext,\n      ...context\n    };\n    if (!isInitialized) {\n      if (enableLogging) {\n        console.log(`Feature variant ${flagName} requested (fallback): null`);\n      }\n      return null;\n    }\n    const variant = unleashService.getVariant(flagName, mergedContext);\n    if (enableLogging) {\n      console.log(`Feature variant ${flagName} requested:`, variant);\n    }\n    return variant;\n  }, [isInitialized, currentContext, enableLogging]);\n\n  // Get all flags\n  const getAllFlags = useCallback(context => {\n    const mergedContext = {\n      ...currentContext,\n      ...context\n    };\n    if (!isInitialized) {\n      return {\n        ...DEFAULT_FEATURE_FLAGS,\n        ...fallbackFlags\n      };\n    }\n    return unleashService.getAllFlags(mergedContext);\n  }, [isInitialized, currentContext, fallbackFlags]);\n\n  // Get flags by category\n  const getFlagsByCategory = useCallback((category, context) => {\n    const mergedContext = {\n      ...currentContext,\n      ...context\n    };\n    if (!isInitialized) {\n      const categoryFlags = FEATURE_CATEGORIES[category];\n      const result = {};\n      categoryFlags.forEach(flagName => {\n        var _fallbackFlags$key;\n        const key = flagName;\n        result[key] = (_fallbackFlags$key = fallbackFlags[key]) !== null && _fallbackFlags$key !== void 0 ? _fallbackFlags$key : DEFAULT_FEATURE_FLAGS[key];\n      });\n      return result;\n    }\n    return unleashService.getFlagsByCategory(category, mergedContext);\n  }, [isInitialized, currentContext, fallbackFlags]);\n\n  // Update context\n  const updateContext = useCallback(newContext => {\n    setCurrentContext(prev => ({\n      ...prev,\n      ...newContext\n    }));\n    if (isInitialized) {\n      unleashService.updateContext(newContext);\n    }\n    if (enableLogging) {\n      console.log('Feature flags context updated:', newContext);\n    }\n  }, [isInitialized, enableLogging]);\n\n  // Refresh flags manually\n  const refresh = useCallback(() => {\n    if (isInitialized) {\n      setFlags(unleashService.getAllFlags(currentContext));\n      setStatus(unleashService.getStatus());\n    }\n    if (enableLogging) {\n      console.log('Feature flags refreshed manually');\n    }\n  }, [isInitialized, currentContext, enableLogging]);\n\n  // Context value\n  const contextValue = {\n    isFeatureEnabled,\n    getFeatureVariant,\n    getAllFlags,\n    getFlagsByCategory,\n    updateContext,\n    isReady,\n    isInitialized,\n    status,\n    refresh\n  };\n\n  // Log provider status changes\n  useEffect(() => {\n    if (enableLogging) {\n      console.log('FeatureFlagsProvider status:', {\n        isReady,\n        isInitialized,\n        flagCount: Object.keys(flags).length,\n        status\n      });\n    }\n  }, [isReady, isInitialized, flags, status, enableLogging]);\n  return /*#__PURE__*/_jsxDEV(FeatureFlagsContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 254,\n    columnNumber: 5\n  }, this);\n};\n\n// Enhanced hook with better error handling\nexport const useFeatureFlags = () => {\n  const context = useContext(FeatureFlagsContext);\n  if (context === undefined) {\n    throw new Error('useFeatureFlags must be used within a FeatureFlagsProvider');\n  }\n  return context;\n};\n\n// Convenience hooks for common patterns\nexport const useFeatureFlag = (flagName, context) => {\n  const {\n    isFeatureEnabled,\n    getFeatureVariant\n  } = useFeatureFlags();\n  return {\n    isEnabled: isFeatureEnabled(flagName, context),\n    variant: getFeatureVariant(flagName, context)\n  };\n};\nexport const useFeatureFlagWithFallback = (flagName, fallback = false, context) => {\n  const {\n    isFeatureEnabled,\n    isReady\n  } = useFeatureFlags();\n  if (!isReady) {\n    return fallback;\n  }\n  return isFeatureEnabled(flagName, context);\n};\n\n// Clean up on unmount\nexport const FeatureFlagsCleanup = () => {\n  useEffect(() => {\n    return () => {\n      unleashService.destroy();\n    };\n  }, []);\n  return null;\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}