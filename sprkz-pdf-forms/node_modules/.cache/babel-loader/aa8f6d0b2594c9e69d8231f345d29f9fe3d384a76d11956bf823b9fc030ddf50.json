{"ast":null,"code":"import { addHandler, maybeInstrument, triggerHandlers, fill, addNonEnumerableProperty, uuid4 } from '@sentry/core';\nimport { WINDOW } from '../types.js';\nconst DEBOUNCE_DURATION = 1000;\nlet debounceTimerID;\nlet lastCapturedEventType;\nlet lastCapturedEventTargetId;\n\n/**\n * Add an instrumentation handler for when a click or a keypress happens.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addClickKeypressInstrumentationHandler(handler) {\n  const type = 'dom';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentDOM);\n}\n\n/** Exported for tests only. */\nfunction instrumentDOM() {\n  if (!WINDOW.document) {\n    return;\n  }\n\n  // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom\n  // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before\n  // we instrument `addEventListener` so that we don't end up attaching this handler twice.\n  const triggerDOMHandler = triggerHandlers.bind(null, 'dom');\n  const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);\n  WINDOW.document.addEventListener('click', globalDOMEventHandler, false);\n  WINDOW.document.addEventListener('keypress', globalDOMEventHandler, false);\n\n  // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled\n  // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That\n  // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler\n  // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still\n  // guaranteed to fire at least once.)\n  ['EventTarget', 'Node'].forEach(target => {\n    const globalObject = WINDOW;\n    const proto = globalObject[target]?.prototype;\n\n    // eslint-disable-next-line no-prototype-builtins\n    if (!proto?.hasOwnProperty?.('addEventListener')) {\n      return;\n    }\n    fill(proto, 'addEventListener', function (originalAddEventListener) {\n      return function (type, listener, options) {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            const handlers = this.__sentry_instrumentation_handlers__ = this.__sentry_instrumentation_handlers__ || {};\n            const handlerForType = handlers[type] = handlers[type] || {\n              refCount: 0\n            };\n            if (!handlerForType.handler) {\n              const handler = makeDOMEventHandler(triggerDOMHandler);\n              handlerForType.handler = handler;\n              originalAddEventListener.call(this, type, handler, options);\n            }\n            handlerForType.refCount++;\n          } catch {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListeners` calls with no proper `this` context.\n          }\n        }\n        return originalAddEventListener.call(this, type, listener, options);\n      };\n    });\n    fill(proto, 'removeEventListener', function (originalRemoveEventListener) {\n      return function (type, listener, options) {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            const handlers = this.__sentry_instrumentation_handlers__ || {};\n            const handlerForType = handlers[type];\n            if (handlerForType) {\n              handlerForType.refCount--;\n              // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.\n              if (handlerForType.refCount <= 0) {\n                originalRemoveEventListener.call(this, type, handlerForType.handler, options);\n                handlerForType.handler = undefined;\n                delete handlers[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n              }\n\n              // If there are no longer any custom handlers of any type on this element, cleanup everything.\n              if (Object.keys(handlers).length === 0) {\n                delete this.__sentry_instrumentation_handlers__;\n              }\n            }\n          } catch {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListeners` calls with no proper `this` context.\n          }\n        }\n        return originalRemoveEventListener.call(this, type, listener, options);\n      };\n    });\n  });\n}\n\n/**\n * Check whether the event is similar to the last captured one. For example, two click events on the same button.\n */\nfunction isSimilarToLastCapturedEvent(event) {\n  // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.\n  if (event.type !== lastCapturedEventType) {\n    return false;\n  }\n  try {\n    // If both events have the same type, it's still possible that actions were performed on different targets.\n    // e.g. 2 clicks on different buttons.\n    if (!event.target || event.target._sentryId !== lastCapturedEventTargetId) {\n      return false;\n    }\n  } catch {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_\n  // to which an event listener was attached), we treat them as the same action, as we want to capture\n  // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.\n  return true;\n}\n\n/**\n * Decide whether an event should be captured.\n * @param event event to be captured\n */\nfunction shouldSkipDOMEvent(eventType, target) {\n  // We are only interested in filtering `keypress` events for now.\n  if (eventType !== 'keypress') {\n    return false;\n  }\n  if (!target?.tagName) {\n    return true;\n  }\n\n  // Only consider keypress events on actual input elements. This will disregard keypresses targeting body\n  // e.g.tabbing through elements, hotkeys, etc.\n  if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n */\nfunction makeDOMEventHandler(handler, globalListener = false) {\n  return event => {\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors).\n    // Ignore if we've already captured that event.\n    if (!event || event['_sentryCaptured']) {\n      return;\n    }\n    const target = getEventTarget(event);\n\n    // We always want to skip _some_ events.\n    if (shouldSkipDOMEvent(event.type, target)) {\n      return;\n    }\n\n    // Mark event as \"seen\"\n    addNonEnumerableProperty(event, '_sentryCaptured', true);\n    if (target && !target._sentryId) {\n      // Add UUID to event target so we can identify if\n      addNonEnumerableProperty(target, '_sentryId', uuid4());\n    }\n    const name = event.type === 'keypress' ? 'input' : event.type;\n\n    // If there is no last captured event, it means that we can safely capture the new event and store it for future comparisons.\n    // If there is a last captured event, see if the new event is different enough to treat it as a unique one.\n    // If that's the case, emit the previous event and store locally the newly-captured DOM event.\n    if (!isSimilarToLastCapturedEvent(event)) {\n      const handlerData = {\n        event,\n        name,\n        global: globalListener\n      };\n      handler(handlerData);\n      lastCapturedEventType = event.type;\n      lastCapturedEventTargetId = target ? target._sentryId : undefined;\n    }\n\n    // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.\n    clearTimeout(debounceTimerID);\n    debounceTimerID = WINDOW.setTimeout(() => {\n      lastCapturedEventTargetId = undefined;\n      lastCapturedEventType = undefined;\n    }, DEBOUNCE_DURATION);\n  };\n}\nfunction getEventTarget(event) {\n  try {\n    return event.target;\n  } catch {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n    return null;\n  }\n}\nexport { addClickKeypressInstrumentationHandler, instrumentDOM };","map":{"version":3,"names":["DEBOUNCE_DURATION","debounceTimerID","lastCapturedEventType","lastCapturedEventTargetId","addClickKeypressInstrumentationHandler","handler","type","addHandler","maybeInstrument","instrumentDOM","WINDOW","document","triggerDOMHandler","triggerHandlers","bind","globalDOMEventHandler","makeDOMEventHandler","addEventListener","forEach","target","globalObject","proto","prototype","hasOwnProperty","fill","originalAddEventListener","listener","options","handlers","__sentry_instrumentation_handlers__","handlerForType","refCount","call","originalRemoveEventListener","undefined","Object","keys","length","isSimilarToLastCapturedEvent","event","_sentryId","shouldSkipDOMEvent","eventType","tagName","isContentEditable","globalListener","getEventTarget","addNonEnumerableProperty","uuid4","name","handlerData","global","clearTimeout","setTimeout"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry-internal/browser-utils/src/instrument/dom.ts"],"sourcesContent":["import type { HandlerDataDom } from '@sentry/core';\nimport { addHandler, addNonEnumerableProperty, fill, maybeInstrument, triggerHandlers, uuid4 } from '@sentry/core';\nimport { WINDOW } from '../types';\n\ntype SentryWrappedTarget = HTMLElement & { _sentryId?: string };\n\ntype AddEventListener = (\n  type: string,\n  listener: EventListenerOrEventListenerObject,\n  options?: boolean | AddEventListenerOptions,\n) => void;\ntype RemoveEventListener = (\n  type: string,\n  listener: EventListenerOrEventListenerObject,\n  options?: boolean | EventListenerOptions,\n) => void;\n\ntype InstrumentedElement = Element & {\n  __sentry_instrumentation_handlers__?: {\n    [key in 'click' | 'keypress']?: {\n      handler?: unknown;\n      /** The number of custom listeners attached to this element */\n      refCount: number;\n    };\n  };\n};\n\nconst DEBOUNCE_DURATION = 1000;\n\nlet debounceTimerID: number | undefined;\nlet lastCapturedEventType: string | undefined;\nlet lastCapturedEventTargetId: string | undefined;\n\n/**\n * Add an instrumentation handler for when a click or a keypress happens.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addClickKeypressInstrumentationHandler(handler: (data: HandlerDataDom) => void): void {\n  const type = 'dom';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentDOM);\n}\n\n/** Exported for tests only. */\nexport function instrumentDOM(): void {\n  if (!WINDOW.document) {\n    return;\n  }\n\n  // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom\n  // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before\n  // we instrument `addEventListener` so that we don't end up attaching this handler twice.\n  const triggerDOMHandler = triggerHandlers.bind(null, 'dom');\n  const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);\n  WINDOW.document.addEventListener('click', globalDOMEventHandler, false);\n  WINDOW.document.addEventListener('keypress', globalDOMEventHandler, false);\n\n  // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled\n  // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That\n  // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler\n  // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still\n  // guaranteed to fire at least once.)\n  ['EventTarget', 'Node'].forEach((target: string) => {\n    const globalObject = WINDOW as unknown as Record<string, { prototype?: object }>;\n    const proto = globalObject[target]?.prototype;\n\n    // eslint-disable-next-line no-prototype-builtins\n    if (!proto?.hasOwnProperty?.('addEventListener')) {\n      return;\n    }\n\n    fill(proto, 'addEventListener', function (originalAddEventListener: AddEventListener): AddEventListener {\n      return function (this: InstrumentedElement, type, listener, options): AddEventListener {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            const handlers = (this.__sentry_instrumentation_handlers__ =\n              this.__sentry_instrumentation_handlers__ || {});\n            const handlerForType = (handlers[type] = handlers[type] || { refCount: 0 });\n\n            if (!handlerForType.handler) {\n              const handler = makeDOMEventHandler(triggerDOMHandler);\n              handlerForType.handler = handler;\n              originalAddEventListener.call(this, type, handler, options);\n            }\n\n            handlerForType.refCount++;\n          } catch {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListeners` calls with no proper `this` context.\n          }\n        }\n\n        return originalAddEventListener.call(this, type, listener, options);\n      };\n    });\n\n    fill(\n      proto,\n      'removeEventListener',\n      function (originalRemoveEventListener: RemoveEventListener): RemoveEventListener {\n        return function (this: InstrumentedElement, type, listener, options): () => void {\n          if (type === 'click' || type == 'keypress') {\n            try {\n              const handlers = this.__sentry_instrumentation_handlers__ || {};\n              const handlerForType = handlers[type];\n\n              if (handlerForType) {\n                handlerForType.refCount--;\n                // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.\n                if (handlerForType.refCount <= 0) {\n                  originalRemoveEventListener.call(this, type, handlerForType.handler, options);\n                  handlerForType.handler = undefined;\n                  delete handlers[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n                }\n\n                // If there are no longer any custom handlers of any type on this element, cleanup everything.\n                if (Object.keys(handlers).length === 0) {\n                  delete this.__sentry_instrumentation_handlers__;\n                }\n              }\n            } catch {\n              // Accessing dom properties is always fragile.\n              // Also allows us to skip `addEventListeners` calls with no proper `this` context.\n            }\n          }\n\n          return originalRemoveEventListener.call(this, type, listener, options);\n        };\n      },\n    );\n  });\n}\n\n/**\n * Check whether the event is similar to the last captured one. For example, two click events on the same button.\n */\nfunction isSimilarToLastCapturedEvent(event: Event): boolean {\n  // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.\n  if (event.type !== lastCapturedEventType) {\n    return false;\n  }\n\n  try {\n    // If both events have the same type, it's still possible that actions were performed on different targets.\n    // e.g. 2 clicks on different buttons.\n    if (!event.target || (event.target as SentryWrappedTarget)._sentryId !== lastCapturedEventTargetId) {\n      return false;\n    }\n  } catch {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_\n  // to which an event listener was attached), we treat them as the same action, as we want to capture\n  // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.\n  return true;\n}\n\n/**\n * Decide whether an event should be captured.\n * @param event event to be captured\n */\nfunction shouldSkipDOMEvent(eventType: string, target: SentryWrappedTarget | null): boolean {\n  // We are only interested in filtering `keypress` events for now.\n  if (eventType !== 'keypress') {\n    return false;\n  }\n\n  if (!target?.tagName) {\n    return true;\n  }\n\n  // Only consider keypress events on actual input elements. This will disregard keypresses targeting body\n  // e.g.tabbing through elements, hotkeys, etc.\n  if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n */\nfunction makeDOMEventHandler(\n  handler: (data: HandlerDataDom) => void,\n  globalListener: boolean = false,\n): (event: Event) => void {\n  return (event: Event & { _sentryCaptured?: true }): void => {\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors).\n    // Ignore if we've already captured that event.\n    if (!event || event['_sentryCaptured']) {\n      return;\n    }\n\n    const target = getEventTarget(event);\n\n    // We always want to skip _some_ events.\n    if (shouldSkipDOMEvent(event.type, target)) {\n      return;\n    }\n\n    // Mark event as \"seen\"\n    addNonEnumerableProperty(event, '_sentryCaptured', true);\n\n    if (target && !target._sentryId) {\n      // Add UUID to event target so we can identify if\n      addNonEnumerableProperty(target, '_sentryId', uuid4());\n    }\n\n    const name = event.type === 'keypress' ? 'input' : event.type;\n\n    // If there is no last captured event, it means that we can safely capture the new event and store it for future comparisons.\n    // If there is a last captured event, see if the new event is different enough to treat it as a unique one.\n    // If that's the case, emit the previous event and store locally the newly-captured DOM event.\n    if (!isSimilarToLastCapturedEvent(event)) {\n      const handlerData: HandlerDataDom = { event, name, global: globalListener };\n      handler(handlerData);\n      lastCapturedEventType = event.type;\n      lastCapturedEventTargetId = target ? target._sentryId : undefined;\n    }\n\n    // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.\n    clearTimeout(debounceTimerID);\n    debounceTimerID = WINDOW.setTimeout(() => {\n      lastCapturedEventTargetId = undefined;\n      lastCapturedEventType = undefined;\n    }, DEBOUNCE_DURATION);\n  };\n}\n\nfunction getEventTarget(event: Event): SentryWrappedTarget | null {\n  try {\n    return event.target as SentryWrappedTarget | null;\n  } catch {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n    return null;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}