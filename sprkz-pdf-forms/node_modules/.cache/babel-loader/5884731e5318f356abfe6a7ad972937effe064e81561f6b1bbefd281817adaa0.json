{"ast":null,"code":"import { browserTracingIntegration, WINDOW, startBrowserTracingPageLoadSpan, startBrowserTracingNavigationSpan } from '@sentry/browser';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_OP } from '@sentry/core';\n\n// Many of the types below had to be mocked out to prevent typescript issues\n// these types are required for correct functionality.\n\n/**\n * A browser tracing integration that uses React Router v3 to instrument navigations.\n * Expects `history` (and optionally `routes` and `matchPath`) to be passed as options.\n */\nfunction reactRouterV3BrowserTracingIntegration(options) {\n  const integration = browserTracingIntegration({\n    ...options,\n    instrumentPageLoad: false,\n    instrumentNavigation: false\n  });\n  const {\n    history,\n    routes,\n    match,\n    instrumentPageLoad = true,\n    instrumentNavigation = true\n  } = options;\n  return {\n    ...integration,\n    afterAllSetup(client) {\n      integration.afterAllSetup(client);\n      if (instrumentPageLoad && WINDOW.location) {\n        normalizeTransactionName(routes, WINDOW.location, match, (localName, source = 'url') => {\n          startBrowserTracingPageLoadSpan(client, {\n            name: localName,\n            attributes: {\n              [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'pageload',\n              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.pageload.react.reactrouter_v3',\n              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source\n            }\n          });\n        });\n      }\n      if (instrumentNavigation && history.listen) {\n        history.listen(location => {\n          if (location.action === 'PUSH' || location.action === 'POP') {\n            normalizeTransactionName(routes, location, match, (localName, source = 'url') => {\n              startBrowserTracingNavigationSpan(client, {\n                name: localName,\n                attributes: {\n                  [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'navigation',\n                  [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.react.reactrouter_v3',\n                  [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source\n                }\n              });\n            });\n          }\n        });\n      }\n    }\n  };\n}\n\n/**\n * Normalize transaction names using `Router.match`\n */\nfunction normalizeTransactionName(appRoutes, location, match, callback) {\n  let name = location.pathname;\n  match({\n    location,\n    routes: appRoutes\n  }, (error, _redirectLocation, renderProps) => {\n    if (error || !renderProps) {\n      return callback(name);\n    }\n    const routePath = getRouteStringFromRoutes(renderProps.routes || []);\n    if (routePath.length === 0 || routePath === '/*') {\n      return callback(name);\n    }\n    name = routePath;\n    return callback(name, 'route');\n  });\n}\n\n/**\n * Generate route name from array of routes\n */\nfunction getRouteStringFromRoutes(routes) {\n  if (!Array.isArray(routes) || routes.length === 0) {\n    return '';\n  }\n  const routesWithPaths = routes.filter(route => !!route.path);\n  let index = -1;\n  for (let x = routesWithPaths.length - 1; x >= 0; x--) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const route = routesWithPaths[x];\n    if (route.path?.startsWith('/')) {\n      index = x;\n      break;\n    }\n  }\n  return routesWithPaths.slice(index).reduce((acc, {\n    path\n  }) => {\n    const pathSegment = acc === '/' || acc === '' ? path : `/${path}`;\n    return `${acc}${pathSegment}`;\n  }, '');\n}\nexport { reactRouterV3BrowserTracingIntegration };","map":{"version":3,"names":["reactRouterV3BrowserTracingIntegration","options","integration","browserTracingIntegration","instrumentPageLoad","instrumentNavigation","history","routes","match","afterAllSetup","client","WINDOW","location","normalizeTransactionName","localName","source","startBrowserTracingPageLoadSpan","name","attributes","SEMANTIC_ATTRIBUTE_SENTRY_OP","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","listen","action","startBrowserTracingNavigationSpan","appRoutes","callback","pathname","error","_redirectLocation","renderProps","routePath","getRouteStringFromRoutes","length","Array","isArray","routesWithPaths","filter","route","path","index","x","startsWith","slice","reduce","acc","pathSegment"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/react/src/reactrouterv3.ts"],"sourcesContent":["import {\n  browserTracingIntegration,\n  startBrowserTracingNavigationSpan,\n  startBrowserTracingPageLoadSpan,\n  WINDOW,\n} from '@sentry/browser';\nimport type { Integration, TransactionSource } from '@sentry/core';\nimport {\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n} from '@sentry/core';\nimport type { Location } from './types';\n\n// Many of the types below had to be mocked out to prevent typescript issues\n// these types are required for correct functionality.\n\ntype HistoryV3 = {\n  location?: Location;\n  listen?(cb: (location: Location) => void): void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n} & Record<string, any>;\n\nexport type Route = { path?: string; childRoutes?: Route[] };\n\nexport type Match = (\n  props: { location: Location; routes: Route[] },\n  cb: (error?: Error, _redirectLocation?: Location, renderProps?: { routes?: Route[] }) => void,\n) => void;\n\ntype ReactRouterV3TransactionSource = Extract<TransactionSource, 'url' | 'route'>;\n\ninterface ReactRouterOptions {\n  history: HistoryV3;\n  routes: Route[];\n  match: Match;\n}\n\n/**\n * A browser tracing integration that uses React Router v3 to instrument navigations.\n * Expects `history` (and optionally `routes` and `matchPath`) to be passed as options.\n */\nexport function reactRouterV3BrowserTracingIntegration(\n  options: Parameters<typeof browserTracingIntegration>[0] & ReactRouterOptions,\n): Integration {\n  const integration = browserTracingIntegration({\n    ...options,\n    instrumentPageLoad: false,\n    instrumentNavigation: false,\n  });\n\n  const { history, routes, match, instrumentPageLoad = true, instrumentNavigation = true } = options;\n\n  return {\n    ...integration,\n    afterAllSetup(client) {\n      integration.afterAllSetup(client);\n\n      if (instrumentPageLoad && WINDOW.location) {\n        normalizeTransactionName(\n          routes,\n          WINDOW.location as unknown as Location,\n          match,\n          (localName: string, source: ReactRouterV3TransactionSource = 'url') => {\n            startBrowserTracingPageLoadSpan(client, {\n              name: localName,\n              attributes: {\n                [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'pageload',\n                [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.pageload.react.reactrouter_v3',\n                [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,\n              },\n            });\n          },\n        );\n      }\n\n      if (instrumentNavigation && history.listen) {\n        history.listen(location => {\n          if (location.action === 'PUSH' || location.action === 'POP') {\n            normalizeTransactionName(\n              routes,\n              location,\n              match,\n              (localName: string, source: TransactionSource = 'url') => {\n                startBrowserTracingNavigationSpan(client, {\n                  name: localName,\n                  attributes: {\n                    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'navigation',\n                    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.react.reactrouter_v3',\n                    [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,\n                  },\n                });\n              },\n            );\n          }\n        });\n      }\n    },\n  };\n}\n\n/**\n * Normalize transaction names using `Router.match`\n */\nfunction normalizeTransactionName(\n  appRoutes: Route[],\n  location: Location,\n  match: Match,\n  callback: (pathname: string, source?: ReactRouterV3TransactionSource) => void,\n): void {\n  let name = location.pathname;\n  match(\n    {\n      location,\n      routes: appRoutes,\n    },\n    (error, _redirectLocation, renderProps) => {\n      if (error || !renderProps) {\n        return callback(name);\n      }\n\n      const routePath = getRouteStringFromRoutes(renderProps.routes || []);\n      if (routePath.length === 0 || routePath === '/*') {\n        return callback(name);\n      }\n\n      name = routePath;\n      return callback(name, 'route');\n    },\n  );\n}\n\n/**\n * Generate route name from array of routes\n */\nfunction getRouteStringFromRoutes(routes: Route[]): string {\n  if (!Array.isArray(routes) || routes.length === 0) {\n    return '';\n  }\n\n  const routesWithPaths: Route[] = routes.filter((route: Route) => !!route.path);\n\n  let index = -1;\n  for (let x = routesWithPaths.length - 1; x >= 0; x--) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const route = routesWithPaths[x]!;\n    if (route.path?.startsWith('/')) {\n      index = x;\n      break;\n    }\n  }\n\n  return routesWithPaths.slice(index).reduce((acc, { path }) => {\n    const pathSegment = acc === '/' || acc === '' ? path : `/${path}`;\n    return `${acc}${pathSegment}`;\n  }, '');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}