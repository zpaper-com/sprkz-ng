{"ast":null,"code":"import { isParameterizedString, isError, isPlainObject, isErrorEvent } from './is.js';\nimport { addExceptionMechanism, addExceptionTypeValue } from './misc.js';\nimport { normalizeToSize } from './normalize.js';\nimport { extractExceptionKeysForMessage } from './object.js';\n\n/**\n * Extracts stack frames from the error.stack string\n */\nfunction parseStackFrames(stackParser, error) {\n  return stackParser(error.stack || '', 1);\n}\n\n/**\n * Extracts stack frames from the error and builds a Sentry Exception\n */\nfunction exceptionFromError(stackParser, error) {\n  const exception = {\n    type: error.name || error.constructor.name,\n    value: error.message\n  };\n  const frames = parseStackFrames(stackParser, error);\n  if (frames.length) {\n    exception.stacktrace = {\n      frames\n    };\n  }\n  return exception;\n}\n\n/** If a plain object has a property that is an `Error`, return this error. */\nfunction getErrorPropertyFromObject(obj) {\n  for (const prop in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n      const value = obj[prop];\n      if (value instanceof Error) {\n        return value;\n      }\n    }\n  }\n  return undefined;\n}\nfunction getMessageForObject(exception) {\n  if ('name' in exception && typeof exception.name === 'string') {\n    let message = `'${exception.name}' captured as exception`;\n    if ('message' in exception && typeof exception.message === 'string') {\n      message += ` with message '${exception.message}'`;\n    }\n    return message;\n  } else if ('message' in exception && typeof exception.message === 'string') {\n    return exception.message;\n  }\n  const keys = extractExceptionKeysForMessage(exception);\n\n  // Some ErrorEvent instances do not have an `error` property, which is why they are not handled before\n  // We still want to try to get a decent message for these cases\n  if (isErrorEvent(exception)) {\n    return `Event \\`ErrorEvent\\` captured as exception with message \\`${exception.message}\\``;\n  }\n  const className = getObjectClassName(exception);\n  return `${className && className !== 'Object' ? `'${className}'` : 'Object'} captured as exception with keys: ${keys}`;\n}\nfunction getObjectClassName(obj) {\n  try {\n    const prototype = Object.getPrototypeOf(obj);\n    return prototype ? prototype.constructor.name : undefined;\n  } catch {\n    // ignore errors here\n  }\n}\nfunction getException(client, mechanism, exception, hint) {\n  if (isError(exception)) {\n    return [exception, undefined];\n  }\n\n  // Mutate this!\n  mechanism.synthetic = true;\n  if (isPlainObject(exception)) {\n    const normalizeDepth = client?.getOptions().normalizeDepth;\n    const extras = {\n      ['__serialized__']: normalizeToSize(exception, normalizeDepth)\n    };\n    const errorFromProp = getErrorPropertyFromObject(exception);\n    if (errorFromProp) {\n      return [errorFromProp, extras];\n    }\n    const message = getMessageForObject(exception);\n    const ex = hint?.syntheticException || new Error(message);\n    ex.message = message;\n    return [ex, extras];\n  }\n\n  // This handles when someone does: `throw \"something awesome\";`\n  // We use synthesized Error here so we can extract a (rough) stack trace.\n  const ex = hint?.syntheticException || new Error(exception);\n  ex.message = `${exception}`;\n  return [ex, undefined];\n}\n\n/**\n * Builds and Event from a Exception\n * @hidden\n */\nfunction eventFromUnknownInput(client, stackParser, exception, hint) {\n  const providedMechanism = hint?.data && hint.data.mechanism;\n  const mechanism = providedMechanism || {\n    handled: true,\n    type: 'generic'\n  };\n  const [ex, extras] = getException(client, mechanism, exception, hint);\n  const event = {\n    exception: {\n      values: [exceptionFromError(stackParser, ex)]\n    }\n  };\n  if (extras) {\n    event.extra = extras;\n  }\n  addExceptionTypeValue(event, undefined, undefined);\n  addExceptionMechanism(event, mechanism);\n  return {\n    ...event,\n    event_id: hint?.event_id\n  };\n}\n\n/**\n * Builds and Event from a Message\n * @hidden\n */\nfunction eventFromMessage(stackParser, message, level = 'info', hint, attachStacktrace) {\n  const event = {\n    event_id: hint?.event_id,\n    level\n  };\n  if (attachStacktrace && hint?.syntheticException) {\n    const frames = parseStackFrames(stackParser, hint.syntheticException);\n    if (frames.length) {\n      event.exception = {\n        values: [{\n          value: message,\n          stacktrace: {\n            frames\n          }\n        }]\n      };\n      addExceptionMechanism(event, {\n        synthetic: true\n      });\n    }\n  }\n  if (isParameterizedString(message)) {\n    const {\n      __sentry_template_string__,\n      __sentry_template_values__\n    } = message;\n    event.logentry = {\n      message: __sentry_template_string__,\n      params: __sentry_template_values__\n    };\n    return event;\n  }\n  event.message = message;\n  return event;\n}\nexport { eventFromMessage, eventFromUnknownInput, exceptionFromError, parseStackFrames };\n//# sourceMappingURL=eventbuilder.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}