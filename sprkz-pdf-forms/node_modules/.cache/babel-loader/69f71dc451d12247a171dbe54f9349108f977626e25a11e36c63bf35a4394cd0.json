{"ast":null,"code":"import { SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD, SEMANTIC_ATTRIBUTE_URL_FULL, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '../semanticAttributes.js';\n\n// Curious about `thismessage:/`? See: https://www.rfc-editor.org/rfc/rfc2557.html\n//  > When the methods above do not yield an absolute URI, a base URL\n//  > of \"thismessage:/\" MUST be employed. This base URL has been\n//  > defined for the sole purpose of resolving relative references\n//  > within a multipart/related structure when no other base URI is\n//  > specified.\n//\n// We need to provide a base URL to `parseStringToURLObject` because the fetch API gives us a\n// relative URL sometimes.\n//\n// This is the only case where we need to provide a base URL to `parseStringToURLObject`\n// because the relative URL is not valid on its own.\nconst DEFAULT_BASE_URL = 'thismessage:/';\n\n/**\n * Checks if the URL object is relative\n *\n * @param url - The URL object to check\n * @returns True if the URL object is relative, false otherwise\n */\nfunction isURLObjectRelative(url) {\n  return 'isRelative' in url;\n}\n\n/**\n * Parses string to a URL object\n *\n * @param url - The URL to parse\n * @returns The parsed URL object or undefined if the URL is invalid\n */\nfunction parseStringToURLObject(url, urlBase) {\n  const isRelative = url.indexOf('://') <= 0 && url.indexOf('//') !== 0;\n  const base = urlBase ?? (isRelative ? DEFAULT_BASE_URL : undefined);\n  try {\n    // Use `canParse` to short-circuit the URL constructor if it's not a valid URL\n    // This is faster than trying to construct the URL and catching the error\n    // Node 20+, Chrome 120+, Firefox 115+, Safari 17+\n    if ('canParse' in URL && !URL.canParse(url, base)) {\n      return undefined;\n    }\n    const fullUrlObject = new URL(url, base);\n    if (isRelative) {\n      // Because we used a fake base URL, we need to return a relative URL object.\n      // We cannot return anything about the origin, host, etc. because it will refer to the fake base URL.\n      return {\n        isRelative,\n        pathname: fullUrlObject.pathname,\n        search: fullUrlObject.search,\n        hash: fullUrlObject.hash\n      };\n    }\n    return fullUrlObject;\n  } catch {\n    // empty body\n  }\n  return undefined;\n}\n\n/**\n * Takes a URL object and returns a sanitized string which is safe to use as span name\n * see: https://develop.sentry.dev/sdk/data-handling/#structuring-data\n */\nfunction getSanitizedUrlStringFromUrlObject(url) {\n  if (isURLObjectRelative(url)) {\n    return url.pathname;\n  }\n  const newUrl = new URL(url);\n  newUrl.search = '';\n  newUrl.hash = '';\n  if (['80', '443'].includes(newUrl.port)) {\n    newUrl.port = '';\n  }\n  if (newUrl.password) {\n    newUrl.password = '%filtered%';\n  }\n  if (newUrl.username) {\n    newUrl.username = '%filtered%';\n  }\n  return newUrl.toString();\n}\nfunction getHttpSpanNameFromUrlObject(urlObject, kind, request, routeName) {\n  const method = request?.method?.toUpperCase() ?? 'GET';\n  const route = routeName ? routeName : urlObject ? kind === 'client' ? getSanitizedUrlStringFromUrlObject(urlObject) : urlObject.pathname : '/';\n  return `${method} ${route}`;\n}\n\n/**\n * Takes a parsed URL object and returns a set of attributes for the span\n * that represents the HTTP request for that url. This is used for both server\n * and client http spans.\n *\n * Follows https://opentelemetry.io/docs/specs/semconv/http/.\n *\n * @param urlObject - see {@link parseStringToURLObject}\n * @param kind - The type of HTTP operation (server or client)\n * @param spanOrigin - The origin of the span\n * @param request - The request object, see {@link PartialRequest}\n * @param routeName - The name of the route, must be low cardinality\n * @returns The span name and attributes for the HTTP operation\n */\nfunction getHttpSpanDetailsFromUrlObject(urlObject, kind, spanOrigin, request, routeName) {\n  const attributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: spanOrigin,\n    [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url'\n  };\n  if (routeName) {\n    // This is based on https://opentelemetry.io/docs/specs/semconv/http/http-spans/#name\n    attributes[kind === 'server' ? 'http.route' : 'url.template'] = routeName;\n    attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] = 'route';\n  }\n  if (request?.method) {\n    attributes[SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD] = request.method.toUpperCase();\n  }\n  if (urlObject) {\n    if (urlObject.search) {\n      attributes['url.query'] = urlObject.search;\n    }\n    if (urlObject.hash) {\n      attributes['url.fragment'] = urlObject.hash;\n    }\n    if (urlObject.pathname) {\n      attributes['url.path'] = urlObject.pathname;\n      if (urlObject.pathname === '/') {\n        attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] = 'route';\n      }\n    }\n    if (!isURLObjectRelative(urlObject)) {\n      attributes[SEMANTIC_ATTRIBUTE_URL_FULL] = urlObject.href;\n      if (urlObject.port) {\n        attributes['url.port'] = urlObject.port;\n      }\n      if (urlObject.protocol) {\n        attributes['url.scheme'] = urlObject.protocol;\n      }\n      if (urlObject.hostname) {\n        attributes[kind === 'server' ? 'server.address' : 'url.domain'] = urlObject.hostname;\n      }\n    }\n  }\n  return [getHttpSpanNameFromUrlObject(urlObject, kind, request, routeName), attributes];\n}\n\n/**\n * Parses string form of URL into an object\n * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B\n * // intentionally using regex and not <a/> href parsing trick because React Native and other\n * // environments where DOM might not be available\n * @returns parsed URL object\n */\nfunction parseUrl(url) {\n  if (!url) {\n    return {};\n  }\n  const match = url.match(/^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/);\n  if (!match) {\n    return {};\n  }\n\n  // coerce to undefined values to empty string so we don't get 'undefined'\n  const query = match[6] || '';\n  const fragment = match[8] || '';\n  return {\n    host: match[4],\n    path: match[5],\n    protocol: match[2],\n    search: query,\n    hash: fragment,\n    relative: match[5] + query + fragment // everything minus origin\n  };\n}\n\n/**\n * Strip the query string and fragment off of a given URL or path (if present)\n *\n * @param urlPath Full URL or path, including possible query string and/or fragment\n * @returns URL or path without query string or fragment\n */\nfunction stripUrlQueryAndFragment(urlPath) {\n  return urlPath.split(/[?#]/, 1)[0];\n}\n\n/**\n * Takes a URL object and returns a sanitized string which is safe to use as span name\n * see: https://develop.sentry.dev/sdk/data-handling/#structuring-data\n */\nfunction getSanitizedUrlString(url) {\n  const {\n    protocol,\n    host,\n    path\n  } = url;\n  const filteredHost = host\n  // Always filter out authority\n  ?.replace(/^.*@/, '[filtered]:[filtered]@')\n  // Don't show standard :80 (http) and :443 (https) ports to reduce the noise\n  // TODO: Use new URL global if it exists\n  .replace(/(:80)$/, '').replace(/(:443)$/, '') || '';\n  return `${protocol ? `${protocol}://` : ''}${filteredHost}${path}`;\n}\nexport { getHttpSpanDetailsFromUrlObject, getSanitizedUrlString, getSanitizedUrlStringFromUrlObject, isURLObjectRelative, parseStringToURLObject, parseUrl, stripUrlQueryAndFragment };","map":{"version":3,"names":["DEFAULT_BASE_URL","isURLObjectRelative","url","parseStringToURLObject","urlBase","isRelative","indexOf","base","undefined","URL","canParse","fullUrlObject","pathname","search","hash","getSanitizedUrlStringFromUrlObject","newUrl","includes","port","password","username","toString","getHttpSpanNameFromUrlObject","urlObject","kind","request","routeName","method","toUpperCase","route","getHttpSpanDetailsFromUrlObject","spanOrigin","attributes","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD","SEMANTIC_ATTRIBUTE_URL_FULL","href","protocol","hostname","parseUrl","match","query","fragment","host","path","relative","stripUrlQueryAndFragment","urlPath","split","getSanitizedUrlString","filteredHost","replace"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/utils/url.ts"],"sourcesContent":["import {\n  SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  SEMANTIC_ATTRIBUTE_URL_FULL,\n} from '../semanticAttributes';\nimport type { SpanAttributes } from '../types-hoist/span';\n\ntype PartialURL = {\n  host?: string;\n  path?: string;\n  protocol?: string;\n  relative?: string;\n  search?: string;\n  hash?: string;\n};\n\ninterface URLwithCanParse extends URL {\n  canParse: (url: string, base?: string | URL | undefined) => boolean;\n}\n\n// A subset of the URL object that is valid for relative URLs\n// The URL object cannot handle relative URLs, so we need to handle them separately\ntype RelativeURL = {\n  isRelative: true;\n  pathname: URL['pathname'];\n  search: URL['search'];\n  hash: URL['hash'];\n};\n\ntype URLObject = RelativeURL | URL;\n\n// Curious about `thismessage:/`? See: https://www.rfc-editor.org/rfc/rfc2557.html\n//  > When the methods above do not yield an absolute URI, a base URL\n//  > of \"thismessage:/\" MUST be employed. This base URL has been\n//  > defined for the sole purpose of resolving relative references\n//  > within a multipart/related structure when no other base URI is\n//  > specified.\n//\n// We need to provide a base URL to `parseStringToURLObject` because the fetch API gives us a\n// relative URL sometimes.\n//\n// This is the only case where we need to provide a base URL to `parseStringToURLObject`\n// because the relative URL is not valid on its own.\nconst DEFAULT_BASE_URL = 'thismessage:/';\n\n/**\n * Checks if the URL object is relative\n *\n * @param url - The URL object to check\n * @returns True if the URL object is relative, false otherwise\n */\nexport function isURLObjectRelative(url: URLObject): url is RelativeURL {\n  return 'isRelative' in url;\n}\n\n/**\n * Parses string to a URL object\n *\n * @param url - The URL to parse\n * @returns The parsed URL object or undefined if the URL is invalid\n */\nexport function parseStringToURLObject(url: string, urlBase?: string | URL | undefined): URLObject | undefined {\n  const isRelative = url.indexOf('://') <= 0 && url.indexOf('//') !== 0;\n  const base = urlBase ?? (isRelative ? DEFAULT_BASE_URL : undefined);\n  try {\n    // Use `canParse` to short-circuit the URL constructor if it's not a valid URL\n    // This is faster than trying to construct the URL and catching the error\n    // Node 20+, Chrome 120+, Firefox 115+, Safari 17+\n    if ('canParse' in URL && !(URL as unknown as URLwithCanParse).canParse(url, base)) {\n      return undefined;\n    }\n\n    const fullUrlObject = new URL(url, base);\n    if (isRelative) {\n      // Because we used a fake base URL, we need to return a relative URL object.\n      // We cannot return anything about the origin, host, etc. because it will refer to the fake base URL.\n      return {\n        isRelative,\n        pathname: fullUrlObject.pathname,\n        search: fullUrlObject.search,\n        hash: fullUrlObject.hash,\n      };\n    }\n    return fullUrlObject;\n  } catch {\n    // empty body\n  }\n\n  return undefined;\n}\n\n/**\n * Takes a URL object and returns a sanitized string which is safe to use as span name\n * see: https://develop.sentry.dev/sdk/data-handling/#structuring-data\n */\nexport function getSanitizedUrlStringFromUrlObject(url: URLObject): string {\n  if (isURLObjectRelative(url)) {\n    return url.pathname;\n  }\n\n  const newUrl = new URL(url);\n  newUrl.search = '';\n  newUrl.hash = '';\n  if (['80', '443'].includes(newUrl.port)) {\n    newUrl.port = '';\n  }\n  if (newUrl.password) {\n    newUrl.password = '%filtered%';\n  }\n  if (newUrl.username) {\n    newUrl.username = '%filtered%';\n  }\n\n  return newUrl.toString();\n}\n\ntype PartialRequest = {\n  method?: string;\n};\n\nfunction getHttpSpanNameFromUrlObject(\n  urlObject: URLObject | undefined,\n  kind: 'server' | 'client',\n  request?: PartialRequest,\n  routeName?: string,\n): string {\n  const method = request?.method?.toUpperCase() ?? 'GET';\n  const route = routeName\n    ? routeName\n    : urlObject\n      ? kind === 'client'\n        ? getSanitizedUrlStringFromUrlObject(urlObject)\n        : urlObject.pathname\n      : '/';\n\n  return `${method} ${route}`;\n}\n\n/**\n * Takes a parsed URL object and returns a set of attributes for the span\n * that represents the HTTP request for that url. This is used for both server\n * and client http spans.\n *\n * Follows https://opentelemetry.io/docs/specs/semconv/http/.\n *\n * @param urlObject - see {@link parseStringToURLObject}\n * @param kind - The type of HTTP operation (server or client)\n * @param spanOrigin - The origin of the span\n * @param request - The request object, see {@link PartialRequest}\n * @param routeName - The name of the route, must be low cardinality\n * @returns The span name and attributes for the HTTP operation\n */\nexport function getHttpSpanDetailsFromUrlObject(\n  urlObject: URLObject | undefined,\n  kind: 'server' | 'client',\n  spanOrigin: string,\n  request?: PartialRequest,\n  routeName?: string,\n): [name: string, attributes: SpanAttributes] {\n  const attributes: SpanAttributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: spanOrigin,\n    [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n  };\n\n  if (routeName) {\n    // This is based on https://opentelemetry.io/docs/specs/semconv/http/http-spans/#name\n    attributes[kind === 'server' ? 'http.route' : 'url.template'] = routeName;\n    attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] = 'route';\n  }\n\n  if (request?.method) {\n    attributes[SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD] = request.method.toUpperCase();\n  }\n\n  if (urlObject) {\n    if (urlObject.search) {\n      attributes['url.query'] = urlObject.search;\n    }\n    if (urlObject.hash) {\n      attributes['url.fragment'] = urlObject.hash;\n    }\n    if (urlObject.pathname) {\n      attributes['url.path'] = urlObject.pathname;\n      if (urlObject.pathname === '/') {\n        attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] = 'route';\n      }\n    }\n\n    if (!isURLObjectRelative(urlObject)) {\n      attributes[SEMANTIC_ATTRIBUTE_URL_FULL] = urlObject.href;\n      if (urlObject.port) {\n        attributes['url.port'] = urlObject.port;\n      }\n      if (urlObject.protocol) {\n        attributes['url.scheme'] = urlObject.protocol;\n      }\n      if (urlObject.hostname) {\n        attributes[kind === 'server' ? 'server.address' : 'url.domain'] = urlObject.hostname;\n      }\n    }\n  }\n\n  return [getHttpSpanNameFromUrlObject(urlObject, kind, request, routeName), attributes];\n}\n\n/**\n * Parses string form of URL into an object\n * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B\n * // intentionally using regex and not <a/> href parsing trick because React Native and other\n * // environments where DOM might not be available\n * @returns parsed URL object\n */\nexport function parseUrl(url: string): PartialURL {\n  if (!url) {\n    return {};\n  }\n\n  const match = url.match(/^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/);\n\n  if (!match) {\n    return {};\n  }\n\n  // coerce to undefined values to empty string so we don't get 'undefined'\n  const query = match[6] || '';\n  const fragment = match[8] || '';\n  return {\n    host: match[4],\n    path: match[5],\n    protocol: match[2],\n    search: query,\n    hash: fragment,\n    relative: match[5] + query + fragment, // everything minus origin\n  };\n}\n\n/**\n * Strip the query string and fragment off of a given URL or path (if present)\n *\n * @param urlPath Full URL or path, including possible query string and/or fragment\n * @returns URL or path without query string or fragment\n */\nexport function stripUrlQueryAndFragment(urlPath: string): string {\n  return (urlPath.split(/[?#]/, 1) as [string, ...string[]])[0];\n}\n\n/**\n * Takes a URL object and returns a sanitized string which is safe to use as span name\n * see: https://develop.sentry.dev/sdk/data-handling/#structuring-data\n */\nexport function getSanitizedUrlString(url: PartialURL): string {\n  const { protocol, host, path } = url;\n\n  const filteredHost =\n    host\n      // Always filter out authority\n      ?.replace(/^.*@/, '[filtered]:[filtered]@')\n      // Don't show standard :80 (http) and :443 (https) ports to reduce the noise\n      // TODO: Use new URL global if it exists\n      .replace(/(:80)$/, '')\n      .replace(/(:443)$/, '') || '';\n\n  return `${protocol ? `${protocol}://` : ''}${filteredHost}${path}`;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}