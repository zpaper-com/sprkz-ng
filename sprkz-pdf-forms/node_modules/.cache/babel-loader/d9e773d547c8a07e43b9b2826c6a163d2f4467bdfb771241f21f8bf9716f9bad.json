{"ast":null,"code":"import { getSentryCarrier } from '../carrier.js';\nimport { dsnToString } from './dsn.js';\nimport { normalize } from './normalize.js';\nimport { GLOBAL_OBJ } from './worldwide.js';\n\n/**\n * Creates an envelope.\n * Make sure to always explicitly provide the generic to this function\n * so that the envelope types resolve correctly.\n */\nfunction createEnvelope(headers, items = []) {\n  return [headers, items];\n}\n\n/**\n * Add an item to an envelope.\n * Make sure to always explicitly provide the generic to this function\n * so that the envelope types resolve correctly.\n */\nfunction addItemToEnvelope(envelope, newItem) {\n  const [headers, items] = envelope;\n  return [headers, [...items, newItem]];\n}\n\n/**\n * Convenience function to loop through the items and item types of an envelope.\n * (This function was mostly created because working with envelope types is painful at the moment)\n *\n * If the callback returns true, the rest of the items will be skipped.\n */\nfunction forEachEnvelopeItem(envelope, callback) {\n  const envelopeItems = envelope[1];\n  for (const envelopeItem of envelopeItems) {\n    const envelopeItemType = envelopeItem[0].type;\n    const result = callback(envelopeItem, envelopeItemType);\n    if (result) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Returns true if the envelope contains any of the given envelope item types\n */\nfunction envelopeContainsItemType(envelope, types) {\n  return forEachEnvelopeItem(envelope, (_, type) => types.includes(type));\n}\n\n/**\n * Encode a string to UTF8 array.\n */\nfunction encodeUTF8(input) {\n  const carrier = getSentryCarrier(GLOBAL_OBJ);\n  return carrier.encodePolyfill ? carrier.encodePolyfill(input) : new TextEncoder().encode(input);\n}\n\n/**\n * Decode a UTF8 array to string.\n */\nfunction decodeUTF8(input) {\n  const carrier = getSentryCarrier(GLOBAL_OBJ);\n  return carrier.decodePolyfill ? carrier.decodePolyfill(input) : new TextDecoder().decode(input);\n}\n\n/**\n * Serializes an envelope.\n */\nfunction serializeEnvelope(envelope) {\n  const [envHeaders, items] = envelope;\n  // Initially we construct our envelope as a string and only convert to binary chunks if we encounter binary data\n  let parts = JSON.stringify(envHeaders);\n  function append(next) {\n    if (typeof parts === 'string') {\n      parts = typeof next === 'string' ? parts + next : [encodeUTF8(parts), next];\n    } else {\n      parts.push(typeof next === 'string' ? encodeUTF8(next) : next);\n    }\n  }\n  for (const item of items) {\n    const [itemHeaders, payload] = item;\n    append(`\\n${JSON.stringify(itemHeaders)}\\n`);\n    if (typeof payload === 'string' || payload instanceof Uint8Array) {\n      append(payload);\n    } else {\n      let stringifiedPayload;\n      try {\n        stringifiedPayload = JSON.stringify(payload);\n      } catch {\n        // In case, despite all our efforts to keep `payload` circular-dependency-free, `JSON.stringify()` still\n        // fails, we try again after normalizing it again with infinite normalization depth. This of course has a\n        // performance impact but in this case a performance hit is better than throwing.\n        stringifiedPayload = JSON.stringify(normalize(payload));\n      }\n      append(stringifiedPayload);\n    }\n  }\n  return typeof parts === 'string' ? parts : concatBuffers(parts);\n}\nfunction concatBuffers(buffers) {\n  const totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);\n  const merged = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const buffer of buffers) {\n    merged.set(buffer, offset);\n    offset += buffer.length;\n  }\n  return merged;\n}\n\n/**\n * Parses an envelope\n */\nfunction parseEnvelope(env) {\n  let buffer = typeof env === 'string' ? encodeUTF8(env) : env;\n  function readBinary(length) {\n    const bin = buffer.subarray(0, length);\n    // Replace the buffer with the remaining data excluding trailing newline\n    buffer = buffer.subarray(length + 1);\n    return bin;\n  }\n  function readJson() {\n    let i = buffer.indexOf(0xa);\n    // If we couldn't find a newline, we must have found the end of the buffer\n    if (i < 0) {\n      i = buffer.length;\n    }\n    return JSON.parse(decodeUTF8(readBinary(i)));\n  }\n  const envelopeHeader = readJson();\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const items = [];\n  while (buffer.length) {\n    const itemHeader = readJson();\n    const binaryLength = typeof itemHeader.length === 'number' ? itemHeader.length : undefined;\n    items.push([itemHeader, binaryLength ? readBinary(binaryLength) : readJson()]);\n  }\n  return [envelopeHeader, items];\n}\n\n/**\n * Creates envelope item for a single span\n */\nfunction createSpanEnvelopeItem(spanJson) {\n  const spanHeaders = {\n    type: 'span'\n  };\n  return [spanHeaders, spanJson];\n}\n\n/**\n * Creates attachment envelope items\n */\nfunction createAttachmentEnvelopeItem(attachment) {\n  const buffer = typeof attachment.data === 'string' ? encodeUTF8(attachment.data) : attachment.data;\n  return [{\n    type: 'attachment',\n    length: buffer.length,\n    filename: attachment.filename,\n    content_type: attachment.contentType,\n    attachment_type: attachment.attachmentType\n  }, buffer];\n}\nconst ITEM_TYPE_TO_DATA_CATEGORY_MAP = {\n  session: 'session',\n  sessions: 'session',\n  attachment: 'attachment',\n  transaction: 'transaction',\n  event: 'error',\n  client_report: 'internal',\n  user_report: 'default',\n  profile: 'profile',\n  profile_chunk: 'profile',\n  replay_event: 'replay',\n  replay_recording: 'replay',\n  check_in: 'monitor',\n  feedback: 'feedback',\n  span: 'span',\n  raw_security: 'security',\n  log: 'log_item'\n};\n\n/**\n * Maps the type of an envelope item to a data category.\n */\nfunction envelopeItemTypeToDataCategory(type) {\n  return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];\n}\n\n/** Extracts the minimal SDK info from the metadata or an events */\nfunction getSdkMetadataForEnvelopeHeader(metadataOrEvent) {\n  if (!metadataOrEvent?.sdk) {\n    return;\n  }\n  const {\n    name,\n    version\n  } = metadataOrEvent.sdk;\n  return {\n    name,\n    version\n  };\n}\n\n/**\n * Creates event envelope headers, based on event, sdk info and tunnel\n * Note: This function was extracted from the core package to make it available in Replay\n */\nfunction createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn) {\n  const dynamicSamplingContext = event.sdkProcessingMetadata?.dynamicSamplingContext;\n  return {\n    event_id: event.event_id,\n    sent_at: new Date().toISOString(),\n    ...(sdkInfo && {\n      sdk: sdkInfo\n    }),\n    ...(!!tunnel && dsn && {\n      dsn: dsnToString(dsn)\n    }),\n    ...(dynamicSamplingContext && {\n      trace: dynamicSamplingContext\n    })\n  };\n}\nexport { addItemToEnvelope, createAttachmentEnvelopeItem, createEnvelope, createEventEnvelopeHeaders, createSpanEnvelopeItem, envelopeContainsItemType, envelopeItemTypeToDataCategory, forEachEnvelopeItem, getSdkMetadataForEnvelopeHeader, parseEnvelope, serializeEnvelope };","map":{"version":3,"names":["createEnvelope","headers","items","addItemToEnvelope","envelope","newItem","forEachEnvelopeItem","callback","envelopeItems","envelopeItem","envelopeItemType","type","result","envelopeContainsItemType","types","_","includes","encodeUTF8","input","carrier","getSentryCarrier","GLOBAL_OBJ","encodePolyfill","TextEncoder","encode","decodeUTF8","decodePolyfill","TextDecoder","decode","serializeEnvelope","envHeaders","parts","JSON","stringify","append","next","push","item","itemHeaders","payload","Uint8Array","stringifiedPayload","normalize","concatBuffers","buffers","totalLength","reduce","acc","buf","length","merged","offset","buffer","set","parseEnvelope","env","readBinary","bin","subarray","readJson","i","indexOf","parse","envelopeHeader","itemHeader","binaryLength","undefined","createSpanEnvelopeItem","spanJson","spanHeaders","createAttachmentEnvelopeItem","attachment","data","filename","content_type","contentType","attachment_type","attachmentType","ITEM_TYPE_TO_DATA_CATEGORY_MAP","session","sessions","transaction","event","client_report","user_report","profile","profile_chunk","replay_event","replay_recording","check_in","feedback","span","raw_security","log","envelopeItemTypeToDataCategory","getSdkMetadataForEnvelopeHeader","metadataOrEvent","sdk","name","version","createEventEnvelopeHeaders","sdkInfo","tunnel","dsn","dynamicSamplingContext","sdkProcessingMetadata","event_id","sent_at","Date","toISOString","dsnToString","trace"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/utils/envelope.ts"],"sourcesContent":["import { getSentryCarrier } from '../carrier';\nimport type { Attachment } from '../types-hoist/attachment';\nimport type { DataCategory } from '../types-hoist/datacategory';\nimport type { DsnComponents } from '../types-hoist/dsn';\nimport type {\n  AttachmentItem,\n  BaseEnvelopeHeaders,\n  BaseEnvelopeItemHeaders,\n  Envelope,\n  EnvelopeItemType,\n  EventEnvelopeHeaders,\n  SpanItem,\n} from '../types-hoist/envelope';\nimport type { Event } from '../types-hoist/event';\nimport type { SdkInfo } from '../types-hoist/sdkinfo';\nimport type { SdkMetadata } from '../types-hoist/sdkmetadata';\nimport type { SpanJSON } from '../types-hoist/span';\nimport { dsnToString } from './dsn';\nimport { normalize } from './normalize';\nimport { GLOBAL_OBJ } from './worldwide';\n\n/**\n * Creates an envelope.\n * Make sure to always explicitly provide the generic to this function\n * so that the envelope types resolve correctly.\n */\nexport function createEnvelope<E extends Envelope>(headers: E[0], items: E[1] = []): E {\n  return [headers, items] as E;\n}\n\n/**\n * Add an item to an envelope.\n * Make sure to always explicitly provide the generic to this function\n * so that the envelope types resolve correctly.\n */\nexport function addItemToEnvelope<E extends Envelope>(envelope: E, newItem: E[1][number]): E {\n  const [headers, items] = envelope;\n  return [headers, [...items, newItem]] as unknown as E;\n}\n\n/**\n * Convenience function to loop through the items and item types of an envelope.\n * (This function was mostly created because working with envelope types is painful at the moment)\n *\n * If the callback returns true, the rest of the items will be skipped.\n */\nexport function forEachEnvelopeItem<E extends Envelope>(\n  envelope: Envelope,\n  callback: (envelopeItem: E[1][number], envelopeItemType: E[1][number][0]['type']) => boolean | void,\n): boolean {\n  const envelopeItems = envelope[1];\n\n  for (const envelopeItem of envelopeItems) {\n    const envelopeItemType = envelopeItem[0].type;\n    const result = callback(envelopeItem, envelopeItemType);\n\n    if (result) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Returns true if the envelope contains any of the given envelope item types\n */\nexport function envelopeContainsItemType(envelope: Envelope, types: EnvelopeItemType[]): boolean {\n  return forEachEnvelopeItem(envelope, (_, type) => types.includes(type));\n}\n\n/**\n * Encode a string to UTF8 array.\n */\nfunction encodeUTF8(input: string): Uint8Array {\n  const carrier = getSentryCarrier(GLOBAL_OBJ);\n  return carrier.encodePolyfill ? carrier.encodePolyfill(input) : new TextEncoder().encode(input);\n}\n\n/**\n * Decode a UTF8 array to string.\n */\nfunction decodeUTF8(input: Uint8Array): string {\n  const carrier = getSentryCarrier(GLOBAL_OBJ);\n  return carrier.decodePolyfill ? carrier.decodePolyfill(input) : new TextDecoder().decode(input);\n}\n\n/**\n * Serializes an envelope.\n */\nexport function serializeEnvelope(envelope: Envelope): string | Uint8Array {\n  const [envHeaders, items] = envelope;\n  // Initially we construct our envelope as a string and only convert to binary chunks if we encounter binary data\n  let parts: string | Uint8Array[] = JSON.stringify(envHeaders);\n\n  function append(next: string | Uint8Array): void {\n    if (typeof parts === 'string') {\n      parts = typeof next === 'string' ? parts + next : [encodeUTF8(parts), next];\n    } else {\n      parts.push(typeof next === 'string' ? encodeUTF8(next) : next);\n    }\n  }\n\n  for (const item of items) {\n    const [itemHeaders, payload] = item;\n\n    append(`\\n${JSON.stringify(itemHeaders)}\\n`);\n\n    if (typeof payload === 'string' || payload instanceof Uint8Array) {\n      append(payload);\n    } else {\n      let stringifiedPayload: string;\n      try {\n        stringifiedPayload = JSON.stringify(payload);\n      } catch {\n        // In case, despite all our efforts to keep `payload` circular-dependency-free, `JSON.stringify()` still\n        // fails, we try again after normalizing it again with infinite normalization depth. This of course has a\n        // performance impact but in this case a performance hit is better than throwing.\n        stringifiedPayload = JSON.stringify(normalize(payload));\n      }\n      append(stringifiedPayload);\n    }\n  }\n\n  return typeof parts === 'string' ? parts : concatBuffers(parts);\n}\n\nfunction concatBuffers(buffers: Uint8Array[]): Uint8Array {\n  const totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);\n\n  const merged = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const buffer of buffers) {\n    merged.set(buffer, offset);\n    offset += buffer.length;\n  }\n\n  return merged;\n}\n\n/**\n * Parses an envelope\n */\nexport function parseEnvelope(env: string | Uint8Array): Envelope {\n  let buffer = typeof env === 'string' ? encodeUTF8(env) : env;\n\n  function readBinary(length: number): Uint8Array {\n    const bin = buffer.subarray(0, length);\n    // Replace the buffer with the remaining data excluding trailing newline\n    buffer = buffer.subarray(length + 1);\n    return bin;\n  }\n\n  function readJson<T>(): T {\n    let i = buffer.indexOf(0xa);\n    // If we couldn't find a newline, we must have found the end of the buffer\n    if (i < 0) {\n      i = buffer.length;\n    }\n\n    return JSON.parse(decodeUTF8(readBinary(i))) as T;\n  }\n\n  const envelopeHeader = readJson<BaseEnvelopeHeaders>();\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const items: [any, any][] = [];\n\n  while (buffer.length) {\n    const itemHeader = readJson<BaseEnvelopeItemHeaders>();\n    const binaryLength = typeof itemHeader.length === 'number' ? itemHeader.length : undefined;\n\n    items.push([itemHeader, binaryLength ? readBinary(binaryLength) : readJson()]);\n  }\n\n  return [envelopeHeader, items];\n}\n\n/**\n * Creates envelope item for a single span\n */\nexport function createSpanEnvelopeItem(spanJson: Partial<SpanJSON>): SpanItem {\n  const spanHeaders: SpanItem[0] = {\n    type: 'span',\n  };\n\n  return [spanHeaders, spanJson];\n}\n\n/**\n * Creates attachment envelope items\n */\nexport function createAttachmentEnvelopeItem(attachment: Attachment): AttachmentItem {\n  const buffer = typeof attachment.data === 'string' ? encodeUTF8(attachment.data) : attachment.data;\n\n  return [\n    {\n      type: 'attachment',\n      length: buffer.length,\n      filename: attachment.filename,\n      content_type: attachment.contentType,\n      attachment_type: attachment.attachmentType,\n    },\n    buffer,\n  ];\n}\n\nconst ITEM_TYPE_TO_DATA_CATEGORY_MAP: Record<EnvelopeItemType, DataCategory> = {\n  session: 'session',\n  sessions: 'session',\n  attachment: 'attachment',\n  transaction: 'transaction',\n  event: 'error',\n  client_report: 'internal',\n  user_report: 'default',\n  profile: 'profile',\n  profile_chunk: 'profile',\n  replay_event: 'replay',\n  replay_recording: 'replay',\n  check_in: 'monitor',\n  feedback: 'feedback',\n  span: 'span',\n  raw_security: 'security',\n  log: 'log_item',\n};\n\n/**\n * Maps the type of an envelope item to a data category.\n */\nexport function envelopeItemTypeToDataCategory(type: EnvelopeItemType): DataCategory {\n  return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];\n}\n\n/** Extracts the minimal SDK info from the metadata or an events */\nexport function getSdkMetadataForEnvelopeHeader(metadataOrEvent?: SdkMetadata | Event): SdkInfo | undefined {\n  if (!metadataOrEvent?.sdk) {\n    return;\n  }\n  const { name, version } = metadataOrEvent.sdk;\n  return { name, version };\n}\n\n/**\n * Creates event envelope headers, based on event, sdk info and tunnel\n * Note: This function was extracted from the core package to make it available in Replay\n */\nexport function createEventEnvelopeHeaders(\n  event: Event,\n  sdkInfo: SdkInfo | undefined,\n  tunnel: string | undefined,\n  dsn?: DsnComponents,\n): EventEnvelopeHeaders {\n  const dynamicSamplingContext = event.sdkProcessingMetadata?.dynamicSamplingContext;\n  return {\n    event_id: event.event_id as string,\n    sent_at: new Date().toISOString(),\n    ...(sdkInfo && { sdk: sdkInfo }),\n    ...(!!tunnel && dsn && { dsn: dsnToString(dsn) }),\n    ...(dynamicSamplingContext && {\n      trace: dynamicSamplingContext,\n    }),\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}