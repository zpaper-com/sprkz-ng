{"ast":null,"code":"import { SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '../semanticAttributes.js';\nimport { spanToJSON } from './spanUtils.js';\nimport { AI_TOOL_CALL_NAME_ATTRIBUTE, AI_TOOL_CALL_ID_ATTRIBUTE, AI_MODEL_ID_ATTRIBUTE, AI_MODEL_PROVIDER_ATTRIBUTE, AI_TELEMETRY_FUNCTION_ID_ATTRIBUTE, AI_PROMPT_ATTRIBUTE, GEN_AI_RESPONSE_MODEL_ATTRIBUTE, GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE, GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE, AI_RESPONSE_PROVIDER_METADATA_ATTRIBUTE, AI_USAGE_COMPLETION_TOKENS_ATTRIBUTE, AI_USAGE_PROMPT_TOKENS_ATTRIBUTE, AI_PROMPT_MESSAGES_ATTRIBUTE, AI_RESPONSE_TEXT_ATTRIBUTE, AI_RESPONSE_TOOL_CALLS_ATTRIBUTE, AI_PROMPT_TOOLS_ATTRIBUTE, AI_TOOL_CALL_ARGS_ATTRIBUTE, AI_TOOL_CALL_RESULT_ATTRIBUTE } from './vercel-ai-attributes.js';\nfunction addOriginToSpan(span, origin) {\n  span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, origin);\n}\n\n/**\n * Post-process spans emitted by the Vercel AI SDK.\n * This is supposed to be used in `client.on('spanStart', ...)\n */\nfunction onVercelAiSpanStart(span) {\n  const {\n    data: attributes,\n    description: name\n  } = spanToJSON(span);\n  if (!name) {\n    return;\n  }\n\n  // Tool call spans\n  // https://ai-sdk.dev/docs/ai-sdk-core/telemetry#tool-call-spans\n  if (attributes[AI_TOOL_CALL_NAME_ATTRIBUTE] && attributes[AI_TOOL_CALL_ID_ATTRIBUTE] && name === 'ai.toolCall') {\n    processToolCallSpan(span, attributes);\n    return;\n  }\n\n  // The AI and Provider must be defined for generate, stream, and embed spans.\n  // The id of the model\n  const aiModelId = attributes[AI_MODEL_ID_ATTRIBUTE];\n  // the provider of the model\n  const aiModelProvider = attributes[AI_MODEL_PROVIDER_ATTRIBUTE];\n  if (typeof aiModelId !== 'string' || typeof aiModelProvider !== 'string' || !aiModelId || !aiModelProvider) {\n    return;\n  }\n  processGenerateSpan(span, name, attributes);\n}\nfunction vercelAiEventProcessor(event) {\n  if (event.type === 'transaction' && event.spans) {\n    for (const span of event.spans) {\n      // this mutates spans in-place\n      processEndedVercelAiSpan(span);\n    }\n  }\n  return event;\n}\n/**\n * Post-process spans emitted by the Vercel AI SDK.\n */\nfunction processEndedVercelAiSpan(span) {\n  const {\n    data: attributes,\n    origin\n  } = span;\n  if (origin !== 'auto.vercelai.otel') {\n    return;\n  }\n  renameAttributeKey(attributes, AI_USAGE_COMPLETION_TOKENS_ATTRIBUTE, GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE);\n  renameAttributeKey(attributes, AI_USAGE_PROMPT_TOKENS_ATTRIBUTE, GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE);\n  if (typeof attributes[GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE] === 'number' && typeof attributes[GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE] === 'number') {\n    attributes['gen_ai.usage.total_tokens'] = attributes[GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE] + attributes[GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE];\n  }\n\n  // Rename AI SDK attributes to standardized gen_ai attributes\n  renameAttributeKey(attributes, AI_PROMPT_MESSAGES_ATTRIBUTE, 'gen_ai.request.messages');\n  renameAttributeKey(attributes, AI_RESPONSE_TEXT_ATTRIBUTE, 'gen_ai.response.text');\n  renameAttributeKey(attributes, AI_RESPONSE_TOOL_CALLS_ATTRIBUTE, 'gen_ai.response.tool_calls');\n  renameAttributeKey(attributes, AI_PROMPT_TOOLS_ATTRIBUTE, 'gen_ai.request.available_tools');\n  renameAttributeKey(attributes, AI_TOOL_CALL_ARGS_ATTRIBUTE, 'gen_ai.tool.input');\n  renameAttributeKey(attributes, AI_TOOL_CALL_RESULT_ATTRIBUTE, 'gen_ai.tool.output');\n  addProviderMetadataToAttributes(attributes);\n\n  // Change attributes namespaced with `ai.X` to `vercel.ai.X`\n  for (const key of Object.keys(attributes)) {\n    if (key.startsWith('ai.')) {\n      renameAttributeKey(attributes, key, `vercel.${key}`);\n    }\n  }\n}\n\n/**\n * Renames an attribute key in the provided attributes object if the old key exists.\n * This function safely handles null and undefined values.\n */\nfunction renameAttributeKey(attributes, oldKey, newKey) {\n  if (attributes[oldKey] != null) {\n    attributes[newKey] = attributes[oldKey];\n    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n    delete attributes[oldKey];\n  }\n}\nfunction processToolCallSpan(span, attributes) {\n  addOriginToSpan(span, 'auto.vercelai.otel');\n  span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.execute_tool');\n  renameAttributeKey(attributes, AI_TOOL_CALL_NAME_ATTRIBUTE, 'gen_ai.tool.name');\n  renameAttributeKey(attributes, AI_TOOL_CALL_ID_ATTRIBUTE, 'gen_ai.tool.call.id');\n  // https://opentelemetry.io/docs/specs/semconv/registry/attributes/gen-ai/#gen-ai-tool-type\n  if (!attributes['gen_ai.tool.type']) {\n    span.setAttribute('gen_ai.tool.type', 'function');\n  }\n  const toolName = attributes['gen_ai.tool.name'];\n  if (toolName) {\n    span.updateName(`execute_tool ${toolName}`);\n  }\n}\nfunction processGenerateSpan(span, name, attributes) {\n  addOriginToSpan(span, 'auto.vercelai.otel');\n  const nameWthoutAi = name.replace('ai.', '');\n  span.setAttribute('ai.pipeline.name', nameWthoutAi);\n  span.updateName(nameWthoutAi);\n\n  // If a Telemetry name is set and it is a pipeline span, use that as the operation name\n  const functionId = attributes[AI_TELEMETRY_FUNCTION_ID_ATTRIBUTE];\n  if (functionId && typeof functionId === 'string' && name.split('.').length - 1 === 1) {\n    span.updateName(`${nameWthoutAi} ${functionId}`);\n    span.setAttribute('gen_ai.function_id', functionId);\n  }\n  if (attributes[AI_PROMPT_ATTRIBUTE]) {\n    span.setAttribute('gen_ai.prompt', attributes[AI_PROMPT_ATTRIBUTE]);\n  }\n  if (attributes[AI_MODEL_ID_ATTRIBUTE] && !attributes[GEN_AI_RESPONSE_MODEL_ATTRIBUTE]) {\n    span.setAttribute(GEN_AI_RESPONSE_MODEL_ATTRIBUTE, attributes[AI_MODEL_ID_ATTRIBUTE]);\n  }\n  span.setAttribute('ai.streaming', name.includes('stream'));\n\n  // Generate Spans\n  if (name === 'ai.generateText') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');\n    return;\n  }\n  if (name === 'ai.generateText.doGenerate') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.generate_text');\n    span.updateName(`generate_text ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);\n    return;\n  }\n  if (name === 'ai.streamText') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');\n    return;\n  }\n  if (name === 'ai.streamText.doStream') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.stream_text');\n    span.updateName(`stream_text ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);\n    return;\n  }\n  if (name === 'ai.generateObject') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');\n    return;\n  }\n  if (name === 'ai.generateObject.doGenerate') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.generate_object');\n    span.updateName(`generate_object ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);\n    return;\n  }\n  if (name === 'ai.streamObject') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');\n    return;\n  }\n  if (name === 'ai.streamObject.doStream') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.stream_object');\n    span.updateName(`stream_object ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);\n    return;\n  }\n  if (name === 'ai.embed') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');\n    return;\n  }\n  if (name === 'ai.embed.doEmbed') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.embed');\n    span.updateName(`embed ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);\n    return;\n  }\n  if (name === 'ai.embedMany') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');\n    return;\n  }\n  if (name === 'ai.embedMany.doEmbed') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.embed_many');\n    span.updateName(`embed_many ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);\n    return;\n  }\n  if (name.startsWith('ai.stream')) {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'ai.run');\n    return;\n  }\n}\n\n/**\n * Add event processors to the given client to process Vercel AI spans.\n */\nfunction addVercelAiProcessors(client) {\n  client.on('spanStart', onVercelAiSpanStart);\n  // Note: We cannot do this on `spanEnd`, because the span cannot be mutated anymore at this point\n  client.addEventProcessor(Object.assign(vercelAiEventProcessor, {\n    id: 'VercelAiEventProcessor'\n  }));\n}\nfunction addProviderMetadataToAttributes(attributes) {\n  const providerMetadata = attributes[AI_RESPONSE_PROVIDER_METADATA_ATTRIBUTE];\n  if (providerMetadata) {\n    try {\n      const providerMetadataObject = JSON.parse(providerMetadata);\n      if (providerMetadataObject.openai) {\n        setAttributeIfDefined(attributes, 'gen_ai.usage.input_tokens.cached', providerMetadataObject.openai.cachedPromptTokens);\n        setAttributeIfDefined(attributes, 'gen_ai.usage.output_tokens.reasoning', providerMetadataObject.openai.reasoningTokens);\n        setAttributeIfDefined(attributes, 'gen_ai.usage.output_tokens.prediction_accepted', providerMetadataObject.openai.acceptedPredictionTokens);\n        setAttributeIfDefined(attributes, 'gen_ai.usage.output_tokens.prediction_rejected', providerMetadataObject.openai.rejectedPredictionTokens);\n        setAttributeIfDefined(attributes, 'gen_ai.conversation.id', providerMetadataObject.openai.responseId);\n      }\n      if (providerMetadataObject.anthropic) {\n        setAttributeIfDefined(attributes, 'gen_ai.usage.input_tokens.cached', providerMetadataObject.anthropic.cacheReadInputTokens);\n        setAttributeIfDefined(attributes, 'gen_ai.usage.input_tokens.cache_write', providerMetadataObject.anthropic.cacheCreationInputTokens);\n      }\n      if (providerMetadataObject.bedrock?.usage) {\n        setAttributeIfDefined(attributes, 'gen_ai.usage.input_tokens.cached', providerMetadataObject.bedrock.usage.cacheReadInputTokens);\n        setAttributeIfDefined(attributes, 'gen_ai.usage.input_tokens.cache_write', providerMetadataObject.bedrock.usage.cacheWriteInputTokens);\n      }\n      if (providerMetadataObject.deepseek) {\n        setAttributeIfDefined(attributes, 'gen_ai.usage.input_tokens.cached', providerMetadataObject.deepseek.promptCacheHitTokens);\n        setAttributeIfDefined(attributes, 'gen_ai.usage.input_tokens.cache_miss', providerMetadataObject.deepseek.promptCacheMissTokens);\n      }\n    } catch {\n      // Ignore\n    }\n  }\n}\n\n/**\n * Sets an attribute only if the value is not null or undefined.\n */\nfunction setAttributeIfDefined(attributes, key, value) {\n  if (value != null) {\n    attributes[key] = value;\n  }\n}\nexport { addVercelAiProcessors };","map":{"version":3,"names":["addOriginToSpan","span","origin","setAttribute","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","onVercelAiSpanStart","data","attributes","description","name","spanToJSON","AI_TOOL_CALL_NAME_ATTRIBUTE","AI_TOOL_CALL_ID_ATTRIBUTE","processToolCallSpan","aiModelId","AI_MODEL_ID_ATTRIBUTE","aiModelProvider","AI_MODEL_PROVIDER_ATTRIBUTE","processGenerateSpan","vercelAiEventProcessor","event","type","spans","processEndedVercelAiSpan","renameAttributeKey","AI_USAGE_COMPLETION_TOKENS_ATTRIBUTE","GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE","AI_USAGE_PROMPT_TOKENS_ATTRIBUTE","GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE","AI_PROMPT_MESSAGES_ATTRIBUTE","AI_RESPONSE_TEXT_ATTRIBUTE","AI_RESPONSE_TOOL_CALLS_ATTRIBUTE","AI_PROMPT_TOOLS_ATTRIBUTE","AI_TOOL_CALL_ARGS_ATTRIBUTE","AI_TOOL_CALL_RESULT_ATTRIBUTE","addProviderMetadataToAttributes","key","Object","keys","startsWith","oldKey","newKey","SEMANTIC_ATTRIBUTE_SENTRY_OP","toolName","updateName","nameWthoutAi","replace","functionId","AI_TELEMETRY_FUNCTION_ID_ATTRIBUTE","split","length","AI_PROMPT_ATTRIBUTE","GEN_AI_RESPONSE_MODEL_ATTRIBUTE","includes","addVercelAiProcessors","client","on","addEventProcessor","assign","id","providerMetadata","AI_RESPONSE_PROVIDER_METADATA_ATTRIBUTE","providerMetadataObject","JSON","parse","openai","setAttributeIfDefined","cachedPromptTokens","reasoningTokens","acceptedPredictionTokens","rejectedPredictionTokens","responseId","anthropic","cacheReadInputTokens","cacheCreationInputTokens","bedrock","usage","cacheWriteInputTokens","deepseek","promptCacheHitTokens","promptCacheMissTokens","value"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/utils/vercel-ai.ts"],"sourcesContent":["import type { Client } from '../client';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '../semanticAttributes';\nimport type { Event } from '../types-hoist/event';\nimport type { Span, SpanAttributes, SpanAttributeValue, SpanJSON, SpanOrigin } from '../types-hoist/span';\nimport { spanToJSON } from './spanUtils';\nimport type { ProviderMetadata } from './vercel-ai-attributes';\nimport {\n  AI_MODEL_ID_ATTRIBUTE,\n  AI_MODEL_PROVIDER_ATTRIBUTE,\n  AI_PROMPT_ATTRIBUTE,\n  AI_PROMPT_MESSAGES_ATTRIBUTE,\n  AI_PROMPT_TOOLS_ATTRIBUTE,\n  AI_RESPONSE_PROVIDER_METADATA_ATTRIBUTE,\n  AI_RESPONSE_TEXT_ATTRIBUTE,\n  AI_RESPONSE_TOOL_CALLS_ATTRIBUTE,\n  AI_TELEMETRY_FUNCTION_ID_ATTRIBUTE,\n  AI_TOOL_CALL_ARGS_ATTRIBUTE,\n  AI_TOOL_CALL_ID_ATTRIBUTE,\n  AI_TOOL_CALL_NAME_ATTRIBUTE,\n  AI_TOOL_CALL_RESULT_ATTRIBUTE,\n  AI_USAGE_COMPLETION_TOKENS_ATTRIBUTE,\n  AI_USAGE_PROMPT_TOKENS_ATTRIBUTE,\n  GEN_AI_RESPONSE_MODEL_ATTRIBUTE,\n  GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE,\n  GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE,\n} from './vercel-ai-attributes';\n\nfunction addOriginToSpan(span: Span, origin: SpanOrigin): void {\n  span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, origin);\n}\n\n/**\n * Post-process spans emitted by the Vercel AI SDK.\n * This is supposed to be used in `client.on('spanStart', ...)\n */\nfunction onVercelAiSpanStart(span: Span): void {\n  const { data: attributes, description: name } = spanToJSON(span);\n\n  if (!name) {\n    return;\n  }\n\n  // Tool call spans\n  // https://ai-sdk.dev/docs/ai-sdk-core/telemetry#tool-call-spans\n  if (attributes[AI_TOOL_CALL_NAME_ATTRIBUTE] && attributes[AI_TOOL_CALL_ID_ATTRIBUTE] && name === 'ai.toolCall') {\n    processToolCallSpan(span, attributes);\n    return;\n  }\n\n  // The AI and Provider must be defined for generate, stream, and embed spans.\n  // The id of the model\n  const aiModelId = attributes[AI_MODEL_ID_ATTRIBUTE];\n  // the provider of the model\n  const aiModelProvider = attributes[AI_MODEL_PROVIDER_ATTRIBUTE];\n  if (typeof aiModelId !== 'string' || typeof aiModelProvider !== 'string' || !aiModelId || !aiModelProvider) {\n    return;\n  }\n\n  processGenerateSpan(span, name, attributes);\n}\n\nfunction vercelAiEventProcessor(event: Event): Event {\n  if (event.type === 'transaction' && event.spans) {\n    for (const span of event.spans) {\n      // this mutates spans in-place\n      processEndedVercelAiSpan(span);\n    }\n  }\n  return event;\n}\n/**\n * Post-process spans emitted by the Vercel AI SDK.\n */\nfunction processEndedVercelAiSpan(span: SpanJSON): void {\n  const { data: attributes, origin } = span;\n\n  if (origin !== 'auto.vercelai.otel') {\n    return;\n  }\n\n  renameAttributeKey(attributes, AI_USAGE_COMPLETION_TOKENS_ATTRIBUTE, GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE);\n  renameAttributeKey(attributes, AI_USAGE_PROMPT_TOKENS_ATTRIBUTE, GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE);\n\n  if (\n    typeof attributes[GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE] === 'number' &&\n    typeof attributes[GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE] === 'number'\n  ) {\n    attributes['gen_ai.usage.total_tokens'] =\n      attributes[GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE] + attributes[GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE];\n  }\n\n  // Rename AI SDK attributes to standardized gen_ai attributes\n  renameAttributeKey(attributes, AI_PROMPT_MESSAGES_ATTRIBUTE, 'gen_ai.request.messages');\n  renameAttributeKey(attributes, AI_RESPONSE_TEXT_ATTRIBUTE, 'gen_ai.response.text');\n  renameAttributeKey(attributes, AI_RESPONSE_TOOL_CALLS_ATTRIBUTE, 'gen_ai.response.tool_calls');\n  renameAttributeKey(attributes, AI_PROMPT_TOOLS_ATTRIBUTE, 'gen_ai.request.available_tools');\n\n  renameAttributeKey(attributes, AI_TOOL_CALL_ARGS_ATTRIBUTE, 'gen_ai.tool.input');\n  renameAttributeKey(attributes, AI_TOOL_CALL_RESULT_ATTRIBUTE, 'gen_ai.tool.output');\n\n  addProviderMetadataToAttributes(attributes);\n\n  // Change attributes namespaced with `ai.X` to `vercel.ai.X`\n  for (const key of Object.keys(attributes)) {\n    if (key.startsWith('ai.')) {\n      renameAttributeKey(attributes, key, `vercel.${key}`);\n    }\n  }\n}\n\n/**\n * Renames an attribute key in the provided attributes object if the old key exists.\n * This function safely handles null and undefined values.\n */\nfunction renameAttributeKey(attributes: Record<string, unknown>, oldKey: string, newKey: string): void {\n  if (attributes[oldKey] != null) {\n    attributes[newKey] = attributes[oldKey];\n    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n    delete attributes[oldKey];\n  }\n}\n\nfunction processToolCallSpan(span: Span, attributes: SpanAttributes): void {\n  addOriginToSpan(span, 'auto.vercelai.otel');\n  span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.execute_tool');\n  renameAttributeKey(attributes, AI_TOOL_CALL_NAME_ATTRIBUTE, 'gen_ai.tool.name');\n  renameAttributeKey(attributes, AI_TOOL_CALL_ID_ATTRIBUTE, 'gen_ai.tool.call.id');\n  // https://opentelemetry.io/docs/specs/semconv/registry/attributes/gen-ai/#gen-ai-tool-type\n  if (!attributes['gen_ai.tool.type']) {\n    span.setAttribute('gen_ai.tool.type', 'function');\n  }\n  const toolName = attributes['gen_ai.tool.name'];\n  if (toolName) {\n    span.updateName(`execute_tool ${toolName}`);\n  }\n}\n\nfunction processGenerateSpan(span: Span, name: string, attributes: SpanAttributes): void {\n  addOriginToSpan(span, 'auto.vercelai.otel');\n\n  const nameWthoutAi = name.replace('ai.', '');\n  span.setAttribute('ai.pipeline.name', nameWthoutAi);\n  span.updateName(nameWthoutAi);\n\n  // If a Telemetry name is set and it is a pipeline span, use that as the operation name\n  const functionId = attributes[AI_TELEMETRY_FUNCTION_ID_ATTRIBUTE];\n  if (functionId && typeof functionId === 'string' && name.split('.').length - 1 === 1) {\n    span.updateName(`${nameWthoutAi} ${functionId}`);\n    span.setAttribute('gen_ai.function_id', functionId);\n  }\n\n  if (attributes[AI_PROMPT_ATTRIBUTE]) {\n    span.setAttribute('gen_ai.prompt', attributes[AI_PROMPT_ATTRIBUTE]);\n  }\n  if (attributes[AI_MODEL_ID_ATTRIBUTE] && !attributes[GEN_AI_RESPONSE_MODEL_ATTRIBUTE]) {\n    span.setAttribute(GEN_AI_RESPONSE_MODEL_ATTRIBUTE, attributes[AI_MODEL_ID_ATTRIBUTE]);\n  }\n  span.setAttribute('ai.streaming', name.includes('stream'));\n\n  // Generate Spans\n  if (name === 'ai.generateText') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');\n    return;\n  }\n\n  if (name === 'ai.generateText.doGenerate') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.generate_text');\n    span.updateName(`generate_text ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);\n    return;\n  }\n\n  if (name === 'ai.streamText') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');\n    return;\n  }\n\n  if (name === 'ai.streamText.doStream') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.stream_text');\n    span.updateName(`stream_text ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);\n    return;\n  }\n\n  if (name === 'ai.generateObject') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');\n    return;\n  }\n\n  if (name === 'ai.generateObject.doGenerate') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.generate_object');\n    span.updateName(`generate_object ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);\n    return;\n  }\n\n  if (name === 'ai.streamObject') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');\n    return;\n  }\n\n  if (name === 'ai.streamObject.doStream') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.stream_object');\n    span.updateName(`stream_object ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);\n    return;\n  }\n\n  if (name === 'ai.embed') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');\n    return;\n  }\n\n  if (name === 'ai.embed.doEmbed') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.embed');\n    span.updateName(`embed ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);\n    return;\n  }\n\n  if (name === 'ai.embedMany') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');\n    return;\n  }\n\n  if (name === 'ai.embedMany.doEmbed') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.embed_many');\n    span.updateName(`embed_many ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);\n    return;\n  }\n\n  if (name.startsWith('ai.stream')) {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'ai.run');\n    return;\n  }\n}\n\n/**\n * Add event processors to the given client to process Vercel AI spans.\n */\nexport function addVercelAiProcessors(client: Client): void {\n  client.on('spanStart', onVercelAiSpanStart);\n  // Note: We cannot do this on `spanEnd`, because the span cannot be mutated anymore at this point\n  client.addEventProcessor(Object.assign(vercelAiEventProcessor, { id: 'VercelAiEventProcessor' }));\n}\n\nfunction addProviderMetadataToAttributes(attributes: SpanAttributes): void {\n  const providerMetadata = attributes[AI_RESPONSE_PROVIDER_METADATA_ATTRIBUTE] as string | undefined;\n  if (providerMetadata) {\n    try {\n      const providerMetadataObject = JSON.parse(providerMetadata) as ProviderMetadata;\n      if (providerMetadataObject.openai) {\n        setAttributeIfDefined(\n          attributes,\n          'gen_ai.usage.input_tokens.cached',\n          providerMetadataObject.openai.cachedPromptTokens,\n        );\n        setAttributeIfDefined(\n          attributes,\n          'gen_ai.usage.output_tokens.reasoning',\n          providerMetadataObject.openai.reasoningTokens,\n        );\n        setAttributeIfDefined(\n          attributes,\n          'gen_ai.usage.output_tokens.prediction_accepted',\n          providerMetadataObject.openai.acceptedPredictionTokens,\n        );\n        setAttributeIfDefined(\n          attributes,\n          'gen_ai.usage.output_tokens.prediction_rejected',\n          providerMetadataObject.openai.rejectedPredictionTokens,\n        );\n        setAttributeIfDefined(attributes, 'gen_ai.conversation.id', providerMetadataObject.openai.responseId);\n      }\n\n      if (providerMetadataObject.anthropic) {\n        setAttributeIfDefined(\n          attributes,\n          'gen_ai.usage.input_tokens.cached',\n          providerMetadataObject.anthropic.cacheReadInputTokens,\n        );\n        setAttributeIfDefined(\n          attributes,\n          'gen_ai.usage.input_tokens.cache_write',\n          providerMetadataObject.anthropic.cacheCreationInputTokens,\n        );\n      }\n\n      if (providerMetadataObject.bedrock?.usage) {\n        setAttributeIfDefined(\n          attributes,\n          'gen_ai.usage.input_tokens.cached',\n          providerMetadataObject.bedrock.usage.cacheReadInputTokens,\n        );\n        setAttributeIfDefined(\n          attributes,\n          'gen_ai.usage.input_tokens.cache_write',\n          providerMetadataObject.bedrock.usage.cacheWriteInputTokens,\n        );\n      }\n\n      if (providerMetadataObject.deepseek) {\n        setAttributeIfDefined(\n          attributes,\n          'gen_ai.usage.input_tokens.cached',\n          providerMetadataObject.deepseek.promptCacheHitTokens,\n        );\n        setAttributeIfDefined(\n          attributes,\n          'gen_ai.usage.input_tokens.cache_miss',\n          providerMetadataObject.deepseek.promptCacheMissTokens,\n        );\n      }\n    } catch {\n      // Ignore\n    }\n  }\n}\n\n/**\n * Sets an attribute only if the value is not null or undefined.\n */\nfunction setAttributeIfDefined(attributes: SpanAttributes, key: string, value: SpanAttributeValue | undefined): void {\n  if (value != null) {\n    attributes[key] = value;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}