{"ast":null,"code":"import { withScope, captureException } from '@sentry/browser';\nimport { isError } from '@sentry/core';\nimport { version } from 'react';\n\n/**\n * See if React major version is 17+ by parsing version string.\n */\nfunction isAtLeastReact17(reactVersion) {\n  const reactMajor = reactVersion.match(/^([^.]+)/);\n  return reactMajor !== null && parseInt(reactMajor[0]) >= 17;\n}\n\n/**\n * Recurse through `error.cause` chain to set cause on an error.\n */\nfunction setCause(error, cause) {\n  const seenErrors = new WeakSet();\n  function recurse(error, cause) {\n    // If we've already seen the error, there is a recursive loop somewhere in the error's\n    // cause chain. Let's just bail out then to prevent a stack overflow.\n    if (seenErrors.has(error)) {\n      return;\n    }\n    if (error.cause) {\n      seenErrors.add(error);\n      return recurse(error.cause, cause);\n    }\n    error.cause = cause;\n  }\n  recurse(error, cause);\n}\n\n/**\n * Captures an error that was thrown by a React ErrorBoundary or React root.\n *\n * @param error The error to capture.\n * @param errorInfo The errorInfo provided by React.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured Sentry event.\n */\nfunction captureReactException(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nerror, _ref, hint) {\n  let {\n    componentStack\n  } = _ref;\n  // If on React version >= 17, create stack trace from componentStack param and links\n  // to to the original error using `error.cause` otherwise relies on error param for stacktrace.\n  // Linking errors requires the `LinkedErrors` integration be enabled.\n  // See: https://reactjs.org/blog/2020/08/10/react-v17-rc.html#native-component-stacks\n  //\n  // Although `componentDidCatch` is typed to accept an `Error` object, it can also be invoked\n  // with non-error objects. This is why we need to check if the error is an error-like object.\n  // See: https://github.com/getsentry/sentry-javascript/issues/6167\n  if (isAtLeastReact17(version) && isError(error) && componentStack) {\n    const errorBoundaryError = new Error(error.message);\n    errorBoundaryError.name = `React ErrorBoundary ${error.name}`;\n    errorBoundaryError.stack = componentStack;\n\n    // Using the `LinkedErrors` integration to link the errors together.\n    setCause(error, errorBoundaryError);\n  }\n  return withScope(scope => {\n    scope.setContext('react', {\n      componentStack\n    });\n    return captureException(error, hint);\n  });\n}\n\n/**\n * Creates an error handler that can be used with the `onCaughtError`, `onUncaughtError`,\n * and `onRecoverableError` options in `createRoot` and `hydrateRoot` React DOM methods.\n *\n * @param callback An optional callback that will be called after the error is captured.\n * Use this to add custom handling for errors.\n *\n * @example\n *\n * ```JavaScript\n * const root = createRoot(container, {\n *  onCaughtError: Sentry.reactErrorHandler(),\n *  onUncaughtError: Sentry.reactErrorHandler((error, errorInfo) => {\n *    console.warn('Caught error', error, errorInfo.componentStack);\n *  });\n * });\n * ```\n */\nfunction reactErrorHandler(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ncallback\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return (error, errorInfo) => {\n    const eventId = captureReactException(error, errorInfo);\n    if (callback) {\n      callback(error, errorInfo, eventId);\n    }\n  };\n}\nexport { captureReactException, isAtLeastReact17, reactErrorHandler, setCause };\n//# sourceMappingURL=error.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}