{"ast":null,"code":"import { isThenable } from './is.js';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/** SyncPromise internal states */\nconst STATE_PENDING = 0;\nconst STATE_RESOLVED = 1;\nconst STATE_REJECTED = 2;\n\n/**\n * Creates a resolved sync promise.\n *\n * @param value the value to resolve the promise with\n * @returns the resolved sync promise\n */\nfunction resolvedSyncPromise(value) {\n  return new SyncPromise(resolve => {\n    resolve(value);\n  });\n}\n\n/**\n * Creates a rejected sync promise.\n *\n * @param value the value to reject the promise with\n * @returns the rejected sync promise\n */\nfunction rejectedSyncPromise(reason) {\n  return new SyncPromise((_, reject) => {\n    reject(reason);\n  });\n}\n\n/**\n * Thenable class that behaves like a Promise and follows it's interface\n * but is not async internally\n */\nclass SyncPromise {\n  constructor(executor) {\n    this._state = STATE_PENDING;\n    this._handlers = [];\n    this._runExecutor(executor);\n  }\n\n  /** @inheritdoc */\n  then(onfulfilled, onrejected) {\n    return new SyncPromise((resolve, reject) => {\n      this._handlers.push([false, result => {\n        if (!onfulfilled) {\n          // TODO: ¯\\_(ツ)_/¯\n          // TODO: FIXME\n          resolve(result);\n        } else {\n          try {\n            resolve(onfulfilled(result));\n          } catch (e) {\n            reject(e);\n          }\n        }\n      }, reason => {\n        if (!onrejected) {\n          reject(reason);\n        } else {\n          try {\n            resolve(onrejected(reason));\n          } catch (e) {\n            reject(e);\n          }\n        }\n      }]);\n      this._executeHandlers();\n    });\n  }\n\n  /** @inheritdoc */\n  catch(onrejected) {\n    return this.then(val => val, onrejected);\n  }\n\n  /** @inheritdoc */\n  finally(onfinally) {\n    return new SyncPromise((resolve, reject) => {\n      let val;\n      let isRejected;\n      return this.then(value => {\n        isRejected = false;\n        val = value;\n        if (onfinally) {\n          onfinally();\n        }\n      }, reason => {\n        isRejected = true;\n        val = reason;\n        if (onfinally) {\n          onfinally();\n        }\n      }).then(() => {\n        if (isRejected) {\n          reject(val);\n          return;\n        }\n        resolve(val);\n      });\n    });\n  }\n\n  /** Excute the resolve/reject handlers. */\n  _executeHandlers() {\n    if (this._state === STATE_PENDING) {\n      return;\n    }\n    const cachedHandlers = this._handlers.slice();\n    this._handlers = [];\n    cachedHandlers.forEach(handler => {\n      if (handler[0]) {\n        return;\n      }\n      if (this._state === STATE_RESOLVED) {\n        handler[1](this._value);\n      }\n      if (this._state === STATE_REJECTED) {\n        handler[2](this._value);\n      }\n      handler[0] = true;\n    });\n  }\n\n  /** Run the executor for the SyncPromise. */\n  _runExecutor(executor) {\n    const setResult = (state, value) => {\n      if (this._state !== STATE_PENDING) {\n        return;\n      }\n      if (isThenable(value)) {\n        void value.then(resolve, reject);\n        return;\n      }\n      this._state = state;\n      this._value = value;\n      this._executeHandlers();\n    };\n    const resolve = value => {\n      setResult(STATE_RESOLVED, value);\n    };\n    const reject = reason => {\n      setResult(STATE_REJECTED, reason);\n    };\n    try {\n      executor(resolve, reject);\n    } catch (e) {\n      reject(e);\n    }\n  }\n}\nexport { SyncPromise, rejectedSyncPromise, resolvedSyncPromise };","map":{"version":3,"names":["STATE_PENDING","STATE_RESOLVED","STATE_REJECTED","resolvedSyncPromise","value","SyncPromise","resolve","rejectedSyncPromise","reason","_","reject","constructor","executor","_state","_handlers","_runExecutor","then","onfulfilled","onrejected","push","result","e","_executeHandlers","catch","val","finally","onfinally","isRejected","cachedHandlers","slice","forEach","handler","_value","setResult","state","isThenable"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/utils/syncpromise.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { isThenable } from './is';\n\n/** SyncPromise internal states */\nconst STATE_PENDING = 0;\nconst STATE_RESOLVED = 1;\nconst STATE_REJECTED = 2;\n\ntype State = typeof STATE_PENDING | typeof STATE_RESOLVED | typeof STATE_REJECTED;\n\n// Overloads so we can call resolvedSyncPromise without arguments and generic argument\nexport function resolvedSyncPromise(): PromiseLike<void>;\nexport function resolvedSyncPromise<T>(value: T | PromiseLike<T>): PromiseLike<T>;\n\n/**\n * Creates a resolved sync promise.\n *\n * @param value the value to resolve the promise with\n * @returns the resolved sync promise\n */\nexport function resolvedSyncPromise<T>(value?: T | PromiseLike<T>): PromiseLike<T> {\n  return new SyncPromise(resolve => {\n    resolve(value);\n  });\n}\n\n/**\n * Creates a rejected sync promise.\n *\n * @param value the value to reject the promise with\n * @returns the rejected sync promise\n */\nexport function rejectedSyncPromise<T = never>(reason?: any): PromiseLike<T> {\n  return new SyncPromise((_, reject) => {\n    reject(reason);\n  });\n}\n\ntype Executor<T> = (resolve: (value?: T | PromiseLike<T> | null) => void, reject: (reason?: any) => void) => void;\n\n/**\n * Thenable class that behaves like a Promise and follows it's interface\n * but is not async internally\n */\nexport class SyncPromise<T> implements PromiseLike<T> {\n  private _state: State;\n  private _handlers: Array<[boolean, (value: T) => void, (reason: any) => any]>;\n  private _value: any;\n\n  public constructor(executor: Executor<T>) {\n    this._state = STATE_PENDING;\n    this._handlers = [];\n\n    this._runExecutor(executor);\n  }\n\n  /** @inheritdoc */\n  public then<TResult1 = T, TResult2 = never>(\n    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,\n  ): PromiseLike<TResult1 | TResult2> {\n    return new SyncPromise((resolve, reject) => {\n      this._handlers.push([\n        false,\n        result => {\n          if (!onfulfilled) {\n            // TODO: ¯\\_(ツ)_/¯\n            // TODO: FIXME\n            resolve(result as any);\n          } else {\n            try {\n              resolve(onfulfilled(result));\n            } catch (e) {\n              reject(e);\n            }\n          }\n        },\n        reason => {\n          if (!onrejected) {\n            reject(reason);\n          } else {\n            try {\n              resolve(onrejected(reason));\n            } catch (e) {\n              reject(e);\n            }\n          }\n        },\n      ]);\n      this._executeHandlers();\n    });\n  }\n\n  /** @inheritdoc */\n  public catch<TResult = never>(\n    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,\n  ): PromiseLike<T | TResult> {\n    return this.then(val => val, onrejected);\n  }\n\n  /** @inheritdoc */\n  public finally<TResult>(onfinally?: (() => void) | null): PromiseLike<TResult> {\n    return new SyncPromise<TResult>((resolve, reject) => {\n      let val: TResult | any;\n      let isRejected: boolean;\n\n      return this.then(\n        value => {\n          isRejected = false;\n          val = value;\n          if (onfinally) {\n            onfinally();\n          }\n        },\n        reason => {\n          isRejected = true;\n          val = reason;\n          if (onfinally) {\n            onfinally();\n          }\n        },\n      ).then(() => {\n        if (isRejected) {\n          reject(val);\n          return;\n        }\n\n        resolve(val as unknown as any);\n      });\n    });\n  }\n\n  /** Excute the resolve/reject handlers. */\n  private _executeHandlers(): void {\n    if (this._state === STATE_PENDING) {\n      return;\n    }\n\n    const cachedHandlers = this._handlers.slice();\n    this._handlers = [];\n\n    cachedHandlers.forEach(handler => {\n      if (handler[0]) {\n        return;\n      }\n\n      if (this._state === STATE_RESOLVED) {\n        handler[1](this._value as unknown as any);\n      }\n\n      if (this._state === STATE_REJECTED) {\n        handler[2](this._value);\n      }\n\n      handler[0] = true;\n    });\n  }\n\n  /** Run the executor for the SyncPromise. */\n  private _runExecutor(executor: Executor<T>): void {\n    const setResult = (state: State, value?: T | PromiseLike<T> | any): void => {\n      if (this._state !== STATE_PENDING) {\n        return;\n      }\n\n      if (isThenable(value)) {\n        void (value as PromiseLike<T>).then(resolve, reject);\n        return;\n      }\n\n      this._state = state;\n      this._value = value;\n\n      this._executeHandlers();\n    };\n\n    const resolve = (value: unknown): void => {\n      setResult(STATE_RESOLVED, value);\n    };\n\n    const reject = (reason: unknown): void => {\n      setResult(STATE_REJECTED, reason);\n    };\n\n    try {\n      executor(resolve, reject);\n    } catch (e) {\n      reject(e);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}