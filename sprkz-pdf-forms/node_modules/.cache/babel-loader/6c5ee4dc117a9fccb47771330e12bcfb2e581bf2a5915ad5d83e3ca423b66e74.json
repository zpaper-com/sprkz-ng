{"ast":null,"code":"import { browserTracingIntegration, WINDOW, startBrowserTracingPageLoadSpan, startBrowserTracingNavigationSpan } from '@sentry/browser';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, debug, getActiveSpan, getRootSpan, spanToJSON, getCurrentScope, getClient } from '@sentry/core';\nimport * as React from 'react';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { hoistNonReactStatics } from './hoist-non-react-statics.js';\n\n/* eslint-disable max-lines */\n// Inspired from Donnie McNeal's solution:\n// https://gist.github.com/wontondon/e8c4bdf2888875e4c755712e99279536\n\nlet _useEffect;\nlet _useLocation;\nlet _useNavigationType;\nlet _createRoutesFromChildren;\nlet _matchRoutes;\nlet _stripBasename = false;\nconst CLIENTS_WITH_INSTRUMENT_NAVIGATION = new WeakSet();\n\n// Keeping as a global variable for cross-usage in multiple functions\nconst allRoutes = new Set();\n\n/**\n * Creates a wrapCreateBrowserRouter function that can be used with all React Router v6 compatible versions.\n */\nfunction createV6CompatibleWrapCreateBrowserRouter(createRouterFunction, version) {\n  if (!_useEffect || !_useLocation || !_useNavigationType || !_matchRoutes) {\n    DEBUG_BUILD && debug.warn(`reactRouterV${version}Instrumentation was unable to wrap the \\`createRouter\\` function because of one or more missing parameters.`);\n    return createRouterFunction;\n  }\n  return function (routes, opts) {\n    addRoutesToAllRoutes(routes);\n    const router = createRouterFunction(routes, opts);\n    const basename = opts?.basename;\n    const activeRootSpan = getActiveRootSpan();\n\n    // The initial load ends when `createBrowserRouter` is called.\n    // This is the earliest convenient time to update the transaction name.\n    // Callbacks to `router.subscribe` are not called for the initial load.\n    if (router.state.historyAction === 'POP' && activeRootSpan) {\n      updatePageloadTransaction(activeRootSpan, router.state.location, routes, undefined, basename, Array.from(allRoutes));\n    }\n    router.subscribe(state => {\n      if (state.historyAction === 'PUSH' || state.historyAction === 'POP') {\n        // Wait for the next render if loading an unsettled route\n        if (state.navigation.state !== 'idle') {\n          requestAnimationFrame(() => {\n            handleNavigation({\n              location: state.location,\n              routes,\n              navigationType: state.historyAction,\n              version,\n              basename,\n              allRoutes: Array.from(allRoutes)\n            });\n          });\n        } else {\n          handleNavigation({\n            location: state.location,\n            routes,\n            navigationType: state.historyAction,\n            version,\n            basename,\n            allRoutes: Array.from(allRoutes)\n          });\n        }\n      }\n    });\n    return router;\n  };\n}\n\n/**\n * Creates a wrapCreateMemoryRouter function that can be used with all React Router v6 compatible versions.\n */\nfunction createV6CompatibleWrapCreateMemoryRouter(createRouterFunction, version) {\n  if (!_useEffect || !_useLocation || !_useNavigationType || !_matchRoutes) {\n    DEBUG_BUILD && debug.warn(`reactRouterV${version}Instrumentation was unable to wrap the \\`createMemoryRouter\\` function because of one or more missing parameters.`);\n    return createRouterFunction;\n  }\n  return function (routes, opts) {\n    addRoutesToAllRoutes(routes);\n    const router = createRouterFunction(routes, opts);\n    const basename = opts?.basename;\n    const activeRootSpan = getActiveRootSpan();\n    let initialEntry = undefined;\n    const initialEntries = opts?.initialEntries;\n    const initialIndex = opts?.initialIndex;\n    const hasOnlyOneInitialEntry = initialEntries && initialEntries.length === 1;\n    const hasIndexedEntry = initialIndex !== undefined && initialEntries && initialEntries[initialIndex];\n    initialEntry = hasOnlyOneInitialEntry ? initialEntries[0] : hasIndexedEntry ? initialEntries[initialIndex] : undefined;\n    const location = initialEntry ? typeof initialEntry === 'string' ? {\n      pathname: initialEntry\n    } : initialEntry : router.state.location;\n    if (router.state.historyAction === 'POP' && activeRootSpan) {\n      updatePageloadTransaction(activeRootSpan, location, routes, undefined, basename, Array.from(allRoutes));\n    }\n    router.subscribe(state => {\n      const location = state.location;\n      if (state.historyAction === 'PUSH' || state.historyAction === 'POP') {\n        handleNavigation({\n          location,\n          routes,\n          navigationType: state.historyAction,\n          version,\n          basename,\n          allRoutes: Array.from(allRoutes)\n        });\n      }\n    });\n    return router;\n  };\n}\n\n/**\n * Creates a browser tracing integration that can be used with all React Router v6 compatible versions.\n */\nfunction createReactRouterV6CompatibleTracingIntegration(options, version) {\n  const integration = browserTracingIntegration({\n    ...options,\n    instrumentPageLoad: false,\n    instrumentNavigation: false\n  });\n  const {\n    useEffect,\n    useLocation,\n    useNavigationType,\n    createRoutesFromChildren,\n    matchRoutes,\n    stripBasename,\n    instrumentPageLoad = true,\n    instrumentNavigation = true\n  } = options;\n  return {\n    ...integration,\n    setup(client) {\n      integration.setup(client);\n      _useEffect = useEffect;\n      _useLocation = useLocation;\n      _useNavigationType = useNavigationType;\n      _matchRoutes = matchRoutes;\n      _createRoutesFromChildren = createRoutesFromChildren;\n      _stripBasename = stripBasename || false;\n    },\n    afterAllSetup(client) {\n      integration.afterAllSetup(client);\n      const initPathName = WINDOW.location?.pathname;\n      if (instrumentPageLoad && initPathName) {\n        startBrowserTracingPageLoadSpan(client, {\n          name: initPathName,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'pageload',\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: `auto.pageload.react.reactrouter_v${version}`\n          }\n        });\n      }\n      if (instrumentNavigation) {\n        CLIENTS_WITH_INSTRUMENT_NAVIGATION.add(client);\n      }\n    }\n  };\n}\nfunction createV6CompatibleWrapUseRoutes(origUseRoutes, version) {\n  if (!_useEffect || !_useLocation || !_useNavigationType || !_matchRoutes) {\n    DEBUG_BUILD && debug.warn('reactRouterV6Instrumentation was unable to wrap `useRoutes` because of one or more missing parameters.');\n    return origUseRoutes;\n  }\n  const SentryRoutes = props => {\n    const isMountRenderPass = React.useRef(true);\n    const {\n      routes,\n      locationArg\n    } = props;\n    const Routes = origUseRoutes(routes, locationArg);\n    const location = _useLocation();\n    const navigationType = _useNavigationType();\n\n    // A value with stable identity to either pick `locationArg` if available or `location` if not\n    const stableLocationParam = typeof locationArg === 'string' || locationArg?.pathname ? locationArg : location;\n    _useEffect(() => {\n      const normalizedLocation = typeof stableLocationParam === 'string' ? {\n        pathname: stableLocationParam\n      } : stableLocationParam;\n      if (isMountRenderPass.current) {\n        addRoutesToAllRoutes(routes);\n        updatePageloadTransaction(getActiveRootSpan(), normalizedLocation, routes, undefined, undefined, Array.from(allRoutes));\n        isMountRenderPass.current = false;\n      } else {\n        handleNavigation({\n          location: normalizedLocation,\n          routes,\n          navigationType,\n          version,\n          allRoutes: Array.from(allRoutes)\n        });\n      }\n    }, [navigationType, stableLocationParam]);\n    return Routes;\n  };\n\n  // eslint-disable-next-line react/display-name\n  return (routes, locationArg) => {\n    return React.createElement(SentryRoutes, {\n      routes: routes,\n      locationArg: locationArg\n    });\n  };\n}\nfunction handleNavigation(opts) {\n  const {\n    location,\n    routes,\n    navigationType,\n    version,\n    matches,\n    basename,\n    allRoutes\n  } = opts;\n  const branches = Array.isArray(matches) ? matches : _matchRoutes(routes, location, basename);\n  const client = getClient();\n  if (!client || !CLIENTS_WITH_INSTRUMENT_NAVIGATION.has(client)) {\n    return;\n  }\n  if ((navigationType === 'PUSH' || navigationType === 'POP') && branches) {\n    let name,\n      source = 'url';\n    const isInDescendantRoute = locationIsInsideDescendantRoute(location, allRoutes || routes);\n    if (isInDescendantRoute) {\n      name = prefixWithSlash(rebuildRoutePathFromAllRoutes(allRoutes || routes, location));\n      source = 'route';\n    }\n    if (!isInDescendantRoute || !name) {\n      [name, source] = getNormalizedName(routes, location, branches, basename);\n    }\n    const activeSpan = getActiveSpan();\n    const isAlreadyInNavigationSpan = activeSpan && spanToJSON(activeSpan).op === 'navigation';\n\n    // Cross usage can result in multiple navigation spans being created without this check\n    if (isAlreadyInNavigationSpan) {\n      activeSpan?.updateName(name);\n      activeSpan?.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, source);\n    } else {\n      startBrowserTracingNavigationSpan(client, {\n        name,\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,\n          [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'navigation',\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: `auto.navigation.react.reactrouter_v${version}`\n        }\n      });\n    }\n  }\n}\n\n/**\n * Strip the basename from a pathname if exists.\n *\n * Vendored and modified from `react-router`\n * https://github.com/remix-run/react-router/blob/462bb712156a3f739d6139a0f14810b76b002df6/packages/router/utils.ts#L1038\n */\nfunction stripBasenameFromPathname(pathname, basename) {\n  if (!basename || basename === '/') {\n    return pathname;\n  }\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return pathname;\n  }\n\n  // We want to leave trailing slash behavior in the user's control, so if they\n  // specify a basename with a trailing slash, we should support it\n  const startIndex = basename.endsWith('/') ? basename.length - 1 : basename.length;\n  const nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== '/') {\n    // pathname does not start with basename/\n    return pathname;\n  }\n  return pathname.slice(startIndex) || '/';\n}\nfunction sendIndexPath(pathBuilder, pathname, basename) {\n  const reconstructedPath = pathBuilder || _stripBasename ? stripBasenameFromPathname(pathname, basename) : pathname;\n  const formattedPath =\n  // If the path ends with a slash, remove it\n  reconstructedPath[reconstructedPath.length - 1] === '/' ? reconstructedPath.slice(0, -1) :\n  // If the path ends with a wildcard, remove it\n  reconstructedPath.slice(-2) === '/*' ? reconstructedPath.slice(0, -1) : reconstructedPath;\n  return [formattedPath, 'route'];\n}\nfunction pathEndsWithWildcard(path) {\n  return path.endsWith('*');\n}\nfunction pathIsWildcardAndHasChildren(path, branch) {\n  return pathEndsWithWildcard(path) && !!branch.route.children?.length || false;\n}\nfunction routeIsDescendant(route) {\n  return !!(!route.children && route.element && route.path?.endsWith('/*'));\n}\nfunction locationIsInsideDescendantRoute(location, routes) {\n  const matchedRoutes = _matchRoutes(routes, location);\n  if (matchedRoutes) {\n    for (const match of matchedRoutes) {\n      if (routeIsDescendant(match.route) && pickSplat(match)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction addRoutesToAllRoutes(routes) {\n  routes.forEach(route => {\n    const extractedChildRoutes = getChildRoutesRecursively(route);\n    extractedChildRoutes.forEach(r => {\n      allRoutes.add(r);\n    });\n  });\n}\nfunction getChildRoutesRecursively(route) {\n  let allRoutes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n  if (!allRoutes.has(route)) {\n    allRoutes.add(route);\n    if (route.children && !route.index) {\n      route.children.forEach(child => {\n        const childRoutes = getChildRoutesRecursively(child, allRoutes);\n        childRoutes.forEach(r => {\n          allRoutes.add(r);\n        });\n      });\n    }\n  }\n  return allRoutes;\n}\nfunction pickPath(match) {\n  return trimWildcard(match.route.path || '');\n}\nfunction pickSplat(match) {\n  return match.params['*'] || '';\n}\nfunction trimWildcard(path) {\n  return path[path.length - 1] === '*' ? path.slice(0, -1) : path;\n}\nfunction trimSlash(path) {\n  return path[path.length - 1] === '/' ? path.slice(0, -1) : path;\n}\nfunction prefixWithSlash(path) {\n  return path[0] === '/' ? path : `/${path}`;\n}\nfunction rebuildRoutePathFromAllRoutes(allRoutes, location) {\n  const matchedRoutes = _matchRoutes(allRoutes, location);\n  if (!matchedRoutes || matchedRoutes.length === 0) {\n    return '';\n  }\n  for (const match of matchedRoutes) {\n    if (match.route.path && match.route.path !== '*') {\n      const path = pickPath(match);\n      const strippedPath = stripBasenameFromPathname(location.pathname, prefixWithSlash(match.pathnameBase));\n      if (location.pathname === strippedPath) {\n        return trimSlash(strippedPath);\n      }\n      return trimSlash(trimSlash(path || '') + prefixWithSlash(rebuildRoutePathFromAllRoutes(allRoutes.filter(route => route !== match.route), {\n        pathname: strippedPath\n      })));\n    }\n  }\n  return '';\n}\nfunction getNormalizedName(routes, location, branches) {\n  let basename = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n  if (!routes || routes.length === 0) {\n    return [_stripBasename ? stripBasenameFromPathname(location.pathname, basename) : location.pathname, 'url'];\n  }\n  let pathBuilder = '';\n  if (branches) {\n    for (const branch of branches) {\n      const route = branch.route;\n      if (route) {\n        // Early return if index route\n        if (route.index) {\n          return sendIndexPath(pathBuilder, branch.pathname, basename);\n        }\n        const path = route.path;\n\n        // If path is not a wildcard and has no child routes, append the path\n        if (path && !pathIsWildcardAndHasChildren(path, branch)) {\n          const newPath = path[0] === '/' || pathBuilder[pathBuilder.length - 1] === '/' ? path : `/${path}`;\n          pathBuilder = trimSlash(pathBuilder) + prefixWithSlash(newPath);\n\n          // If the path matches the current location, return the path\n          if (trimSlash(location.pathname) === trimSlash(basename + branch.pathname)) {\n            if (\n            // If the route defined on the element is something like\n            // <Route path=\"/stores/:storeId/products/:productId\" element={<div>Product</div>} />\n            // We should check against the branch.pathname for the number of / separators\n            getNumberOfUrlSegments(pathBuilder) !== getNumberOfUrlSegments(branch.pathname) &&\n            // We should not count wildcard operators in the url segments calculation\n            !pathEndsWithWildcard(pathBuilder)) {\n              return [(_stripBasename ? '' : basename) + newPath, 'route'];\n            }\n\n            // if the last character of the pathbuilder is a wildcard and there are children, remove the wildcard\n            if (pathIsWildcardAndHasChildren(pathBuilder, branch)) {\n              pathBuilder = pathBuilder.slice(0, -1);\n            }\n            return [(_stripBasename ? '' : basename) + pathBuilder, 'route'];\n          }\n        }\n      }\n    }\n  }\n  const fallbackTransactionName = _stripBasename ? stripBasenameFromPathname(location.pathname, basename) : location.pathname || '/';\n  return [fallbackTransactionName, 'url'];\n}\nfunction updatePageloadTransaction(activeRootSpan, location, routes, matches, basename, allRoutes) {\n  const branches = Array.isArray(matches) ? matches : _matchRoutes(allRoutes || routes, location, basename);\n  if (branches) {\n    let name,\n      source = 'url';\n    const isInDescendantRoute = locationIsInsideDescendantRoute(location, allRoutes || routes);\n    if (isInDescendantRoute) {\n      name = prefixWithSlash(rebuildRoutePathFromAllRoutes(allRoutes || routes, location));\n      source = 'route';\n    }\n    if (!isInDescendantRoute || !name) {\n      [name, source] = getNormalizedName(routes, location, branches, basename);\n    }\n    getCurrentScope().setTransactionName(name || '/');\n    if (activeRootSpan) {\n      activeRootSpan.updateName(name);\n      activeRootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, source);\n    }\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction createV6CompatibleWithSentryReactRouterRouting(Routes, version) {\n  if (!_useEffect || !_useLocation || !_useNavigationType || !_createRoutesFromChildren || !_matchRoutes) {\n    DEBUG_BUILD && debug.warn(`reactRouterV6Instrumentation was unable to wrap Routes because of one or more missing parameters.\n      useEffect: ${_useEffect}. useLocation: ${_useLocation}. useNavigationType: ${_useNavigationType}.\n      createRoutesFromChildren: ${_createRoutesFromChildren}. matchRoutes: ${_matchRoutes}.`);\n    return Routes;\n  }\n  const SentryRoutes = props => {\n    const isMountRenderPass = React.useRef(true);\n    const location = _useLocation();\n    const navigationType = _useNavigationType();\n    _useEffect(() => {\n      const routes = _createRoutesFromChildren(props.children);\n      if (isMountRenderPass.current) {\n        addRoutesToAllRoutes(routes);\n        updatePageloadTransaction(getActiveRootSpan(), location, routes, undefined, undefined, Array.from(allRoutes));\n        isMountRenderPass.current = false;\n      } else {\n        handleNavigation({\n          location,\n          routes,\n          navigationType,\n          version,\n          allRoutes: Array.from(allRoutes)\n        });\n      }\n    },\n    // `props.children` is purposely not included in the dependency array, because we do not want to re-run this effect\n    // when the children change. We only want to start transactions when the location or navigation type change.\n    [location, navigationType]);\n\n    // @ts-expect-error Setting more specific React Component typing for `R` generic above\n    // will break advanced type inference done by react router params\n    return React.createElement(Routes, {\n      ...props\n    });\n  };\n  hoistNonReactStatics(SentryRoutes, Routes);\n\n  // @ts-expect-error Setting more specific React Component typing for `R` generic above\n  // will break advanced type inference done by react router params\n  return SentryRoutes;\n}\nfunction getActiveRootSpan() {\n  const span = getActiveSpan();\n  const rootSpan = span ? getRootSpan(span) : undefined;\n  if (!rootSpan) {\n    return undefined;\n  }\n  const op = spanToJSON(rootSpan).op;\n\n  // Only use this root span if it is a pageload or navigation span\n  return op === 'navigation' || op === 'pageload' ? rootSpan : undefined;\n}\n\n/**\n * Returns number of URL segments of a passed string URL.\n */\nfunction getNumberOfUrlSegments(url) {\n  // split at '/' or at '\\/' to split regex urls correctly\n  return url.split(/\\\\?\\//).filter(s => s.length > 0 && s !== ',').length;\n}\nexport { createReactRouterV6CompatibleTracingIntegration, createV6CompatibleWithSentryReactRouterRouting, createV6CompatibleWrapCreateBrowserRouter, createV6CompatibleWrapCreateMemoryRouter, createV6CompatibleWrapUseRoutes, getNumberOfUrlSegments, handleNavigation };\n//# sourceMappingURL=reactrouterv6-compat-utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}