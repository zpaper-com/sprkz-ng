{"ast":null,"code":"import * as pdfjsLib from 'pdfjs-dist';\nimport { isFeatureEnabled } from './unleashService';\n\n// Configure PDF.js worker\npdfjsLib.GlobalWorkerOptions.workerSrc = process.env.REACT_APP_PDF_WORKER_URL || '/pdf.worker.min.mjs';\nexport class PDFService {\n  // Maximum number of pages to cache\n\n  /**\n   * Load PDF document from URL or data\n   */\n  static async loadDocument(options) {\n    const startTime = performance.now();\n\n    // Check feature flags for PDF processing options\n    const enableLazyLoading = isFeatureEnabled('PDF_LAZY_LOADING');\n    const enablePerformanceMonitoring = isFeatureEnabled('PERFORMANCE_MONITORING');\n    if (enablePerformanceMonitoring) {\n      console.log('PDF loading started:', options);\n    }\n    try {\n      const cacheKey = options.url || 'data-pdf';\n\n      // Check cache first (if lazy loading is enabled)\n      if (enableLazyLoading && options.url && this.loadedDocuments.has(cacheKey)) {\n        if (enablePerformanceMonitoring) {\n          const duration = performance.now() - startTime;\n          console.log(`PDF loaded from cache in ${duration.toFixed(2)}ms`);\n        }\n        return this.loadedDocuments.get(cacheKey);\n      }\n      const loadingTask = options.url ? pdfjsLib.getDocument({\n        url: options.url,\n        withCredentials: options.withCredentials || false\n      }) : pdfjsLib.getDocument({\n        data: options.data\n      });\n      const pdfDoc = await loadingTask.promise;\n\n      // Cache the document (if lazy loading is enabled)\n      if (enableLazyLoading && options.url) {\n        this.loadedDocuments.set(cacheKey, pdfDoc);\n      }\n      if (enablePerformanceMonitoring) {\n        const duration = performance.now() - startTime;\n        console.log(`PDF loaded successfully in ${duration.toFixed(2)}ms. Pages: ${pdfDoc.numPages}`);\n      }\n      return pdfDoc;\n    } catch (error) {\n      const duration = performance.now() - startTime;\n      const pdfError = {\n        type: 'LOADING_FAILED',\n        message: `Failed to load PDF after ${duration.toFixed(2)}ms: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        originalError: error instanceof Error ? error : new Error(String(error))\n      };\n      console.error('PDF loading error:', pdfError);\n      throw pdfError;\n    }\n  }\n\n  /**\n   * Get a specific page from the PDF document\n   */\n  static async getPage(pdfDoc, pageNumber) {\n    const startTime = performance.now();\n    const cacheKey = `${pdfDoc.fingerprints[0]}-page-${pageNumber}`;\n\n    // Feature flags\n    const enableLazyLoading = isFeatureEnabled('PDF_LAZY_LOADING');\n    const enablePerformanceMonitoring = isFeatureEnabled('PERFORMANCE_MONITORING');\n    try {\n      // Check cache first (if lazy loading enabled)\n      if (enableLazyLoading && this.loadedPages.has(cacheKey)) {\n        if (enablePerformanceMonitoring) {\n          const duration = performance.now() - startTime;\n          console.log(`Page ${pageNumber} loaded from cache in ${duration.toFixed(2)}ms`);\n        }\n        return this.loadedPages.get(cacheKey);\n      }\n      if (pageNumber < 1 || pageNumber > pdfDoc.numPages) {\n        throw new Error(`Invalid page number: ${pageNumber}. Document has ${pdfDoc.numPages} pages.`);\n      }\n      const page = await pdfDoc.getPage(pageNumber);\n\n      // Cache the page with size management\n      this.manageCacheSize();\n      this.loadedPages.set(cacheKey, page);\n      const duration = performance.now() - startTime;\n      console.log(`Page ${pageNumber} loaded in ${duration.toFixed(2)}ms`);\n      return page;\n    } catch (error) {\n      const duration = performance.now() - startTime;\n      const pdfError = {\n        type: 'LOADING_FAILED',\n        message: `Failed to load page ${pageNumber} after ${duration.toFixed(2)}ms: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        originalError: error instanceof Error ? error : new Error(String(error))\n      };\n      console.error('Page loading error:', pdfError);\n      throw pdfError;\n    }\n  }\n\n  /**\n   * Render page to canvas with proper scaling\n   */\n  static async renderPageToCanvas(page, canvas, scale = 1) {\n    const startTime = performance.now();\n    try {\n      const viewport = page.getViewport({\n        scale\n      });\n      const context = canvas.getContext('2d');\n      if (!context) {\n        throw new Error('Could not get 2D context from canvas');\n      }\n\n      // Set canvas dimensions\n      canvas.width = viewport.width;\n      canvas.height = viewport.height;\n      canvas.style.width = `${viewport.width}px`;\n      canvas.style.height = `${viewport.height}px`;\n      const renderContext = {\n        canvasContext: context,\n        viewport: viewport\n      };\n      await page.render(renderContext).promise;\n      const duration = performance.now() - startTime;\n      console.log(`Page rendered to canvas in ${duration.toFixed(2)}ms (${viewport.width}x${viewport.height})`);\n    } catch (error) {\n      const duration = performance.now() - startTime;\n      const pdfError = {\n        type: 'RENDERING_FAILED',\n        message: `Failed to render page to canvas after ${duration.toFixed(2)}ms: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        originalError: error instanceof Error ? error : new Error(String(error))\n      };\n      console.error('Canvas rendering error:', pdfError);\n      throw pdfError;\n    }\n  }\n\n  /**\n   * Extract text content from a page\n   */\n  static async extractTextContent(page) {\n    try {\n      const textContent = await page.getTextContent();\n      return textContent.items.map(item => 'str' in item ? item.str : '').join(' ');\n    } catch (error) {\n      const pdfError = {\n        type: 'PARSING_FAILED',\n        message: `Failed to extract text content: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        originalError: error instanceof Error ? error : new Error(String(error))\n      };\n      console.error('Text extraction error:', pdfError);\n      throw pdfError;\n    }\n  }\n\n  /**\n   * Extract form fields from a page using annotation layer\n   */\n  static async extractFormFields(page) {\n    try {\n      const annotations = await page.getAnnotations({\n        intent: 'display'\n      });\n      const formFields = [];\n      for (const annotation of annotations) {\n        if (annotation.subtype === 'Widget') {\n          const field = {\n            name: annotation.fieldName || `field_${annotation.id}`,\n            type: annotation.fieldType || 'unknown',\n            value: annotation.fieldValue || '',\n            required: !annotation.readOnly && (annotation.required || false),\n            readOnly: annotation.readOnly || false,\n            page: page.pageNumber,\n            rect: annotation.rect,\n            options: annotation.options || null,\n            multiline: annotation.multiLine || false,\n            maxLength: annotation.maxLen || null,\n            id: annotation.id,\n            subtype: annotation.subtype\n          };\n          formFields.push(field);\n        }\n      }\n      console.log(`Extracted ${formFields.length} form fields from page ${page.pageNumber}`);\n      return formFields;\n    } catch (error) {\n      const pdfError = {\n        type: 'PARSING_FAILED',\n        message: `Failed to extract form fields: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        originalError: error instanceof Error ? error : new Error(String(error))\n      };\n      console.error('Form field extraction error:', pdfError);\n      throw pdfError;\n    }\n  }\n\n  /**\n   * Generate thumbnail for a page\n   */\n  static async generateThumbnail(page, maxWidth = 150) {\n    const startTime = performance.now();\n    const cacheKey = `${page.pageNumber}-${maxWidth}`;\n\n    // Check thumbnail cache first\n    if (this.thumbnailCache.has(cacheKey)) {\n      const cachedThumbnail = this.thumbnailCache.get(cacheKey);\n      console.log(`Thumbnail loaded from cache in 0ms`);\n      return cachedThumbnail;\n    }\n    try {\n      const viewport = page.getViewport({\n        scale: 1\n      });\n      const scale = maxWidth / viewport.width;\n      const scaledViewport = page.getViewport({\n        scale\n      });\n      const canvas = document.createElement('canvas');\n      const context = canvas.getContext('2d');\n      if (!context) {\n        throw new Error('Could not create canvas context for thumbnail');\n      }\n      canvas.width = scaledViewport.width;\n      canvas.height = scaledViewport.height;\n      await page.render({\n        canvasContext: context,\n        viewport: scaledViewport\n      }).promise;\n      const thumbnailDataUrl = canvas.toDataURL('image/png');\n\n      // Cache the thumbnail\n      this.thumbnailCache.set(cacheKey, thumbnailDataUrl);\n      const duration = performance.now() - startTime;\n      console.log(`Thumbnail generated in ${duration.toFixed(2)}ms (${canvas.width}x${canvas.height})`);\n      return thumbnailDataUrl;\n    } catch (error) {\n      const duration = performance.now() - startTime;\n      const pdfError = {\n        type: 'RENDERING_FAILED',\n        message: `Failed to generate thumbnail after ${duration.toFixed(2)}ms: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        originalError: error instanceof Error ? error : new Error(String(error))\n      };\n      console.error('Thumbnail generation error:', pdfError);\n      throw pdfError;\n    }\n  }\n\n  /**\n   * Preload adjacent pages for smooth navigation\n   */\n  static async preloadAdjacentPages(pdfDoc, currentPage, range = 1) {\n    const pagesToPreload = [];\n    for (let i = Math.max(1, currentPage - range); i <= Math.min(pdfDoc.numPages, currentPage + range); i++) {\n      if (i !== currentPage) {\n        pagesToPreload.push(i);\n      }\n    }\n    const preloadPromises = pagesToPreload.map(async pageNum => {\n      try {\n        await this.getPage(pdfDoc, pageNum);\n        console.log(`Preloaded page ${pageNum}`);\n      } catch (error) {\n        console.warn(`Failed to preload page ${pageNum}:`, error);\n      }\n    });\n    await Promise.allSettled(preloadPromises);\n  }\n\n  /**\n   * Manage cache size to prevent memory leaks\n   */\n  static manageCacheSize() {\n    if (this.loadedPages.size > this.maxCacheSize) {\n      const keysToDelete = Array.from(this.loadedPages.keys()).slice(0, 10); // Remove oldest 10 entries\n      keysToDelete.forEach(key => this.loadedPages.delete(key));\n      console.log(`Cache cleaned up - removed ${keysToDelete.length} pages`);\n    }\n  }\n\n  /**\n   * Clean up cached resources\n   */\n  static cleanup(documentUrl) {\n    if (documentUrl) {\n      this.loadedDocuments.delete(documentUrl);\n      // Clean up related pages\n      const keysToDelete = Array.from(this.loadedPages.keys()).filter(key => key.includes(documentUrl));\n      keysToDelete.forEach(key => this.loadedPages.delete(key));\n    } else {\n      // Clean up all cached resources\n      this.loadedDocuments.clear();\n      this.loadedPages.clear();\n      this.thumbnailCache.clear();\n    }\n    console.log('PDF service cache cleaned up');\n  }\n\n  /**\n   * Get default PDF URL from environment or URL parameter\n   */\n  static getDefaultPDFUrl() {\n    // Check URL parameter first\n    const urlParams = new URLSearchParams(window.location.search);\n    const pdfParam = urlParams.get('f') || urlParams.get('file') || urlParams.get('pdf');\n    if (pdfParam) {\n      // Resolve relative paths to pdfs directory\n      if (!pdfParam.startsWith('http') && !pdfParam.startsWith('/')) {\n        return `/pdfs/${pdfParam}`;\n      }\n      return pdfParam;\n    }\n\n    // Return default PDF from environment\n    return process.env.REACT_APP_DEFAULT_PDF || '/pdfs/makana2025.pdf';\n  }\n}\nPDFService.loadedDocuments = new Map();\nPDFService.loadedPages = new Map();\nPDFService.thumbnailCache = new Map();\nPDFService.maxCacheSize = 50;","map":{"version":3,"names":["pdfjsLib","isFeatureEnabled","GlobalWorkerOptions","workerSrc","process","env","REACT_APP_PDF_WORKER_URL","PDFService","loadDocument","options","startTime","performance","now","enableLazyLoading","enablePerformanceMonitoring","console","log","cacheKey","url","loadedDocuments","has","duration","toFixed","get","loadingTask","getDocument","withCredentials","data","pdfDoc","promise","set","numPages","error","pdfError","type","message","Error","originalError","String","getPage","pageNumber","fingerprints","loadedPages","page","manageCacheSize","renderPageToCanvas","canvas","scale","viewport","getViewport","context","getContext","width","height","style","renderContext","canvasContext","render","extractTextContent","textContent","getTextContent","items","map","item","str","join","extractFormFields","annotations","getAnnotations","intent","formFields","annotation","subtype","field","name","fieldName","id","fieldType","value","fieldValue","required","readOnly","rect","multiline","multiLine","maxLength","maxLen","push","length","generateThumbnail","maxWidth","thumbnailCache","cachedThumbnail","scaledViewport","document","createElement","thumbnailDataUrl","toDataURL","preloadAdjacentPages","currentPage","range","pagesToPreload","i","Math","max","min","preloadPromises","pageNum","warn","Promise","allSettled","size","maxCacheSize","keysToDelete","Array","from","keys","slice","forEach","key","delete","cleanup","documentUrl","filter","includes","clear","getDefaultPDFUrl","urlParams","URLSearchParams","window","location","search","pdfParam","startsWith","REACT_APP_DEFAULT_PDF","Map"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/src/services/pdfService.ts"],"sourcesContent":["import * as pdfjsLib from 'pdfjs-dist';\nimport type { PDFDocumentProxy, PDFPageProxy } from 'pdfjs-dist';\nimport { isFeatureEnabled } from './unleashService';\n\n// Configure PDF.js worker\npdfjsLib.GlobalWorkerOptions.workerSrc = process.env.REACT_APP_PDF_WORKER_URL || '/pdf.worker.min.mjs';\n\nexport interface PDFLoadOptions {\n  url?: string;\n  data?: ArrayBuffer;\n  withCredentials?: boolean;\n}\n\nexport interface PDFServiceError {\n  type: 'LOADING_FAILED' | 'PARSING_FAILED' | 'RENDERING_FAILED';\n  message: string;\n  originalError?: Error;\n}\n\nexport class PDFService {\n  private static loadedDocuments: Map<string, PDFDocumentProxy> = new Map();\n  private static loadedPages: Map<string, PDFPageProxy> = new Map();\n  private static thumbnailCache: Map<string, string> = new Map();\n  private static maxCacheSize: number = 50; // Maximum number of pages to cache\n\n  /**\n   * Load PDF document from URL or data\n   */\n  static async loadDocument(options: PDFLoadOptions): Promise<PDFDocumentProxy> {\n    const startTime = performance.now();\n    \n    // Check feature flags for PDF processing options\n    const enableLazyLoading = isFeatureEnabled('PDF_LAZY_LOADING');\n    const enablePerformanceMonitoring = isFeatureEnabled('PERFORMANCE_MONITORING');\n    \n    if (enablePerformanceMonitoring) {\n      console.log('PDF loading started:', options);\n    }\n    \n    try {\n      const cacheKey = options.url || 'data-pdf';\n      \n      // Check cache first (if lazy loading is enabled)\n      if (enableLazyLoading && options.url && this.loadedDocuments.has(cacheKey)) {\n        if (enablePerformanceMonitoring) {\n          const duration = performance.now() - startTime;\n          console.log(`PDF loaded from cache in ${duration.toFixed(2)}ms`);\n        }\n        return this.loadedDocuments.get(cacheKey)!;\n      }\n\n      const loadingTask = options.url \n        ? pdfjsLib.getDocument({\n            url: options.url,\n            withCredentials: options.withCredentials || false,\n          })\n        : pdfjsLib.getDocument({ data: options.data! });\n\n      const pdfDoc = await loadingTask.promise;\n      \n      // Cache the document (if lazy loading is enabled)\n      if (enableLazyLoading && options.url) {\n        this.loadedDocuments.set(cacheKey, pdfDoc);\n      }\n\n      if (enablePerformanceMonitoring) {\n        const duration = performance.now() - startTime;\n        console.log(`PDF loaded successfully in ${duration.toFixed(2)}ms. Pages: ${pdfDoc.numPages}`);\n      }\n      \n      return pdfDoc;\n    } catch (error) {\n      const duration = performance.now() - startTime;\n      const pdfError: PDFServiceError = {\n        type: 'LOADING_FAILED',\n        message: `Failed to load PDF after ${duration.toFixed(2)}ms: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        originalError: error instanceof Error ? error : new Error(String(error))\n      };\n      \n      console.error('PDF loading error:', pdfError);\n      throw pdfError;\n    }\n  }\n\n  /**\n   * Get a specific page from the PDF document\n   */\n  static async getPage(pdfDoc: PDFDocumentProxy, pageNumber: number): Promise<PDFPageProxy> {\n    const startTime = performance.now();\n    const cacheKey = `${pdfDoc.fingerprints[0]}-page-${pageNumber}`;\n    \n    // Feature flags\n    const enableLazyLoading = isFeatureEnabled('PDF_LAZY_LOADING');\n    const enablePerformanceMonitoring = isFeatureEnabled('PERFORMANCE_MONITORING');\n    \n    try {\n      // Check cache first (if lazy loading enabled)\n      if (enableLazyLoading && this.loadedPages.has(cacheKey)) {\n        if (enablePerformanceMonitoring) {\n          const duration = performance.now() - startTime;\n          console.log(`Page ${pageNumber} loaded from cache in ${duration.toFixed(2)}ms`);\n        }\n        return this.loadedPages.get(cacheKey)!;\n      }\n\n      if (pageNumber < 1 || pageNumber > pdfDoc.numPages) {\n        throw new Error(`Invalid page number: ${pageNumber}. Document has ${pdfDoc.numPages} pages.`);\n      }\n\n      const page = await pdfDoc.getPage(pageNumber);\n      \n      // Cache the page with size management\n      this.manageCacheSize();\n      this.loadedPages.set(cacheKey, page);\n\n      const duration = performance.now() - startTime;\n      console.log(`Page ${pageNumber} loaded in ${duration.toFixed(2)}ms`);\n      \n      return page;\n    } catch (error) {\n      const duration = performance.now() - startTime;\n      const pdfError: PDFServiceError = {\n        type: 'LOADING_FAILED',\n        message: `Failed to load page ${pageNumber} after ${duration.toFixed(2)}ms: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        originalError: error instanceof Error ? error : new Error(String(error))\n      };\n      \n      console.error('Page loading error:', pdfError);\n      throw pdfError;\n    }\n  }\n\n  /**\n   * Render page to canvas with proper scaling\n   */\n  static async renderPageToCanvas(\n    page: PDFPageProxy, \n    canvas: HTMLCanvasElement, \n    scale: number = 1\n  ): Promise<void> {\n    const startTime = performance.now();\n    \n    try {\n      const viewport = page.getViewport({ scale });\n      const context = canvas.getContext('2d');\n      \n      if (!context) {\n        throw new Error('Could not get 2D context from canvas');\n      }\n\n      // Set canvas dimensions\n      canvas.width = viewport.width;\n      canvas.height = viewport.height;\n      canvas.style.width = `${viewport.width}px`;\n      canvas.style.height = `${viewport.height}px`;\n\n      const renderContext = {\n        canvasContext: context,\n        viewport: viewport,\n      };\n\n      await page.render(renderContext).promise;\n      \n      const duration = performance.now() - startTime;\n      console.log(`Page rendered to canvas in ${duration.toFixed(2)}ms (${viewport.width}x${viewport.height})`);\n    } catch (error) {\n      const duration = performance.now() - startTime;\n      const pdfError: PDFServiceError = {\n        type: 'RENDERING_FAILED',\n        message: `Failed to render page to canvas after ${duration.toFixed(2)}ms: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        originalError: error instanceof Error ? error : new Error(String(error))\n      };\n      \n      console.error('Canvas rendering error:', pdfError);\n      throw pdfError;\n    }\n  }\n\n  /**\n   * Extract text content from a page\n   */\n  static async extractTextContent(page: PDFPageProxy): Promise<string> {\n    try {\n      const textContent = await page.getTextContent();\n      return textContent.items\n        .map((item: any) => 'str' in item ? item.str : '')\n        .join(' ');\n    } catch (error) {\n      const pdfError: PDFServiceError = {\n        type: 'PARSING_FAILED',\n        message: `Failed to extract text content: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        originalError: error instanceof Error ? error : new Error(String(error))\n      };\n      \n      console.error('Text extraction error:', pdfError);\n      throw pdfError;\n    }\n  }\n\n  /**\n   * Extract form fields from a page using annotation layer\n   */\n  static async extractFormFields(page: PDFPageProxy) {\n    try {\n      const annotations = await page.getAnnotations({ intent: 'display' });\n      const formFields = [];\n\n      for (const annotation of annotations) {\n        if (annotation.subtype === 'Widget') {\n          const field = {\n            name: annotation.fieldName || `field_${annotation.id}`,\n            type: annotation.fieldType || 'unknown',\n            value: annotation.fieldValue || '',\n            required: !annotation.readOnly && (annotation.required || false),\n            readOnly: annotation.readOnly || false,\n            page: page.pageNumber,\n            rect: annotation.rect,\n            options: annotation.options || null,\n            multiline: annotation.multiLine || false,\n            maxLength: annotation.maxLen || null,\n            id: annotation.id,\n            subtype: annotation.subtype\n          };\n          formFields.push(field);\n        }\n      }\n\n      console.log(`Extracted ${formFields.length} form fields from page ${page.pageNumber}`);\n      return formFields;\n    } catch (error) {\n      const pdfError: PDFServiceError = {\n        type: 'PARSING_FAILED',\n        message: `Failed to extract form fields: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        originalError: error instanceof Error ? error : new Error(String(error))\n      };\n      \n      console.error('Form field extraction error:', pdfError);\n      throw pdfError;\n    }\n  }\n\n  /**\n   * Generate thumbnail for a page\n   */\n  static async generateThumbnail(\n    page: PDFPageProxy, \n    maxWidth: number = 150\n  ): Promise<string> {\n    const startTime = performance.now();\n    const cacheKey = `${page.pageNumber}-${maxWidth}`;\n    \n    // Check thumbnail cache first\n    if (this.thumbnailCache.has(cacheKey)) {\n      const cachedThumbnail = this.thumbnailCache.get(cacheKey)!;\n      console.log(`Thumbnail loaded from cache in 0ms`);\n      return cachedThumbnail;\n    }\n    \n    try {\n      const viewport = page.getViewport({ scale: 1 });\n      const scale = maxWidth / viewport.width;\n      const scaledViewport = page.getViewport({ scale });\n\n      const canvas = document.createElement('canvas');\n      const context = canvas.getContext('2d');\n      \n      if (!context) {\n        throw new Error('Could not create canvas context for thumbnail');\n      }\n\n      canvas.width = scaledViewport.width;\n      canvas.height = scaledViewport.height;\n\n      await page.render({\n        canvasContext: context,\n        viewport: scaledViewport\n      }).promise;\n\n      const thumbnailDataUrl = canvas.toDataURL('image/png');\n      \n      // Cache the thumbnail\n      this.thumbnailCache.set(cacheKey, thumbnailDataUrl);\n      \n      const duration = performance.now() - startTime;\n      console.log(`Thumbnail generated in ${duration.toFixed(2)}ms (${canvas.width}x${canvas.height})`);\n      \n      return thumbnailDataUrl;\n    } catch (error) {\n      const duration = performance.now() - startTime;\n      const pdfError: PDFServiceError = {\n        type: 'RENDERING_FAILED',\n        message: `Failed to generate thumbnail after ${duration.toFixed(2)}ms: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        originalError: error instanceof Error ? error : new Error(String(error))\n      };\n      \n      console.error('Thumbnail generation error:', pdfError);\n      throw pdfError;\n    }\n  }\n\n  /**\n   * Preload adjacent pages for smooth navigation\n   */\n  static async preloadAdjacentPages(\n    pdfDoc: PDFDocumentProxy, \n    currentPage: number, \n    range: number = 1\n  ): Promise<void> {\n    const pagesToPreload = [];\n    \n    for (let i = Math.max(1, currentPage - range); i <= Math.min(pdfDoc.numPages, currentPage + range); i++) {\n      if (i !== currentPage) {\n        pagesToPreload.push(i);\n      }\n    }\n\n    const preloadPromises = pagesToPreload.map(async (pageNum) => {\n      try {\n        await this.getPage(pdfDoc, pageNum);\n        console.log(`Preloaded page ${pageNum}`);\n      } catch (error) {\n        console.warn(`Failed to preload page ${pageNum}:`, error);\n      }\n    });\n\n    await Promise.allSettled(preloadPromises);\n  }\n\n  /**\n   * Manage cache size to prevent memory leaks\n   */\n  private static manageCacheSize(): void {\n    if (this.loadedPages.size > this.maxCacheSize) {\n      const keysToDelete = Array.from(this.loadedPages.keys()).slice(0, 10); // Remove oldest 10 entries\n      keysToDelete.forEach(key => this.loadedPages.delete(key));\n      console.log(`Cache cleaned up - removed ${keysToDelete.length} pages`);\n    }\n  }\n\n  /**\n   * Clean up cached resources\n   */\n  static cleanup(documentUrl?: string): void {\n    if (documentUrl) {\n      this.loadedDocuments.delete(documentUrl);\n      // Clean up related pages\n      const keysToDelete = Array.from(this.loadedPages.keys()).filter(key => key.includes(documentUrl));\n      keysToDelete.forEach(key => this.loadedPages.delete(key));\n    } else {\n      // Clean up all cached resources\n      this.loadedDocuments.clear();\n      this.loadedPages.clear();\n      this.thumbnailCache.clear();\n    }\n    \n    console.log('PDF service cache cleaned up');\n  }\n\n  /**\n   * Get default PDF URL from environment or URL parameter\n   */\n  static getDefaultPDFUrl(): string {\n    // Check URL parameter first\n    const urlParams = new URLSearchParams(window.location.search);\n    const pdfParam = urlParams.get('f') || urlParams.get('file') || urlParams.get('pdf');\n    \n    if (pdfParam) {\n      // Resolve relative paths to pdfs directory\n      if (!pdfParam.startsWith('http') && !pdfParam.startsWith('/')) {\n        return `/pdfs/${pdfParam}`;\n      }\n      return pdfParam;\n    }\n    \n    // Return default PDF from environment\n    return process.env.REACT_APP_DEFAULT_PDF || '/pdfs/makana2025.pdf';\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}