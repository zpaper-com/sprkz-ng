{"ast":null,"code":"import*as Sentry from'@sentry/react';export class ValidationService{/**\n   * Validate a single form field\n   */static async validateField(field,value){let allFields=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[];let options=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};const startTime=performance.now();// Check feature flags\nconst enhancedValidation=isFeatureEnabled('ENHANCED_FIELD_VALIDATION');const performanceMonitoring=isFeatureEnabled('PERFORMANCE_MONITORING');const securityAuditLogging=isFeatureEnabled('SECURITY_AUDIT_LOGGING');try{// Use enhanced validation options if feature is enabled\nconst{validateRequired=enhancedValidation?true:true,validateFormat=enhancedValidation?true:false,validateDependencies=enhancedValidation?true:false,excludeReadOnly=true,performanceMode=performanceMonitoring?false:true}=options;// Security audit logging\nif(securityAuditLogging){console.log(`Validating field: ${field.name}, type: ${field.type}, value length: ${(value===null||value===void 0?void 0:value.toString().length)||0}`);}// Create cache key\nconst cacheKey=`${field.name}_${JSON.stringify(value)}_${field.type}`;// Check cache in performance mode\nif(performanceMode&&this.validationCache.has(cacheKey)){const cached=this.validationCache.get(cacheKey);// Use cached result if less than 1 minute old\nif(Date.now()-cached.validatedAt<60000){return cached;}}const errors=[];const warnings=[];// Skip validation for read-only fields if requested\nif(excludeReadOnly&&field.readOnly){const result={isValid:true,errors:[],warnings:[],fieldName:field.name,validatedAt:Date.now()};return result;}// Get validation rules for field type\nconst fieldType=this.getFieldValidationType(field);const rules=this.FIELD_VALIDATION_RULES[fieldType]||[];// Apply validation rules\nfor(const rule of rules){// Skip certain validations based on options\nif(!validateRequired&&rule.type==='required')continue;if(!validateFormat&&rule.type==='format')continue;if(!validateDependencies&&rule.type==='dependency')continue;const ruleValid=await this.applyValidationRule(rule,value,field,allFields);if(!ruleValid){if(rule.type==='required'&&!field.required){warnings.push(rule.message);}else{errors.push(rule.message);}}}// Additional field-specific validations\nif(validateDependencies){const dependencyErrors=await this.validateFieldDependencies(field,value,allFields);errors.push(...dependencyErrors);}// Custom business logic validations\nconst customErrors=await this.validateCustomBusinessRules(field,value,allFields);errors.push(...customErrors);const result={isValid:errors.length===0,errors,warnings,fieldName:field.name,validatedAt:Date.now()};// Cache result\nthis.validationCache.set(cacheKey,result);// Performance monitoring\nconst duration=performance.now()-startTime;if(duration>this.performanceTarget){console.warn(`Validation for field \"${field.name}\" took ${duration.toFixed(2)}ms (target: ${this.performanceTarget}ms)`);// Report to Sentry if performance is very poor\nif(duration>this.performanceTarget*3){Sentry.addBreadcrumb({message:'Slow field validation detected',data:{fieldName:field.name,fieldType:field.type,duration:duration,target:this.performanceTarget},level:'warning'});}}return result;}catch(error){console.error(`Validation error for field \"${field.name}\":`,error);Sentry.captureException(error,{tags:{component:'ValidationService',fieldName:field.name,fieldType:field.type}});return{isValid:false,errors:['An error occurred while validating this field'],warnings:[],fieldName:field.name,validatedAt:Date.now()};}}/**\n   * Validate multiple fields\n   */static async validateFields(fields,values){let options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};const results={};// Validate fields in parallel for better performance\nconst validationPromises=fields.map(async field=>{const value=values[field.name];const result=await this.validateField(field,value,fields,options);results[field.name]=result;});await Promise.all(validationPromises);return results;}/**\n   * Validate all required fields are completed\n   */static validateRequiredFieldsCompletion(fields,values){const requiredFields=fields.filter(field=>field.required&&!field.readOnly);const missingFields=[];let completedCount=0;for(const field of requiredFields){const value=values[field.name];const hasValue=this.hasValidValue(field,value);if(hasValue){completedCount++;}else{missingFields.push(field.name);}}const completionPercentage=requiredFields.length>0?Math.round(completedCount/requiredFields.length*100):100;return{isComplete:missingFields.length===0,missingFields,completionPercentage};}/**\n   * Apply a single validation rule\n   */static async applyValidationRule(rule,value,field,allFields){var _rule$params;switch(rule.type){case'required':return this.hasValidValue(field,value);case'format':if(!value)return true;// Format validation only applies to non-empty values\nconst pattern=(_rule$params=rule.params)===null||_rule$params===void 0?void 0:_rule$params.pattern;if(pattern instanceof RegExp){return pattern.test(String(value));}return true;case'length':if(!value)return true;const str=String(value);const{min,max}=rule.params||{};if(min!==undefined&&str.length<min)return false;if(max!==undefined&&str.length>max)return false;return true;case'custom':if(rule.validator){return rule.validator(value,field,allFields);}return true;case'dependency':return this.validateFieldDependencies(field,value,allFields).then(errors=>errors.length===0);default:return true;}}/**\n   * Check if field has a valid value\n   */static hasValidValue(field,value){if(value===null||value===undefined||value===''){return false;}switch(field.type){case'checkbox':return value===true||value==='true'||value==='on';case'signature':return typeof value==='string'&&value.startsWith('data:image/')&&value.length>100;case'radio':case'dropdown':return value!==null&&value!==undefined&&value!=='';default:return String(value).trim().length>0;}}/**\n   * Get validation type based on field properties\n   */static getFieldValidationType(field){// Check field name patterns for common types\nconst fieldName=field.name.toLowerCase();if(fieldName.includes('email'))return'email';if(fieldName.includes('phone')||fieldName.includes('tel'))return'phone';if(fieldName.includes('date'))return'date';if(fieldName.includes('number')||fieldName.includes('amount'))return'number';// Use field type\nreturn field.type||'text';}/**\n   * Validate field dependencies\n   */static async validateFieldDependencies(field,value,allFields){const errors=[];// Example dependency validation logic\n// This can be extended based on specific business requirements\n// Check for conditional required fields\n// Example: If field A is filled, then field B becomes required\nconst fieldName=field.name.toLowerCase();if(fieldName.includes('spouse')&&fieldName.includes('name')){// If marital status is married, spouse name is required\nconst maritalField=allFields.find(f=>f.name.toLowerCase().includes('marital')||f.name.toLowerCase().includes('status'));if(maritalField){const maritalValue=String(value||'').toLowerCase();if((maritalValue.includes('married')||maritalValue.includes('spouse'))&&!value){errors.push('Spouse name is required when married');}}}return errors;}/**\n   * Custom business rule validation\n   */static async validateCustomBusinessRules(field,value,allFields){const errors=[];try{// Age validation example\nif(field.name.toLowerCase().includes('age')&&value){const age=parseInt(String(value),10);if(!isNaN(age)){if(age<0||age>150){errors.push('Please enter a valid age');}if(age<18){errors.push('Must be 18 or older');}}}// Date range validation example\nif(field.name.toLowerCase().includes('start')&&field.name.toLowerCase().includes('date')){const endDateField=allFields.find(f=>f.name.toLowerCase().includes('end')&&f.name.toLowerCase().includes('date'));if(endDateField&&value){const startDate=new Date(value);// This would need the end date value from the form state\n// For now, just validate the start date is not in the far future\nconst oneYearFromNow=new Date();oneYearFromNow.setFullYear(oneYearFromNow.getFullYear()+1);if(startDate>oneYearFromNow){errors.push('Start date cannot be more than one year in the future');}}}}catch(error){console.warn(`Error in custom business rule validation for field \"${field.name}\":`,error);}return errors;}/**\n   * Clear validation cache\n   */static clearValidationCache(){this.validationCache.clear();}/**\n   * Get validation cache statistics\n   */static getValidationCacheStats(){return{size:this.validationCache.size,entries:Array.from(this.validationCache.keys())};}/**\n   * Validate form submission readiness\n   */static async validateFormSubmission(fields,values){const validationResults=await this.validateFields(fields,values,{validateRequired:true,validateFormat:true,validateDependencies:true,excludeReadOnly:true});const requiredCompletion=this.validateRequiredFieldsCompletion(fields,values);const errors={};const warnings={};let validFields=0;let invalidFields=0;Object.entries(validationResults).forEach(_ref=>{let[fieldName,result]=_ref;if(result.errors.length>0){errors[fieldName]=result.errors;invalidFields++;}else{validFields++;}if(result.warnings.length>0){warnings[fieldName]=result.warnings;}});const requiredFields=fields.filter(f=>f.required&&!f.readOnly);return{canSubmit:requiredCompletion.isComplete&&invalidFields===0,errors,warnings,summary:{totalFields:fields.length,validFields,invalidFields,requiredFields:requiredFields.length,completedRequiredFields:requiredFields.length-requiredCompletion.missingFields.length}};}}ValidationService.validationCache=new Map();ValidationService.performanceTarget=10;// milliseconds per field\n/**\n   * Validation rules for different field types\n   */ValidationService.FIELD_VALIDATION_RULES={text:[{type:'required',message:'This field is required'},{type:'length',message:'Text is too long',params:{max:1000}}],email:[{type:'required',message:'Email address is required'},{type:'format',message:'Please enter a valid email address',params:{pattern:/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/}}],phone:[{type:'required',message:'Phone number is required'},{type:'format',message:'Please enter a valid phone number',params:{pattern:/^[\\+]?[1-9][\\d]{0,15}$/}}],date:[{type:'required',message:'Date is required'},{type:'format',message:'Please enter a valid date',params:{pattern:/^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$|^\\d{4}-\\d{2}-\\d{2}$/}},{type:'custom',message:'Date cannot be in the future',validator:value=>{if(!value)return true;const date=new Date(String(value));return!isNaN(date.getTime())&&date<=new Date();}}],number:[{type:'format',message:'Please enter a valid number',params:{pattern:/^-?\\d+(\\.\\d+)?$/}}],checkbox:[{type:'custom',message:'This checkbox must be checked',validator:value=>{return value===true||value==='true'||value==='on';}}],radio:[{type:'required',message:'Please select an option'}],dropdown:[{type:'required',message:'Please select an option'}],signature:[{type:'required',message:'Signature is required'},{type:'custom',message:'Please provide a valid signature',validator:value=>{return Boolean(value&&typeof value==='string'&&value.startsWith('data:image/')&&value.length>100);}}]};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}