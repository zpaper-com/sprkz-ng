{"ast":null,"code":"import { defineIntegration, supportsNativeFetch, addFetchInstrumentationHandler, getClient, GLOBAL_OBJ, debug, captureEvent, isSentryRequestUrl, addExceptionMechanism } from '@sentry/core';\nimport { addXhrInstrumentationHandler, SENTRY_XHR_DATA_KEY } from '@sentry-internal/browser-utils';\nimport { DEBUG_BUILD } from '../debug-build.js';\nconst INTEGRATION_NAME = 'HttpClient';\nconst _httpClientIntegration = (options = {}) => {\n  const _options = {\n    failedRequestStatusCodes: [[500, 599]],\n    failedRequestTargets: [/.*/],\n    ...options\n  };\n  return {\n    name: INTEGRATION_NAME,\n    setup(client) {\n      _wrapFetch(client, _options);\n      _wrapXHR(client, _options);\n    }\n  };\n};\n\n/**\n * Create events for failed client side HTTP requests.\n */\nconst httpClientIntegration = defineIntegration(_httpClientIntegration);\n\n/**\n * Interceptor function for fetch requests\n *\n * @param requestInfo The Fetch API request info\n * @param response The Fetch API response\n * @param requestInit The request init object\n */\nfunction _fetchResponseHandler(options, requestInfo, response, requestInit, error) {\n  if (_shouldCaptureResponse(options, response.status, response.url)) {\n    const request = _getRequest(requestInfo, requestInit);\n    let requestHeaders, responseHeaders, requestCookies, responseCookies;\n    if (_shouldSendDefaultPii()) {\n      [requestHeaders, requestCookies] = _parseCookieHeaders('Cookie', request);\n      [responseHeaders, responseCookies] = _parseCookieHeaders('Set-Cookie', response);\n    }\n    const event = _createEvent({\n      url: request.url,\n      method: request.method,\n      status: response.status,\n      requestHeaders,\n      responseHeaders,\n      requestCookies,\n      responseCookies,\n      error\n    });\n    captureEvent(event);\n  }\n}\nfunction _parseCookieHeaders(cookieHeader, obj) {\n  const headers = _extractFetchHeaders(obj.headers);\n  let cookies;\n  try {\n    const cookieString = headers[cookieHeader] || headers[cookieHeader.toLowerCase()] || undefined;\n    if (cookieString) {\n      cookies = _parseCookieString(cookieString);\n    }\n  } catch {\n    // ignore it if parsing fails\n  }\n  return [headers, cookies];\n}\n\n/**\n * Interceptor function for XHR requests\n *\n * @param xhr The XHR request\n * @param method The HTTP method\n * @param headers The HTTP headers\n */\nfunction _xhrResponseHandler(options, xhr, method, headers, error) {\n  if (_shouldCaptureResponse(options, xhr.status, xhr.responseURL)) {\n    let requestHeaders, responseCookies, responseHeaders;\n    if (_shouldSendDefaultPii()) {\n      try {\n        const cookieString = xhr.getResponseHeader('Set-Cookie') || xhr.getResponseHeader('set-cookie') || undefined;\n        if (cookieString) {\n          responseCookies = _parseCookieString(cookieString);\n        }\n      } catch {\n        // ignore it if parsing fails\n      }\n      try {\n        responseHeaders = _getXHRResponseHeaders(xhr);\n      } catch {\n        // ignore it if parsing fails\n      }\n      requestHeaders = headers;\n    }\n    const event = _createEvent({\n      url: xhr.responseURL,\n      method,\n      status: xhr.status,\n      requestHeaders,\n      // Can't access request cookies from XHR\n      responseHeaders,\n      responseCookies,\n      error\n    });\n    captureEvent(event);\n  }\n}\n\n/**\n * Extracts response size from `Content-Length` header when possible\n *\n * @param headers\n * @returns The response size in bytes or undefined\n */\nfunction _getResponseSizeFromHeaders(headers) {\n  if (headers) {\n    const contentLength = headers['Content-Length'] || headers['content-length'];\n    if (contentLength) {\n      return parseInt(contentLength, 10);\n    }\n  }\n  return undefined;\n}\n\n/**\n * Creates an object containing cookies from the given cookie string\n *\n * @param cookieString The cookie string to parse\n * @returns The parsed cookies\n */\nfunction _parseCookieString(cookieString) {\n  return cookieString.split('; ').reduce((acc, cookie) => {\n    const [key, value] = cookie.split('=');\n    if (key && value) {\n      acc[key] = value;\n    }\n    return acc;\n  }, {});\n}\n\n/**\n * Extracts the headers as an object from the given Fetch API request or response object\n *\n * @param headers The headers to extract\n * @returns The extracted headers as an object\n */\nfunction _extractFetchHeaders(headers) {\n  const result = {};\n  headers.forEach((value, key) => {\n    result[key] = value;\n  });\n  return result;\n}\n\n/**\n * Extracts the response headers as an object from the given XHR object\n *\n * @param xhr The XHR object to extract the response headers from\n * @returns The response headers as an object\n */\nfunction _getXHRResponseHeaders(xhr) {\n  const headers = xhr.getAllResponseHeaders();\n  if (!headers) {\n    return {};\n  }\n  return headers.split('\\r\\n').reduce((acc, line) => {\n    const [key, value] = line.split(': ');\n    if (key && value) {\n      acc[key] = value;\n    }\n    return acc;\n  }, {});\n}\n\n/**\n * Checks if the given target url is in the given list of targets\n *\n * @param target The target url to check\n * @returns true if the target url is in the given list of targets, false otherwise\n */\nfunction _isInGivenRequestTargets(failedRequestTargets, target) {\n  return failedRequestTargets.some(givenRequestTarget => {\n    if (typeof givenRequestTarget === 'string') {\n      return target.includes(givenRequestTarget);\n    }\n    return givenRequestTarget.test(target);\n  });\n}\n\n/**\n * Checks if the given status code is in the given range\n *\n * @param status The status code to check\n * @returns true if the status code is in the given range, false otherwise\n */\nfunction _isInGivenStatusRanges(failedRequestStatusCodes, status) {\n  return failedRequestStatusCodes.some(range => {\n    if (typeof range === 'number') {\n      return range === status;\n    }\n    return status >= range[0] && status <= range[1];\n  });\n}\n\n/**\n * Wraps `fetch` function to capture request and response data\n */\nfunction _wrapFetch(client, options) {\n  if (!supportsNativeFetch()) {\n    return;\n  }\n  addFetchInstrumentationHandler(handlerData => {\n    if (getClient() !== client) {\n      return;\n    }\n    const {\n      response,\n      args,\n      error,\n      virtualError\n    } = handlerData;\n    const [requestInfo, requestInit] = args;\n    if (!response) {\n      return;\n    }\n    _fetchResponseHandler(options, requestInfo, response, requestInit, error || virtualError);\n  }, false);\n}\n\n/**\n * Wraps XMLHttpRequest to capture request and response data\n */\nfunction _wrapXHR(client, options) {\n  if (!('XMLHttpRequest' in GLOBAL_OBJ)) {\n    return;\n  }\n  addXhrInstrumentationHandler(handlerData => {\n    if (getClient() !== client) {\n      return;\n    }\n    const {\n      error,\n      virtualError\n    } = handlerData;\n    const xhr = handlerData.xhr;\n    const sentryXhrData = xhr[SENTRY_XHR_DATA_KEY];\n    if (!sentryXhrData) {\n      return;\n    }\n    const {\n      method,\n      request_headers: headers\n    } = sentryXhrData;\n    try {\n      _xhrResponseHandler(options, xhr, method, headers, error || virtualError);\n    } catch (e) {\n      DEBUG_BUILD && debug.warn('Error while extracting response event form XHR response', e);\n    }\n  });\n}\n\n/**\n * Checks whether to capture given response as an event\n *\n * @param status response status code\n * @param url response url\n */\nfunction _shouldCaptureResponse(options, status, url) {\n  return _isInGivenStatusRanges(options.failedRequestStatusCodes, status) && _isInGivenRequestTargets(options.failedRequestTargets, url) && !isSentryRequestUrl(url, getClient());\n}\n\n/**\n * Creates a synthetic Sentry event from given response data\n *\n * @param data response data\n * @returns event\n */\nfunction _createEvent(data) {\n  const client = getClient();\n  const virtualStackTrace = client && data.error && data.error instanceof Error ? data.error.stack : undefined;\n  // Remove the first frame from the stack as it's the HttpClient call\n  const stack = virtualStackTrace && client ? client.getOptions().stackParser(virtualStackTrace, 0, 1) : undefined;\n  const message = `HTTP Client Error with status code: ${data.status}`;\n  const event = {\n    message,\n    exception: {\n      values: [{\n        type: 'Error',\n        value: message,\n        stacktrace: stack ? {\n          frames: stack\n        } : undefined\n      }]\n    },\n    request: {\n      url: data.url,\n      method: data.method,\n      headers: data.requestHeaders,\n      cookies: data.requestCookies\n    },\n    contexts: {\n      response: {\n        status_code: data.status,\n        headers: data.responseHeaders,\n        cookies: data.responseCookies,\n        body_size: _getResponseSizeFromHeaders(data.responseHeaders)\n      }\n    }\n  };\n  addExceptionMechanism(event, {\n    type: 'http.client',\n    handled: false\n  });\n  return event;\n}\nfunction _getRequest(requestInfo, requestInit) {\n  if (!requestInit && requestInfo instanceof Request) {\n    return requestInfo;\n  }\n\n  // If both are set, we try to construct a new Request with the given arguments\n  // However, if e.g. the original request has a `body`, this will throw an error because it was already accessed\n  // In this case, as a fallback, we just use the original request - using both is rather an edge case\n  if (requestInfo instanceof Request && requestInfo.bodyUsed) {\n    return requestInfo;\n  }\n  return new Request(requestInfo, requestInit);\n}\nfunction _shouldSendDefaultPii() {\n  const client = getClient();\n  return client ? Boolean(client.getOptions().sendDefaultPii) : false;\n}\nexport { httpClientIntegration };","map":{"version":3,"names":["INTEGRATION_NAME","_httpClientIntegration","options","_options","failedRequestStatusCodes","failedRequestTargets","name","setup","client","_wrapFetch","_wrapXHR","httpClientIntegration","defineIntegration","_fetchResponseHandler","requestInfo","response","requestInit","error","_shouldCaptureResponse","status","url","request","_getRequest","requestHeaders","responseHeaders","requestCookies","responseCookies","_shouldSendDefaultPii","_parseCookieHeaders","event","_createEvent","method","captureEvent","cookieHeader","obj","headers","_extractFetchHeaders","cookies","cookieString","toLowerCase","undefined","_parseCookieString","_xhrResponseHandler","xhr","responseURL","getResponseHeader","_getXHRResponseHeaders","_getResponseSizeFromHeaders","contentLength","parseInt","split","reduce","acc","cookie","key","value","result","forEach","getAllResponseHeaders","line","_isInGivenRequestTargets","target","some","givenRequestTarget","includes","test","_isInGivenStatusRanges","range","supportsNativeFetch","addFetchInstrumentationHandler","handlerData","getClient","args","virtualError","GLOBAL_OBJ","addXhrInstrumentationHandler","sentryXhrData","SENTRY_XHR_DATA_KEY","request_headers","e","DEBUG_BUILD","debug","warn","isSentryRequestUrl","data","virtualStackTrace","Error","stack","getOptions","stackParser","message","exception","values","type","stacktrace","frames","contexts","status_code","body_size","addExceptionMechanism","handled","Request","bodyUsed","Boolean","sendDefaultPii"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/browser/src/integrations/httpclient.ts"],"sourcesContent":["import type { Client, Event as SentryEvent, IntegrationFn, SentryWrappedXMLHttpRequest } from '@sentry/core';\nimport {\n  addExceptionMechanism,\n  addFetchInstrumentationHandler,\n  captureEvent,\n  debug,\n  defineIntegration,\n  getClient,\n  GLOBAL_OBJ,\n  isSentryRequestUrl,\n  supportsNativeFetch,\n} from '@sentry/core';\nimport { addXhrInstrumentationHandler, SENTRY_XHR_DATA_KEY } from '@sentry-internal/browser-utils';\nimport { DEBUG_BUILD } from '../debug-build';\n\nexport type HttpStatusCodeRange = [number, number] | number;\nexport type HttpRequestTarget = string | RegExp;\n\nconst INTEGRATION_NAME = 'HttpClient';\n\ninterface HttpClientOptions {\n  /**\n   * HTTP status codes that should be considered failed.\n   * This array can contain tuples of `[begin, end]` (both inclusive),\n   * single status codes, or a combinations of both\n   *\n   * Example: [[500, 505], 507]\n   * Default: [[500, 599]]\n   */\n  failedRequestStatusCodes: HttpStatusCodeRange[];\n\n  /**\n   * Targets to track for failed requests.\n   * This array can contain strings or regular expressions.\n   *\n   * Example: ['http://localhost', /api\\/.*\\/]\n   * Default: [/.*\\/]\n   */\n  failedRequestTargets: HttpRequestTarget[];\n}\n\nconst _httpClientIntegration = ((options: Partial<HttpClientOptions> = {}) => {\n  const _options: HttpClientOptions = {\n    failedRequestStatusCodes: [[500, 599]],\n    failedRequestTargets: [/.*/],\n    ...options,\n  };\n\n  return {\n    name: INTEGRATION_NAME,\n    setup(client): void {\n      _wrapFetch(client, _options);\n      _wrapXHR(client, _options);\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Create events for failed client side HTTP requests.\n */\nexport const httpClientIntegration = defineIntegration(_httpClientIntegration);\n\n/**\n * Interceptor function for fetch requests\n *\n * @param requestInfo The Fetch API request info\n * @param response The Fetch API response\n * @param requestInit The request init object\n */\nfunction _fetchResponseHandler(\n  options: HttpClientOptions,\n  requestInfo: RequestInfo,\n  response: Response,\n  requestInit?: RequestInit,\n  error?: unknown,\n): void {\n  if (_shouldCaptureResponse(options, response.status, response.url)) {\n    const request = _getRequest(requestInfo, requestInit);\n\n    let requestHeaders, responseHeaders, requestCookies, responseCookies;\n\n    if (_shouldSendDefaultPii()) {\n      [requestHeaders, requestCookies] = _parseCookieHeaders('Cookie', request);\n      [responseHeaders, responseCookies] = _parseCookieHeaders('Set-Cookie', response);\n    }\n\n    const event = _createEvent({\n      url: request.url,\n      method: request.method,\n      status: response.status,\n      requestHeaders,\n      responseHeaders,\n      requestCookies,\n      responseCookies,\n      error,\n    });\n\n    captureEvent(event);\n  }\n}\n\nfunction _parseCookieHeaders(\n  cookieHeader: string,\n  obj: Request | Response,\n): [Record<string, string>, Record<string, string> | undefined] {\n  const headers = _extractFetchHeaders(obj.headers);\n  let cookies;\n\n  try {\n    const cookieString = headers[cookieHeader] || headers[cookieHeader.toLowerCase()] || undefined;\n\n    if (cookieString) {\n      cookies = _parseCookieString(cookieString);\n    }\n  } catch {\n    // ignore it if parsing fails\n  }\n\n  return [headers, cookies];\n}\n\n/**\n * Interceptor function for XHR requests\n *\n * @param xhr The XHR request\n * @param method The HTTP method\n * @param headers The HTTP headers\n */\nfunction _xhrResponseHandler(\n  options: HttpClientOptions,\n  xhr: XMLHttpRequest,\n  method: string,\n  headers: Record<string, string>,\n  error?: unknown,\n): void {\n  if (_shouldCaptureResponse(options, xhr.status, xhr.responseURL)) {\n    let requestHeaders, responseCookies, responseHeaders;\n\n    if (_shouldSendDefaultPii()) {\n      try {\n        const cookieString = xhr.getResponseHeader('Set-Cookie') || xhr.getResponseHeader('set-cookie') || undefined;\n\n        if (cookieString) {\n          responseCookies = _parseCookieString(cookieString);\n        }\n      } catch {\n        // ignore it if parsing fails\n      }\n\n      try {\n        responseHeaders = _getXHRResponseHeaders(xhr);\n      } catch {\n        // ignore it if parsing fails\n      }\n\n      requestHeaders = headers;\n    }\n\n    const event = _createEvent({\n      url: xhr.responseURL,\n      method,\n      status: xhr.status,\n      requestHeaders,\n      // Can't access request cookies from XHR\n      responseHeaders,\n      responseCookies,\n      error,\n    });\n\n    captureEvent(event);\n  }\n}\n\n/**\n * Extracts response size from `Content-Length` header when possible\n *\n * @param headers\n * @returns The response size in bytes or undefined\n */\nfunction _getResponseSizeFromHeaders(headers?: Record<string, string>): number | undefined {\n  if (headers) {\n    const contentLength = headers['Content-Length'] || headers['content-length'];\n\n    if (contentLength) {\n      return parseInt(contentLength, 10);\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Creates an object containing cookies from the given cookie string\n *\n * @param cookieString The cookie string to parse\n * @returns The parsed cookies\n */\nfunction _parseCookieString(cookieString: string): Record<string, string> {\n  return cookieString.split('; ').reduce((acc: Record<string, string>, cookie: string) => {\n    const [key, value] = cookie.split('=');\n    if (key && value) {\n      acc[key] = value;\n    }\n    return acc;\n  }, {});\n}\n\n/**\n * Extracts the headers as an object from the given Fetch API request or response object\n *\n * @param headers The headers to extract\n * @returns The extracted headers as an object\n */\nfunction _extractFetchHeaders(headers: Headers): Record<string, string> {\n  const result: Record<string, string> = {};\n\n  headers.forEach((value, key) => {\n    result[key] = value;\n  });\n\n  return result;\n}\n\n/**\n * Extracts the response headers as an object from the given XHR object\n *\n * @param xhr The XHR object to extract the response headers from\n * @returns The response headers as an object\n */\nfunction _getXHRResponseHeaders(xhr: XMLHttpRequest): Record<string, string> {\n  const headers = xhr.getAllResponseHeaders();\n\n  if (!headers) {\n    return {};\n  }\n\n  return headers.split('\\r\\n').reduce((acc: Record<string, string>, line: string) => {\n    const [key, value] = line.split(': ');\n    if (key && value) {\n      acc[key] = value;\n    }\n    return acc;\n  }, {});\n}\n\n/**\n * Checks if the given target url is in the given list of targets\n *\n * @param target The target url to check\n * @returns true if the target url is in the given list of targets, false otherwise\n */\nfunction _isInGivenRequestTargets(\n  failedRequestTargets: HttpClientOptions['failedRequestTargets'],\n  target: string,\n): boolean {\n  return failedRequestTargets.some((givenRequestTarget: HttpRequestTarget) => {\n    if (typeof givenRequestTarget === 'string') {\n      return target.includes(givenRequestTarget);\n    }\n\n    return givenRequestTarget.test(target);\n  });\n}\n\n/**\n * Checks if the given status code is in the given range\n *\n * @param status The status code to check\n * @returns true if the status code is in the given range, false otherwise\n */\nfunction _isInGivenStatusRanges(\n  failedRequestStatusCodes: HttpClientOptions['failedRequestStatusCodes'],\n  status: number,\n): boolean {\n  return failedRequestStatusCodes.some((range: HttpStatusCodeRange) => {\n    if (typeof range === 'number') {\n      return range === status;\n    }\n\n    return status >= range[0] && status <= range[1];\n  });\n}\n\n/**\n * Wraps `fetch` function to capture request and response data\n */\nfunction _wrapFetch(client: Client, options: HttpClientOptions): void {\n  if (!supportsNativeFetch()) {\n    return;\n  }\n\n  addFetchInstrumentationHandler(handlerData => {\n    if (getClient() !== client) {\n      return;\n    }\n\n    const { response, args, error, virtualError } = handlerData;\n    const [requestInfo, requestInit] = args as [RequestInfo, RequestInit | undefined];\n\n    if (!response) {\n      return;\n    }\n\n    _fetchResponseHandler(options, requestInfo, response as Response, requestInit, error || virtualError);\n  }, false);\n}\n\n/**\n * Wraps XMLHttpRequest to capture request and response data\n */\nfunction _wrapXHR(client: Client, options: HttpClientOptions): void {\n  if (!('XMLHttpRequest' in GLOBAL_OBJ)) {\n    return;\n  }\n\n  addXhrInstrumentationHandler(handlerData => {\n    if (getClient() !== client) {\n      return;\n    }\n\n    const { error, virtualError } = handlerData;\n\n    const xhr = handlerData.xhr as SentryWrappedXMLHttpRequest & XMLHttpRequest;\n\n    const sentryXhrData = xhr[SENTRY_XHR_DATA_KEY];\n\n    if (!sentryXhrData) {\n      return;\n    }\n\n    const { method, request_headers: headers } = sentryXhrData;\n\n    try {\n      _xhrResponseHandler(options, xhr, method, headers, error || virtualError);\n    } catch (e) {\n      DEBUG_BUILD && debug.warn('Error while extracting response event form XHR response', e);\n    }\n  });\n}\n\n/**\n * Checks whether to capture given response as an event\n *\n * @param status response status code\n * @param url response url\n */\nfunction _shouldCaptureResponse(options: HttpClientOptions, status: number, url: string): boolean {\n  return (\n    _isInGivenStatusRanges(options.failedRequestStatusCodes, status) &&\n    _isInGivenRequestTargets(options.failedRequestTargets, url) &&\n    !isSentryRequestUrl(url, getClient())\n  );\n}\n\n/**\n * Creates a synthetic Sentry event from given response data\n *\n * @param data response data\n * @returns event\n */\nfunction _createEvent(data: {\n  url: string;\n  method: string;\n  status: number;\n  responseHeaders?: Record<string, string>;\n  responseCookies?: Record<string, string>;\n  requestHeaders?: Record<string, string>;\n  requestCookies?: Record<string, string>;\n  error?: unknown;\n}): SentryEvent {\n  const client = getClient();\n  const virtualStackTrace = client && data.error && data.error instanceof Error ? data.error.stack : undefined;\n  // Remove the first frame from the stack as it's the HttpClient call\n  const stack = virtualStackTrace && client ? client.getOptions().stackParser(virtualStackTrace, 0, 1) : undefined;\n  const message = `HTTP Client Error with status code: ${data.status}`;\n\n  const event: SentryEvent = {\n    message,\n    exception: {\n      values: [\n        {\n          type: 'Error',\n          value: message,\n          stacktrace: stack ? { frames: stack } : undefined,\n        },\n      ],\n    },\n    request: {\n      url: data.url,\n      method: data.method,\n      headers: data.requestHeaders,\n      cookies: data.requestCookies,\n    },\n    contexts: {\n      response: {\n        status_code: data.status,\n        headers: data.responseHeaders,\n        cookies: data.responseCookies,\n        body_size: _getResponseSizeFromHeaders(data.responseHeaders),\n      },\n    },\n  };\n\n  addExceptionMechanism(event, {\n    type: 'http.client',\n    handled: false,\n  });\n\n  return event;\n}\n\nfunction _getRequest(requestInfo: RequestInfo, requestInit?: RequestInit): Request {\n  if (!requestInit && requestInfo instanceof Request) {\n    return requestInfo;\n  }\n\n  // If both are set, we try to construct a new Request with the given arguments\n  // However, if e.g. the original request has a `body`, this will throw an error because it was already accessed\n  // In this case, as a fallback, we just use the original request - using both is rather an edge case\n  if (requestInfo instanceof Request && requestInfo.bodyUsed) {\n    return requestInfo;\n  }\n\n  return new Request(requestInfo, requestInit);\n}\n\nfunction _shouldSendDefaultPii(): boolean {\n  const client = getClient();\n  return client ? Boolean(client.getOptions().sendDefaultPii) : false;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}