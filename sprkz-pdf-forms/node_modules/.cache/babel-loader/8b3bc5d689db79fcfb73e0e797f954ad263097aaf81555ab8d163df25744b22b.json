{"ast":null,"code":"import { getAsyncContextStrategy } from './asyncContext/index.js';\nimport { getMainCarrier, getGlobalSingleton } from './carrier.js';\nimport { Scope } from './scope.js';\nimport { generateSpanId } from './utils/propagationContext.js';\n\n/**\n * Get the currently active scope.\n */\nfunction getCurrentScope() {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  return acs.getCurrentScope();\n}\n\n/**\n * Get the currently active isolation scope.\n * The isolation scope is active for the current execution context.\n */\nfunction getIsolationScope() {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  return acs.getIsolationScope();\n}\n\n/**\n * Get the global scope.\n * This scope is applied to _all_ events.\n */\nfunction getGlobalScope() {\n  return getGlobalSingleton('globalScope', () => new Scope());\n}\n\n/**\n * Creates a new scope with and executes the given operation within.\n * The scope is automatically removed once the operation\n * finishes or throws.\n */\n\n/**\n * Either creates a new active scope, or sets the given scope as active scope in the given callback.\n */\nfunction withScope(...rest) {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n\n  // If a scope is defined, we want to make this the active scope instead of the default one\n  if (rest.length === 2) {\n    const [scope, callback] = rest;\n    if (!scope) {\n      return acs.withScope(callback);\n    }\n    return acs.withSetScope(scope, callback);\n  }\n  return acs.withScope(rest[0]);\n}\n\n/**\n * Attempts to fork the current isolation scope and the current scope based on the current async context strategy. If no\n * async context strategy is set, the isolation scope and the current scope will not be forked (this is currently the\n * case, for example, in the browser).\n *\n * Usage of this function in environments without async context strategy is discouraged and may lead to unexpected behaviour.\n *\n * This function is intended for Sentry SDK and SDK integration development. It is not recommended to be used in \"normal\"\n * applications directly because it comes with pitfalls. Use at your own risk!\n */\n\n/**\n * Either creates a new active isolation scope, or sets the given isolation scope as active scope in the given callback.\n */\nfunction withIsolationScope(...rest) {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n\n  // If a scope is defined, we want to make this the active scope instead of the default one\n  if (rest.length === 2) {\n    const [isolationScope, callback] = rest;\n    if (!isolationScope) {\n      return acs.withIsolationScope(callback);\n    }\n    return acs.withSetIsolationScope(isolationScope, callback);\n  }\n  return acs.withIsolationScope(rest[0]);\n}\n\n/**\n * Get the currently active client.\n */\nfunction getClient() {\n  return getCurrentScope().getClient();\n}\n\n/**\n * Get a trace context for the given scope.\n */\nfunction getTraceContextFromScope(scope) {\n  const propagationContext = scope.getPropagationContext();\n  const {\n    traceId,\n    parentSpanId,\n    propagationSpanId\n  } = propagationContext;\n  const traceContext = {\n    trace_id: traceId,\n    span_id: propagationSpanId || generateSpanId()\n  };\n  if (parentSpanId) {\n    traceContext.parent_span_id = parentSpanId;\n  }\n  return traceContext;\n}\nexport { getClient, getCurrentScope, getGlobalScope, getIsolationScope, getTraceContextFromScope, withIsolationScope, withScope };","map":{"version":3,"names":["getCurrentScope","carrier","getMainCarrier","acs","getAsyncContextStrategy","getIsolationScope","getGlobalScope","getGlobalSingleton","Scope","withScope","rest","length","scope","callback","withSetScope","withIsolationScope","isolationScope","withSetIsolationScope","getClient","getTraceContextFromScope","propagationContext","getPropagationContext","traceId","parentSpanId","propagationSpanId","traceContext","trace_id","span_id","generateSpanId","parent_span_id"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/currentScopes.ts"],"sourcesContent":["import { getAsyncContextStrategy } from './asyncContext';\nimport { getGlobalSingleton, getMainCarrier } from './carrier';\nimport type { Client } from './client';\nimport { Scope } from './scope';\nimport type { TraceContext } from './types-hoist/context';\nimport { generateSpanId } from './utils/propagationContext';\n\n/**\n * Get the currently active scope.\n */\nexport function getCurrentScope(): Scope {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  return acs.getCurrentScope();\n}\n\n/**\n * Get the currently active isolation scope.\n * The isolation scope is active for the current execution context.\n */\nexport function getIsolationScope(): Scope {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  return acs.getIsolationScope();\n}\n\n/**\n * Get the global scope.\n * This scope is applied to _all_ events.\n */\nexport function getGlobalScope(): Scope {\n  return getGlobalSingleton('globalScope', () => new Scope());\n}\n\n/**\n * Creates a new scope with and executes the given operation within.\n * The scope is automatically removed once the operation\n * finishes or throws.\n */\nexport function withScope<T>(callback: (scope: Scope) => T): T;\n/**\n * Set the given scope as the active scope in the callback.\n */\nexport function withScope<T>(scope: Scope | undefined, callback: (scope: Scope) => T): T;\n/**\n * Either creates a new active scope, or sets the given scope as active scope in the given callback.\n */\nexport function withScope<T>(\n  ...rest: [callback: (scope: Scope) => T] | [scope: Scope | undefined, callback: (scope: Scope) => T]\n): T {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n\n  // If a scope is defined, we want to make this the active scope instead of the default one\n  if (rest.length === 2) {\n    const [scope, callback] = rest;\n\n    if (!scope) {\n      return acs.withScope(callback);\n    }\n\n    return acs.withSetScope(scope, callback);\n  }\n\n  return acs.withScope(rest[0]);\n}\n\n/**\n * Attempts to fork the current isolation scope and the current scope based on the current async context strategy. If no\n * async context strategy is set, the isolation scope and the current scope will not be forked (this is currently the\n * case, for example, in the browser).\n *\n * Usage of this function in environments without async context strategy is discouraged and may lead to unexpected behaviour.\n *\n * This function is intended for Sentry SDK and SDK integration development. It is not recommended to be used in \"normal\"\n * applications directly because it comes with pitfalls. Use at your own risk!\n */\nexport function withIsolationScope<T>(callback: (isolationScope: Scope) => T): T;\n/**\n * Set the provided isolation scope as active in the given callback. If no\n * async context strategy is set, the isolation scope and the current scope will not be forked (this is currently the\n * case, for example, in the browser).\n *\n * Usage of this function in environments without async context strategy is discouraged and may lead to unexpected behaviour.\n *\n * This function is intended for Sentry SDK and SDK integration development. It is not recommended to be used in \"normal\"\n * applications directly because it comes with pitfalls. Use at your own risk!\n *\n * If you pass in `undefined` as a scope, it will fork a new isolation scope, the same as if no scope is passed.\n */\nexport function withIsolationScope<T>(isolationScope: Scope | undefined, callback: (isolationScope: Scope) => T): T;\n/**\n * Either creates a new active isolation scope, or sets the given isolation scope as active scope in the given callback.\n */\nexport function withIsolationScope<T>(\n  ...rest:\n    | [callback: (isolationScope: Scope) => T]\n    | [isolationScope: Scope | undefined, callback: (isolationScope: Scope) => T]\n): T {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n\n  // If a scope is defined, we want to make this the active scope instead of the default one\n  if (rest.length === 2) {\n    const [isolationScope, callback] = rest;\n\n    if (!isolationScope) {\n      return acs.withIsolationScope(callback);\n    }\n\n    return acs.withSetIsolationScope(isolationScope, callback);\n  }\n\n  return acs.withIsolationScope(rest[0]);\n}\n\n/**\n * Get the currently active client.\n */\nexport function getClient<C extends Client>(): C | undefined {\n  return getCurrentScope().getClient<C>();\n}\n\n/**\n * Get a trace context for the given scope.\n */\nexport function getTraceContextFromScope(scope: Scope): TraceContext {\n  const propagationContext = scope.getPropagationContext();\n\n  const { traceId, parentSpanId, propagationSpanId } = propagationContext;\n\n  const traceContext: TraceContext = {\n    trace_id: traceId,\n    span_id: propagationSpanId || generateSpanId(),\n  };\n\n  if (parentSpanId) {\n    traceContext.parent_span_id = parentSpanId;\n  }\n\n  return traceContext;\n}\n"],"mappings":";;;;;AAOA;AACA;AACA;AACO,SAASA,eAAeA,CAAA,EAAU;EACvC,MAAMC,OAAA,GAAUC,cAAc,EAAE;EAChC,MAAMC,GAAA,GAAMC,uBAAuB,CAACH,OAAO,CAAC;EAC5C,OAAOE,GAAG,CAACH,eAAe,EAAE;AAC9B;;AAEA;AACA;AACA;AACA;AACO,SAASK,iBAAiBA,CAAA,EAAU;EACzC,MAAMJ,OAAA,GAAUC,cAAc,EAAE;EAChC,MAAMC,GAAA,GAAMC,uBAAuB,CAACH,OAAO,CAAC;EAC5C,OAAOE,GAAG,CAACE,iBAAiB,EAAE;AAChC;;AAEA;AACA;AACA;AACA;AACO,SAASC,cAAcA,CAAA,EAAU;EACtC,OAAOC,kBAAkB,CAAC,aAAa,EAAE,MAAM,IAAIC,KAAK,EAAE,CAAC;AAC7D;;AAEA;AACA;AACA;AACA;AACA;;AAMA;AACA;AACA;AACO,SAASC,SAASA,CACvB,GAAGC,IAAA,EACA;EACH,MAAMT,OAAA,GAAUC,cAAc,EAAE;EAChC,MAAMC,GAAA,GAAMC,uBAAuB,CAACH,OAAO,CAAC;;EAE9C;EACE,IAAIS,IAAI,CAACC,MAAA,KAAW,CAAC,EAAE;IACrB,MAAM,CAACC,KAAK,EAAEC,QAAQ,IAAIH,IAAI;IAE9B,IAAI,CAACE,KAAK,EAAE;MACV,OAAOT,GAAG,CAACM,SAAS,CAACI,QAAQ,CAAC;IACpC;IAEI,OAAOV,GAAG,CAACW,YAAY,CAACF,KAAK,EAAEC,QAAQ,CAAC;EAC5C;EAEE,OAAOV,GAAG,CAACM,SAAS,CAACC,IAAI,CAAC,CAAC,CAAC,CAAC;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAeA;AACA;AACA;AACO,SAASK,kBAAkBA,CAChC,GAAGL,IAAA,EAGA;EACH,MAAMT,OAAA,GAAUC,cAAc,EAAE;EAChC,MAAMC,GAAA,GAAMC,uBAAuB,CAACH,OAAO,CAAC;;EAE9C;EACE,IAAIS,IAAI,CAACC,MAAA,KAAW,CAAC,EAAE;IACrB,MAAM,CAACK,cAAc,EAAEH,QAAQ,IAAIH,IAAI;IAEvC,IAAI,CAACM,cAAc,EAAE;MACnB,OAAOb,GAAG,CAACY,kBAAkB,CAACF,QAAQ,CAAC;IAC7C;IAEI,OAAOV,GAAG,CAACc,qBAAqB,CAACD,cAAc,EAAEH,QAAQ,CAAC;EAC9D;EAEE,OAAOV,GAAG,CAACY,kBAAkB,CAACL,IAAI,CAAC,CAAC,CAAC,CAAC;AACxC;;AAEA;AACA;AACA;AACO,SAASQ,SAASA,CAAA,EAAoC;EAC3D,OAAOlB,eAAe,EAAE,CAACkB,SAAS,EAAK;AACzC;;AAEA;AACA;AACA;AACO,SAASC,wBAAwBA,CAACP,KAAK,EAAuB;EACnE,MAAMQ,kBAAA,GAAqBR,KAAK,CAACS,qBAAqB,EAAE;EAExD,MAAM;IAAEC,OAAO;IAAEC,YAAY;IAAEC;EAAA,CAAkB,GAAIJ,kBAAkB;EAEvE,MAAMK,YAAY,GAAiB;IACjCC,QAAQ,EAAEJ,OAAO;IACjBK,OAAO,EAAEH,iBAAA,IAAqBI,cAAc;EAChD,CAAG;EAED,IAAIL,YAAY,EAAE;IAChBE,YAAY,CAACI,cAAA,GAAiBN,YAAY;EAC9C;EAEE,OAAOE,YAAY;AACrB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}