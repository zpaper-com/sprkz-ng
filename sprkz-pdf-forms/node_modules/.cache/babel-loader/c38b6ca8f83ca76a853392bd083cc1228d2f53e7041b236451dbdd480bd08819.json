{"ast":null,"code":"import { GLOBAL_OBJ, getOriginalFunction, markFunctionWrapped, addNonEnumerableProperty, withScope, addExceptionTypeValue, addExceptionMechanism, captureException, getLocationHref } from '@sentry/core';\nconst WINDOW = GLOBAL_OBJ;\nlet ignoreOnError = 0;\n\n/**\n * @hidden\n */\nfunction shouldIgnoreOnError() {\n  return ignoreOnError > 0;\n}\n\n/**\n * @hidden\n */\nfunction ignoreNextOnError() {\n  // onerror should trigger before setTimeout\n  ignoreOnError++;\n  setTimeout(() => {\n    ignoreOnError--;\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\n\n/**\n * Instruments the given function and sends an event to Sentry every time the\n * function throws an exception.\n *\n * @param fn A function to wrap. It is generally safe to pass an unbound function, because the returned wrapper always\n * has a correct `this` context.\n * @returns The wrapped function.\n * @hidden\n */\nfunction wrap(fn, options = {}) {\n  // for future readers what this does is wrap a function and then create\n  // a bi-directional wrapping between them.\n  //\n  // example: wrapped = wrap(original);\n  //  original.__sentry_wrapped__ -> wrapped\n  //  wrapped.__sentry_original__ -> original\n\n  function isFunction(fn) {\n    return typeof fn === 'function';\n  }\n  if (!isFunction(fn)) {\n    return fn;\n  }\n  try {\n    // if we're dealing with a function that was previously wrapped, return\n    // the original wrapper.\n    const wrapper = fn.__sentry_wrapped__;\n    if (wrapper) {\n      if (typeof wrapper === 'function') {\n        return wrapper;\n      } else {\n        // If we find that the `__sentry_wrapped__` function is not a function at the time of accessing it, it means\n        // that something messed with it. In that case we want to return the originally passed function.\n        return fn;\n      }\n    }\n\n    // We don't wanna wrap it twice\n    if (getOriginalFunction(fn)) {\n      return fn;\n    }\n  } catch {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    // Bail on wrapping and return the function as-is (defers to window.onerror).\n    return fn;\n  }\n\n  // Wrap the function itself\n  // It is important that `sentryWrapped` is not an arrow function to preserve the context of `this`\n  const sentryWrapped = function (...args) {\n    try {\n      // Also wrap arguments that are themselves functions\n      const wrappedArguments = args.map(arg => wrap(arg, options));\n\n      // Attempt to invoke user-land function\n      // NOTE: If you are a Sentry user, and you are seeing this stack frame, it\n      //       means the sentry.javascript SDK caught an error invoking your application code. This\n      //       is expected behavior and NOT indicative of a bug with sentry.javascript.\n      return fn.apply(this, wrappedArguments);\n    } catch (ex) {\n      ignoreNextOnError();\n      withScope(scope => {\n        scope.addEventProcessor(event => {\n          if (options.mechanism) {\n            addExceptionTypeValue(event, undefined, undefined);\n            addExceptionMechanism(event, options.mechanism);\n          }\n          event.extra = {\n            ...event.extra,\n            arguments: args\n          };\n          return event;\n        });\n        captureException(ex);\n      });\n      throw ex;\n    }\n  };\n\n  // Wrap the wrapped function in a proxy, to ensure any other properties of the original function remain available\n  try {\n    for (const property in fn) {\n      if (Object.prototype.hasOwnProperty.call(fn, property)) {\n        sentryWrapped[property] = fn[property];\n      }\n    }\n  } catch {\n    // Accessing some objects may throw\n    // ref: https://github.com/getsentry/sentry-javascript/issues/1168\n  }\n\n  // Signal that this function has been wrapped/filled already\n  // for both debugging and to prevent it to being wrapped/filled twice\n  markFunctionWrapped(sentryWrapped, fn);\n  addNonEnumerableProperty(fn, '__sentry_wrapped__', sentryWrapped);\n\n  // Restore original function name (not all browsers allow that)\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, 'name');\n    if (descriptor.configurable) {\n      Object.defineProperty(sentryWrapped, 'name', {\n        get() {\n          return fn.name;\n        }\n      });\n    }\n  } catch {\n    // This may throw if e.g. the descriptor does not exist, or a browser does not allow redefining `name`.\n    // to save some bytes we simply try-catch this\n  }\n  return sentryWrapped;\n}\n\n/**\n * Get HTTP request data from the current page.\n */\nfunction getHttpRequestData() {\n  // grab as much info as exists and add it to the event\n  const url = getLocationHref();\n  const {\n    referrer\n  } = WINDOW.document || {};\n  const {\n    userAgent\n  } = WINDOW.navigator || {};\n  const headers = {\n    ...(referrer && {\n      Referer: referrer\n    }),\n    ...(userAgent && {\n      'User-Agent': userAgent\n    })\n  };\n  const request = {\n    url,\n    headers\n  };\n  return request;\n}\nexport { WINDOW, getHttpRequestData, ignoreNextOnError, shouldIgnoreOnError, wrap };","map":{"version":3,"names":["WINDOW","GLOBAL_OBJ","ignoreOnError","shouldIgnoreOnError","ignoreNextOnError","setTimeout","wrap","fn","options","isFunction","wrapper","__sentry_wrapped__","getOriginalFunction","sentryWrapped","args","wrappedArguments","map","arg","apply","ex","withScope","scope","addEventProcessor","event","mechanism","addExceptionTypeValue","undefined","addExceptionMechanism","extra","arguments","captureException","property","Object","prototype","hasOwnProperty","call","markFunctionWrapped","addNonEnumerableProperty","descriptor","getOwnPropertyDescriptor","configurable","defineProperty","get","name","getHttpRequestData","url","getLocationHref","referrer","document","userAgent","navigator","headers","Referer","request"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/browser/src/helpers.ts"],"sourcesContent":["import type { Mechanism, WrappedFunction } from '@sentry/core';\nimport {\n  addExceptionMechanism,\n  addExceptionTypeValue,\n  addNonEnumerableProperty,\n  captureException,\n  getLocationHref,\n  getOriginalFunction,\n  GLOBAL_OBJ,\n  markFunctionWrapped,\n  withScope,\n} from '@sentry/core';\n\nexport const WINDOW = GLOBAL_OBJ as typeof GLOBAL_OBJ & Window;\n\nlet ignoreOnError: number = 0;\n\n/**\n * @hidden\n */\nexport function shouldIgnoreOnError(): boolean {\n  return ignoreOnError > 0;\n}\n\n/**\n * @hidden\n */\nexport function ignoreNextOnError(): void {\n  // onerror should trigger before setTimeout\n  ignoreOnError++;\n  setTimeout(() => {\n    ignoreOnError--;\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\ntype WrappableFunction = Function;\n\nexport function wrap<T extends WrappableFunction>(\n  fn: T,\n  options?: {\n    mechanism?: Mechanism;\n  },\n): WrappedFunction<T>;\nexport function wrap<NonFunction>(\n  fn: NonFunction,\n  options?: {\n    mechanism?: Mechanism;\n  },\n): NonFunction;\n/**\n * Instruments the given function and sends an event to Sentry every time the\n * function throws an exception.\n *\n * @param fn A function to wrap. It is generally safe to pass an unbound function, because the returned wrapper always\n * has a correct `this` context.\n * @returns The wrapped function.\n * @hidden\n */\nexport function wrap<T extends WrappableFunction, NonFunction>(\n  fn: T | NonFunction,\n  options: {\n    mechanism?: Mechanism;\n  } = {},\n): NonFunction | WrappedFunction<T> {\n  // for future readers what this does is wrap a function and then create\n  // a bi-directional wrapping between them.\n  //\n  // example: wrapped = wrap(original);\n  //  original.__sentry_wrapped__ -> wrapped\n  //  wrapped.__sentry_original__ -> original\n\n  function isFunction(fn: T | NonFunction): fn is T {\n    return typeof fn === 'function';\n  }\n\n  if (!isFunction(fn)) {\n    return fn;\n  }\n\n  try {\n    // if we're dealing with a function that was previously wrapped, return\n    // the original wrapper.\n    const wrapper = (fn as WrappedFunction<T>).__sentry_wrapped__;\n    if (wrapper) {\n      if (typeof wrapper === 'function') {\n        return wrapper;\n      } else {\n        // If we find that the `__sentry_wrapped__` function is not a function at the time of accessing it, it means\n        // that something messed with it. In that case we want to return the originally passed function.\n        return fn;\n      }\n    }\n\n    // We don't wanna wrap it twice\n    if (getOriginalFunction(fn)) {\n      return fn;\n    }\n  } catch {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    // Bail on wrapping and return the function as-is (defers to window.onerror).\n    return fn;\n  }\n\n  // Wrap the function itself\n  // It is important that `sentryWrapped` is not an arrow function to preserve the context of `this`\n  const sentryWrapped = function (this: unknown, ...args: unknown[]): unknown {\n    try {\n      // Also wrap arguments that are themselves functions\n      const wrappedArguments = args.map(arg => wrap(arg, options));\n\n      // Attempt to invoke user-land function\n      // NOTE: If you are a Sentry user, and you are seeing this stack frame, it\n      //       means the sentry.javascript SDK caught an error invoking your application code. This\n      //       is expected behavior and NOT indicative of a bug with sentry.javascript.\n      return fn.apply(this, wrappedArguments);\n    } catch (ex) {\n      ignoreNextOnError();\n\n      withScope(scope => {\n        scope.addEventProcessor(event => {\n          if (options.mechanism) {\n            addExceptionTypeValue(event, undefined, undefined);\n            addExceptionMechanism(event, options.mechanism);\n          }\n\n          event.extra = {\n            ...event.extra,\n            arguments: args,\n          };\n\n          return event;\n        });\n\n        captureException(ex);\n      });\n\n      throw ex;\n    }\n  } as unknown as WrappedFunction<T>;\n\n  // Wrap the wrapped function in a proxy, to ensure any other properties of the original function remain available\n  try {\n    for (const property in fn) {\n      if (Object.prototype.hasOwnProperty.call(fn, property)) {\n        sentryWrapped[property as keyof T] = fn[property as keyof T];\n      }\n    }\n  } catch {\n    // Accessing some objects may throw\n    // ref: https://github.com/getsentry/sentry-javascript/issues/1168\n  }\n\n  // Signal that this function has been wrapped/filled already\n  // for both debugging and to prevent it to being wrapped/filled twice\n  markFunctionWrapped(sentryWrapped, fn);\n\n  addNonEnumerableProperty(fn, '__sentry_wrapped__', sentryWrapped);\n\n  // Restore original function name (not all browsers allow that)\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, 'name')!;\n    if (descriptor.configurable) {\n      Object.defineProperty(sentryWrapped, 'name', {\n        get(): string {\n          return fn.name;\n        },\n      });\n    }\n  } catch {\n    // This may throw if e.g. the descriptor does not exist, or a browser does not allow redefining `name`.\n    // to save some bytes we simply try-catch this\n  }\n\n  return sentryWrapped;\n}\n\n/**\n * Get HTTP request data from the current page.\n */\nexport function getHttpRequestData(): { url: string; headers: Record<string, string> } {\n  // grab as much info as exists and add it to the event\n  const url = getLocationHref();\n  const { referrer } = WINDOW.document || {};\n  const { userAgent } = WINDOW.navigator || {};\n\n  const headers = {\n    ...(referrer && { Referer: referrer }),\n    ...(userAgent && { 'User-Agent': userAgent }),\n  };\n  const request = {\n    url,\n    headers,\n  };\n\n  return request;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}