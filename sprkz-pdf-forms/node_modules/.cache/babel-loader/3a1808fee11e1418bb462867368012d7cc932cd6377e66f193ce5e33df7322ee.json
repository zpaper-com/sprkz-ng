{"ast":null,"code":"import { baggageHeaderToDynamicSamplingContext } from './baggage.js';\nimport { parseSampleRate } from './parseSampleRate.js';\nimport { generateTraceId, generateSpanId } from './propagationContext.js';\n\n// eslint-disable-next-line @sentry-internal/sdk/no-regexp-constructor -- RegExp is used for readability here\nconst TRACEPARENT_REGEXP = new RegExp('^[ \\\\t]*' +\n// whitespace\n'([0-9a-f]{32})?' +\n// trace_id\n'-?([0-9a-f]{16})?' +\n// span_id\n'-?([01])?' +\n// sampled\n'[ \\\\t]*$') // whitespace\n;\n\n/**\n * Extract transaction context data from a `sentry-trace` header.\n *\n * @param traceparent Traceparent string\n *\n * @returns Object containing data from the header, or undefined if traceparent string is malformed\n */\nfunction extractTraceparentData(traceparent) {\n  if (!traceparent) {\n    return undefined;\n  }\n  const matches = traceparent.match(TRACEPARENT_REGEXP);\n  if (!matches) {\n    return undefined;\n  }\n  let parentSampled;\n  if (matches[3] === '1') {\n    parentSampled = true;\n  } else if (matches[3] === '0') {\n    parentSampled = false;\n  }\n  return {\n    traceId: matches[1],\n    parentSampled,\n    parentSpanId: matches[2]\n  };\n}\n\n/**\n * Create a propagation context from incoming headers or\n * creates a minimal new one if the headers are undefined.\n */\nfunction propagationContextFromHeaders(sentryTrace, baggage) {\n  const traceparentData = extractTraceparentData(sentryTrace);\n  const dynamicSamplingContext = baggageHeaderToDynamicSamplingContext(baggage);\n  if (!traceparentData?.traceId) {\n    return {\n      traceId: generateTraceId(),\n      sampleRand: Math.random()\n    };\n  }\n  const sampleRand = getSampleRandFromTraceparentAndDsc(traceparentData, dynamicSamplingContext);\n\n  // The sample_rand on the DSC needs to be generated based on traceparent + baggage.\n  if (dynamicSamplingContext) {\n    dynamicSamplingContext.sample_rand = sampleRand.toString();\n  }\n  const {\n    traceId,\n    parentSpanId,\n    parentSampled\n  } = traceparentData;\n  return {\n    traceId,\n    parentSpanId,\n    sampled: parentSampled,\n    dsc: dynamicSamplingContext || {},\n    // If we have traceparent data but no DSC it means we are not head of trace and we must freeze it\n    sampleRand\n  };\n}\n\n/**\n * Create sentry-trace header from span context values.\n */\nfunction generateSentryTraceHeader() {\n  let traceId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : generateTraceId();\n  let spanId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : generateSpanId();\n  let sampled = arguments.length > 2 ? arguments[2] : undefined;\n  let sampledString = '';\n  if (sampled !== undefined) {\n    sampledString = sampled ? '-1' : '-0';\n  }\n  return `${traceId}-${spanId}${sampledString}`;\n}\n\n/**\n * Given any combination of an incoming trace, generate a sample rand based on its defined semantics.\n *\n * Read more: https://develop.sentry.dev/sdk/telemetry/traces/#propagated-random-value\n */\nfunction getSampleRandFromTraceparentAndDsc(traceparentData, dsc) {\n  // When there is an incoming sample rand use it.\n  const parsedSampleRand = parseSampleRate(dsc?.sample_rand);\n  if (parsedSampleRand !== undefined) {\n    return parsedSampleRand;\n  }\n\n  // Otherwise, if there is an incoming sampling decision + sample rate, generate a sample rand that would lead to the same sampling decision.\n  const parsedSampleRate = parseSampleRate(dsc?.sample_rate);\n  if (parsedSampleRate && traceparentData?.parentSampled !== undefined) {\n    return traceparentData.parentSampled ?\n    // Returns a sample rand with positive sampling decision [0, sampleRate)\n    Math.random() * parsedSampleRate :\n    // Returns a sample rand with negative sampling decision [sampleRate, 1)\n    parsedSampleRate + Math.random() * (1 - parsedSampleRate);\n  } else {\n    // If nothing applies, return a random sample rand.\n    return Math.random();\n  }\n}\nexport { TRACEPARENT_REGEXP, extractTraceparentData, generateSentryTraceHeader, propagationContextFromHeaders };\n//# sourceMappingURL=tracing.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}