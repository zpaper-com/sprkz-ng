{"ast":null,"code":"import { DEBUG_BUILD } from '../debug-build.js';\nimport { debug } from '../utils/debug-logger.js';\nimport { forEachEnvelopeItem, envelopeItemTypeToDataCategory, createEnvelope, serializeEnvelope } from '../utils/envelope.js';\nimport { makePromiseBuffer, SENTRY_BUFFER_FULL_ERROR } from '../utils/promisebuffer.js';\nimport { isRateLimited, updateRateLimits } from '../utils/ratelimit.js';\nimport { resolvedSyncPromise } from '../utils/syncpromise.js';\nconst DEFAULT_TRANSPORT_BUFFER_SIZE = 64;\n\n/**\n * Creates an instance of a Sentry `Transport`\n *\n * @param options\n * @param makeRequest\n */\nfunction createTransport(options, makeRequest, buffer = makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE)) {\n  let rateLimits = {};\n  const flush = timeout => buffer.drain(timeout);\n  function send(envelope) {\n    const filteredEnvelopeItems = [];\n\n    // Drop rate limited items from envelope\n    forEachEnvelopeItem(envelope, (item, type) => {\n      const dataCategory = envelopeItemTypeToDataCategory(type);\n      if (isRateLimited(rateLimits, dataCategory)) {\n        options.recordDroppedEvent('ratelimit_backoff', dataCategory);\n      } else {\n        filteredEnvelopeItems.push(item);\n      }\n    });\n\n    // Skip sending if envelope is empty after filtering out rate limited events\n    if (filteredEnvelopeItems.length === 0) {\n      return resolvedSyncPromise({});\n    }\n    const filteredEnvelope = createEnvelope(envelope[0], filteredEnvelopeItems);\n\n    // Creates client report for each item in an envelope\n    const recordEnvelopeLoss = reason => {\n      forEachEnvelopeItem(filteredEnvelope, (item, type) => {\n        options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type));\n      });\n    };\n    const requestTask = () => makeRequest({\n      body: serializeEnvelope(filteredEnvelope)\n    }).then(response => {\n      // We don't want to throw on NOK responses, but we want to at least log them\n      if (response.statusCode !== undefined && (response.statusCode < 200 || response.statusCode >= 300)) {\n        DEBUG_BUILD && debug.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);\n      }\n      rateLimits = updateRateLimits(rateLimits, response);\n      return response;\n    }, error => {\n      recordEnvelopeLoss('network_error');\n      DEBUG_BUILD && debug.error('Encountered error running transport request:', error);\n      throw error;\n    });\n    return buffer.add(requestTask).then(result => result, error => {\n      if (error === SENTRY_BUFFER_FULL_ERROR) {\n        DEBUG_BUILD && debug.error('Skipped sending event because buffer is full.');\n        recordEnvelopeLoss('queue_overflow');\n        return resolvedSyncPromise({});\n      } else {\n        throw error;\n      }\n    });\n  }\n  return {\n    send,\n    flush\n  };\n}\nexport { DEFAULT_TRANSPORT_BUFFER_SIZE, createTransport };\n//# sourceMappingURL=base.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}