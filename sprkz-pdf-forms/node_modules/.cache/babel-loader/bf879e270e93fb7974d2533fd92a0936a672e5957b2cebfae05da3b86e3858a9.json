{"ast":null,"code":"import { addHandler, maybeInstrument, triggerHandlers, supportsHistory, fill } from '@sentry/core';\nimport { WINDOW } from '../types.js';\nlet lastHref;\n\n/**\n * Add an instrumentation handler for when a fetch request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addHistoryInstrumentationHandler(handler) {\n  const type = 'history';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentHistory);\n}\n\n/**\n * Exported just for testing\n */\nfunction instrumentHistory() {\n  // The `popstate` event may also be triggered on `pushState`, but it may not always reliably be emitted by the browser\n  // Which is why we also monkey-patch methods below, in addition to this\n  WINDOW.addEventListener('popstate', () => {\n    const to = WINDOW.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    const from = lastHref;\n    lastHref = to;\n    if (from === to) {\n      return;\n    }\n    const handlerData = {\n      from,\n      to\n    };\n    triggerHandlers('history', handlerData);\n  });\n\n  // Just guard against this not being available, in weird environments\n  if (!supportsHistory()) {\n    return;\n  }\n  function historyReplacementFunction(originalHistoryFunction) {\n    return function (...args) {\n      const url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        const from = lastHref;\n\n        // Ensure the URL is absolute\n        // this can be either a path, then it is relative to the current origin\n        // or a full URL of the current origin - other origins are not allowed\n        // See: https://developer.mozilla.org/en-US/docs/Web/API/History/pushState#url\n        // coerce to string (this is what pushState does)\n        const to = getAbsoluteUrl(String(url));\n\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n        if (from === to) {\n          return originalHistoryFunction.apply(this, args);\n        }\n        const handlerData = {\n          from,\n          to\n        };\n        triggerHandlers('history', handlerData);\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n  fill(WINDOW.history, 'pushState', historyReplacementFunction);\n  fill(WINDOW.history, 'replaceState', historyReplacementFunction);\n}\nfunction getAbsoluteUrl(urlOrPath) {\n  try {\n    const url = new URL(urlOrPath, WINDOW.location.origin);\n    return url.toString();\n  } catch {\n    // fallback, just do nothing\n    return urlOrPath;\n  }\n}\nexport { addHistoryInstrumentationHandler, instrumentHistory };","map":{"version":3,"names":["lastHref","addHistoryInstrumentationHandler","handler","type","addHandler","maybeInstrument","instrumentHistory","WINDOW","addEventListener","to","location","href","from","handlerData","triggerHandlers","supportsHistory","historyReplacementFunction","originalHistoryFunction","args","url","length","undefined","getAbsoluteUrl","String","apply","fill","history","urlOrPath","URL","origin","toString"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry-internal/browser-utils/src/instrument/history.ts"],"sourcesContent":["import type { HandlerDataHistory } from '@sentry/core';\nimport { addHandler, fill, maybeInstrument, supportsHistory, triggerHandlers } from '@sentry/core';\nimport { WINDOW } from '../types';\n\nlet lastHref: string | undefined;\n\n/**\n * Add an instrumentation handler for when a fetch request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addHistoryInstrumentationHandler(handler: (data: HandlerDataHistory) => void): void {\n  const type = 'history';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentHistory);\n}\n\n/**\n * Exported just for testing\n */\nexport function instrumentHistory(): void {\n  // The `popstate` event may also be triggered on `pushState`, but it may not always reliably be emitted by the browser\n  // Which is why we also monkey-patch methods below, in addition to this\n  WINDOW.addEventListener('popstate', () => {\n    const to = WINDOW.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    const from = lastHref;\n    lastHref = to;\n\n    if (from === to) {\n      return;\n    }\n\n    const handlerData = { from, to } satisfies HandlerDataHistory;\n    triggerHandlers('history', handlerData);\n  });\n\n  // Just guard against this not being available, in weird environments\n  if (!supportsHistory()) {\n    return;\n  }\n\n  function historyReplacementFunction(originalHistoryFunction: () => void): () => void {\n    return function (this: History, ...args: unknown[]): void {\n      const url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        const from = lastHref;\n\n        // Ensure the URL is absolute\n        // this can be either a path, then it is relative to the current origin\n        // or a full URL of the current origin - other origins are not allowed\n        // See: https://developer.mozilla.org/en-US/docs/Web/API/History/pushState#url\n        // coerce to string (this is what pushState does)\n        const to = getAbsoluteUrl(String(url));\n\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n\n        if (from === to) {\n          return originalHistoryFunction.apply(this, args);\n        }\n\n        const handlerData = { from, to } satisfies HandlerDataHistory;\n        triggerHandlers('history', handlerData);\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n\n  fill(WINDOW.history, 'pushState', historyReplacementFunction);\n  fill(WINDOW.history, 'replaceState', historyReplacementFunction);\n}\n\nfunction getAbsoluteUrl(urlOrPath: string): string {\n  try {\n    const url = new URL(urlOrPath, WINDOW.location.origin);\n    return url.toString();\n  } catch {\n    // fallback, just do nothing\n    return urlOrPath;\n  }\n}\n"],"mappings":";;AAIA,IAAIA,QAAQ;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,gCAAgCA,CAACC,OAAO,EAA4C;EAClG,MAAMC,IAAA,GAAO,SAAS;EACtBC,UAAU,CAACD,IAAI,EAAED,OAAO,CAAC;EACzBG,eAAe,CAACF,IAAI,EAAEG,iBAAiB,CAAC;AAC1C;;AAEA;AACA;AACA;AACO,SAASA,iBAAiBA,CAAA,EAAS;EAC1C;EACA;EACEC,MAAM,CAACC,gBAAgB,CAAC,UAAU,EAAE,MAAM;IACxC,MAAMC,EAAA,GAAKF,MAAM,CAACG,QAAQ,CAACC,IAAI;IACnC;IACI,MAAMC,IAAA,GAAOZ,QAAQ;IACrBA,QAAA,GAAWS,EAAE;IAEb,IAAIG,IAAA,KAASH,EAAE,EAAE;MACf;IACN;IAEI,MAAMI,WAAA,GAAc;MAAED,IAAI;MAAEH;IAAA,CAAG;IAC/BK,eAAe,CAAC,SAAS,EAAED,WAAW,CAAC;EAC3C,CAAG,CAAC;;EAEJ;EACE,IAAI,CAACE,eAAe,EAAE,EAAE;IACtB;EACJ;EAEE,SAASC,0BAA0BA,CAACC,uBAAuB,EAA0B;IACnF,OAAO,UAAyB,GAAGC,IAAI,EAAmB;MACxD,MAAMC,GAAA,GAAMD,IAAI,CAACE,MAAA,GAAS,IAAIF,IAAI,CAAC,CAAC,IAAIG,SAAS;MACjD,IAAIF,GAAG,EAAE;QACP,MAAMP,IAAA,GAAOZ,QAAQ;;QAE7B;QACA;QACA;QACA;QACA;QACQ,MAAMS,EAAA,GAAKa,cAAc,CAACC,MAAM,CAACJ,GAAG,CAAC,CAAC;;QAE9C;QACQnB,QAAA,GAAWS,EAAE;QAEb,IAAIG,IAAA,KAASH,EAAE,EAAE;UACf,OAAOQ,uBAAuB,CAACO,KAAK,CAAC,IAAI,EAAEN,IAAI,CAAC;QAC1D;QAEQ,MAAML,WAAA,GAAc;UAAED,IAAI;UAAEH;QAAA,CAAG;QAC/BK,eAAe,CAAC,SAAS,EAAED,WAAW,CAAC;MAC/C;MACM,OAAOI,uBAAuB,CAACO,KAAK,CAAC,IAAI,EAAEN,IAAI,CAAC;IACtD,CAAK;EACL;EAEEO,IAAI,CAAClB,MAAM,CAACmB,OAAO,EAAE,WAAW,EAAEV,0BAA0B,CAAC;EAC7DS,IAAI,CAAClB,MAAM,CAACmB,OAAO,EAAE,cAAc,EAAEV,0BAA0B,CAAC;AAClE;AAEA,SAASM,cAAcA,CAACK,SAAS,EAAkB;EACjD,IAAI;IACF,MAAMR,GAAA,GAAM,IAAIS,GAAG,CAACD,SAAS,EAAEpB,MAAM,CAACG,QAAQ,CAACmB,MAAM,CAAC;IACtD,OAAOV,GAAG,CAACW,QAAQ,EAAE;EACzB,EAAI,MAAM;IACV;IACI,OAAOH,SAAS;EACpB;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}