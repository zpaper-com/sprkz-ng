{"ast":null,"code":"import { isError, isRequest } from '../utils/is.js';\nimport { fill, addNonEnumerableProperty } from '../utils/object.js';\nimport { supportsNativeFetch } from '../utils/supports.js';\nimport { timestampInSeconds } from '../utils/time.js';\nimport { GLOBAL_OBJ } from '../utils/worldwide.js';\nimport { addHandler, maybeInstrument, triggerHandlers } from './handlers.js';\n\n/**\n * Add an instrumentation handler for when a fetch request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addFetchInstrumentationHandler(handler, skipNativeFetchCheck) {\n  const type = 'fetch';\n  addHandler(type, handler);\n  maybeInstrument(type, () => instrumentFetch(undefined, skipNativeFetchCheck));\n}\n\n/**\n * Add an instrumentation handler for long-lived fetch requests, like consuming server-sent events (SSE) via fetch.\n * The handler will resolve the request body and emit the actual `endTimestamp`, so that the\n * span can be updated accordingly.\n *\n * Only used internally\n * @hidden\n */\nfunction addFetchEndInstrumentationHandler(handler) {\n  const type = 'fetch-body-resolved';\n  addHandler(type, handler);\n  maybeInstrument(type, () => instrumentFetch(streamHandler));\n}\nfunction instrumentFetch(onFetchResolved, skipNativeFetchCheck = false) {\n  if (skipNativeFetchCheck && !supportsNativeFetch()) {\n    return;\n  }\n  fill(GLOBAL_OBJ, 'fetch', function (originalFetch) {\n    return function (...args) {\n      // We capture the error right here and not in the Promise error callback because Safari (and probably other\n      // browsers too) will wipe the stack trace up to this point, only leaving us with this file which is useless.\n\n      // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n      //       it means the error, that was caused by your fetch call did not\n      //       have a stack trace, so the SDK backfilled the stack trace so\n      //       you can see which fetch call failed.\n      const virtualError = new Error();\n      const {\n        method,\n        url\n      } = parseFetchArgs(args);\n      const handlerData = {\n        args,\n        fetchData: {\n          method,\n          url\n        },\n        startTimestamp: timestampInSeconds() * 1000,\n        // // Adding the error to be able to fingerprint the failed fetch event in HttpClient instrumentation\n        virtualError,\n        headers: getHeadersFromFetchArgs(args)\n      };\n\n      // if there is no callback, fetch is instrumented directly\n      if (!onFetchResolved) {\n        triggerHandlers('fetch', {\n          ...handlerData\n        });\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return originalFetch.apply(GLOBAL_OBJ, args).then(async response => {\n        if (onFetchResolved) {\n          onFetchResolved(response);\n        } else {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: timestampInSeconds() * 1000,\n            response\n          });\n        }\n        return response;\n      }, error => {\n        triggerHandlers('fetch', {\n          ...handlerData,\n          endTimestamp: timestampInSeconds() * 1000,\n          error\n        });\n        if (isError(error) && error.stack === undefined) {\n          // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n          //       it means the error, that was caused by your fetch call did not\n          //       have a stack trace, so the SDK backfilled the stack trace so\n          //       you can see which fetch call failed.\n          error.stack = virtualError.stack;\n          addNonEnumerableProperty(error, 'framesToPop', 1);\n        }\n\n        // We enhance the not-so-helpful \"Failed to fetch\" error messages with the host\n        // Possible messages we handle here:\n        // * \"Failed to fetch\" (chromium)\n        // * \"Load failed\" (webkit)\n        // * \"NetworkError when attempting to fetch resource.\" (firefox)\n        if (error instanceof TypeError && (error.message === 'Failed to fetch' || error.message === 'Load failed' || error.message === 'NetworkError when attempting to fetch resource.')) {\n          try {\n            const url = new URL(handlerData.fetchData.url);\n            error.message = `${error.message} (${url.host})`;\n          } catch {\n            // ignore it if errors happen here\n          }\n        }\n\n        // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n        //       it means the sentry.javascript SDK caught an error invoking your application code.\n        //       This is expected behavior and NOT indicative of a bug with sentry.javascript.\n        throw error;\n      });\n    };\n  });\n}\nasync function resolveResponse(res, onFinishedResolving) {\n  if (res?.body) {\n    const body = res.body;\n    const responseReader = body.getReader();\n\n    // Define a maximum duration after which we just cancel\n    const maxFetchDurationTimeout = setTimeout(() => {\n      body.cancel().then(null, () => {\n        // noop\n      });\n    }, 90 * 1000 // 90s\n    );\n    let readingActive = true;\n    while (readingActive) {\n      let chunkTimeout;\n      try {\n        // abort reading if read op takes more than 5s\n        chunkTimeout = setTimeout(() => {\n          body.cancel().then(null, () => {\n            // noop on error\n          });\n        }, 5000);\n\n        // This .read() call will reject/throw when we abort due to timeouts through `body.cancel()`\n        const {\n          done\n        } = await responseReader.read();\n        clearTimeout(chunkTimeout);\n        if (done) {\n          onFinishedResolving();\n          readingActive = false;\n        }\n      } catch {\n        readingActive = false;\n      } finally {\n        clearTimeout(chunkTimeout);\n      }\n    }\n    clearTimeout(maxFetchDurationTimeout);\n    responseReader.releaseLock();\n    body.cancel().then(null, () => {\n      // noop on error\n    });\n  }\n}\nfunction streamHandler(response) {\n  // clone response for awaiting stream\n  let clonedResponseForResolving;\n  try {\n    clonedResponseForResolving = response.clone();\n  } catch {\n    return;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  resolveResponse(clonedResponseForResolving, () => {\n    triggerHandlers('fetch-body-resolved', {\n      endTimestamp: timestampInSeconds() * 1000,\n      response\n    });\n  });\n}\nfunction hasProp(obj, prop) {\n  return !!obj && typeof obj === 'object' && !!obj[prop];\n}\nfunction getUrlFromResource(resource) {\n  if (typeof resource === 'string') {\n    return resource;\n  }\n  if (!resource) {\n    return '';\n  }\n  if (hasProp(resource, 'url')) {\n    return resource.url;\n  }\n  if (resource.toString) {\n    return resource.toString();\n  }\n  return '';\n}\n\n/**\n * Parses the fetch arguments to find the used Http method and the url of the request.\n * Exported for tests only.\n */\nfunction parseFetchArgs(fetchArgs) {\n  if (fetchArgs.length === 0) {\n    return {\n      method: 'GET',\n      url: ''\n    };\n  }\n  if (fetchArgs.length === 2) {\n    const [url, options] = fetchArgs;\n    return {\n      url: getUrlFromResource(url),\n      method: hasProp(options, 'method') ? String(options.method).toUpperCase() : 'GET'\n    };\n  }\n  const arg = fetchArgs[0];\n  return {\n    url: getUrlFromResource(arg),\n    method: hasProp(arg, 'method') ? String(arg.method).toUpperCase() : 'GET'\n  };\n}\nfunction getHeadersFromFetchArgs(fetchArgs) {\n  const [requestArgument, optionsArgument] = fetchArgs;\n  try {\n    if (typeof optionsArgument === 'object' && optionsArgument !== null && 'headers' in optionsArgument && optionsArgument.headers) {\n      return new Headers(optionsArgument.headers);\n    }\n    if (isRequest(requestArgument)) {\n      return new Headers(requestArgument.headers);\n    }\n  } catch {\n    // noop\n  }\n  return;\n}\nexport { addFetchEndInstrumentationHandler, addFetchInstrumentationHandler, parseFetchArgs };","map":{"version":3,"names":["addFetchInstrumentationHandler","handler","skipNativeFetchCheck","type","addHandler","maybeInstrument","instrumentFetch","undefined","addFetchEndInstrumentationHandler","streamHandler","onFetchResolved","supportsNativeFetch","fill","GLOBAL_OBJ","originalFetch","args","virtualError","Error","method","url","parseFetchArgs","handlerData","fetchData","startTimestamp","timestampInSeconds","headers","getHeadersFromFetchArgs","triggerHandlers","apply","then","response","endTimestamp","error","isError","stack","addNonEnumerableProperty","TypeError","message","URL","host","resolveResponse","res","onFinishedResolving","body","responseReader","getReader","maxFetchDurationTimeout","setTimeout","cancel","readingActive","chunkTimeout","done","read","clearTimeout","releaseLock","clonedResponseForResolving","clone","hasProp","obj","prop","getUrlFromResource","resource","toString","fetchArgs","length","options","String","toUpperCase","arg","requestArgument","optionsArgument","Headers","isRequest"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/instrument/fetch.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { HandlerDataFetch } from '../types-hoist/instrument';\nimport type { WebFetchHeaders } from '../types-hoist/webfetchapi';\nimport { isError, isRequest } from '../utils/is';\nimport { addNonEnumerableProperty, fill } from '../utils/object';\nimport { supportsNativeFetch } from '../utils/supports';\nimport { timestampInSeconds } from '../utils/time';\nimport { GLOBAL_OBJ } from '../utils/worldwide';\nimport { addHandler, maybeInstrument, triggerHandlers } from './handlers';\n\ntype FetchResource = string | { toString(): string } | { url: string };\n\n/**\n * Add an instrumentation handler for when a fetch request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addFetchInstrumentationHandler(\n  handler: (data: HandlerDataFetch) => void,\n  skipNativeFetchCheck?: boolean,\n): void {\n  const type = 'fetch';\n  addHandler(type, handler);\n  maybeInstrument(type, () => instrumentFetch(undefined, skipNativeFetchCheck));\n}\n\n/**\n * Add an instrumentation handler for long-lived fetch requests, like consuming server-sent events (SSE) via fetch.\n * The handler will resolve the request body and emit the actual `endTimestamp`, so that the\n * span can be updated accordingly.\n *\n * Only used internally\n * @hidden\n */\nexport function addFetchEndInstrumentationHandler(handler: (data: HandlerDataFetch) => void): void {\n  const type = 'fetch-body-resolved';\n  addHandler(type, handler);\n  maybeInstrument(type, () => instrumentFetch(streamHandler));\n}\n\nfunction instrumentFetch(onFetchResolved?: (response: Response) => void, skipNativeFetchCheck: boolean = false): void {\n  if (skipNativeFetchCheck && !supportsNativeFetch()) {\n    return;\n  }\n\n  fill(GLOBAL_OBJ, 'fetch', function (originalFetch: () => void): () => void {\n    return function (...args: any[]): void {\n      // We capture the error right here and not in the Promise error callback because Safari (and probably other\n      // browsers too) will wipe the stack trace up to this point, only leaving us with this file which is useless.\n\n      // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n      //       it means the error, that was caused by your fetch call did not\n      //       have a stack trace, so the SDK backfilled the stack trace so\n      //       you can see which fetch call failed.\n      const virtualError = new Error();\n\n      const { method, url } = parseFetchArgs(args);\n      const handlerData: HandlerDataFetch = {\n        args,\n        fetchData: {\n          method,\n          url,\n        },\n        startTimestamp: timestampInSeconds() * 1000,\n        // // Adding the error to be able to fingerprint the failed fetch event in HttpClient instrumentation\n        virtualError,\n        headers: getHeadersFromFetchArgs(args),\n      };\n\n      // if there is no callback, fetch is instrumented directly\n      if (!onFetchResolved) {\n        triggerHandlers('fetch', {\n          ...handlerData,\n        });\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return originalFetch.apply(GLOBAL_OBJ, args).then(\n        async (response: Response) => {\n          if (onFetchResolved) {\n            onFetchResolved(response);\n          } else {\n            triggerHandlers('fetch', {\n              ...handlerData,\n              endTimestamp: timestampInSeconds() * 1000,\n              response,\n            });\n          }\n\n          return response;\n        },\n        (error: Error) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: timestampInSeconds() * 1000,\n            error,\n          });\n\n          if (isError(error) && error.stack === undefined) {\n            // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n            //       it means the error, that was caused by your fetch call did not\n            //       have a stack trace, so the SDK backfilled the stack trace so\n            //       you can see which fetch call failed.\n            error.stack = virtualError.stack;\n            addNonEnumerableProperty(error, 'framesToPop', 1);\n          }\n\n          // We enhance the not-so-helpful \"Failed to fetch\" error messages with the host\n          // Possible messages we handle here:\n          // * \"Failed to fetch\" (chromium)\n          // * \"Load failed\" (webkit)\n          // * \"NetworkError when attempting to fetch resource.\" (firefox)\n          if (\n            error instanceof TypeError &&\n            (error.message === 'Failed to fetch' ||\n              error.message === 'Load failed' ||\n              error.message === 'NetworkError when attempting to fetch resource.')\n          ) {\n            try {\n              const url = new URL(handlerData.fetchData.url);\n              error.message = `${error.message} (${url.host})`;\n            } catch {\n              // ignore it if errors happen here\n            }\n          }\n\n          // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n          //       it means the sentry.javascript SDK caught an error invoking your application code.\n          //       This is expected behavior and NOT indicative of a bug with sentry.javascript.\n          throw error;\n        },\n      );\n    };\n  });\n}\n\nasync function resolveResponse(res: Response | undefined, onFinishedResolving: () => void): Promise<void> {\n  if (res?.body) {\n    const body = res.body;\n    const responseReader = body.getReader();\n\n    // Define a maximum duration after which we just cancel\n    const maxFetchDurationTimeout = setTimeout(\n      () => {\n        body.cancel().then(null, () => {\n          // noop\n        });\n      },\n      90 * 1000, // 90s\n    );\n\n    let readingActive = true;\n    while (readingActive) {\n      let chunkTimeout;\n      try {\n        // abort reading if read op takes more than 5s\n        chunkTimeout = setTimeout(() => {\n          body.cancel().then(null, () => {\n            // noop on error\n          });\n        }, 5000);\n\n        // This .read() call will reject/throw when we abort due to timeouts through `body.cancel()`\n        const { done } = await responseReader.read();\n\n        clearTimeout(chunkTimeout);\n\n        if (done) {\n          onFinishedResolving();\n          readingActive = false;\n        }\n      } catch {\n        readingActive = false;\n      } finally {\n        clearTimeout(chunkTimeout);\n      }\n    }\n\n    clearTimeout(maxFetchDurationTimeout);\n\n    responseReader.releaseLock();\n    body.cancel().then(null, () => {\n      // noop on error\n    });\n  }\n}\n\nfunction streamHandler(response: Response): void {\n  // clone response for awaiting stream\n  let clonedResponseForResolving: Response;\n  try {\n    clonedResponseForResolving = response.clone();\n  } catch {\n    return;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  resolveResponse(clonedResponseForResolving, () => {\n    triggerHandlers('fetch-body-resolved', {\n      endTimestamp: timestampInSeconds() * 1000,\n      response,\n    });\n  });\n}\n\nfunction hasProp<T extends string>(obj: unknown, prop: T): obj is Record<string, string> {\n  return !!obj && typeof obj === 'object' && !!(obj as Record<string, string>)[prop];\n}\n\nfunction getUrlFromResource(resource: FetchResource): string {\n  if (typeof resource === 'string') {\n    return resource;\n  }\n\n  if (!resource) {\n    return '';\n  }\n\n  if (hasProp(resource, 'url')) {\n    return resource.url;\n  }\n\n  if (resource.toString) {\n    return resource.toString();\n  }\n\n  return '';\n}\n\n/**\n * Parses the fetch arguments to find the used Http method and the url of the request.\n * Exported for tests only.\n */\nexport function parseFetchArgs(fetchArgs: unknown[]): { method: string; url: string } {\n  if (fetchArgs.length === 0) {\n    return { method: 'GET', url: '' };\n  }\n\n  if (fetchArgs.length === 2) {\n    const [url, options] = fetchArgs as [FetchResource, object];\n\n    return {\n      url: getUrlFromResource(url),\n      method: hasProp(options, 'method') ? String(options.method).toUpperCase() : 'GET',\n    };\n  }\n\n  const arg = fetchArgs[0];\n  return {\n    url: getUrlFromResource(arg as FetchResource),\n    method: hasProp(arg, 'method') ? String(arg.method).toUpperCase() : 'GET',\n  };\n}\n\nfunction getHeadersFromFetchArgs(fetchArgs: unknown[]): WebFetchHeaders | undefined {\n  const [requestArgument, optionsArgument] = fetchArgs;\n\n  try {\n    if (\n      typeof optionsArgument === 'object' &&\n      optionsArgument !== null &&\n      'headers' in optionsArgument &&\n      optionsArgument.headers\n    ) {\n      return new Headers(optionsArgument.headers as any);\n    }\n\n    if (isRequest(requestArgument)) {\n      return new Headers(requestArgument.headers);\n    }\n  } catch {\n    // noop\n  }\n\n  return;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}