{"ast":null,"code":"var t = function (e, r) {\n  return t = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (t, e) {\n    t.__proto__ = e;\n  } || function (t, e) {\n    for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);\n  }, t(e, r);\n};\nvar e = function () {\n  return e = Object.assign || function (t) {\n    for (var e, r = 1, n = arguments.length; r < n; r++) for (var o in e = arguments[r]) Object.prototype.hasOwnProperty.call(e, o) && (t[o] = e[o]);\n    return t;\n  }, e.apply(this, arguments);\n};\nfunction r(t, e, r, n) {\n  return new (r || (r = Promise))(function (o, i) {\n    function s(t) {\n      try {\n        c(n.next(t));\n      } catch (t) {\n        i(t);\n      }\n    }\n    function a(t) {\n      try {\n        c(n.throw(t));\n      } catch (t) {\n        i(t);\n      }\n    }\n    function c(t) {\n      var e;\n      t.done ? o(t.value) : (e = t.value, e instanceof r ? e : new r(function (t) {\n        t(e);\n      })).then(s, a);\n    }\n    c((n = n.apply(t, e || [])).next());\n  });\n}\nfunction n(t, e) {\n  var r,\n    n,\n    o,\n    i = {\n      label: 0,\n      sent: function () {\n        if (1 & o[0]) throw o[1];\n        return o[1];\n      },\n      trys: [],\n      ops: []\n    },\n    s = Object.create((\"function\" == typeof Iterator ? Iterator : Object).prototype);\n  return s.next = a(0), s.throw = a(1), s.return = a(2), \"function\" == typeof Symbol && (s[Symbol.iterator] = function () {\n    return this;\n  }), s;\n  function a(a) {\n    return function (c) {\n      return function (a) {\n        if (r) throw new TypeError(\"Generator is already executing.\");\n        for (; s && (s = 0, a[0] && (i = 0)), i;) try {\n          if (r = 1, n && (o = 2 & a[0] ? n.return : a[0] ? n.throw || ((o = n.return) && o.call(n), 0) : n.next) && !(o = o.call(n, a[1])).done) return o;\n          switch (n = 0, o && (a = [2 & a[0], o.value]), a[0]) {\n            case 0:\n            case 1:\n              o = a;\n              break;\n            case 4:\n              return i.label++, {\n                value: a[1],\n                done: !1\n              };\n            case 5:\n              i.label++, n = a[1], a = [0];\n              continue;\n            case 7:\n              a = i.ops.pop(), i.trys.pop();\n              continue;\n            default:\n              if (!(o = i.trys, (o = o.length > 0 && o[o.length - 1]) || 6 !== a[0] && 2 !== a[0])) {\n                i = 0;\n                continue;\n              }\n              if (3 === a[0] && (!o || a[1] > o[0] && a[1] < o[3])) {\n                i.label = a[1];\n                break;\n              }\n              if (6 === a[0] && i.label < o[1]) {\n                i.label = o[1], o = a;\n                break;\n              }\n              if (o && i.label < o[2]) {\n                i.label = o[2], i.ops.push(a);\n                break;\n              }\n              o[2] && i.ops.pop(), i.trys.pop();\n              continue;\n          }\n          a = e.call(t, i);\n        } catch (t) {\n          a = [6, t], n = 0;\n        } finally {\n          r = o = 0;\n        }\n        if (5 & a[0]) throw a[1];\n        return {\n          value: a[0] ? a[1] : void 0,\n          done: !0\n        };\n      }([a, c]);\n    };\n  }\n}\n\"function\" == typeof SuppressedError && SuppressedError;\nvar o = {\n  exports: {}\n};\nfunction i() {}\ni.prototype = {\n  on: function (t, e, r) {\n    var n = this.e || (this.e = {});\n    return (n[t] || (n[t] = [])).push({\n      fn: e,\n      ctx: r\n    }), this;\n  },\n  once: function (t, e, r) {\n    var n = this;\n    function o() {\n      n.off(t, o), e.apply(r, arguments);\n    }\n    return o._ = e, this.on(t, o, r);\n  },\n  emit: function (t) {\n    for (var e = [].slice.call(arguments, 1), r = ((this.e || (this.e = {}))[t] || []).slice(), n = 0, o = r.length; n < o; n++) r[n].fn.apply(r[n].ctx, e);\n    return this;\n  },\n  off: function (t, e) {\n    var r = this.e || (this.e = {}),\n      n = r[t],\n      o = [];\n    if (n && e) for (var i = 0, s = n.length; i < s; i++) n[i].fn !== e && n[i].fn._ !== e && o.push(n[i]);\n    return o.length ? r[t] = o : delete r[t], this;\n  }\n}, o.exports = i;\nvar s = o.exports.TinyEmitter = i,\n  a = function (t) {\n    var e = t[1];\n    return null != e;\n  },\n  c = function (t) {\n    var e = t.properties,\n      r = void 0 === e ? {} : e,\n      n = function (t, e) {\n        var r = {};\n        for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);\n        if (null != t && \"function\" == typeof Object.getOwnPropertySymbols) {\n          var o = 0;\n          for (n = Object.getOwnPropertySymbols(t); o < n.length; o++) e.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[o]) && (r[n[o]] = t[n[o]]);\n        }\n        return r;\n      }(t, [\"properties\"]),\n      o = function (t) {\n        return Object.entries(t).sort(function (t, e) {\n          var r = t[0],\n            n = e[0];\n          return r.localeCompare(n, void 0);\n        });\n      };\n    return JSON.stringify([o(n), o(r)]);\n  },\n  u = function (t) {\n    return r(void 0, void 0, void 0, function () {\n      var e;\n      return n(this, function (o) {\n        switch (o.label) {\n          case 0:\n            e = c(t), o.label = 1;\n          case 1:\n            return o.trys.push([1, 3,, 4]), [4, (i = e, r(void 0, void 0, void 0, function () {\n              var t, e, r, o, s;\n              return n(this, function (n) {\n                switch (n.label) {\n                  case 0:\n                    if (t = \"undefined\" != typeof globalThis && (null === (o = globalThis.crypto) || void 0 === o ? void 0 : o.subtle) ? null === (s = globalThis.crypto) || void 0 === s ? void 0 : s.subtle : void 0, \"undefined\" == typeof TextEncoder || !(null == t ? void 0 : t.digest) || \"undefined\" == typeof Uint8Array) throw new Error(\"Hashing function not available\");\n                    return e = new TextEncoder().encode(i), [4, t.digest(\"SHA-256\", e)];\n                  case 1:\n                    return r = n.sent(), [2, Array.from(new Uint8Array(r)).map(function (t) {\n                      return t.toString(16).padStart(2, \"0\");\n                    }).join(\"\")];\n                }\n              });\n            }))];\n          case 2:\n            return [2, o.sent()];\n          case 3:\n            return o.sent(), [2, e];\n          case 4:\n            return [2];\n        }\n        var i;\n      });\n    });\n  },\n  l = function (t) {\n    var e,\n      r = t.clientKey,\n      n = t.appName,\n      o = t.connectionId,\n      i = t.customHeaders,\n      s = t.headerName,\n      c = void 0 === s ? \"authorization\" : s,\n      u = t.etag,\n      l = t.isPost,\n      h = ((e = {\n        accept: \"application/json\"\n      })[c.toLocaleLowerCase()] = r, e[\"unleash-sdk\"] = \"unleash-client-js:3.7.6\", e[\"unleash-appname\"] = n, e);\n    return l && (h[\"content-type\"] = \"application/json\"), u && (h[\"if-none-match\"] = u), Object.entries(i || {}).filter(a).forEach(function (t) {\n      var e = t[0],\n        r = t[1];\n      return h[e.toLocaleLowerCase()] = r;\n    }), h[\"unleash-connection-id\"] = o, h;\n  },\n  h = function () {},\n  p = function () {\n    function t(t) {\n      var e = t.onError,\n        r = t.onSent,\n        n = t.appName,\n        o = t.metricsInterval,\n        i = t.disableMetrics,\n        s = void 0 !== i && i,\n        a = t.url,\n        c = t.clientKey,\n        u = t.fetch,\n        l = t.headerName,\n        p = t.customHeaders,\n        d = void 0 === p ? {} : p,\n        f = t.metricsIntervalInitial,\n        v = t.connectionId;\n      this.onError = e, this.onSent = r || h, this.disabled = s, this.metricsInterval = 1e3 * o, this.metricsIntervalInitial = 1e3 * f, this.appName = n, this.url = a instanceof URL ? a : new URL(a), this.clientKey = c, this.bucket = this.createEmptyBucket(), this.fetch = u, this.headerName = l, this.customHeaders = d, this.connectionId = v;\n    }\n    return t.prototype.start = function () {\n      var t = this;\n      if (this.disabled) return !1;\n      \"number\" == typeof this.metricsInterval && this.metricsInterval > 0 && (this.metricsIntervalInitial > 0 ? setTimeout(function () {\n        t.startTimer(), t.sendMetrics();\n      }, this.metricsIntervalInitial) : this.startTimer());\n    }, t.prototype.stop = function () {\n      this.timer && (clearInterval(this.timer), delete this.timer);\n    }, t.prototype.createEmptyBucket = function () {\n      return {\n        start: new Date(),\n        stop: null,\n        toggles: {}\n      };\n    }, t.prototype.getHeaders = function () {\n      return l({\n        clientKey: this.clientKey,\n        appName: this.appName,\n        connectionId: this.connectionId,\n        customHeaders: this.customHeaders,\n        headerName: this.headerName,\n        isPost: !0\n      });\n    }, t.prototype.sendMetrics = function () {\n      return r(this, void 0, void 0, function () {\n        var t, e, r;\n        return n(this, function (n) {\n          switch (n.label) {\n            case 0:\n              if (t = \"\".concat(this.url, \"/client/metrics\"), e = this.getPayload(), this.bucketIsEmpty(e)) return [2];\n              n.label = 1;\n            case 1:\n              return n.trys.push([1, 3,, 4]), [4, this.fetch(t, {\n                cache: \"no-cache\",\n                method: \"POST\",\n                headers: this.getHeaders(),\n                body: JSON.stringify(e)\n              })];\n            case 2:\n              return n.sent(), this.onSent(e), [3, 4];\n            case 3:\n              return r = n.sent(), console.error(\"Unleash: unable to send feature metrics\", r), this.onError(r), [3, 4];\n            case 4:\n              return [2];\n          }\n        });\n      });\n    }, t.prototype.count = function (t, e) {\n      return !(this.disabled || !this.bucket) && (this.assertBucket(t), this.bucket.toggles[t][e ? \"yes\" : \"no\"]++, !0);\n    }, t.prototype.countVariant = function (t, e) {\n      return !(this.disabled || !this.bucket) && (this.assertBucket(t), this.bucket.toggles[t].variants[e] ? this.bucket.toggles[t].variants[e] += 1 : this.bucket.toggles[t].variants[e] = 1, !0);\n    }, t.prototype.assertBucket = function (t) {\n      if (this.disabled || !this.bucket) return !1;\n      this.bucket.toggles[t] || (this.bucket.toggles[t] = {\n        yes: 0,\n        no: 0,\n        variants: {}\n      });\n    }, t.prototype.startTimer = function () {\n      var t = this;\n      this.timer = setInterval(function () {\n        t.sendMetrics();\n      }, this.metricsInterval);\n    }, t.prototype.bucketIsEmpty = function (t) {\n      return 0 === Object.keys(t.bucket.toggles).length;\n    }, t.prototype.getPayload = function () {\n      var t = e(e({}, this.bucket), {\n        stop: new Date()\n      });\n      return this.bucket = this.createEmptyBucket(), {\n        bucket: t,\n        appName: this.appName,\n        instanceId: \"browser\"\n      };\n    }, t;\n  }(),\n  d = function () {\n    function t() {\n      this.store = new Map();\n    }\n    return t.prototype.save = function (t, e) {\n      return r(this, void 0, void 0, function () {\n        return n(this, function (r) {\n          return this.store.set(t, e), [2];\n        });\n      });\n    }, t.prototype.get = function (t) {\n      return r(this, void 0, void 0, function () {\n        return n(this, function (e) {\n          return [2, this.store.get(t)];\n        });\n      });\n    }, t;\n  }(),\n  f = function () {\n    function t(t) {\n      void 0 === t && (t = \"unleash:repository\"), this.prefix = t;\n    }\n    return t.prototype.save = function (t, e) {\n      return r(this, void 0, void 0, function () {\n        var r, o;\n        return n(this, function (n) {\n          r = JSON.stringify(e), o = \"\".concat(this.prefix, \":\").concat(t);\n          try {\n            window.localStorage.setItem(o, r);\n          } catch (t) {\n            console.error(t);\n          }\n          return [2];\n        });\n      });\n    }, t.prototype.get = function (t) {\n      try {\n        var e = \"\".concat(this.prefix, \":\").concat(t),\n          r = window.localStorage.getItem(e);\n        return r ? JSON.parse(r) : void 0;\n      } catch (t) {\n        console.error(t);\n      }\n    }, t;\n  }();\nlet v;\nconst m = new Uint8Array(16);\nfunction g() {\n  if (!v && (v = \"undefined\" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !v)) throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n  return v(m);\n}\nconst y = [];\nfor (let t = 0; t < 256; ++t) y.push((t + 256).toString(16).slice(1));\nvar b = {\n  randomUUID: \"undefined\" != typeof crypto && crypto.randomUUID && crypto.randomUUID.bind(crypto)\n};\nfunction x(t, e, r) {\n  if (b.randomUUID && !e && !t) return b.randomUUID();\n  const n = (t = t || {}).random || (t.rng || g)();\n  if (n[6] = 15 & n[6] | 64, n[8] = 63 & n[8] | 128, e) {\n    r = r || 0;\n    for (let t = 0; t < 16; ++t) e[r + t] = n[t];\n    return e;\n  }\n  return function (t, e = 0) {\n    return y[t[e + 0]] + y[t[e + 1]] + y[t[e + 2]] + y[t[e + 3]] + \"-\" + y[t[e + 4]] + y[t[e + 5]] + \"-\" + y[t[e + 6]] + y[t[e + 7]] + \"-\" + y[t[e + 8]] + y[t[e + 9]] + \"-\" + y[t[e + 10]] + y[t[e + 11]] + y[t[e + 12]] + y[t[e + 13]] + y[t[e + 14]] + y[t[e + 15]];\n  }(n);\n}\nvar T = function () {\n    function t() {}\n    return t.prototype.generateEventId = function () {\n      return x();\n    }, t.prototype.createImpressionEvent = function (t, r, n, o, i, s) {\n      var a = this.createBaseEvent(t, r, n, o, i);\n      return s ? e(e({}, a), {\n        variant: s\n      }) : a;\n    }, t.prototype.createBaseEvent = function (t, e, r, n, o) {\n      return {\n        eventType: n,\n        eventId: this.generateEventId(),\n        context: t,\n        enabled: e,\n        featureName: r,\n        impressionData: o\n      };\n    }, t;\n  }(),\n  w = [\"userId\", \"sessionId\", \"remoteAddress\", \"currentTime\"],\n  E = function (t) {\n    return w.includes(t);\n  },\n  I = {\n    INIT: \"initialized\",\n    ERROR: \"error\",\n    READY: \"ready\",\n    UPDATE: \"update\",\n    IMPRESSION: \"impression\",\n    SENT: \"sent\",\n    RECOVERED: \"recovered\"\n  },\n  S = \"isEnabled\",\n  R = \"getVariant\",\n  O = {\n    name: \"disabled\",\n    enabled: !1,\n    feature_enabled: !1\n  },\n  k = \"repo\",\n  N = \"repoLastUpdateTimestamp\",\n  A = function () {\n    try {\n      if (\"undefined\" != typeof window && \"fetch\" in window) return fetch.bind(window);\n      if (\"fetch\" in globalThis) return fetch.bind(globalThis);\n    } catch (t) {\n      console.error('Unleash failed to resolve \"fetch\"', t);\n    }\n  },\n  U = function (o) {\n    function i(t) {\n      var r = t.storageProvider,\n        n = t.url,\n        i = t.clientKey,\n        s = t.disableRefresh,\n        a = void 0 !== s && s,\n        c = t.refreshInterval,\n        u = void 0 === c ? 30 : c,\n        l = t.metricsInterval,\n        h = void 0 === l ? 30 : l,\n        v = t.metricsIntervalInitial,\n        m = void 0 === v ? 2 : v,\n        g = t.disableMetrics,\n        y = void 0 !== g && g,\n        b = t.appName,\n        x = t.environment,\n        w = void 0 === x ? \"default\" : x,\n        E = t.context,\n        S = t.fetch,\n        R = void 0 === S ? A() : S,\n        O = t.createAbortController,\n        k = void 0 === O ? function () {\n          try {\n            if (\"undefined\" != typeof window && \"AbortController\" in window) return function () {\n              return new window.AbortController();\n            };\n            if (\"fetch\" in globalThis) return function () {\n              return new globalThis.AbortController();\n            };\n          } catch (t) {\n            console.error('Unleash failed to resolve \"AbortController\" factory', t);\n          }\n        }() : O,\n        N = t.bootstrap,\n        U = t.bootstrapOverride,\n        D = void 0 === U || U,\n        P = t.headerName,\n        C = void 0 === P ? \"Authorization\" : P,\n        L = t.customHeaders,\n        j = void 0 === L ? {} : L,\n        H = t.impressionDataAll,\n        M = void 0 !== H && H,\n        K = t.usePOSTrequests,\n        _ = void 0 !== K && K,\n        F = t.experimental,\n        V = o.call(this) || this;\n      if (V.toggles = [], V.etag = \"\", V.readyEventEmitted = !1, V.fetchedFromServer = !1, V.usePOSTrequests = !1, V.started = !1, !n) throw new Error(\"url is required\");\n      if (!i) throw new Error(\"clientKey is required\");\n      if (!b) throw new Error(\"appName is required.\");\n      return V.eventsHandler = new T(), V.impressionDataAll = M, V.toggles = N && N.length > 0 ? N : [], V.url = n instanceof URL ? n : new URL(n), V.clientKey = i, V.headerName = C, V.customHeaders = j, V.storage = r || (\"undefined\" != typeof window ? new f() : new d()), V.refreshInterval = a ? 0 : 1e3 * u, V.context = e({\n        appName: b,\n        environment: w\n      }, E), V.usePOSTrequests = _, V.sdkState = \"initializing\", V.experimental = e({}, F), (null == F ? void 0 : F.togglesStorageTTL) && (null == F ? void 0 : F.togglesStorageTTL) > 0 && (V.experimental.togglesStorageTTL = 1e3 * F.togglesStorageTTL), V.lastRefreshTimestamp = 0, V.ready = new Promise(function (t) {\n        V.init().then(t).catch(function (e) {\n          console.error(e), V.sdkState = \"error\", V.emit(I.ERROR, e), V.lastError = e, t();\n        });\n      }), R || console.error('Unleash: You must either provide your own \"fetch\" implementation or run in an environment where \"fetch\" is available.'), k || console.error('Unleash: You must either provide your own \"AbortController\" implementation or run in an environment where \"AbortController\" is available.'), V.fetch = R, V.createAbortController = k, V.bootstrap = N && N.length > 0 ? N : void 0, V.bootstrapOverride = D, V.connectionId = \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (t) {\n        var e = 16 * Math.random() | 0;\n        return (\"x\" === t ? e : 3 & e | 8).toString(16);\n      }), V.metrics = new p({\n        onError: V.emit.bind(V, I.ERROR),\n        onSent: V.emit.bind(V, I.SENT),\n        appName: b,\n        metricsInterval: h,\n        disableMetrics: y,\n        url: V.url,\n        clientKey: i,\n        fetch: R,\n        headerName: C,\n        customHeaders: j,\n        metricsIntervalInitial: m,\n        connectionId: V.connectionId\n      }), V;\n    }\n    return function (e, r) {\n      if (\"function\" != typeof r && null !== r) throw new TypeError(\"Class extends value \" + String(r) + \" is not a constructor or null\");\n      function n() {\n        this.constructor = e;\n      }\n      t(e, r), e.prototype = null === r ? Object.create(r) : (n.prototype = r.prototype, new n());\n    }(i, o), i.prototype.getAllToggles = function () {\n      return function (t, e, r) {\n        if (r || 2 === arguments.length) for (var n, o = 0, i = e.length; o < i; o++) !n && o in e || (n || (n = Array.prototype.slice.call(e, 0, o)), n[o] = e[o]);\n        return t.concat(n || Array.prototype.slice.call(e));\n      }([], this.toggles, !0);\n    }, i.prototype.isEnabled = function (t) {\n      var e,\n        r = this.toggles.find(function (e) {\n          return e.name === t;\n        }),\n        n = !!r && r.enabled;\n      if (this.metrics.count(t, n), (null == r ? void 0 : r.impressionData) || this.impressionDataAll) {\n        var o = this.eventsHandler.createImpressionEvent(this.context, n, t, S, null !== (e = null == r ? void 0 : r.impressionData) && void 0 !== e ? e : void 0);\n        this.emit(I.IMPRESSION, o);\n      }\n      return n;\n    }, i.prototype.getVariant = function (t) {\n      var r,\n        n = this.toggles.find(function (e) {\n          return e.name === t;\n        }),\n        o = (null == n ? void 0 : n.enabled) || !1,\n        i = n ? n.variant : O;\n      if (i.name && this.metrics.countVariant(t, i.name), this.metrics.count(t, o), (null == n ? void 0 : n.impressionData) || this.impressionDataAll) {\n        var s = this.eventsHandler.createImpressionEvent(this.context, o, t, R, null !== (r = null == n ? void 0 : n.impressionData) && void 0 !== r ? r : void 0, i.name);\n        this.emit(I.IMPRESSION, s);\n      }\n      return e(e({}, i), {\n        feature_enabled: o\n      });\n    }, i.prototype.updateToggles = function () {\n      return r(this, void 0, void 0, function () {\n        var t = this;\n        return n(this, function (e) {\n          switch (e.label) {\n            case 0:\n              return this.timerRef || this.fetchedFromServer ? [4, this.fetchToggles()] : [3, 2];\n            case 1:\n              return e.sent(), [3, 4];\n            case 2:\n              return this.started ? [4, new Promise(function (e) {\n                var r = function () {\n                  t.fetchToggles().then(function () {\n                    t.off(I.READY, r), e();\n                  });\n                };\n                t.once(I.READY, r);\n              })] : [3, 4];\n            case 3:\n              e.sent(), e.label = 4;\n            case 4:\n              return [2];\n          }\n        });\n      });\n    }, i.prototype.updateContext = function (t) {\n      return r(this, void 0, void 0, function () {\n        var r;\n        return n(this, function (n) {\n          switch (n.label) {\n            case 0:\n              return (t.appName || t.environment) && console.warn(\"appName and environment are static. They can't be updated with updateContext.\"), r = {\n                environment: this.context.environment,\n                appName: this.context.appName,\n                sessionId: this.context.sessionId\n              }, this.context = e(e({}, r), t), [4, this.updateToggles()];\n            case 1:\n              return n.sent(), [2];\n          }\n        });\n      });\n    }, i.prototype.getContext = function () {\n      return e({}, this.context);\n    }, i.prototype.setContextField = function (t, r) {\n      var n, o;\n      if (E(t)) this.context = e(e({}, this.context), ((n = {})[t] = r, n));else {\n        var i = e(e({}, this.context.properties), ((o = {})[t] = r, o));\n        this.context = e(e({}, this.context), {\n          properties: i\n        });\n      }\n      this.updateToggles();\n    }, i.prototype.removeContextField = function (t) {\n      var r;\n      E(t) ? this.context = e(e({}, this.context), ((r = {})[t] = void 0, r)) : \"object\" == typeof this.context.properties && delete this.context.properties[t], this.updateToggles();\n    }, i.prototype.setReady = function () {\n      this.readyEventEmitted = !0, this.emit(I.READY);\n    }, i.prototype.init = function () {\n      return r(this, void 0, void 0, function () {\n        var t, r, o;\n        return n(this, function (n) {\n          switch (n.label) {\n            case 0:\n              return [4, this.resolveSessionId()];\n            case 1:\n              return t = n.sent(), this.context = e({\n                sessionId: t\n              }, this.context), [4, this.storage.get(k)];\n            case 2:\n              return r = n.sent() || [], o = this, [4, this.getLastRefreshTimestamp()];\n            case 3:\n              return o.lastRefreshTimestamp = n.sent(), !this.bootstrap || !this.bootstrapOverride && 0 !== r.length ? [3, 6] : [4, this.storage.save(k, this.bootstrap)];\n            case 4:\n              return n.sent(), this.toggles = this.bootstrap, this.sdkState = \"healthy\", [4, this.storeLastRefreshTimestamp()];\n            case 5:\n              return n.sent(), this.setReady(), [3, 7];\n            case 6:\n              this.toggles = r, n.label = 7;\n            case 7:\n              return this.sdkState = \"healthy\", this.emit(I.INIT), [2];\n          }\n        });\n      });\n    }, i.prototype.start = function () {\n      return r(this, void 0, void 0, function () {\n        var t,\n          e = this;\n        return n(this, function (r) {\n          switch (r.label) {\n            case 0:\n              return this.started = !0, this.timerRef ? (console.error(\"Unleash SDK has already started, if you want to restart the SDK you should call client.stop() before starting again.\"), [2]) : [4, this.ready];\n            case 1:\n              return r.sent(), this.metrics.start(), t = this.refreshInterval, [4, this.initialFetchToggles()];\n            case 2:\n              return r.sent(), t > 0 && (this.timerRef = setInterval(function () {\n                return e.fetchToggles();\n              }, t)), [2];\n          }\n        });\n      });\n    }, i.prototype.stop = function () {\n      this.timerRef && (clearInterval(this.timerRef), this.timerRef = void 0), this.metrics.stop();\n    }, i.prototype.isReady = function () {\n      return this.readyEventEmitted;\n    }, i.prototype.getError = function () {\n      return \"error\" === this.sdkState ? this.lastError : void 0;\n    }, i.prototype.sendMetrics = function () {\n      return this.metrics.sendMetrics();\n    }, i.prototype.resolveSessionId = function () {\n      return r(this, void 0, void 0, function () {\n        var t;\n        return n(this, function (e) {\n          switch (e.label) {\n            case 0:\n              return this.context.sessionId ? [2, this.context.sessionId] : [4, this.storage.get(\"sessionId\")];\n            case 1:\n              return (t = e.sent()) ? [3, 3] : (t = Math.floor(1e9 * Math.random()), [4, this.storage.save(\"sessionId\", t.toString(10))]);\n            case 2:\n              e.sent(), e.label = 3;\n            case 3:\n              return [2, t.toString(10)];\n          }\n        });\n      });\n    }, i.prototype.getHeaders = function () {\n      return l({\n        clientKey: this.clientKey,\n        connectionId: this.connectionId,\n        appName: this.context.appName,\n        customHeaders: this.customHeaders,\n        headerName: this.headerName,\n        etag: this.etag,\n        isPost: this.usePOSTrequests\n      });\n    }, i.prototype.storeToggles = function (t) {\n      return r(this, void 0, void 0, function () {\n        return n(this, function (e) {\n          switch (e.label) {\n            case 0:\n              return this.toggles = t, this.emit(I.UPDATE), [4, this.storage.save(k, t)];\n            case 1:\n              return e.sent(), [2];\n          }\n        });\n      });\n    }, i.prototype.isTogglesStorageTTLEnabled = function () {\n      var t;\n      return !!((null === (t = this.experimental) || void 0 === t ? void 0 : t.togglesStorageTTL) && this.experimental.togglesStorageTTL > 0);\n    }, i.prototype.isUpToDate = function () {\n      var t;\n      if (!this.isTogglesStorageTTLEnabled()) return !1;\n      var e = Date.now(),\n        r = (null === (t = this.experimental) || void 0 === t ? void 0 : t.togglesStorageTTL) || 0;\n      return this.lastRefreshTimestamp > 0 && this.lastRefreshTimestamp <= e && e - this.lastRefreshTimestamp <= r;\n    }, i.prototype.getLastRefreshTimestamp = function () {\n      return r(this, void 0, void 0, function () {\n        var t, e;\n        return n(this, function (r) {\n          switch (r.label) {\n            case 0:\n              return this.isTogglesStorageTTLEnabled() ? [4, this.storage.get(N)] : [3, 3];\n            case 1:\n              return t = r.sent(), [4, u(this.context)];\n            case 2:\n              return e = r.sent(), [2, (null == t ? void 0 : t.key) === e ? t.timestamp : 0];\n            case 3:\n              return [2, 0];\n          }\n        });\n      });\n    }, i.prototype.storeLastRefreshTimestamp = function () {\n      return r(this, void 0, void 0, function () {\n        var t, e;\n        return n(this, function (r) {\n          switch (r.label) {\n            case 0:\n              return this.isTogglesStorageTTLEnabled() ? (this.lastRefreshTimestamp = Date.now(), e = {}, [4, u(this.context)]) : [3, 3];\n            case 1:\n              return e.key = r.sent(), e.timestamp = this.lastRefreshTimestamp, t = e, [4, this.storage.save(N, t)];\n            case 2:\n              r.sent(), r.label = 3;\n            case 3:\n              return [2];\n          }\n        });\n      });\n    }, i.prototype.initialFetchToggles = function () {\n      if (!this.isUpToDate()) return this.fetchToggles();\n      this.fetchedFromServer || (this.fetchedFromServer = !0, this.setReady());\n    }, i.prototype.fetchToggles = function () {\n      return r(this, void 0, void 0, function () {\n        var t, e, r, o, i, s, c, u, l;\n        return n(this, function (n) {\n          switch (n.label) {\n            case 0:\n              if (!this.fetch) return [3, 9];\n              this.abortController && !this.abortController.signal.aborted && this.abortController.abort(), this.abortController = null === (l = this.createAbortController) || void 0 === l ? void 0 : l.call(this), t = this.abortController ? this.abortController.signal : void 0, n.label = 1;\n            case 1:\n              return n.trys.push([1, 7, 8, 9]), e = this.usePOSTrequests, r = e ? this.url : function (t, e) {\n                var r = new URL(t.toString());\n                return Object.entries(e).filter(a).forEach(function (t) {\n                  var e = t[0],\n                    n = t[1];\n                  \"properties\" === e && n ? Object.entries(n).filter(a).forEach(function (t) {\n                    var e = t[0],\n                      n = t[1];\n                    return r.searchParams.append(\"properties[\".concat(e, \"]\"), n);\n                  }) : r.searchParams.append(e, n);\n                }), r;\n              }(this.url, this.context), o = e ? \"POST\" : \"GET\", i = e ? JSON.stringify({\n                context: this.context\n              }) : void 0, [4, this.fetch(r.toString(), {\n                method: o,\n                cache: \"no-cache\",\n                headers: this.getHeaders(),\n                body: i,\n                signal: t\n              })];\n            case 2:\n              return s = n.sent(), \"error\" === this.sdkState && s.status < 400 && (this.sdkState = \"healthy\", this.emit(I.RECOVERED)), s.ok ? (this.etag = s.headers.get(\"ETag\") || \"\", [4, s.json()]) : [3, 5];\n            case 3:\n              return c = n.sent(), [4, this.storeToggles(c.toggles)];\n            case 4:\n              return n.sent(), \"healthy\" !== this.sdkState && (this.sdkState = \"healthy\"), this.fetchedFromServer || (this.fetchedFromServer = !0, this.setReady()), this.storeLastRefreshTimestamp(), [3, 6];\n            case 5:\n              304 === s.status ? this.storeLastRefreshTimestamp() : (console.error(\"Unleash: Fetching feature toggles did not have an ok response\"), this.sdkState = \"error\", this.emit(I.ERROR, {\n                type: \"HttpError\",\n                code: s.status\n              }), this.lastError = {\n                type: \"HttpError\",\n                code: s.status\n              }), n.label = 6;\n            case 6:\n              return [3, 9];\n            case 7:\n              return \"object\" == typeof (u = n.sent()) && null !== u && \"name\" in u && \"AbortError\" === u.name || (console.error(\"Unleash: unable to fetch feature toggles\", u), this.sdkState = \"error\", this.emit(I.ERROR, u), this.lastError = u), [3, 9];\n            case 8:\n              return this.abortController = null, [7];\n            case 9:\n              return [2];\n          }\n        });\n      });\n    }, i;\n  }(s);\nexport { I as EVENTS, d as InMemoryStorageProvider, f as LocalStorageProvider, U as UnleashClient, N as lastUpdateKey, A as resolveFetch };\n//# sourceMappingURL=main.esm.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}