{"ast":null,"code":"import { getEnvelopeEndpointWithUrlEncodedAuth } from './api.js';\nimport { DEFAULT_ENVIRONMENT } from './constants.js';\nimport { getTraceContextFromScope, getCurrentScope, getIsolationScope, withScope } from './currentScopes.js';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { createEventEnvelope, createSessionEnvelope } from './envelope.js';\nimport { setupIntegration, afterSetupIntegrations, setupIntegrations } from './integration.js';\nimport { updateSession } from './session.js';\nimport { getDynamicSamplingContextFromScope, getDynamicSamplingContextFromSpan } from './tracing/dynamicSamplingContext.js';\nimport { createClientReportEnvelope } from './utils/clientreport.js';\nimport { debug } from './utils/debug-logger.js';\nimport { makeDsn, dsnToString } from './utils/dsn.js';\nimport { addItemToEnvelope, createAttachmentEnvelopeItem } from './utils/envelope.js';\nimport { getPossibleEventMessages } from './utils/eventUtils.js';\nimport { isPrimitive, isParameterizedString, isThenable, isPlainObject } from './utils/is.js';\nimport { merge } from './utils/merge.js';\nimport { uuid4, checkOrSetAlreadyCaught } from './utils/misc.js';\nimport { parseSampleRate } from './utils/parseSampleRate.js';\nimport { prepareEvent } from './utils/prepareEvent.js';\nimport { showSpanDropWarning, getActiveSpan, spanToTraceContext } from './utils/spanUtils.js';\nimport { resolvedSyncPromise, SyncPromise, rejectedSyncPromise } from './utils/syncpromise.js';\nimport { convertTransactionEventToSpanJson, convertSpanJsonToTransactionEvent } from './utils/transactionEvent.js';\n\n/* eslint-disable max-lines */\n\nconst ALREADY_SEEN_ERROR = \"Not capturing exception because it's already been captured.\";\nconst MISSING_RELEASE_FOR_SESSION_ERROR = 'Discarded session because of missing or non-string release';\nconst INTERNAL_ERROR_SYMBOL = Symbol.for('SentryInternalError');\nconst DO_NOT_SEND_EVENT_SYMBOL = Symbol.for('SentryDoNotSendEventError');\nfunction _makeInternalError(message) {\n  return {\n    message,\n    [INTERNAL_ERROR_SYMBOL]: true\n  };\n}\nfunction _makeDoNotSendEventError(message) {\n  return {\n    message,\n    [DO_NOT_SEND_EVENT_SYMBOL]: true\n  };\n}\nfunction _isInternalError(error) {\n  return !!error && typeof error === 'object' && INTERNAL_ERROR_SYMBOL in error;\n}\nfunction _isDoNotSendEventError(error) {\n  return !!error && typeof error === 'object' && DO_NOT_SEND_EVENT_SYMBOL in error;\n}\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event, it is passed through\n * {@link Client._prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends Client<NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(options);\n *   }\n *\n *   // ...\n * }\n */\nclass Client {\n  /** Options passed to the SDK. */\n\n  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n\n  /** Array of set up integrations. */\n\n  /** Number of calls being processed */\n\n  /** Holds flushable  */\n\n  // eslint-disable-next-line @typescript-eslint/ban-types\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param options Options for the client.\n   */\n  constructor(options) {\n    this._options = options;\n    this._integrations = {};\n    this._numProcessing = 0;\n    this._outcomes = {};\n    this._hooks = {};\n    this._eventProcessors = [];\n    if (options.dsn) {\n      this._dsn = makeDsn(options.dsn);\n    } else {\n      DEBUG_BUILD && debug.warn('No DSN provided, client will not send events.');\n    }\n    if (this._dsn) {\n      const url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options.tunnel, options._metadata ? options._metadata.sdk : undefined);\n      this._transport = options.transport({\n        tunnel: this._options.tunnel,\n        recordDroppedEvent: this.recordDroppedEvent.bind(this),\n        ...options.transportOptions,\n        url\n      });\n    }\n  }\n\n  /**\n   * Captures an exception event and sends it to Sentry.\n   *\n   * Unlike `captureException` exported from every SDK, this method requires that you pass it the current scope.\n   */\n  captureException(exception, hint, scope) {\n    const eventId = uuid4();\n\n    // ensure we haven't captured this very object before\n    if (checkOrSetAlreadyCaught(exception)) {\n      DEBUG_BUILD && debug.log(ALREADY_SEEN_ERROR);\n      return eventId;\n    }\n    const hintWithEventId = {\n      event_id: eventId,\n      ...hint\n    };\n    this._process(this.eventFromException(exception, hintWithEventId).then(event => this._captureEvent(event, hintWithEventId, scope)));\n    return hintWithEventId.event_id;\n  }\n\n  /**\n   * Captures a message event and sends it to Sentry.\n   *\n   * Unlike `captureMessage` exported from every SDK, this method requires that you pass it the current scope.\n   */\n  captureMessage(message, level, hint, currentScope) {\n    const hintWithEventId = {\n      event_id: uuid4(),\n      ...hint\n    };\n    const eventMessage = isParameterizedString(message) ? message : String(message);\n    const promisedEvent = isPrimitive(message) ? this.eventFromMessage(eventMessage, level, hintWithEventId) : this.eventFromException(message, hintWithEventId);\n    this._process(promisedEvent.then(event => this._captureEvent(event, hintWithEventId, currentScope)));\n    return hintWithEventId.event_id;\n  }\n\n  /**\n   * Captures a manually created event and sends it to Sentry.\n   *\n   * Unlike `captureEvent` exported from every SDK, this method requires that you pass it the current scope.\n   */\n  captureEvent(event, hint, currentScope) {\n    const eventId = uuid4();\n\n    // ensure we haven't captured this very object before\n    if (hint?.originalException && checkOrSetAlreadyCaught(hint.originalException)) {\n      DEBUG_BUILD && debug.log(ALREADY_SEEN_ERROR);\n      return eventId;\n    }\n    const hintWithEventId = {\n      event_id: eventId,\n      ...hint\n    };\n    const sdkProcessingMetadata = event.sdkProcessingMetadata || {};\n    const capturedSpanScope = sdkProcessingMetadata.capturedSpanScope;\n    const capturedSpanIsolationScope = sdkProcessingMetadata.capturedSpanIsolationScope;\n    this._process(this._captureEvent(event, hintWithEventId, capturedSpanScope || currentScope, capturedSpanIsolationScope));\n    return hintWithEventId.event_id;\n  }\n\n  /**\n   * Captures a session.\n   */\n  captureSession(session) {\n    this.sendSession(session);\n    // After sending, we set init false to indicate it's not the first occurrence\n    updateSession(session, {\n      init: false\n    });\n  }\n\n  /**\n   * Create a cron monitor check in and send it to Sentry. This method is not available on all clients.\n   *\n   * @param checkIn An object that describes a check in.\n   * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n   * to create a monitor automatically when sending a check in.\n   * @param scope An optional scope containing event metadata.\n   * @returns A string representing the id of the check in.\n   */\n\n  /**\n   * Get the current Dsn.\n   */\n  getDsn() {\n    return this._dsn;\n  }\n\n  /**\n   * Get the current options.\n   */\n  getOptions() {\n    return this._options;\n  }\n\n  /**\n   * Get the SDK metadata.\n   * @see SdkMetadata\n   */\n  getSdkMetadata() {\n    return this._options._metadata;\n  }\n\n  /**\n   * Returns the transport that is used by the client.\n   * Please note that the transport gets lazy initialized so it will only be there once the first event has been sent.\n   */\n  getTransport() {\n    return this._transport;\n  }\n\n  /**\n   * Wait for all events to be sent or the timeout to expire, whichever comes first.\n   *\n   * @param timeout Maximum time in ms the client should wait for events to be flushed. Omitting this parameter will\n   *   cause the client to wait until all events are sent before resolving the promise.\n   * @returns A promise that will resolve with `true` if all events are sent before the timeout, or `false` if there are\n   * still events in the queue when the timeout is reached.\n   */\n  flush(timeout) {\n    const transport = this._transport;\n    if (transport) {\n      this.emit('flush');\n      return this._isClientDoneProcessing(timeout).then(clientFinished => {\n        return transport.flush(timeout).then(transportFlushed => clientFinished && transportFlushed);\n      });\n    } else {\n      return resolvedSyncPromise(true);\n    }\n  }\n\n  /**\n   * Flush the event queue and set the client to `enabled = false`. See {@link Client.flush}.\n   *\n   * @param {number} timeout Maximum time in ms the client should wait before shutting down. Omitting this parameter will cause\n   *   the client to wait until all events are sent before disabling itself.\n   * @returns {Promise<boolean>} A promise which resolves to `true` if the flush completes successfully before the timeout, or `false` if\n   * it doesn't.\n   */\n  close(timeout) {\n    return this.flush(timeout).then(result => {\n      this.getOptions().enabled = false;\n      this.emit('close');\n      return result;\n    });\n  }\n\n  /**\n   * Get all installed event processors.\n   */\n  getEventProcessors() {\n    return this._eventProcessors;\n  }\n\n  /**\n   * Adds an event processor that applies to any event processed by this client.\n   */\n  addEventProcessor(eventProcessor) {\n    this._eventProcessors.push(eventProcessor);\n  }\n\n  /**\n   * Initialize this client.\n   * Call this after the client was set on a scope.\n   */\n  init() {\n    if (this._isEnabled() ||\n    // Force integrations to be setup even if no DSN was set when we have\n    // Spotlight enabled. This is particularly important for browser as we\n    // don't support the `spotlight` option there and rely on the users\n    // adding the `spotlightBrowserIntegration()` to their integrations which\n    // wouldn't get initialized with the check below when there's no DSN set.\n    this._options.integrations.some(({\n      name\n    }) => name.startsWith('Spotlight'))) {\n      this._setupIntegrations();\n    }\n  }\n\n  /**\n   * Gets an installed integration by its name.\n   *\n   * @returns {Integration|undefined} The installed integration or `undefined` if no integration with that `name` was installed.\n   */\n  getIntegrationByName(integrationName) {\n    return this._integrations[integrationName];\n  }\n\n  /**\n   * Add an integration to the client.\n   * This can be used to e.g. lazy load integrations.\n   * In most cases, this should not be necessary,\n   * and you're better off just passing the integrations via `integrations: []` at initialization time.\n   * However, if you find the need to conditionally load & add an integration, you can use `addIntegration` to do so.\n   */\n  addIntegration(integration) {\n    const isAlreadyInstalled = this._integrations[integration.name];\n\n    // This hook takes care of only installing if not already installed\n    setupIntegration(this, integration, this._integrations);\n    // Here we need to check manually to make sure to not run this multiple times\n    if (!isAlreadyInstalled) {\n      afterSetupIntegrations(this, [integration]);\n    }\n  }\n\n  /**\n   * Send a fully prepared event to Sentry.\n   */\n  sendEvent(event, hint = {}) {\n    this.emit('beforeSendEvent', event, hint);\n    let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);\n    for (const attachment of hint.attachments || []) {\n      env = addItemToEnvelope(env, createAttachmentEnvelopeItem(attachment));\n    }\n    const promise = this.sendEnvelope(env);\n    if (promise) {\n      promise.then(sendResponse => this.emit('afterSendEvent', event, sendResponse), null);\n    }\n  }\n\n  /**\n   * Send a session or session aggregrates to Sentry.\n   */\n  sendSession(session) {\n    // Backfill release and environment on session\n    const {\n      release: clientReleaseOption,\n      environment: clientEnvironmentOption = DEFAULT_ENVIRONMENT\n    } = this._options;\n    if ('aggregates' in session) {\n      const sessionAttrs = session.attrs || {};\n      if (!sessionAttrs.release && !clientReleaseOption) {\n        DEBUG_BUILD && debug.warn(MISSING_RELEASE_FOR_SESSION_ERROR);\n        return;\n      }\n      sessionAttrs.release = sessionAttrs.release || clientReleaseOption;\n      sessionAttrs.environment = sessionAttrs.environment || clientEnvironmentOption;\n      session.attrs = sessionAttrs;\n    } else {\n      if (!session.release && !clientReleaseOption) {\n        DEBUG_BUILD && debug.warn(MISSING_RELEASE_FOR_SESSION_ERROR);\n        return;\n      }\n      session.release = session.release || clientReleaseOption;\n      session.environment = session.environment || clientEnvironmentOption;\n    }\n    this.emit('beforeSendSession', session);\n    const env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);\n\n    // sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.sendEnvelope(env);\n  }\n\n  /**\n   * Record on the client that an event got dropped (ie, an event that will not be sent to Sentry).\n   */\n  recordDroppedEvent(reason, category, count = 1) {\n    if (this._options.sendClientReports) {\n      // We want to track each category (error, transaction, session, replay_event) separately\n      // but still keep the distinction between different type of outcomes.\n      // We could use nested maps, but it's much easier to read and type this way.\n      // A correct type for map-based implementation if we want to go that route\n      // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n      // With typescript 4.1 we could even use template literal types\n      const key = `${reason}:${category}`;\n      DEBUG_BUILD && debug.log(`Recording outcome: \"${key}\"${count > 1 ? ` (${count} times)` : ''}`);\n      this._outcomes[key] = (this._outcomes[key] || 0) + count;\n    }\n  }\n\n  /* eslint-disable @typescript-eslint/unified-signatures */\n  /**\n   * Register a callback for whenever a span is started.\n   * Receives the span as argument.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n\n  /**\n   * Register a hook on this client.\n   */\n  on(hook, callback) {\n    const hooks = this._hooks[hook] = this._hooks[hook] || [];\n\n    // @ts-expect-error We assume the types are correct\n    hooks.push(callback);\n\n    // This function returns a callback execution handler that, when invoked,\n    // deregisters a callback. This is crucial for managing instances where callbacks\n    // need to be unregistered to prevent self-referencing in callback closures,\n    // ensuring proper garbage collection.\n    return () => {\n      // @ts-expect-error We assume the types are correct\n      const cbIndex = hooks.indexOf(callback);\n      if (cbIndex > -1) {\n        hooks.splice(cbIndex, 1);\n      }\n    };\n  }\n\n  /** Fire a hook whenever a span starts. */\n\n  /**\n   * Emit a hook that was previously registered via `on()`.\n   */\n  emit(hook, ...rest) {\n    const callbacks = this._hooks[hook];\n    if (callbacks) {\n      callbacks.forEach(callback => callback(...rest));\n    }\n  }\n\n  /**\n   * Send an envelope to Sentry.\n   */\n  sendEnvelope(envelope) {\n    this.emit('beforeEnvelope', envelope);\n    if (this._isEnabled() && this._transport) {\n      return this._transport.send(envelope).then(null, reason => {\n        DEBUG_BUILD && debug.error('Error while sending envelope:', reason);\n        return reason;\n      });\n    }\n    DEBUG_BUILD && debug.error('Transport disabled');\n    return resolvedSyncPromise({});\n  }\n\n  /* eslint-enable @typescript-eslint/unified-signatures */\n\n  /** Setup integrations for this client. */\n  _setupIntegrations() {\n    const {\n      integrations\n    } = this._options;\n    this._integrations = setupIntegrations(this, integrations);\n    afterSetupIntegrations(this, integrations);\n  }\n\n  /** Updates existing session based on the provided event */\n  _updateSessionFromEvent(session, event) {\n    let crashed = event.level === 'fatal';\n    let errored = false;\n    const exceptions = event.exception?.values;\n    if (exceptions) {\n      errored = true;\n      for (const ex of exceptions) {\n        const mechanism = ex.mechanism;\n        if (mechanism?.handled === false) {\n          crashed = true;\n          break;\n        }\n      }\n    }\n\n    // A session is updated and that session update is sent in only one of the two following scenarios:\n    // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update\n    // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update\n    const sessionNonTerminal = session.status === 'ok';\n    const shouldUpdateAndSend = sessionNonTerminal && session.errors === 0 || sessionNonTerminal && crashed;\n    if (shouldUpdateAndSend) {\n      updateSession(session, {\n        ...(crashed && {\n          status: 'crashed'\n        }),\n        errors: session.errors || Number(errored || crashed)\n      });\n      this.captureSession(session);\n    }\n  }\n\n  /**\n   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying\n   * \"no\" (resolving to `false`) in order to give the client a chance to potentially finish first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not\n   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and\n   * `false` otherwise\n   */\n  _isClientDoneProcessing(timeout) {\n    return new SyncPromise(resolve => {\n      let ticked = 0;\n      const tick = 1;\n      const interval = setInterval(() => {\n        if (this._numProcessing == 0) {\n          clearInterval(interval);\n          resolve(true);\n        } else {\n          ticked += tick;\n          if (timeout && ticked >= timeout) {\n            clearInterval(interval);\n            resolve(false);\n          }\n        }\n      }, tick);\n    });\n  }\n\n  /** Determines whether this SDK is enabled and a transport is present. */\n  _isEnabled() {\n    return this.getOptions().enabled !== false && this._transport !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional information about the original exception.\n   * @param currentScope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n  _prepareEvent(event, hint, currentScope, isolationScope) {\n    const options = this.getOptions();\n    const integrations = Object.keys(this._integrations);\n    if (!hint.integrations && integrations?.length) {\n      hint.integrations = integrations;\n    }\n    this.emit('preprocessEvent', event, hint);\n    if (!event.type) {\n      isolationScope.setLastEventId(event.event_id || hint.event_id);\n    }\n    return prepareEvent(options, event, hint, currentScope, this, isolationScope).then(evt => {\n      if (evt === null) {\n        return evt;\n      }\n      this.emit('postprocessEvent', evt, hint);\n      evt.contexts = {\n        trace: getTraceContextFromScope(currentScope),\n        ...evt.contexts\n      };\n      const dynamicSamplingContext = getDynamicSamplingContextFromScope(this, currentScope);\n      evt.sdkProcessingMetadata = {\n        dynamicSamplingContext,\n        ...evt.sdkProcessingMetadata\n      };\n      return evt;\n    });\n  }\n\n  /**\n   * Processes the event and logs an error in case of rejection\n   * @param event\n   * @param hint\n   * @param scope\n   */\n  _captureEvent(event, hint = {}, currentScope = getCurrentScope(), isolationScope = getIsolationScope()) {\n    if (DEBUG_BUILD && isErrorEvent(event)) {\n      debug.log(`Captured error event \\`${getPossibleEventMessages(event)[0] || '<unknown>'}\\``);\n    }\n    return this._processEvent(event, hint, currentScope, isolationScope).then(finalEvent => {\n      return finalEvent.event_id;\n    }, reason => {\n      if (DEBUG_BUILD) {\n        if (_isDoNotSendEventError(reason)) {\n          debug.log(reason.message);\n        } else if (_isInternalError(reason)) {\n          debug.warn(reason.message);\n        } else {\n          debug.warn(reason);\n        }\n      }\n      return undefined;\n    });\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param currentScope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n  _processEvent(event, hint, currentScope, isolationScope) {\n    const options = this.getOptions();\n    const {\n      sampleRate\n    } = options;\n    const isTransaction = isTransactionEvent(event);\n    const isError = isErrorEvent(event);\n    const eventType = event.type || 'error';\n    const beforeSendLabel = `before send for type \\`${eventType}\\``;\n\n    // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    // Sampling for transaction happens somewhere else\n    const parsedSampleRate = typeof sampleRate === 'undefined' ? undefined : parseSampleRate(sampleRate);\n    if (isError && typeof parsedSampleRate === 'number' && Math.random() > parsedSampleRate) {\n      this.recordDroppedEvent('sample_rate', 'error');\n      return rejectedSyncPromise(_makeDoNotSendEventError(`Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`));\n    }\n    const dataCategory = eventType === 'replay_event' ? 'replay' : eventType;\n    return this._prepareEvent(event, hint, currentScope, isolationScope).then(prepared => {\n      if (prepared === null) {\n        this.recordDroppedEvent('event_processor', dataCategory);\n        throw _makeDoNotSendEventError('An event processor returned `null`, will not send event.');\n      }\n      const isInternalException = hint.data && hint.data.__sentry__ === true;\n      if (isInternalException) {\n        return prepared;\n      }\n      const result = processBeforeSend(this, options, prepared, hint);\n      return _validateBeforeSendResult(result, beforeSendLabel);\n    }).then(processedEvent => {\n      if (processedEvent === null) {\n        this.recordDroppedEvent('before_send', dataCategory);\n        if (isTransaction) {\n          const spans = event.spans || [];\n          // the transaction itself counts as one span, plus all the child spans that are added\n          const spanCount = 1 + spans.length;\n          this.recordDroppedEvent('before_send', 'span', spanCount);\n        }\n        throw _makeDoNotSendEventError(`${beforeSendLabel} returned \\`null\\`, will not send event.`);\n      }\n      const session = currentScope.getSession() || isolationScope.getSession();\n      if (isError && session) {\n        this._updateSessionFromEvent(session, processedEvent);\n      }\n      if (isTransaction) {\n        const spanCountBefore = processedEvent.sdkProcessingMetadata?.spanCountBeforeProcessing || 0;\n        const spanCountAfter = processedEvent.spans ? processedEvent.spans.length : 0;\n        const droppedSpanCount = spanCountBefore - spanCountAfter;\n        if (droppedSpanCount > 0) {\n          this.recordDroppedEvent('before_send', 'span', droppedSpanCount);\n        }\n      }\n\n      // None of the Sentry built event processor will update transaction name,\n      // so if the transaction name has been changed by an event processor, we know\n      // it has to come from custom event processor added by a user\n      const transactionInfo = processedEvent.transaction_info;\n      if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {\n        const source = 'custom';\n        processedEvent.transaction_info = {\n          ...transactionInfo,\n          source\n        };\n      }\n      this.sendEvent(processedEvent, hint);\n      return processedEvent;\n    }).then(null, reason => {\n      if (_isDoNotSendEventError(reason) || _isInternalError(reason)) {\n        throw reason;\n      }\n      this.captureException(reason, {\n        data: {\n          __sentry__: true\n        },\n        originalException: reason\n      });\n      throw _makeInternalError(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: ${reason}`);\n    });\n  }\n\n  /**\n   * Occupies the client with processing and event\n   */\n  _process(promise) {\n    this._numProcessing++;\n    void promise.then(value => {\n      this._numProcessing--;\n      return value;\n    }, reason => {\n      this._numProcessing--;\n      return reason;\n    });\n  }\n\n  /**\n   * Clears outcomes on this client and returns them.\n   */\n  _clearOutcomes() {\n    const outcomes = this._outcomes;\n    this._outcomes = {};\n    return Object.entries(outcomes).map(([key, quantity]) => {\n      const [reason, category] = key.split(':');\n      return {\n        reason,\n        category,\n        quantity\n      };\n    });\n  }\n\n  /**\n   * Sends client reports as an envelope.\n   */\n  _flushOutcomes() {\n    DEBUG_BUILD && debug.log('Flushing outcomes...');\n    const outcomes = this._clearOutcomes();\n    if (outcomes.length === 0) {\n      DEBUG_BUILD && debug.log('No outcomes to send');\n      return;\n    }\n\n    // This is really the only place where we want to check for a DSN and only send outcomes then\n    if (!this._dsn) {\n      DEBUG_BUILD && debug.log('No dsn provided, will not send outcomes');\n      return;\n    }\n    DEBUG_BUILD && debug.log('Sending outcomes:', outcomes);\n    const envelope = createClientReportEnvelope(outcomes, this._options.tunnel && dsnToString(this._dsn));\n\n    // sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.sendEnvelope(envelope);\n  }\n\n  /**\n   * Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`.\n   */\n}\n\n/**\n * @deprecated Use `Client` instead. This alias may be removed in a future major version.\n */\n// TODO(v10): Remove\n\n/**\n * @deprecated Use `Client` instead. This alias may be removed in a future major version.\n */\n// TODO(v10): Remove\nconst BaseClient = Client;\n\n/**\n * Verifies that return value of configured `beforeSend` or `beforeSendTransaction` is of expected type, and returns the value if so.\n */\nfunction _validateBeforeSendResult(beforeSendResult, beforeSendLabel) {\n  const invalidValueError = `${beforeSendLabel} must return \\`null\\` or a valid event.`;\n  if (isThenable(beforeSendResult)) {\n    return beforeSendResult.then(event => {\n      if (!isPlainObject(event) && event !== null) {\n        throw _makeInternalError(invalidValueError);\n      }\n      return event;\n    }, e => {\n      throw _makeInternalError(`${beforeSendLabel} rejected with ${e}`);\n    });\n  } else if (!isPlainObject(beforeSendResult) && beforeSendResult !== null) {\n    throw _makeInternalError(invalidValueError);\n  }\n  return beforeSendResult;\n}\n\n/**\n * Process the matching `beforeSendXXX` callback.\n */\nfunction processBeforeSend(client, options, event, hint) {\n  const {\n    beforeSend,\n    beforeSendTransaction,\n    beforeSendSpan\n  } = options;\n  let processedEvent = event;\n  if (isErrorEvent(processedEvent) && beforeSend) {\n    return beforeSend(processedEvent, hint);\n  }\n  if (isTransactionEvent(processedEvent)) {\n    if (beforeSendSpan) {\n      // process root span\n      const processedRootSpanJson = beforeSendSpan(convertTransactionEventToSpanJson(processedEvent));\n      if (!processedRootSpanJson) {\n        showSpanDropWarning();\n      } else {\n        // update event with processed root span values\n        processedEvent = merge(event, convertSpanJsonToTransactionEvent(processedRootSpanJson));\n      }\n\n      // process child spans\n      if (processedEvent.spans) {\n        const processedSpans = [];\n        for (const span of processedEvent.spans) {\n          const processedSpan = beforeSendSpan(span);\n          if (!processedSpan) {\n            showSpanDropWarning();\n            processedSpans.push(span);\n          } else {\n            processedSpans.push(processedSpan);\n          }\n        }\n        processedEvent.spans = processedSpans;\n      }\n    }\n    if (beforeSendTransaction) {\n      if (processedEvent.spans) {\n        // We store the # of spans before processing in SDK metadata,\n        // so we can compare it afterwards to determine how many spans were dropped\n        const spanCountBefore = processedEvent.spans.length;\n        processedEvent.sdkProcessingMetadata = {\n          ...event.sdkProcessingMetadata,\n          spanCountBeforeProcessing: spanCountBefore\n        };\n      }\n      return beforeSendTransaction(processedEvent, hint);\n    }\n  }\n  return processedEvent;\n}\nfunction isErrorEvent(event) {\n  return event.type === undefined;\n}\nfunction isTransactionEvent(event) {\n  return event.type === 'transaction';\n}\n\n/** Extract trace information from scope */\nfunction _getTraceInfoFromScope(client, scope) {\n  if (!scope) {\n    return [undefined, undefined];\n  }\n  return withScope(scope, () => {\n    const span = getActiveSpan();\n    const traceContext = span ? spanToTraceContext(span) : getTraceContextFromScope(scope);\n    const dynamicSamplingContext = span ? getDynamicSamplingContextFromSpan(span) : getDynamicSamplingContextFromScope(client, scope);\n    return [dynamicSamplingContext, traceContext];\n  });\n}\nexport { BaseClient, Client, _getTraceInfoFromScope };","map":{"version":3,"names":["ALREADY_SEEN_ERROR","MISSING_RELEASE_FOR_SESSION_ERROR","INTERNAL_ERROR_SYMBOL","Symbol","for","DO_NOT_SEND_EVENT_SYMBOL","_makeInternalError","message","_makeDoNotSendEventError","_isInternalError","error","_isDoNotSendEventError","Client","constructor","options","_options","_integrations","_numProcessing","_outcomes","_hooks","_eventProcessors","dsn","_dsn","makeDsn","DEBUG_BUILD","debug","warn","url","getEnvelopeEndpointWithUrlEncodedAuth","tunnel","_metadata","sdk","undefined","_transport","transport","recordDroppedEvent","bind","transportOptions","captureException","exception","hint","scope","eventId","uuid4","checkOrSetAlreadyCaught","log","hintWithEventId","event_id","_process","eventFromException","then","event","_captureEvent","captureMessage","level","currentScope","eventMessage","isParameterizedString","String","promisedEvent","isPrimitive","eventFromMessage","captureEvent","originalException","sdkProcessingMetadata","capturedSpanScope","capturedSpanIsolationScope","captureSession","session","sendSession","updateSession","init","getDsn","getOptions","getSdkMetadata","getTransport","flush","timeout","emit","_isClientDoneProcessing","clientFinished","transportFlushed","resolvedSyncPromise","close","result","enabled","getEventProcessors","addEventProcessor","eventProcessor","push","_isEnabled","integrations","some","name","startsWith","_setupIntegrations","getIntegrationByName","integrationName","addIntegration","integration","isAlreadyInstalled","setupIntegration","afterSetupIntegrations","sendEvent","env","createEventEnvelope","attachment","attachments","addItemToEnvelope","createAttachmentEnvelopeItem","promise","sendEnvelope","sendResponse","release","clientReleaseOption","environment","clientEnvironmentOption","DEFAULT_ENVIRONMENT","sessionAttrs","attrs","createSessionEnvelope","reason","category","count","sendClientReports","key","on","hook","callback","hooks","cbIndex","indexOf","splice","rest","callbacks","forEach","envelope","send","setupIntegrations","_updateSessionFromEvent","crashed","errored","exceptions","values","ex","mechanism","handled","sessionNonTerminal","status","shouldUpdateAndSend","errors","Number","SyncPromise","resolve","ticked","tick","interval","setInterval","clearInterval","_prepareEvent","isolationScope","Object","keys","length","type","setLastEventId","prepareEvent","evt","contexts","trace","getTraceContextFromScope","dynamicSamplingContext","getDynamicSamplingContextFromScope","getCurrentScope","getIsolationScope","isErrorEvent","getPossibleEventMessages","_processEvent","finalEvent","sampleRate","isTransaction","isTransactionEvent","isError","eventType","beforeSendLabel","parsedSampleRate","parseSampleRate","Math","random","rejectedSyncPromise","dataCategory","prepared","isInternalException","data","__sentry__","processBeforeSend","_validateBeforeSendResult","processedEvent","spans","spanCount","getSession","spanCountBefore","spanCountBeforeProcessing","spanCountAfter","droppedSpanCount","transactionInfo","transaction_info","transaction","source","value","_clearOutcomes","outcomes","entries","map","quantity","split","_flushOutcomes","createClientReportEnvelope","dsnToString","BaseClient","beforeSendResult","invalidValueError","isThenable","isPlainObject","e","client","beforeSend","beforeSendTransaction","beforeSendSpan","processedRootSpanJson","convertTransactionEventToSpanJson","showSpanDropWarning","merge","convertSpanJsonToTransactionEvent","processedSpans","span","processedSpan","_getTraceInfoFromScope","withScope","getActiveSpan","traceContext","spanToTraceContext","getDynamicSamplingContextFromSpan"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/client.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport { getEnvelopeEndpointWithUrlEncodedAuth } from './api';\nimport { DEFAULT_ENVIRONMENT } from './constants';\nimport { getCurrentScope, getIsolationScope, getTraceContextFromScope, withScope } from './currentScopes';\nimport { DEBUG_BUILD } from './debug-build';\nimport { createEventEnvelope, createSessionEnvelope } from './envelope';\nimport type { IntegrationIndex } from './integration';\nimport { afterSetupIntegrations, setupIntegration, setupIntegrations } from './integration';\nimport type { Scope } from './scope';\nimport { updateSession } from './session';\nimport {\n  getDynamicSamplingContextFromScope,\n  getDynamicSamplingContextFromSpan,\n} from './tracing/dynamicSamplingContext';\nimport type { Breadcrumb, BreadcrumbHint, FetchBreadcrumbHint, XhrBreadcrumbHint } from './types-hoist/breadcrumb';\nimport type { CheckIn, MonitorConfig } from './types-hoist/checkin';\nimport type { EventDropReason, Outcome } from './types-hoist/clientreport';\nimport type { TraceContext } from './types-hoist/context';\nimport type { DataCategory } from './types-hoist/datacategory';\nimport type { DsnComponents } from './types-hoist/dsn';\nimport type { DynamicSamplingContext, Envelope } from './types-hoist/envelope';\nimport type { ErrorEvent, Event, EventHint, TransactionEvent } from './types-hoist/event';\nimport type { EventProcessor } from './types-hoist/eventprocessor';\nimport type { FeedbackEvent } from './types-hoist/feedback';\nimport type { Integration } from './types-hoist/integration';\nimport type { Log } from './types-hoist/log';\nimport type { ClientOptions } from './types-hoist/options';\nimport type { ParameterizedString } from './types-hoist/parameterize';\nimport type { SdkMetadata } from './types-hoist/sdkmetadata';\nimport type { Session, SessionAggregates } from './types-hoist/session';\nimport type { SeverityLevel } from './types-hoist/severity';\nimport type { Span, SpanAttributes, SpanContextData, SpanJSON } from './types-hoist/span';\nimport type { StartSpanOptions } from './types-hoist/startSpanOptions';\nimport type { Transport, TransportMakeRequestResponse } from './types-hoist/transport';\nimport { createClientReportEnvelope } from './utils/clientreport';\nimport { debug } from './utils/debug-logger';\nimport { dsnToString, makeDsn } from './utils/dsn';\nimport { addItemToEnvelope, createAttachmentEnvelopeItem } from './utils/envelope';\nimport { getPossibleEventMessages } from './utils/eventUtils';\nimport { isParameterizedString, isPlainObject, isPrimitive, isThenable } from './utils/is';\nimport { merge } from './utils/merge';\nimport { checkOrSetAlreadyCaught, uuid4 } from './utils/misc';\nimport { parseSampleRate } from './utils/parseSampleRate';\nimport { prepareEvent } from './utils/prepareEvent';\nimport { getActiveSpan, showSpanDropWarning, spanToTraceContext } from './utils/spanUtils';\nimport { rejectedSyncPromise, resolvedSyncPromise, SyncPromise } from './utils/syncpromise';\nimport { convertSpanJsonToTransactionEvent, convertTransactionEventToSpanJson } from './utils/transactionEvent';\n\nconst ALREADY_SEEN_ERROR = \"Not capturing exception because it's already been captured.\";\nconst MISSING_RELEASE_FOR_SESSION_ERROR = 'Discarded session because of missing or non-string release';\n\nconst INTERNAL_ERROR_SYMBOL = Symbol.for('SentryInternalError');\nconst DO_NOT_SEND_EVENT_SYMBOL = Symbol.for('SentryDoNotSendEventError');\n\ninterface InternalError {\n  message: string;\n  [INTERNAL_ERROR_SYMBOL]: true;\n}\n\ninterface DoNotSendEventError {\n  message: string;\n  [DO_NOT_SEND_EVENT_SYMBOL]: true;\n}\n\nfunction _makeInternalError(message: string): InternalError {\n  return {\n    message,\n    [INTERNAL_ERROR_SYMBOL]: true,\n  };\n}\n\nfunction _makeDoNotSendEventError(message: string): DoNotSendEventError {\n  return {\n    message,\n    [DO_NOT_SEND_EVENT_SYMBOL]: true,\n  };\n}\n\nfunction _isInternalError(error: unknown): error is InternalError {\n  return !!error && typeof error === 'object' && INTERNAL_ERROR_SYMBOL in error;\n}\n\nfunction _isDoNotSendEventError(error: unknown): error is DoNotSendEventError {\n  return !!error && typeof error === 'object' && DO_NOT_SEND_EVENT_SYMBOL in error;\n}\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event, it is passed through\n * {@link Client._prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends Client<NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(options);\n *   }\n *\n *   // ...\n * }\n */\nexport abstract class Client<O extends ClientOptions = ClientOptions> {\n  /** Options passed to the SDK. */\n  protected readonly _options: O;\n\n  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n  protected readonly _dsn?: DsnComponents;\n\n  protected readonly _transport?: Transport;\n\n  /** Array of set up integrations. */\n  protected _integrations: IntegrationIndex;\n\n  /** Number of calls being processed */\n  protected _numProcessing: number;\n\n  protected _eventProcessors: EventProcessor[];\n\n  /** Holds flushable  */\n  private _outcomes: { [key: string]: number };\n\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  private _hooks: Record<string, Function[]>;\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param options Options for the client.\n   */\n  protected constructor(options: O) {\n    this._options = options;\n    this._integrations = {};\n    this._numProcessing = 0;\n    this._outcomes = {};\n    this._hooks = {};\n    this._eventProcessors = [];\n\n    if (options.dsn) {\n      this._dsn = makeDsn(options.dsn);\n    } else {\n      DEBUG_BUILD && debug.warn('No DSN provided, client will not send events.');\n    }\n\n    if (this._dsn) {\n      const url = getEnvelopeEndpointWithUrlEncodedAuth(\n        this._dsn,\n        options.tunnel,\n        options._metadata ? options._metadata.sdk : undefined,\n      );\n      this._transport = options.transport({\n        tunnel: this._options.tunnel,\n        recordDroppedEvent: this.recordDroppedEvent.bind(this),\n        ...options.transportOptions,\n        url,\n      });\n    }\n  }\n\n  /**\n   * Captures an exception event and sends it to Sentry.\n   *\n   * Unlike `captureException` exported from every SDK, this method requires that you pass it the current scope.\n   */\n  public captureException(exception: unknown, hint?: EventHint, scope?: Scope): string {\n    const eventId = uuid4();\n\n    // ensure we haven't captured this very object before\n    if (checkOrSetAlreadyCaught(exception)) {\n      DEBUG_BUILD && debug.log(ALREADY_SEEN_ERROR);\n      return eventId;\n    }\n\n    const hintWithEventId = {\n      event_id: eventId,\n      ...hint,\n    };\n\n    this._process(\n      this.eventFromException(exception, hintWithEventId).then(event =>\n        this._captureEvent(event, hintWithEventId, scope),\n      ),\n    );\n\n    return hintWithEventId.event_id;\n  }\n\n  /**\n   * Captures a message event and sends it to Sentry.\n   *\n   * Unlike `captureMessage` exported from every SDK, this method requires that you pass it the current scope.\n   */\n  public captureMessage(\n    message: ParameterizedString,\n    level?: SeverityLevel,\n    hint?: EventHint,\n    currentScope?: Scope,\n  ): string {\n    const hintWithEventId = {\n      event_id: uuid4(),\n      ...hint,\n    };\n\n    const eventMessage = isParameterizedString(message) ? message : String(message);\n\n    const promisedEvent = isPrimitive(message)\n      ? this.eventFromMessage(eventMessage, level, hintWithEventId)\n      : this.eventFromException(message, hintWithEventId);\n\n    this._process(promisedEvent.then(event => this._captureEvent(event, hintWithEventId, currentScope)));\n\n    return hintWithEventId.event_id;\n  }\n\n  /**\n   * Captures a manually created event and sends it to Sentry.\n   *\n   * Unlike `captureEvent` exported from every SDK, this method requires that you pass it the current scope.\n   */\n  public captureEvent(event: Event, hint?: EventHint, currentScope?: Scope): string {\n    const eventId = uuid4();\n\n    // ensure we haven't captured this very object before\n    if (hint?.originalException && checkOrSetAlreadyCaught(hint.originalException)) {\n      DEBUG_BUILD && debug.log(ALREADY_SEEN_ERROR);\n      return eventId;\n    }\n\n    const hintWithEventId = {\n      event_id: eventId,\n      ...hint,\n    };\n\n    const sdkProcessingMetadata = event.sdkProcessingMetadata || {};\n    const capturedSpanScope: Scope | undefined = sdkProcessingMetadata.capturedSpanScope;\n    const capturedSpanIsolationScope: Scope | undefined = sdkProcessingMetadata.capturedSpanIsolationScope;\n\n    this._process(\n      this._captureEvent(event, hintWithEventId, capturedSpanScope || currentScope, capturedSpanIsolationScope),\n    );\n\n    return hintWithEventId.event_id;\n  }\n\n  /**\n   * Captures a session.\n   */\n  public captureSession(session: Session): void {\n    this.sendSession(session);\n    // After sending, we set init false to indicate it's not the first occurrence\n    updateSession(session, { init: false });\n  }\n\n  /**\n   * Create a cron monitor check in and send it to Sentry. This method is not available on all clients.\n   *\n   * @param checkIn An object that describes a check in.\n   * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n   * to create a monitor automatically when sending a check in.\n   * @param scope An optional scope containing event metadata.\n   * @returns A string representing the id of the check in.\n   */\n  public captureCheckIn?(checkIn: CheckIn, monitorConfig?: MonitorConfig, scope?: Scope): string;\n\n  /**\n   * Get the current Dsn.\n   */\n  public getDsn(): DsnComponents | undefined {\n    return this._dsn;\n  }\n\n  /**\n   * Get the current options.\n   */\n  public getOptions(): O {\n    return this._options;\n  }\n\n  /**\n   * Get the SDK metadata.\n   * @see SdkMetadata\n   */\n  public getSdkMetadata(): SdkMetadata | undefined {\n    return this._options._metadata;\n  }\n\n  /**\n   * Returns the transport that is used by the client.\n   * Please note that the transport gets lazy initialized so it will only be there once the first event has been sent.\n   */\n  public getTransport(): Transport | undefined {\n    return this._transport;\n  }\n\n  /**\n   * Wait for all events to be sent or the timeout to expire, whichever comes first.\n   *\n   * @param timeout Maximum time in ms the client should wait for events to be flushed. Omitting this parameter will\n   *   cause the client to wait until all events are sent before resolving the promise.\n   * @returns A promise that will resolve with `true` if all events are sent before the timeout, or `false` if there are\n   * still events in the queue when the timeout is reached.\n   */\n  public flush(timeout?: number): PromiseLike<boolean> {\n    const transport = this._transport;\n    if (transport) {\n      this.emit('flush');\n      return this._isClientDoneProcessing(timeout).then(clientFinished => {\n        return transport.flush(timeout).then(transportFlushed => clientFinished && transportFlushed);\n      });\n    } else {\n      return resolvedSyncPromise(true);\n    }\n  }\n\n  /**\n   * Flush the event queue and set the client to `enabled = false`. See {@link Client.flush}.\n   *\n   * @param {number} timeout Maximum time in ms the client should wait before shutting down. Omitting this parameter will cause\n   *   the client to wait until all events are sent before disabling itself.\n   * @returns {Promise<boolean>} A promise which resolves to `true` if the flush completes successfully before the timeout, or `false` if\n   * it doesn't.\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    return this.flush(timeout).then(result => {\n      this.getOptions().enabled = false;\n      this.emit('close');\n      return result;\n    });\n  }\n\n  /**\n   * Get all installed event processors.\n   */\n  public getEventProcessors(): EventProcessor[] {\n    return this._eventProcessors;\n  }\n\n  /**\n   * Adds an event processor that applies to any event processed by this client.\n   */\n  public addEventProcessor(eventProcessor: EventProcessor): void {\n    this._eventProcessors.push(eventProcessor);\n  }\n\n  /**\n   * Initialize this client.\n   * Call this after the client was set on a scope.\n   */\n  public init(): void {\n    if (\n      this._isEnabled() ||\n      // Force integrations to be setup even if no DSN was set when we have\n      // Spotlight enabled. This is particularly important for browser as we\n      // don't support the `spotlight` option there and rely on the users\n      // adding the `spotlightBrowserIntegration()` to their integrations which\n      // wouldn't get initialized with the check below when there's no DSN set.\n      this._options.integrations.some(({ name }) => name.startsWith('Spotlight'))\n    ) {\n      this._setupIntegrations();\n    }\n  }\n\n  /**\n   * Gets an installed integration by its name.\n   *\n   * @returns {Integration|undefined} The installed integration or `undefined` if no integration with that `name` was installed.\n   */\n  public getIntegrationByName<T extends Integration = Integration>(integrationName: string): T | undefined {\n    return this._integrations[integrationName] as T | undefined;\n  }\n\n  /**\n   * Add an integration to the client.\n   * This can be used to e.g. lazy load integrations.\n   * In most cases, this should not be necessary,\n   * and you're better off just passing the integrations via `integrations: []` at initialization time.\n   * However, if you find the need to conditionally load & add an integration, you can use `addIntegration` to do so.\n   */\n  public addIntegration(integration: Integration): void {\n    const isAlreadyInstalled = this._integrations[integration.name];\n\n    // This hook takes care of only installing if not already installed\n    setupIntegration(this, integration, this._integrations);\n    // Here we need to check manually to make sure to not run this multiple times\n    if (!isAlreadyInstalled) {\n      afterSetupIntegrations(this, [integration]);\n    }\n  }\n\n  /**\n   * Send a fully prepared event to Sentry.\n   */\n  public sendEvent(event: Event, hint: EventHint = {}): void {\n    this.emit('beforeSendEvent', event, hint);\n\n    let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);\n\n    for (const attachment of hint.attachments || []) {\n      env = addItemToEnvelope(env, createAttachmentEnvelopeItem(attachment));\n    }\n\n    const promise = this.sendEnvelope(env);\n    if (promise) {\n      promise.then(sendResponse => this.emit('afterSendEvent', event, sendResponse), null);\n    }\n  }\n\n  /**\n   * Send a session or session aggregrates to Sentry.\n   */\n  public sendSession(session: Session | SessionAggregates): void {\n    // Backfill release and environment on session\n    const { release: clientReleaseOption, environment: clientEnvironmentOption = DEFAULT_ENVIRONMENT } = this._options;\n    if ('aggregates' in session) {\n      const sessionAttrs = session.attrs || {};\n      if (!sessionAttrs.release && !clientReleaseOption) {\n        DEBUG_BUILD && debug.warn(MISSING_RELEASE_FOR_SESSION_ERROR);\n        return;\n      }\n      sessionAttrs.release = sessionAttrs.release || clientReleaseOption;\n      sessionAttrs.environment = sessionAttrs.environment || clientEnvironmentOption;\n      session.attrs = sessionAttrs;\n    } else {\n      if (!session.release && !clientReleaseOption) {\n        DEBUG_BUILD && debug.warn(MISSING_RELEASE_FOR_SESSION_ERROR);\n        return;\n      }\n      session.release = session.release || clientReleaseOption;\n      session.environment = session.environment || clientEnvironmentOption;\n    }\n\n    this.emit('beforeSendSession', session);\n\n    const env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);\n\n    // sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.sendEnvelope(env);\n  }\n\n  /**\n   * Record on the client that an event got dropped (ie, an event that will not be sent to Sentry).\n   */\n  public recordDroppedEvent(reason: EventDropReason, category: DataCategory, count: number = 1): void {\n    if (this._options.sendClientReports) {\n      // We want to track each category (error, transaction, session, replay_event) separately\n      // but still keep the distinction between different type of outcomes.\n      // We could use nested maps, but it's much easier to read and type this way.\n      // A correct type for map-based implementation if we want to go that route\n      // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n      // With typescript 4.1 we could even use template literal types\n      const key = `${reason}:${category}`;\n      DEBUG_BUILD && debug.log(`Recording outcome: \"${key}\"${count > 1 ? ` (${count} times)` : ''}`);\n      this._outcomes[key] = (this._outcomes[key] || 0) + count;\n    }\n  }\n\n  /* eslint-disable @typescript-eslint/unified-signatures */\n  /**\n   * Register a callback for whenever a span is started.\n   * Receives the span as argument.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'spanStart', callback: (span: Span) => void): () => void;\n\n  /**\n   * Register a callback before span sampling runs. Receives a `samplingDecision` object argument with a `decision`\n   * property that can be used to make a sampling decision that will be enforced, before any span sampling runs.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(\n    hook: 'beforeSampling',\n    callback: (\n      samplingData: {\n        spanAttributes: SpanAttributes;\n        spanName: string;\n        parentSampled?: boolean;\n        parentSampleRate?: number;\n        parentContext?: SpanContextData;\n      },\n      samplingDecision: { decision: boolean },\n    ) => void,\n  ): void;\n\n  /**\n   * Register a callback for after a span is ended.\n   * NOTE: The span cannot be mutated anymore in this callback.\n   * Receives the span as argument.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'spanEnd', callback: (span: Span) => void): () => void;\n\n  /**\n   * Register a callback for when an idle span is allowed to auto-finish.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'idleSpanEnableAutoFinish', callback: (span: Span) => void): () => void;\n\n  /**\n   * Register a callback for transaction start and finish.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'beforeEnvelope', callback: (envelope: Envelope) => void): () => void;\n\n  /**\n   * Register a callback that runs when stack frame metadata should be applied to an event.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'applyFrameMetadata', callback: (event: Event) => void): () => void;\n\n  /**\n   * Register a callback for before sending an event.\n   * This is called right before an event is sent and should not be used to mutate the event.\n   * Receives an Event & EventHint as arguments.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'beforeSendEvent', callback: (event: Event, hint?: EventHint | undefined) => void): () => void;\n\n  /**\n   * Register a callback for before sending a session or session aggregrates..\n   * Receives the session/aggregate as second argument.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'beforeSendSession', callback: (session: Session | SessionAggregates) => void): () => void;\n\n  /**\n   * Register a callback for preprocessing an event,\n   * before it is passed to (global) event processors.\n   * Receives an Event & EventHint as arguments.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'preprocessEvent', callback: (event: Event, hint?: EventHint | undefined) => void): () => void;\n\n  /**\n   * Register a callback for postprocessing an event,\n   * after it was passed to (global) event processors, before it is being sent.\n   * Receives an Event & EventHint as arguments.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'postprocessEvent', callback: (event: Event, hint?: EventHint | undefined) => void): () => void;\n\n  /**\n   * Register a callback for when an event has been sent.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(\n    hook: 'afterSendEvent',\n    callback: (event: Event, sendResponse: TransportMakeRequestResponse) => void,\n  ): () => void;\n\n  /**\n   * Register a callback before a breadcrumb is added.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'beforeAddBreadcrumb', callback: (breadcrumb: Breadcrumb, hint?: BreadcrumbHint) => void): () => void;\n\n  /**\n   * Register a callback when a DSC (Dynamic Sampling Context) is created.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'createDsc', callback: (dsc: DynamicSamplingContext, rootSpan?: Span) => void): () => void;\n\n  /**\n   * Register a callback when a Feedback event has been prepared.\n   * This should be used to mutate the event. The options argument can hint\n   * about what kind of mutation it expects.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(\n    hook: 'beforeSendFeedback',\n    callback: (feedback: FeedbackEvent, options?: { includeReplay?: boolean }) => void,\n  ): () => void;\n\n  /**\n   * Register a callback when the feedback widget is opened in a user's browser\n   */\n  public on(hook: 'openFeedbackWidget', callback: () => void): () => void;\n\n  /**\n   * A hook for the browser tracing integrations to trigger a span start for a page load.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(\n    hook: 'startPageLoadSpan',\n    callback: (\n      options: StartSpanOptions,\n      traceOptions?: { sentryTrace?: string | undefined; baggage?: string | undefined },\n    ) => void,\n  ): () => void;\n\n  /**\n   * A hook for the browser tracing integrations to trigger after the pageload span was started.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'afterStartPageLoadSpan', callback: (span: Span) => void): () => void;\n\n  /**\n   * A hook for triggering right before a navigation span is started.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(\n    hook: 'beforeStartNavigationSpan',\n    callback: (options: StartSpanOptions, navigationOptions?: { isRedirect?: boolean }) => void,\n  ): () => void;\n\n  /**\n   * A hook for browser tracing integrations to trigger a span for a navigation.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(\n    hook: 'startNavigationSpan',\n    callback: (options: StartSpanOptions, navigationOptions?: { isRedirect?: boolean }) => void,\n  ): () => void;\n\n  /**\n   * A hook for GraphQL client integration to enhance a span with request data.\n   * @returns A function that, when executed, removes the registered callback.\n   */\n  public on(\n    hook: 'beforeOutgoingRequestSpan',\n    callback: (span: Span, hint: XhrBreadcrumbHint | FetchBreadcrumbHint) => void,\n  ): () => void;\n\n  /**\n   * A hook for GraphQL client integration to enhance a breadcrumb with request data.\n   * @returns A function that, when executed, removes the registered callback.\n   */\n  public on(\n    hook: 'beforeOutgoingRequestBreadcrumb',\n    callback: (breadcrumb: Breadcrumb, hint: XhrBreadcrumbHint | FetchBreadcrumbHint) => void,\n  ): () => void;\n\n  /**\n   * A hook that is called when the client is flushing\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'flush', callback: () => void): () => void;\n\n  /**\n   * A hook that is called when the client is closing\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'close', callback: () => void): () => void;\n\n  /**\n   * A hook that is called before a log is captured. This hooks runs before `beforeSendLog` is fired.\n   *\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'beforeCaptureLog', callback: (log: Log) => void): () => void;\n\n  /**\n   * A hook that is called after a log is captured\n   *\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'afterCaptureLog', callback: (log: Log) => void): () => void;\n\n  /**\n   * A hook that is called when the client is flushing logs\n   *\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'flushLogs', callback: () => void): () => void;\n\n  /**\n   * Register a hook on this client.\n   */\n  public on(hook: string, callback: unknown): () => void {\n    const hooks = (this._hooks[hook] = this._hooks[hook] || []);\n\n    // @ts-expect-error We assume the types are correct\n    hooks.push(callback);\n\n    // This function returns a callback execution handler that, when invoked,\n    // deregisters a callback. This is crucial for managing instances where callbacks\n    // need to be unregistered to prevent self-referencing in callback closures,\n    // ensuring proper garbage collection.\n    return () => {\n      // @ts-expect-error We assume the types are correct\n      const cbIndex = hooks.indexOf(callback);\n      if (cbIndex > -1) {\n        hooks.splice(cbIndex, 1);\n      }\n    };\n  }\n\n  /** Fire a hook whenever a span starts. */\n  public emit(hook: 'spanStart', span: Span): void;\n\n  /** A hook that is called every time before a span is sampled. */\n  public emit(\n    hook: 'beforeSampling',\n    samplingData: {\n      spanAttributes: SpanAttributes;\n      spanName: string;\n      parentSampled?: boolean;\n      parentSampleRate?: number;\n      parentContext?: SpanContextData;\n    },\n    samplingDecision: { decision: boolean },\n  ): void;\n\n  /** Fire a hook whenever a span ends. */\n  public emit(hook: 'spanEnd', span: Span): void;\n\n  /**\n   * Fire a hook indicating that an idle span is allowed to auto finish.\n   */\n  public emit(hook: 'idleSpanEnableAutoFinish', span: Span): void;\n\n  /*\n   * Fire a hook event for envelope creation and sending. Expects to be given an envelope as the\n   * second argument.\n   */\n  public emit(hook: 'beforeEnvelope', envelope: Envelope): void;\n\n  /*\n   * Fire a hook indicating that stack frame metadata should be applied to the event passed to the hook.\n   */\n  public emit(hook: 'applyFrameMetadata', event: Event): void;\n\n  /**\n   * Fire a hook event before sending an event.\n   * This is called right before an event is sent and should not be used to mutate the event.\n   * Expects to be given an Event & EventHint as the second/third argument.\n   */\n  public emit(hook: 'beforeSendEvent', event: Event, hint?: EventHint): void;\n\n  /**\n   * Fire a hook event before sending a session/aggregates.\n   * Expects to be given the prepared session/aggregates as second argument.\n   */\n  public emit(hook: 'beforeSendSession', session: Session | SessionAggregates): void;\n\n  /**\n   * Fire a hook event to process events before they are passed to (global) event processors.\n   * Expects to be given an Event & EventHint as the second/third argument.\n   */\n  public emit(hook: 'preprocessEvent', event: Event, hint?: EventHint): void;\n\n  /**\n   * Fire a hook event to process a user on an event before it is sent to Sentry, after all other processors have run.\n   * Expects to be given an Event & EventHint as the second/third argument.\n   */\n  public emit(hook: 'postprocessEvent', event: Event, hint?: EventHint): void;\n\n  /*\n   * Fire a hook event after sending an event. Expects to be given an Event as the\n   * second argument.\n   */\n  public emit(hook: 'afterSendEvent', event: Event, sendResponse: TransportMakeRequestResponse): void;\n\n  /**\n   * Fire a hook for when a breadcrumb is added. Expects the breadcrumb as second argument.\n   */\n  public emit(hook: 'beforeAddBreadcrumb', breadcrumb: Breadcrumb, hint?: BreadcrumbHint): void;\n\n  /**\n   * Fire a hook for when a DSC (Dynamic Sampling Context) is created. Expects the DSC as second argument.\n   */\n  public emit(hook: 'createDsc', dsc: DynamicSamplingContext, rootSpan?: Span): void;\n\n  /**\n   * Fire a hook event for after preparing a feedback event. Events to be given\n   * a feedback event as the second argument, and an optional options object as\n   * third argument.\n   */\n  public emit(hook: 'beforeSendFeedback', feedback: FeedbackEvent, options?: { includeReplay?: boolean }): void;\n\n  /**\n   * Fire a hook event for when the feedback widget is opened in a user's browser\n   */\n  public emit(hook: 'openFeedbackWidget'): void;\n\n  /**\n   * Emit a hook event for browser tracing integrations to trigger a span start for a page load.\n   */\n  public emit(\n    hook: 'startPageLoadSpan',\n    options: StartSpanOptions,\n    traceOptions?: { sentryTrace?: string | undefined; baggage?: string | undefined },\n  ): void;\n\n  /**\n   * Emit a hook event for browser tracing integrations to trigger aafter the pageload span was started.\n   */\n  public emit(hook: 'afterStartPageLoadSpan', span: Span): void;\n\n  /**\n   * Emit a hook event for triggering right before a navigation span is started.\n   */\n  public emit(\n    hook: 'beforeStartNavigationSpan',\n    options: StartSpanOptions,\n    navigationOptions?: { isRedirect?: boolean },\n  ): void;\n\n  /**\n   * Emit a hook event for browser tracing integrations to trigger a span for a navigation.\n   */\n  public emit(\n    hook: 'startNavigationSpan',\n    options: StartSpanOptions,\n    navigationOptions?: { isRedirect?: boolean },\n  ): void;\n\n  /**\n   * Emit a hook event for GraphQL client integration to enhance a span with request data.\n   */\n  public emit(hook: 'beforeOutgoingRequestSpan', span: Span, hint: XhrBreadcrumbHint | FetchBreadcrumbHint): void;\n\n  /**\n   * Emit a hook event for GraphQL client integration to enhance a breadcrumb with request data.\n   */\n  public emit(\n    hook: 'beforeOutgoingRequestBreadcrumb',\n    breadcrumb: Breadcrumb,\n    hint: XhrBreadcrumbHint | FetchBreadcrumbHint,\n  ): void;\n\n  /**\n   * Emit a hook event for client flush\n   */\n  public emit(hook: 'flush'): void;\n\n  /**\n   * Emit a hook event for client close\n   */\n  public emit(hook: 'close'): void;\n\n  /**\n   * Emit a hook event for client before capturing a log. This hooks runs before `beforeSendLog` is fired.\n   */\n  public emit(hook: 'beforeCaptureLog', log: Log): void;\n\n  /**\n   * Emit a hook event for client after capturing a log.\n   */\n  public emit(hook: 'afterCaptureLog', log: Log): void;\n\n  /**\n   * Emit a hook event for client flush logs\n   */\n  public emit(hook: 'flushLogs'): void;\n\n  /**\n   * Emit a hook that was previously registered via `on()`.\n   */\n  public emit(hook: string, ...rest: unknown[]): void {\n    const callbacks = this._hooks[hook];\n    if (callbacks) {\n      callbacks.forEach(callback => callback(...rest));\n    }\n  }\n\n  /**\n   * Send an envelope to Sentry.\n   */\n  public sendEnvelope(envelope: Envelope): PromiseLike<TransportMakeRequestResponse> {\n    this.emit('beforeEnvelope', envelope);\n\n    if (this._isEnabled() && this._transport) {\n      return this._transport.send(envelope).then(null, reason => {\n        DEBUG_BUILD && debug.error('Error while sending envelope:', reason);\n        return reason;\n      });\n    }\n\n    DEBUG_BUILD && debug.error('Transport disabled');\n\n    return resolvedSyncPromise({});\n  }\n\n  /* eslint-enable @typescript-eslint/unified-signatures */\n\n  /** Setup integrations for this client. */\n  protected _setupIntegrations(): void {\n    const { integrations } = this._options;\n    this._integrations = setupIntegrations(this, integrations);\n    afterSetupIntegrations(this, integrations);\n  }\n\n  /** Updates existing session based on the provided event */\n  protected _updateSessionFromEvent(session: Session, event: Event): void {\n    let crashed = event.level === 'fatal';\n    let errored = false;\n    const exceptions = event.exception?.values;\n\n    if (exceptions) {\n      errored = true;\n\n      for (const ex of exceptions) {\n        const mechanism = ex.mechanism;\n        if (mechanism?.handled === false) {\n          crashed = true;\n          break;\n        }\n      }\n    }\n\n    // A session is updated and that session update is sent in only one of the two following scenarios:\n    // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update\n    // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update\n    const sessionNonTerminal = session.status === 'ok';\n    const shouldUpdateAndSend = (sessionNonTerminal && session.errors === 0) || (sessionNonTerminal && crashed);\n\n    if (shouldUpdateAndSend) {\n      updateSession(session, {\n        ...(crashed && { status: 'crashed' }),\n        errors: session.errors || Number(errored || crashed),\n      });\n      this.captureSession(session);\n    }\n  }\n\n  /**\n   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying\n   * \"no\" (resolving to `false`) in order to give the client a chance to potentially finish first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not\n   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and\n   * `false` otherwise\n   */\n  protected _isClientDoneProcessing(timeout?: number): PromiseLike<boolean> {\n    return new SyncPromise(resolve => {\n      let ticked: number = 0;\n      const tick: number = 1;\n\n      const interval = setInterval(() => {\n        if (this._numProcessing == 0) {\n          clearInterval(interval);\n          resolve(true);\n        } else {\n          ticked += tick;\n          if (timeout && ticked >= timeout) {\n            clearInterval(interval);\n            resolve(false);\n          }\n        }\n      }, tick);\n    });\n  }\n\n  /** Determines whether this SDK is enabled and a transport is present. */\n  protected _isEnabled(): boolean {\n    return this.getOptions().enabled !== false && this._transport !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional information about the original exception.\n   * @param currentScope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n  protected _prepareEvent(\n    event: Event,\n    hint: EventHint,\n    currentScope: Scope,\n    isolationScope: Scope,\n  ): PromiseLike<Event | null> {\n    const options = this.getOptions();\n    const integrations = Object.keys(this._integrations);\n    if (!hint.integrations && integrations?.length) {\n      hint.integrations = integrations;\n    }\n\n    this.emit('preprocessEvent', event, hint);\n\n    if (!event.type) {\n      isolationScope.setLastEventId(event.event_id || hint.event_id);\n    }\n\n    return prepareEvent(options, event, hint, currentScope, this, isolationScope).then(evt => {\n      if (evt === null) {\n        return evt;\n      }\n\n      this.emit('postprocessEvent', evt, hint);\n\n      evt.contexts = {\n        trace: getTraceContextFromScope(currentScope),\n        ...evt.contexts,\n      };\n\n      const dynamicSamplingContext = getDynamicSamplingContextFromScope(this, currentScope);\n\n      evt.sdkProcessingMetadata = {\n        dynamicSamplingContext,\n        ...evt.sdkProcessingMetadata,\n      };\n\n      return evt;\n    });\n  }\n\n  /**\n   * Processes the event and logs an error in case of rejection\n   * @param event\n   * @param hint\n   * @param scope\n   */\n  protected _captureEvent(\n    event: Event,\n    hint: EventHint = {},\n    currentScope = getCurrentScope(),\n    isolationScope = getIsolationScope(),\n  ): PromiseLike<string | undefined> {\n    if (DEBUG_BUILD && isErrorEvent(event)) {\n      debug.log(`Captured error event \\`${getPossibleEventMessages(event)[0] || '<unknown>'}\\``);\n    }\n\n    return this._processEvent(event, hint, currentScope, isolationScope).then(\n      finalEvent => {\n        return finalEvent.event_id;\n      },\n      reason => {\n        if (DEBUG_BUILD) {\n          if (_isDoNotSendEventError(reason)) {\n            debug.log(reason.message);\n          } else if (_isInternalError(reason)) {\n            debug.warn(reason.message);\n          } else {\n            debug.warn(reason);\n          }\n        }\n        return undefined;\n      },\n    );\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param currentScope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n  protected _processEvent(\n    event: Event,\n    hint: EventHint,\n    currentScope: Scope,\n    isolationScope: Scope,\n  ): PromiseLike<Event> {\n    const options = this.getOptions();\n    const { sampleRate } = options;\n\n    const isTransaction = isTransactionEvent(event);\n    const isError = isErrorEvent(event);\n    const eventType = event.type || 'error';\n    const beforeSendLabel = `before send for type \\`${eventType}\\``;\n\n    // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    // Sampling for transaction happens somewhere else\n    const parsedSampleRate = typeof sampleRate === 'undefined' ? undefined : parseSampleRate(sampleRate);\n    if (isError && typeof parsedSampleRate === 'number' && Math.random() > parsedSampleRate) {\n      this.recordDroppedEvent('sample_rate', 'error');\n      return rejectedSyncPromise(\n        _makeDoNotSendEventError(\n          `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,\n        ),\n      );\n    }\n\n    const dataCategory = (eventType === 'replay_event' ? 'replay' : eventType) satisfies DataCategory;\n\n    return this._prepareEvent(event, hint, currentScope, isolationScope)\n      .then(prepared => {\n        if (prepared === null) {\n          this.recordDroppedEvent('event_processor', dataCategory);\n          throw _makeDoNotSendEventError('An event processor returned `null`, will not send event.');\n        }\n\n        const isInternalException = hint.data && (hint.data as { __sentry__: boolean }).__sentry__ === true;\n        if (isInternalException) {\n          return prepared;\n        }\n\n        const result = processBeforeSend(this, options, prepared, hint);\n        return _validateBeforeSendResult(result, beforeSendLabel);\n      })\n      .then(processedEvent => {\n        if (processedEvent === null) {\n          this.recordDroppedEvent('before_send', dataCategory);\n          if (isTransaction) {\n            const spans = event.spans || [];\n            // the transaction itself counts as one span, plus all the child spans that are added\n            const spanCount = 1 + spans.length;\n            this.recordDroppedEvent('before_send', 'span', spanCount);\n          }\n          throw _makeDoNotSendEventError(`${beforeSendLabel} returned \\`null\\`, will not send event.`);\n        }\n\n        const session = currentScope.getSession() || isolationScope.getSession();\n        if (isError && session) {\n          this._updateSessionFromEvent(session, processedEvent);\n        }\n\n        if (isTransaction) {\n          const spanCountBefore = processedEvent.sdkProcessingMetadata?.spanCountBeforeProcessing || 0;\n          const spanCountAfter = processedEvent.spans ? processedEvent.spans.length : 0;\n\n          const droppedSpanCount = spanCountBefore - spanCountAfter;\n          if (droppedSpanCount > 0) {\n            this.recordDroppedEvent('before_send', 'span', droppedSpanCount);\n          }\n        }\n\n        // None of the Sentry built event processor will update transaction name,\n        // so if the transaction name has been changed by an event processor, we know\n        // it has to come from custom event processor added by a user\n        const transactionInfo = processedEvent.transaction_info;\n        if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {\n          const source = 'custom';\n          processedEvent.transaction_info = {\n            ...transactionInfo,\n            source,\n          };\n        }\n\n        this.sendEvent(processedEvent, hint);\n        return processedEvent;\n      })\n      .then(null, reason => {\n        if (_isDoNotSendEventError(reason) || _isInternalError(reason)) {\n          throw reason;\n        }\n\n        this.captureException(reason, {\n          data: {\n            __sentry__: true,\n          },\n          originalException: reason,\n        });\n        throw _makeInternalError(\n          `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: ${reason}`,\n        );\n      });\n  }\n\n  /**\n   * Occupies the client with processing and event\n   */\n  protected _process<T>(promise: PromiseLike<T>): void {\n    this._numProcessing++;\n    void promise.then(\n      value => {\n        this._numProcessing--;\n        return value;\n      },\n      reason => {\n        this._numProcessing--;\n        return reason;\n      },\n    );\n  }\n\n  /**\n   * Clears outcomes on this client and returns them.\n   */\n  protected _clearOutcomes(): Outcome[] {\n    const outcomes = this._outcomes;\n    this._outcomes = {};\n    return Object.entries(outcomes).map(([key, quantity]) => {\n      const [reason, category] = key.split(':') as [EventDropReason, DataCategory];\n      return {\n        reason,\n        category,\n        quantity,\n      };\n    });\n  }\n\n  /**\n   * Sends client reports as an envelope.\n   */\n  protected _flushOutcomes(): void {\n    DEBUG_BUILD && debug.log('Flushing outcomes...');\n\n    const outcomes = this._clearOutcomes();\n\n    if (outcomes.length === 0) {\n      DEBUG_BUILD && debug.log('No outcomes to send');\n      return;\n    }\n\n    // This is really the only place where we want to check for a DSN and only send outcomes then\n    if (!this._dsn) {\n      DEBUG_BUILD && debug.log('No dsn provided, will not send outcomes');\n      return;\n    }\n\n    DEBUG_BUILD && debug.log('Sending outcomes:', outcomes);\n\n    const envelope = createClientReportEnvelope(outcomes, this._options.tunnel && dsnToString(this._dsn));\n\n    // sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.sendEnvelope(envelope);\n  }\n\n  /**\n   * Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`.\n   */\n  public abstract eventFromException(_exception: unknown, _hint?: EventHint): PromiseLike<Event>;\n\n  /**\n   * Creates an {@link Event} from primitive inputs to `captureMessage`.\n   */\n  public abstract eventFromMessage(\n    _message: ParameterizedString,\n    _level?: SeverityLevel,\n    _hint?: EventHint,\n  ): PromiseLike<Event>;\n}\n\n/**\n * @deprecated Use `Client` instead. This alias may be removed in a future major version.\n */\n// TODO(v10): Remove\nexport type BaseClient = Client;\n\n/**\n * @deprecated Use `Client` instead. This alias may be removed in a future major version.\n */\n// TODO(v10): Remove\nexport const BaseClient = Client;\n\n/**\n * Verifies that return value of configured `beforeSend` or `beforeSendTransaction` is of expected type, and returns the value if so.\n */\nfunction _validateBeforeSendResult(\n  beforeSendResult: PromiseLike<Event | null> | Event | null,\n  beforeSendLabel: string,\n): PromiseLike<Event | null> | Event | null {\n  const invalidValueError = `${beforeSendLabel} must return \\`null\\` or a valid event.`;\n  if (isThenable(beforeSendResult)) {\n    return beforeSendResult.then(\n      event => {\n        if (!isPlainObject(event) && event !== null) {\n          throw _makeInternalError(invalidValueError);\n        }\n        return event;\n      },\n      e => {\n        throw _makeInternalError(`${beforeSendLabel} rejected with ${e}`);\n      },\n    );\n  } else if (!isPlainObject(beforeSendResult) && beforeSendResult !== null) {\n    throw _makeInternalError(invalidValueError);\n  }\n  return beforeSendResult;\n}\n\n/**\n * Process the matching `beforeSendXXX` callback.\n */\nfunction processBeforeSend(\n  client: Client,\n  options: ClientOptions,\n  event: Event,\n  hint: EventHint,\n): PromiseLike<Event | null> | Event | null {\n  const { beforeSend, beforeSendTransaction, beforeSendSpan } = options;\n  let processedEvent = event;\n\n  if (isErrorEvent(processedEvent) && beforeSend) {\n    return beforeSend(processedEvent, hint);\n  }\n\n  if (isTransactionEvent(processedEvent)) {\n    if (beforeSendSpan) {\n      // process root span\n      const processedRootSpanJson = beforeSendSpan(convertTransactionEventToSpanJson(processedEvent));\n      if (!processedRootSpanJson) {\n        showSpanDropWarning();\n      } else {\n        // update event with processed root span values\n        processedEvent = merge(event, convertSpanJsonToTransactionEvent(processedRootSpanJson));\n      }\n\n      // process child spans\n      if (processedEvent.spans) {\n        const processedSpans: SpanJSON[] = [];\n        for (const span of processedEvent.spans) {\n          const processedSpan = beforeSendSpan(span);\n          if (!processedSpan) {\n            showSpanDropWarning();\n            processedSpans.push(span);\n          } else {\n            processedSpans.push(processedSpan);\n          }\n        }\n        processedEvent.spans = processedSpans;\n      }\n    }\n\n    if (beforeSendTransaction) {\n      if (processedEvent.spans) {\n        // We store the # of spans before processing in SDK metadata,\n        // so we can compare it afterwards to determine how many spans were dropped\n        const spanCountBefore = processedEvent.spans.length;\n        processedEvent.sdkProcessingMetadata = {\n          ...event.sdkProcessingMetadata,\n          spanCountBeforeProcessing: spanCountBefore,\n        };\n      }\n      return beforeSendTransaction(processedEvent as TransactionEvent, hint);\n    }\n  }\n\n  return processedEvent;\n}\n\nfunction isErrorEvent(event: Event): event is ErrorEvent {\n  return event.type === undefined;\n}\n\nfunction isTransactionEvent(event: Event): event is TransactionEvent {\n  return event.type === 'transaction';\n}\n\n/** Extract trace information from scope */\nexport function _getTraceInfoFromScope(\n  client: Client,\n  scope: Scope | undefined,\n): [dynamicSamplingContext: Partial<DynamicSamplingContext> | undefined, traceContext: TraceContext | undefined] {\n  if (!scope) {\n    return [undefined, undefined];\n  }\n\n  return withScope(scope, () => {\n    const span = getActiveSpan();\n    const traceContext = span ? spanToTraceContext(span) : getTraceContextFromScope(scope);\n    const dynamicSamplingContext = span\n      ? getDynamicSamplingContextFromSpan(span)\n      : getDynamicSamplingContextFromScope(client, scope);\n    return [dynamicSamplingContext, traceContext];\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}