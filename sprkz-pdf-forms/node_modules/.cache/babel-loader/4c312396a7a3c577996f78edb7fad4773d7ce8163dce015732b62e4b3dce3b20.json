{"ast":null,"code":"var _UnleashService;\nimport { UnleashClient } from '@unleash/proxy-client-react';\n\n// Unleash configuration\n\n// Default configuration\nconst DEFAULT_CONFIG = {\n  url: process.env.REACT_APP_UNLEASH_PROXY_URL || '',\n  clientKey: process.env.REACT_APP_UNLEASH_CLIENT_KEY || '',\n  refreshInterval: 15,\n  // seconds\n  appName: 'sprkz-pdf-forms',\n  environment: process.env.NODE_ENV || 'development'\n};\n\n// Feature flag definitions with types\n\n// Default feature flag values (fallbacks when Unleash is unavailable)\nexport const DEFAULT_FEATURE_FLAGS = {\n  // Core features - enabled by default for MVP\n  ENHANCED_WIZARD_MODE: true,\n  PROGRESSIVE_FORM_FILLING: true,\n  SMART_FIELD_DETECTION: true,\n  // Signature features - all enabled\n  SIGNATURE_DRAWING_MODE: true,\n  SIGNATURE_TYPED_MODE: true,\n  SIGNATURE_UPLOAD_MODE: false,\n  // Not yet implemented\n  MULTI_SIGNATURE_SUPPORT: true,\n  // PDF processing - basic features enabled\n  ADVANCED_PDF_VALIDATION: true,\n  PDF_FIELD_AUTOCOMPLETE: false,\n  // Future feature\n  PDF_PREVIEW_MODE: true,\n  BULK_PDF_PROCESSING: false,\n  // Future feature\n\n  // UI/UX features\n  DARK_MODE_SUPPORT: false,\n  // Future feature\n  ACCESSIBILITY_ENHANCEMENTS: true,\n  MOBILE_OPTIMIZATIONS: true,\n  ANIMATION_EFFECTS: true,\n  // Performance features\n  PDF_LAZY_LOADING: true,\n  FORM_STATE_PERSISTENCE: true,\n  OFFLINE_MODE_SUPPORT: false,\n  // Future feature\n\n  // Validation and security\n  ENHANCED_FIELD_VALIDATION: true,\n  SECURITY_AUDIT_LOGGING: false,\n  // Production only\n  DATA_ENCRYPTION: false,\n  // Future feature\n\n  // Analytics and monitoring\n  USAGE_ANALYTICS: process.env.NODE_ENV === 'production',\n  ERROR_REPORTING: true,\n  // Sentry integration\n  PERFORMANCE_MONITORING: true\n};\n\n// Feature flag categories for organization\nexport const FEATURE_CATEGORIES = {\n  CORE: ['ENHANCED_WIZARD_MODE', 'PROGRESSIVE_FORM_FILLING', 'SMART_FIELD_DETECTION'],\n  SIGNATURE: ['SIGNATURE_DRAWING_MODE', 'SIGNATURE_TYPED_MODE', 'SIGNATURE_UPLOAD_MODE', 'MULTI_SIGNATURE_SUPPORT'],\n  PDF: ['ADVANCED_PDF_VALIDATION', 'PDF_FIELD_AUTOCOMPLETE', 'PDF_PREVIEW_MODE', 'BULK_PDF_PROCESSING'],\n  UI_UX: ['DARK_MODE_SUPPORT', 'ACCESSIBILITY_ENHANCEMENTS', 'MOBILE_OPTIMIZATIONS', 'ANIMATION_EFFECTS'],\n  PERFORMANCE: ['PDF_LAZY_LOADING', 'FORM_STATE_PERSISTENCE', 'OFFLINE_MODE_SUPPORT'],\n  SECURITY: ['ENHANCED_FIELD_VALIDATION', 'SECURITY_AUDIT_LOGGING', 'DATA_ENCRYPTION'],\n  MONITORING: ['USAGE_ANALYTICS', 'ERROR_REPORTING', 'PERFORMANCE_MONITORING']\n};\n\n// Unleash service class\nexport class UnleashService {\n  constructor(config) {\n    this.client = null;\n    this.config = void 0;\n    this.isInitialized = false;\n    this.listeners = new Set();\n    this.config = {\n      ...DEFAULT_CONFIG,\n      ...config\n    };\n  }\n  static getInstance(config) {\n    if (!UnleashService.instance) {\n      UnleashService.instance = new UnleashService(config);\n    }\n    return UnleashService.instance;\n  }\n\n  // Initialize the Unleash client\n  async initialize(context) {\n    if (this.isInitialized) {\n      return;\n    }\n\n    // Skip initialization if no URL or client key is provided\n    if (!this.config.url || !this.config.clientKey) {\n      console.log('Unleash not configured - using fallback flags');\n      this.isInitialized = true;\n      this.notifyListeners();\n      return;\n    }\n    try {\n      // Create Unleash client\n      this.client = new UnleashClient({\n        url: this.config.url,\n        clientKey: this.config.clientKey,\n        refreshInterval: this.config.refreshInterval,\n        appName: this.config.appName,\n        environment: this.config.environment,\n        context: {\n          userId: this.config.userId || this.generateUserId(),\n          sessionId: this.config.sessionId || this.generateSessionId(),\n          ...context\n        }\n      });\n\n      // Start the client\n      this.client.start();\n\n      // Wait for initial fetch\n      await this.client.on('ready', () => {\n        console.log('Unleash client initialized successfully');\n        this.isInitialized = true;\n        this.notifyListeners();\n      });\n\n      // Handle errors\n      this.client.on('error', error => {\n        console.error('Unleash client error:', error);\n        // Continue with default flags on error\n        this.isInitialized = true;\n      });\n\n      // Handle updates\n      this.client.on('update', () => {\n        console.log('Feature flags updated');\n        this.notifyListeners();\n      });\n    } catch (error) {\n      console.error('Failed to initialize Unleash:', error);\n      // Continue with default flags\n      this.isInitialized = true;\n    }\n  }\n\n  // Check if a feature flag is enabled\n  isEnabled(flagName, context) {\n    if (!this.client || !this.isInitialized) {\n      return DEFAULT_FEATURE_FLAGS[flagName];\n    }\n    try {\n      return this.client.isEnabled(flagName, context);\n    } catch (error) {\n      console.warn(`Failed to check feature flag ${flagName}:`, error);\n      return DEFAULT_FEATURE_FLAGS[flagName];\n    }\n  }\n\n  // Get variant for a feature flag\n  getVariant(flagName, context) {\n    if (!this.client || !this.isInitialized) {\n      return null;\n    }\n    try {\n      return this.client.getVariant(flagName, context);\n    } catch (error) {\n      console.warn(`Failed to get variant for ${flagName}:`, error);\n      return null;\n    }\n  }\n\n  // Get all feature flags as an object\n  getAllFlags(context) {\n    const flags = {};\n    for (const flagName of Object.keys(DEFAULT_FEATURE_FLAGS)) {\n      flags[flagName] = this.isEnabled(flagName, context);\n    }\n    return flags;\n  }\n\n  // Subscribe to flag changes\n  subscribe(listener) {\n    this.listeners.add(listener);\n\n    // Return unsubscribe function\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  // Update context (useful for user-specific flags)\n  updateContext(context) {\n    if (this.client) {\n      this.client.updateContext(context);\n    }\n  }\n\n  // Get feature flags by category\n  getFlagsByCategory(category, context) {\n    const categoryFlags = FEATURE_CATEGORIES[category];\n    const flags = {};\n    for (const flagName of categoryFlags) {\n      flags[flagName] = this.isEnabled(flagName, context);\n    }\n    return flags;\n  }\n\n  // Utility methods for debugging\n  getStatus() {\n    return {\n      initialized: this.isInitialized,\n      clientReady: !!this.client,\n      flagCount: Object.keys(DEFAULT_FEATURE_FLAGS).length\n    };\n  }\n\n  // Generate unique user ID for session\n  generateUserId() {\n    return `user-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  // Generate session ID\n  generateSessionId() {\n    return `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  // Notify all listeners of changes\n  notifyListeners() {\n    this.listeners.forEach(listener => {\n      try {\n        listener();\n      } catch (error) {\n        console.error('Error in feature flag listener:', error);\n      }\n    });\n  }\n\n  // Clean up resources\n  destroy() {\n    if (this.client) {\n      this.client.stop();\n      this.client = null;\n    }\n    this.listeners.clear();\n    this.isInitialized = false;\n  }\n}\n\n// Singleton instance\n_UnleashService = UnleashService;\nUnleashService.instance = void 0;\nexport const unleashService = UnleashService.getInstance();\n\n// Utility function to check individual flags (for convenience)\nexport const isFeatureEnabled = (flagName, context) => {\n  return unleashService.isEnabled(flagName, context);\n};\n\n// Utility function to get feature variant\nexport const getFeatureVariant = (flagName, context) => {\n  return unleashService.getVariant(flagName, context);\n};\nexport default UnleashService;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}