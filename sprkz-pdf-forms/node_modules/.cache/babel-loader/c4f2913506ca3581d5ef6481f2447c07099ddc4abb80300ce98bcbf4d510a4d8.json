{"ast":null,"code":"/** A simple Least Recently Used map */\nclass LRUMap {\n  constructor(_maxSize) {\n    this._maxSize = _maxSize;\n    this._cache = new Map();\n  }\n\n  /** Get the current size of the cache */\n  get size() {\n    return this._cache.size;\n  }\n\n  /** Get an entry or undefined if it was not in the cache. Re-inserts to update the recently used order */\n  get(key) {\n    const value = this._cache.get(key);\n    if (value === undefined) {\n      return undefined;\n    }\n    // Remove and re-insert to update the order\n    this._cache.delete(key);\n    this._cache.set(key, value);\n    return value;\n  }\n\n  /** Insert an entry and evict an older entry if we've reached maxSize */\n  set(key, value) {\n    if (this._cache.size >= this._maxSize) {\n      // keys() returns an iterator in insertion order so keys().next() gives us the oldest key\n      this._cache.delete(this._cache.keys().next().value);\n    }\n    this._cache.set(key, value);\n  }\n\n  /** Remove an entry and return the entry if it was in the cache */\n  remove(key) {\n    const value = this._cache.get(key);\n    if (value) {\n      this._cache.delete(key);\n    }\n    return value;\n  }\n\n  /** Clear all entries */\n  clear() {\n    this._cache.clear();\n  }\n\n  /** Get all the keys */\n  keys() {\n    return Array.from(this._cache.keys());\n  }\n\n  /** Get all the values */\n  values() {\n    const values = [];\n    this._cache.forEach(value => values.push(value));\n    return values;\n  }\n}\nexport { LRUMap };\n//# sourceMappingURL=lru.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}