{"ast":null,"code":"import { getCurrentScope } from '../currentScopes.js';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { debug } from './debug-logger.js';\nimport { getActiveSpan, spanToJSON } from './spanUtils.js';\n\n/**\n * Ordered LRU cache for storing feature flags in the scope context. The name\n * of each flag in the buffer is unique, and the output of getAll() is ordered\n * from oldest to newest.\n */\n\n/**\n * Max size of the LRU flag buffer stored in Sentry scope and event contexts.\n */\nconst _INTERNAL_FLAG_BUFFER_SIZE = 100;\n\n/**\n * Max number of flag evaluations to record per span.\n */\nconst _INTERNAL_MAX_FLAGS_PER_SPAN = 10;\nconst SPAN_FLAG_ATTRIBUTE_PREFIX = 'flag.evaluation.';\n\n/**\n * Copies feature flags that are in current scope context to the event context\n */\nfunction _INTERNAL_copyFlagsFromScopeToEvent(event) {\n  const scope = getCurrentScope();\n  const flagContext = scope.getScopeData().contexts.flags;\n  const flagBuffer = flagContext ? flagContext.values : [];\n  if (!flagBuffer.length) {\n    return event;\n  }\n  if (event.contexts === undefined) {\n    event.contexts = {};\n  }\n  event.contexts.flags = {\n    values: [...flagBuffer]\n  };\n  return event;\n}\n\n/**\n * Inserts a flag into the current scope's context while maintaining ordered LRU properties.\n * Not thread-safe. After inserting:\n * - The flag buffer is sorted in order of recency, with the newest evaluation at the end.\n * - The names in the buffer are always unique.\n * - The length of the buffer never exceeds `maxSize`.\n *\n * @param name     Name of the feature flag to insert.\n * @param value    Value of the feature flag.\n * @param maxSize  Max number of flags the buffer should store. Default value should always be used in production.\n */\nfunction _INTERNAL_insertFlagToScope(name, value, maxSize = _INTERNAL_FLAG_BUFFER_SIZE) {\n  const scopeContexts = getCurrentScope().getScopeData().contexts;\n  if (!scopeContexts.flags) {\n    scopeContexts.flags = {\n      values: []\n    };\n  }\n  const flags = scopeContexts.flags.values;\n  _INTERNAL_insertToFlagBuffer(flags, name, value, maxSize);\n}\n\n/**\n * Exported for tests only. Currently only accepts boolean values (otherwise no-op).\n * Inserts a flag into a FeatureFlag array while maintaining the following properties:\n * - Flags are sorted in order of recency, with the newest evaluation at the end.\n * - The flag names are always unique.\n * - The length of the array never exceeds `maxSize`.\n *\n * @param flags      The buffer to insert the flag into.\n * @param name       Name of the feature flag to insert.\n * @param value      Value of the feature flag.\n * @param maxSize    Max number of flags the buffer should store. Default value should always be used in production.\n */\nfunction _INTERNAL_insertToFlagBuffer(flags, name, value, maxSize) {\n  if (typeof value !== 'boolean') {\n    return;\n  }\n  if (flags.length > maxSize) {\n    DEBUG_BUILD && debug.error(`[Feature Flags] insertToFlagBuffer called on a buffer larger than maxSize=${maxSize}`);\n    return;\n  }\n\n  // Check if the flag is already in the buffer - O(n)\n  const index = flags.findIndex(f => f.flag === name);\n  if (index !== -1) {\n    // The flag was found, remove it from its current position - O(n)\n    flags.splice(index, 1);\n  }\n  if (flags.length === maxSize) {\n    // If at capacity, pop the earliest flag - O(n)\n    flags.shift();\n  }\n\n  // Push the flag to the end - O(1)\n  flags.push({\n    flag: name,\n    result: value\n  });\n}\n\n/**\n * Records a feature flag evaluation for the active span. This is a no-op for non-boolean values.\n * The flag and its value is stored in span attributes with the `flag.evaluation` prefix. Once the\n * unique flags for a span reaches maxFlagsPerSpan, subsequent flags are dropped.\n *\n * @param name             Name of the feature flag.\n * @param value            Value of the feature flag. Non-boolean values are ignored.\n * @param maxFlagsPerSpan  Max number of flags a buffer should store. Default value should always be used in production.\n */\nfunction _INTERNAL_addFeatureFlagToActiveSpan(name, value, maxFlagsPerSpan = _INTERNAL_MAX_FLAGS_PER_SPAN) {\n  if (typeof value !== 'boolean') {\n    return;\n  }\n  const span = getActiveSpan();\n  if (!span) {\n    return;\n  }\n  const attributes = spanToJSON(span).data;\n\n  // If the flag already exists, always update it\n  if (`${SPAN_FLAG_ATTRIBUTE_PREFIX}${name}` in attributes) {\n    span.setAttribute(`${SPAN_FLAG_ATTRIBUTE_PREFIX}${name}`, value);\n    return;\n  }\n\n  // Else, add the flag to the span if we have not reached the max number of flags\n  const numOfAddedFlags = Object.keys(attributes).filter(key => key.startsWith(SPAN_FLAG_ATTRIBUTE_PREFIX)).length;\n  if (numOfAddedFlags < maxFlagsPerSpan) {\n    span.setAttribute(`${SPAN_FLAG_ATTRIBUTE_PREFIX}${name}`, value);\n  }\n}\nexport { _INTERNAL_FLAG_BUFFER_SIZE, _INTERNAL_MAX_FLAGS_PER_SPAN, _INTERNAL_addFeatureFlagToActiveSpan, _INTERNAL_copyFlagsFromScopeToEvent, _INTERNAL_insertFlagToScope, _INTERNAL_insertToFlagBuffer };","map":{"version":3,"names":["_INTERNAL_FLAG_BUFFER_SIZE","_INTERNAL_MAX_FLAGS_PER_SPAN","SPAN_FLAG_ATTRIBUTE_PREFIX","_INTERNAL_copyFlagsFromScopeToEvent","event","scope","getCurrentScope","flagContext","getScopeData","contexts","flags","flagBuffer","values","length","undefined","_INTERNAL_insertFlagToScope","name","value","maxSize","scopeContexts","_INTERNAL_insertToFlagBuffer","DEBUG_BUILD","debug","error","index","findIndex","f","flag","splice","shift","push","result","_INTERNAL_addFeatureFlagToActiveSpan","maxFlagsPerSpan","span","getActiveSpan","attributes","spanToJSON","data","setAttribute","numOfAddedFlags","Object","keys","filter","key","startsWith"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/utils/featureFlags.ts"],"sourcesContent":["import { getCurrentScope } from '../currentScopes';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { type Event } from '../types-hoist/event';\nimport { debug } from './debug-logger';\nimport { getActiveSpan, spanToJSON } from './spanUtils';\n\n/**\n * Ordered LRU cache for storing feature flags in the scope context. The name\n * of each flag in the buffer is unique, and the output of getAll() is ordered\n * from oldest to newest.\n */\n\nexport type FeatureFlag = { readonly flag: string; readonly result: boolean };\n\n/**\n * Max size of the LRU flag buffer stored in Sentry scope and event contexts.\n */\nexport const _INTERNAL_FLAG_BUFFER_SIZE = 100;\n\n/**\n * Max number of flag evaluations to record per span.\n */\nexport const _INTERNAL_MAX_FLAGS_PER_SPAN = 10;\n\nconst SPAN_FLAG_ATTRIBUTE_PREFIX = 'flag.evaluation.';\n\n/**\n * Copies feature flags that are in current scope context to the event context\n */\nexport function _INTERNAL_copyFlagsFromScopeToEvent(event: Event): Event {\n  const scope = getCurrentScope();\n  const flagContext = scope.getScopeData().contexts.flags;\n  const flagBuffer = flagContext ? flagContext.values : [];\n\n  if (!flagBuffer.length) {\n    return event;\n  }\n\n  if (event.contexts === undefined) {\n    event.contexts = {};\n  }\n  event.contexts.flags = { values: [...flagBuffer] };\n  return event;\n}\n\n/**\n * Inserts a flag into the current scope's context while maintaining ordered LRU properties.\n * Not thread-safe. After inserting:\n * - The flag buffer is sorted in order of recency, with the newest evaluation at the end.\n * - The names in the buffer are always unique.\n * - The length of the buffer never exceeds `maxSize`.\n *\n * @param name     Name of the feature flag to insert.\n * @param value    Value of the feature flag.\n * @param maxSize  Max number of flags the buffer should store. Default value should always be used in production.\n */\nexport function _INTERNAL_insertFlagToScope(\n  name: string,\n  value: unknown,\n  maxSize: number = _INTERNAL_FLAG_BUFFER_SIZE,\n): void {\n  const scopeContexts = getCurrentScope().getScopeData().contexts;\n  if (!scopeContexts.flags) {\n    scopeContexts.flags = { values: [] };\n  }\n  const flags = scopeContexts.flags.values as FeatureFlag[];\n  _INTERNAL_insertToFlagBuffer(flags, name, value, maxSize);\n}\n\n/**\n * Exported for tests only. Currently only accepts boolean values (otherwise no-op).\n * Inserts a flag into a FeatureFlag array while maintaining the following properties:\n * - Flags are sorted in order of recency, with the newest evaluation at the end.\n * - The flag names are always unique.\n * - The length of the array never exceeds `maxSize`.\n *\n * @param flags      The buffer to insert the flag into.\n * @param name       Name of the feature flag to insert.\n * @param value      Value of the feature flag.\n * @param maxSize    Max number of flags the buffer should store. Default value should always be used in production.\n */\nexport function _INTERNAL_insertToFlagBuffer(\n  flags: FeatureFlag[],\n  name: string,\n  value: unknown,\n  maxSize: number,\n): void {\n  if (typeof value !== 'boolean') {\n    return;\n  }\n\n  if (flags.length > maxSize) {\n    DEBUG_BUILD && debug.error(`[Feature Flags] insertToFlagBuffer called on a buffer larger than maxSize=${maxSize}`);\n    return;\n  }\n\n  // Check if the flag is already in the buffer - O(n)\n  const index = flags.findIndex(f => f.flag === name);\n\n  if (index !== -1) {\n    // The flag was found, remove it from its current position - O(n)\n    flags.splice(index, 1);\n  }\n\n  if (flags.length === maxSize) {\n    // If at capacity, pop the earliest flag - O(n)\n    flags.shift();\n  }\n\n  // Push the flag to the end - O(1)\n  flags.push({\n    flag: name,\n    result: value,\n  });\n}\n\n/**\n * Records a feature flag evaluation for the active span. This is a no-op for non-boolean values.\n * The flag and its value is stored in span attributes with the `flag.evaluation` prefix. Once the\n * unique flags for a span reaches maxFlagsPerSpan, subsequent flags are dropped.\n *\n * @param name             Name of the feature flag.\n * @param value            Value of the feature flag. Non-boolean values are ignored.\n * @param maxFlagsPerSpan  Max number of flags a buffer should store. Default value should always be used in production.\n */\nexport function _INTERNAL_addFeatureFlagToActiveSpan(\n  name: string,\n  value: unknown,\n  maxFlagsPerSpan: number = _INTERNAL_MAX_FLAGS_PER_SPAN,\n): void {\n  if (typeof value !== 'boolean') {\n    return;\n  }\n\n  const span = getActiveSpan();\n  if (!span) {\n    return;\n  }\n\n  const attributes = spanToJSON(span).data;\n\n  // If the flag already exists, always update it\n  if (`${SPAN_FLAG_ATTRIBUTE_PREFIX}${name}` in attributes) {\n    span.setAttribute(`${SPAN_FLAG_ATTRIBUTE_PREFIX}${name}`, value);\n    return;\n  }\n\n  // Else, add the flag to the span if we have not reached the max number of flags\n  const numOfAddedFlags = Object.keys(attributes).filter(key => key.startsWith(SPAN_FLAG_ATTRIBUTE_PREFIX)).length;\n  if (numOfAddedFlags < maxFlagsPerSpan) {\n    span.setAttribute(`${SPAN_FLAG_ATTRIBUTE_PREFIX}${name}`, value);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}