{"ast":null,"code":"import { debug, getFunctionName } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { onCLS } from './web-vitals/getCLS.js';\nimport { onFID } from './web-vitals/getFID.js';\nimport { onINP } from './web-vitals/getINP.js';\nimport { onLCP } from './web-vitals/getLCP.js';\nimport { observe } from './web-vitals/lib/observe.js';\nimport { onTTFB } from './web-vitals/onTTFB.js';\nconst handlers = {};\nconst instrumented = {};\nlet _previousCls;\nlet _previousFid;\nlet _previousLcp;\nlet _previousTtfb;\nlet _previousInp;\n\n/**\n * Add a callback that will be triggered when a CLS metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n *\n * Pass `stopOnCallback = true` to stop listening for CLS when the cleanup callback is called.\n * This will lead to the CLS being finalized and frozen.\n */\nfunction addClsInstrumentationHandler(callback, stopOnCallback = false) {\n  return addMetricObserver('cls', callback, instrumentCls, _previousCls, stopOnCallback);\n}\n\n/**\n * Add a callback that will be triggered when a LCP metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n *\n * Pass `stopOnCallback = true` to stop listening for LCP when the cleanup callback is called.\n * This will lead to the LCP being finalized and frozen.\n */\nfunction addLcpInstrumentationHandler(callback, stopOnCallback = false) {\n  return addMetricObserver('lcp', callback, instrumentLcp, _previousLcp, stopOnCallback);\n}\n\n/**\n * Add a callback that will be triggered when a FID metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nfunction addFidInstrumentationHandler(callback) {\n  return addMetricObserver('fid', callback, instrumentFid, _previousFid);\n}\n\n/**\n * Add a callback that will be triggered when a FID metric is available.\n */\nfunction addTtfbInstrumentationHandler(callback) {\n  return addMetricObserver('ttfb', callback, instrumentTtfb, _previousTtfb);\n}\n\n/**\n * Add a callback that will be triggered when a INP metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nfunction addInpInstrumentationHandler(callback) {\n  return addMetricObserver('inp', callback, instrumentInp, _previousInp);\n}\n\n/**\n * Add a callback that will be triggered when a performance observer is triggered,\n * and receives the entries of the observer.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nfunction addPerformanceInstrumentationHandler(type, callback) {\n  addHandler(type, callback);\n  if (!instrumented[type]) {\n    instrumentPerformanceObserver(type);\n    instrumented[type] = true;\n  }\n  return getCleanupCallback(type, callback);\n}\n\n/** Trigger all handlers of a given type. */\nfunction triggerHandlers(type, data) {\n  const typeHandlers = handlers[type];\n  if (!typeHandlers?.length) {\n    return;\n  }\n  for (const handler of typeHandlers) {\n    try {\n      handler(data);\n    } catch (e) {\n      DEBUG_BUILD && debug.error(`Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(handler)}\\nError:`, e);\n    }\n  }\n}\nfunction instrumentCls() {\n  return onCLS(metric => {\n    triggerHandlers('cls', {\n      metric\n    });\n    _previousCls = metric;\n  },\n  // We want the callback to be called whenever the CLS value updates.\n  // By default, the callback is only called when the tab goes to the background.\n  {\n    reportAllChanges: true\n  });\n}\nfunction instrumentFid() {\n  return onFID(metric => {\n    triggerHandlers('fid', {\n      metric\n    });\n    _previousFid = metric;\n  });\n}\nfunction instrumentLcp() {\n  return onLCP(metric => {\n    triggerHandlers('lcp', {\n      metric\n    });\n    _previousLcp = metric;\n  },\n  // We want the callback to be called whenever the LCP value updates.\n  // By default, the callback is only called when the tab goes to the background.\n  {\n    reportAllChanges: true\n  });\n}\nfunction instrumentTtfb() {\n  return onTTFB(metric => {\n    triggerHandlers('ttfb', {\n      metric\n    });\n    _previousTtfb = metric;\n  });\n}\nfunction instrumentInp() {\n  return onINP(metric => {\n    triggerHandlers('inp', {\n      metric\n    });\n    _previousInp = metric;\n  });\n}\nfunction addMetricObserver(type, callback, instrumentFn, previousValue, stopOnCallback = false) {\n  addHandler(type, callback);\n  let stopListening;\n  if (!instrumented[type]) {\n    stopListening = instrumentFn();\n    instrumented[type] = true;\n  }\n  if (previousValue) {\n    callback({\n      metric: previousValue\n    });\n  }\n  return getCleanupCallback(type, callback, stopOnCallback ? stopListening : undefined);\n}\nfunction instrumentPerformanceObserver(type) {\n  const options = {};\n\n  // Special per-type options we want to use\n  if (type === 'event') {\n    options.durationThreshold = 0;\n  }\n  observe(type, entries => {\n    triggerHandlers(type, {\n      entries\n    });\n  }, options);\n}\nfunction addHandler(type, handler) {\n  handlers[type] = handlers[type] || [];\n  handlers[type].push(handler);\n}\n\n// Get a callback which can be called to remove the instrumentation handler\nfunction getCleanupCallback(type, callback, stopListening) {\n  return () => {\n    if (stopListening) {\n      stopListening();\n    }\n    const typeHandlers = handlers[type];\n    if (!typeHandlers) {\n      return;\n    }\n    const index = typeHandlers.indexOf(callback);\n    if (index !== -1) {\n      typeHandlers.splice(index, 1);\n    }\n  };\n}\n\n/**\n * Check if a PerformanceEntry is a PerformanceEventTiming by checking for the `duration` property.\n */\nfunction isPerformanceEventTiming(entry) {\n  return 'duration' in entry;\n}\nexport { addClsInstrumentationHandler, addFidInstrumentationHandler, addInpInstrumentationHandler, addLcpInstrumentationHandler, addPerformanceInstrumentationHandler, addTtfbInstrumentationHandler, isPerformanceEventTiming };","map":{"version":3,"names":["handlers","instrumented","_previousCls","_previousFid","_previousLcp","_previousTtfb","_previousInp","addClsInstrumentationHandler","callback","stopOnCallback","addMetricObserver","instrumentCls","addLcpInstrumentationHandler","instrumentLcp","addFidInstrumentationHandler","instrumentFid","addTtfbInstrumentationHandler","instrumentTtfb","addInpInstrumentationHandler","instrumentInp","addPerformanceInstrumentationHandler","type","addHandler","instrumentPerformanceObserver","getCleanupCallback","triggerHandlers","data","typeHandlers","length","handler","e","DEBUG_BUILD","debug","error","getFunctionName","onCLS","metric","reportAllChanges","onFID","onLCP","onTTFB","onINP","instrumentFn","previousValue","stopListening","undefined","options","durationThreshold","observe","entries","push","index","indexOf","splice","isPerformanceEventTiming","entry"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry-internal/browser-utils/src/metrics/instrument.ts"],"sourcesContent":["import { debug, getFunctionName } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { onCLS } from './web-vitals/getCLS';\nimport { onFID } from './web-vitals/getFID';\nimport { onINP } from './web-vitals/getINP';\nimport { onLCP } from './web-vitals/getLCP';\nimport { observe } from './web-vitals/lib/observe';\nimport { onTTFB } from './web-vitals/onTTFB';\n\ntype InstrumentHandlerTypePerformanceObserver =\n  | 'longtask'\n  | 'event'\n  | 'navigation'\n  | 'paint'\n  | 'resource'\n  | 'first-input'\n  | 'element';\n\ntype InstrumentHandlerTypeMetric = 'cls' | 'lcp' | 'fid' | 'ttfb' | 'inp';\n\n// We provide this here manually instead of relying on a global, as this is not available in non-browser environements\n// And we do not want to expose such types\ninterface PerformanceEntry {\n  readonly duration: number;\n  readonly entryType: string;\n  readonly name: string;\n  readonly startTime: number;\n  toJSON(): Record<string, unknown>;\n}\ninterface PerformanceEventTiming extends PerformanceEntry {\n  processingStart: number;\n  processingEnd: number;\n  duration: number;\n  cancelable?: boolean;\n  target?: unknown | null;\n  interactionId?: number;\n}\n\ninterface PerformanceScriptTiming extends PerformanceEntry {\n  sourceURL: string;\n  sourceFunctionName: string;\n  sourceCharPosition: number;\n  invoker: string;\n  invokerType: string;\n}\nexport interface PerformanceLongAnimationFrameTiming extends PerformanceEntry {\n  scripts: PerformanceScriptTiming[];\n}\n\ninterface Metric {\n  /**\n   * The name of the metric (in acronym form).\n   */\n  name: 'CLS' | 'FCP' | 'FID' | 'INP' | 'LCP' | 'TTFB';\n\n  /**\n   * The current value of the metric.\n   */\n  value: number;\n\n  /**\n   * The rating as to whether the metric value is within the \"good\",\n   * \"needs improvement\", or \"poor\" thresholds of the metric.\n   */\n  rating: 'good' | 'needs-improvement' | 'poor';\n\n  /**\n   * The delta between the current value and the last-reported value.\n   * On the first report, `delta` and `value` will always be the same.\n   */\n  delta: number;\n\n  /**\n   * A unique ID representing this particular metric instance. This ID can\n   * be used by an analytics tool to dedupe multiple values sent for the same\n   * metric instance, or to group multiple deltas together and calculate a\n   * total. It can also be used to differentiate multiple different metric\n   * instances sent from the same page, which can happen if the page is\n   * restored from the back/forward cache (in that case new metrics object\n   * get created).\n   */\n  id: string;\n\n  /**\n   * Any performance entries relevant to the metric value calculation.\n   * The array may also be empty if the metric value was not based on any\n   * entries (e.g. a CLS value of 0 given no layout shifts).\n   */\n  entries: PerformanceEntry[];\n\n  /**\n   * The type of navigation\n   *\n   * Navigation Timing API (or `undefined` if the browser doesn't\n   * support that API). For pages that are restored from the bfcache, this\n   * value will be 'back-forward-cache'.\n   */\n  navigationType: 'navigate' | 'reload' | 'back-forward' | 'back-forward-cache' | 'prerender' | 'restore';\n}\n\ntype InstrumentHandlerType = InstrumentHandlerTypeMetric | InstrumentHandlerTypePerformanceObserver;\n\ntype StopListening = undefined | void | (() => void);\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype InstrumentHandlerCallback = (data: any) => void;\n\ntype CleanupHandlerCallback = () => void;\n\nconst handlers: { [key in InstrumentHandlerType]?: InstrumentHandlerCallback[] } = {};\nconst instrumented: { [key in InstrumentHandlerType]?: boolean } = {};\n\nlet _previousCls: Metric | undefined;\nlet _previousFid: Metric | undefined;\nlet _previousLcp: Metric | undefined;\nlet _previousTtfb: Metric | undefined;\nlet _previousInp: Metric | undefined;\n\n/**\n * Add a callback that will be triggered when a CLS metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n *\n * Pass `stopOnCallback = true` to stop listening for CLS when the cleanup callback is called.\n * This will lead to the CLS being finalized and frozen.\n */\nexport function addClsInstrumentationHandler(\n  callback: (data: { metric: Metric }) => void,\n  stopOnCallback = false,\n): CleanupHandlerCallback {\n  return addMetricObserver('cls', callback, instrumentCls, _previousCls, stopOnCallback);\n}\n\n/**\n * Add a callback that will be triggered when a LCP metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n *\n * Pass `stopOnCallback = true` to stop listening for LCP when the cleanup callback is called.\n * This will lead to the LCP being finalized and frozen.\n */\nexport function addLcpInstrumentationHandler(\n  callback: (data: { metric: Metric }) => void,\n  stopOnCallback = false,\n): CleanupHandlerCallback {\n  return addMetricObserver('lcp', callback, instrumentLcp, _previousLcp, stopOnCallback);\n}\n\n/**\n * Add a callback that will be triggered when a FID metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nexport function addFidInstrumentationHandler(callback: (data: { metric: Metric }) => void): CleanupHandlerCallback {\n  return addMetricObserver('fid', callback, instrumentFid, _previousFid);\n}\n\n/**\n * Add a callback that will be triggered when a FID metric is available.\n */\nexport function addTtfbInstrumentationHandler(callback: (data: { metric: Metric }) => void): CleanupHandlerCallback {\n  return addMetricObserver('ttfb', callback, instrumentTtfb, _previousTtfb);\n}\n\nexport type InstrumentationHandlerCallback = (data: {\n  metric: Omit<Metric, 'entries'> & {\n    entries: PerformanceEventTiming[];\n  };\n}) => void;\n\n/**\n * Add a callback that will be triggered when a INP metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nexport function addInpInstrumentationHandler(callback: InstrumentationHandlerCallback): CleanupHandlerCallback {\n  return addMetricObserver('inp', callback, instrumentInp, _previousInp);\n}\n\nexport function addPerformanceInstrumentationHandler(\n  type: 'event',\n  callback: (data: { entries: ((PerformanceEntry & { target?: unknown | null }) | PerformanceEventTiming)[] }) => void,\n): CleanupHandlerCallback;\nexport function addPerformanceInstrumentationHandler(\n  type: InstrumentHandlerTypePerformanceObserver,\n  callback: (data: { entries: PerformanceEntry[] }) => void,\n): CleanupHandlerCallback;\n\n/**\n * Add a callback that will be triggered when a performance observer is triggered,\n * and receives the entries of the observer.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nexport function addPerformanceInstrumentationHandler(\n  type: InstrumentHandlerTypePerformanceObserver,\n  callback: (data: { entries: PerformanceEntry[] }) => void,\n): CleanupHandlerCallback {\n  addHandler(type, callback);\n\n  if (!instrumented[type]) {\n    instrumentPerformanceObserver(type);\n    instrumented[type] = true;\n  }\n\n  return getCleanupCallback(type, callback);\n}\n\n/** Trigger all handlers of a given type. */\nfunction triggerHandlers(type: InstrumentHandlerType, data: unknown): void {\n  const typeHandlers = handlers[type];\n\n  if (!typeHandlers?.length) {\n    return;\n  }\n\n  for (const handler of typeHandlers) {\n    try {\n      handler(data);\n    } catch (e) {\n      DEBUG_BUILD &&\n        debug.error(\n          `Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(handler)}\\nError:`,\n          e,\n        );\n    }\n  }\n}\n\nfunction instrumentCls(): StopListening {\n  return onCLS(\n    metric => {\n      triggerHandlers('cls', {\n        metric,\n      });\n      _previousCls = metric;\n    },\n    // We want the callback to be called whenever the CLS value updates.\n    // By default, the callback is only called when the tab goes to the background.\n    { reportAllChanges: true },\n  );\n}\n\nfunction instrumentFid(): void {\n  return onFID(metric => {\n    triggerHandlers('fid', {\n      metric,\n    });\n    _previousFid = metric;\n  });\n}\n\nfunction instrumentLcp(): StopListening {\n  return onLCP(\n    metric => {\n      triggerHandlers('lcp', {\n        metric,\n      });\n      _previousLcp = metric;\n    },\n    // We want the callback to be called whenever the LCP value updates.\n    // By default, the callback is only called when the tab goes to the background.\n    { reportAllChanges: true },\n  );\n}\n\nfunction instrumentTtfb(): StopListening {\n  return onTTFB(metric => {\n    triggerHandlers('ttfb', {\n      metric,\n    });\n    _previousTtfb = metric;\n  });\n}\n\nfunction instrumentInp(): void {\n  return onINP(metric => {\n    triggerHandlers('inp', {\n      metric,\n    });\n    _previousInp = metric;\n  });\n}\n\nfunction addMetricObserver(\n  type: InstrumentHandlerTypeMetric,\n  callback: InstrumentHandlerCallback,\n  instrumentFn: () => StopListening,\n  previousValue: Metric | undefined,\n  stopOnCallback = false,\n): CleanupHandlerCallback {\n  addHandler(type, callback);\n\n  let stopListening: StopListening | undefined;\n\n  if (!instrumented[type]) {\n    stopListening = instrumentFn();\n    instrumented[type] = true;\n  }\n\n  if (previousValue) {\n    callback({ metric: previousValue });\n  }\n\n  return getCleanupCallback(type, callback, stopOnCallback ? stopListening : undefined);\n}\n\nfunction instrumentPerformanceObserver(type: InstrumentHandlerTypePerformanceObserver): void {\n  const options: PerformanceObserverInit = {};\n\n  // Special per-type options we want to use\n  if (type === 'event') {\n    options.durationThreshold = 0;\n  }\n\n  observe(\n    type,\n    entries => {\n      triggerHandlers(type, { entries });\n    },\n    options,\n  );\n}\n\nfunction addHandler(type: InstrumentHandlerType, handler: InstrumentHandlerCallback): void {\n  handlers[type] = handlers[type] || [];\n  (handlers[type] as InstrumentHandlerCallback[]).push(handler);\n}\n\n// Get a callback which can be called to remove the instrumentation handler\nfunction getCleanupCallback(\n  type: InstrumentHandlerType,\n  callback: InstrumentHandlerCallback,\n  stopListening: StopListening,\n): CleanupHandlerCallback {\n  return () => {\n    if (stopListening) {\n      stopListening();\n    }\n\n    const typeHandlers = handlers[type];\n\n    if (!typeHandlers) {\n      return;\n    }\n\n    const index = typeHandlers.indexOf(callback);\n    if (index !== -1) {\n      typeHandlers.splice(index, 1);\n    }\n  };\n}\n\n/**\n * Check if a PerformanceEntry is a PerformanceEventTiming by checking for the `duration` property.\n */\nexport function isPerformanceEventTiming(entry: PerformanceEntry): entry is PerformanceEventTiming {\n  return 'duration' in entry;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}