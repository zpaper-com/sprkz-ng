{"ast":null,"code":"import { GLOBAL_OBJ } from './utils/worldwide.js';\n\n/** Keys are source filename/url, values are metadata objects. */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst filenameMetadataMap = new Map();\n/** Set of stack strings that have already been parsed. */\nconst parsedStacks = new Set();\nfunction ensureMetadataStacksAreParsed(parser) {\n  if (!GLOBAL_OBJ._sentryModuleMetadata) {\n    return;\n  }\n  for (const stack of Object.keys(GLOBAL_OBJ._sentryModuleMetadata)) {\n    const metadata = GLOBAL_OBJ._sentryModuleMetadata[stack];\n    if (parsedStacks.has(stack)) {\n      continue;\n    }\n\n    // Ensure this stack doesn't get parsed again\n    parsedStacks.add(stack);\n    const frames = parser(stack);\n\n    // Go through the frames starting from the top of the stack and find the first one with a filename\n    for (const frame of frames.reverse()) {\n      if (frame.filename) {\n        // Save the metadata for this filename\n        filenameMetadataMap.set(frame.filename, metadata);\n        break;\n      }\n    }\n  }\n}\n\n/**\n * Retrieve metadata for a specific JavaScript file URL.\n *\n * Metadata is injected by the Sentry bundler plugins using the `_experiments.moduleMetadata` config option.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getMetadataForUrl(parser, filename) {\n  ensureMetadataStacksAreParsed(parser);\n  return filenameMetadataMap.get(filename);\n}\n\n/**\n * Adds metadata to stack frames.\n *\n * Metadata is injected by the Sentry bundler plugins using the `_experiments.moduleMetadata` config option.\n */\nfunction addMetadataToStackFrames(parser, event) {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event.exception.values.forEach(exception => {\n      if (!exception.stacktrace) {\n        return;\n      }\n      for (const frame of exception.stacktrace.frames || []) {\n        if (!frame.filename || frame.module_metadata) {\n          continue;\n        }\n        const metadata = getMetadataForUrl(parser, frame.filename);\n        if (metadata) {\n          frame.module_metadata = metadata;\n        }\n      }\n    });\n  } catch {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n}\n\n/**\n * Strips metadata from stack frames.\n */\nfunction stripMetadataFromStackFrames(event) {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event.exception.values.forEach(exception => {\n      if (!exception.stacktrace) {\n        return;\n      }\n      for (const frame of exception.stacktrace.frames || []) {\n        delete frame.module_metadata;\n      }\n    });\n  } catch {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n}\nexport { addMetadataToStackFrames, getMetadataForUrl, stripMetadataFromStackFrames };","map":{"version":3,"names":["filenameMetadataMap","Map","parsedStacks","Set","ensureMetadataStacksAreParsed","parser","GLOBAL_OBJ","_sentryModuleMetadata","stack","Object","keys","metadata","has","add","frames","frame","reverse","filename","set","getMetadataForUrl","get","addMetadataToStackFrames","event","exception","values","forEach","stacktrace","module_metadata","stripMetadataFromStackFrames"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/metadata.ts"],"sourcesContent":["import type { Event } from './types-hoist/event';\nimport type { StackParser } from './types-hoist/stacktrace';\nimport { GLOBAL_OBJ } from './utils/worldwide';\n\n/** Keys are source filename/url, values are metadata objects. */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst filenameMetadataMap = new Map<string, any>();\n/** Set of stack strings that have already been parsed. */\nconst parsedStacks = new Set<string>();\n\nfunction ensureMetadataStacksAreParsed(parser: StackParser): void {\n  if (!GLOBAL_OBJ._sentryModuleMetadata) {\n    return;\n  }\n\n  for (const stack of Object.keys(GLOBAL_OBJ._sentryModuleMetadata)) {\n    const metadata = GLOBAL_OBJ._sentryModuleMetadata[stack];\n\n    if (parsedStacks.has(stack)) {\n      continue;\n    }\n\n    // Ensure this stack doesn't get parsed again\n    parsedStacks.add(stack);\n\n    const frames = parser(stack);\n\n    // Go through the frames starting from the top of the stack and find the first one with a filename\n    for (const frame of frames.reverse()) {\n      if (frame.filename) {\n        // Save the metadata for this filename\n        filenameMetadataMap.set(frame.filename, metadata);\n        break;\n      }\n    }\n  }\n}\n\n/**\n * Retrieve metadata for a specific JavaScript file URL.\n *\n * Metadata is injected by the Sentry bundler plugins using the `_experiments.moduleMetadata` config option.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getMetadataForUrl(parser: StackParser, filename: string): any | undefined {\n  ensureMetadataStacksAreParsed(parser);\n  return filenameMetadataMap.get(filename);\n}\n\n/**\n * Adds metadata to stack frames.\n *\n * Metadata is injected by the Sentry bundler plugins using the `_experiments.moduleMetadata` config option.\n */\nexport function addMetadataToStackFrames(parser: StackParser, event: Event): void {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event.exception!.values!.forEach(exception => {\n      if (!exception.stacktrace) {\n        return;\n      }\n\n      for (const frame of exception.stacktrace.frames || []) {\n        if (!frame.filename || frame.module_metadata) {\n          continue;\n        }\n\n        const metadata = getMetadataForUrl(parser, frame.filename);\n\n        if (metadata) {\n          frame.module_metadata = metadata;\n        }\n      }\n    });\n  } catch {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n}\n\n/**\n * Strips metadata from stack frames.\n */\nexport function stripMetadataFromStackFrames(event: Event): void {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event.exception!.values!.forEach(exception => {\n      if (!exception.stacktrace) {\n        return;\n      }\n\n      for (const frame of exception.stacktrace.frames || []) {\n        delete frame.module_metadata;\n      }\n    });\n  } catch {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n}\n"],"mappings":";;AAIA;AACA;AACA,MAAMA,mBAAA,GAAsB,IAAIC,GAAG,EAAe;AAClD;AACA,MAAMC,YAAA,GAAe,IAAIC,GAAG,EAAU;AAEtC,SAASC,6BAA6BA,CAACC,MAAM,EAAqB;EAChE,IAAI,CAACC,UAAU,CAACC,qBAAqB,EAAE;IACrC;EACJ;EAEE,KAAK,MAAMC,KAAA,IAASC,MAAM,CAACC,IAAI,CAACJ,UAAU,CAACC,qBAAqB,CAAC,EAAE;IACjE,MAAMI,QAAA,GAAWL,UAAU,CAACC,qBAAqB,CAACC,KAAK,CAAC;IAExD,IAAIN,YAAY,CAACU,GAAG,CAACJ,KAAK,CAAC,EAAE;MAC3B;IACN;;IAEA;IACIN,YAAY,CAACW,GAAG,CAACL,KAAK,CAAC;IAEvB,MAAMM,MAAA,GAAST,MAAM,CAACG,KAAK,CAAC;;IAEhC;IACI,KAAK,MAAMO,KAAA,IAASD,MAAM,CAACE,OAAO,EAAE,EAAE;MACpC,IAAID,KAAK,CAACE,QAAQ,EAAE;QAC1B;QACQjB,mBAAmB,CAACkB,GAAG,CAACH,KAAK,CAACE,QAAQ,EAAEN,QAAQ,CAAC;QACjD;MACR;IACA;EACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAASQ,iBAAiBA,CAACd,MAAM,EAAeY,QAAQ,EAA2B;EACxFb,6BAA6B,CAACC,MAAM,CAAC;EACrC,OAAOL,mBAAmB,CAACoB,GAAG,CAACH,QAAQ,CAAC;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACO,SAASI,wBAAwBA,CAAChB,MAAM,EAAeiB,KAAK,EAAe;EAChF,IAAI;IACN;IACIA,KAAK,CAACC,SAAS,CAAEC,MAAM,CAAEC,OAAO,CAACF,SAAA,IAAa;MAC5C,IAAI,CAACA,SAAS,CAACG,UAAU,EAAE;QACzB;MACR;MAEM,KAAK,MAAMX,KAAA,IAASQ,SAAS,CAACG,UAAU,CAACZ,MAAA,IAAU,EAAE,EAAE;QACrD,IAAI,CAACC,KAAK,CAACE,QAAA,IAAYF,KAAK,CAACY,eAAe,EAAE;UAC5C;QACV;QAEQ,MAAMhB,QAAA,GAAWQ,iBAAiB,CAACd,MAAM,EAAEU,KAAK,CAACE,QAAQ,CAAC;QAE1D,IAAIN,QAAQ,EAAE;UACZI,KAAK,CAACY,eAAA,GAAkBhB,QAAQ;QAC1C;MACA;IACA,CAAK,CAAC;EACN,EAAI,MAAM;IACV;EAAA;AAEA;;AAEA;AACA;AACA;AACO,SAASiB,4BAA4BA,CAACN,KAAK,EAAe;EAC/D,IAAI;IACN;IACIA,KAAK,CAACC,SAAS,CAAEC,MAAM,CAAEC,OAAO,CAACF,SAAA,IAAa;MAC5C,IAAI,CAACA,SAAS,CAACG,UAAU,EAAE;QACzB;MACR;MAEM,KAAK,MAAMX,KAAA,IAASQ,SAAS,CAACG,UAAU,CAACZ,MAAA,IAAU,EAAE,EAAE;QACrD,OAAOC,KAAK,CAACY,eAAe;MACpC;IACA,CAAK,CAAC;EACN,EAAI,MAAM;IACV;EAAA;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}