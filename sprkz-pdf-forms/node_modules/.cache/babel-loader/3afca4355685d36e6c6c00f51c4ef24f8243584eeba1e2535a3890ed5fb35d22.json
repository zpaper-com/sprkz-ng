{"ast":null,"code":"import { isError, isRequest } from '../utils/is.js';\nimport { fill, addNonEnumerableProperty } from '../utils/object.js';\nimport { supportsNativeFetch } from '../utils/supports.js';\nimport { timestampInSeconds } from '../utils/time.js';\nimport { GLOBAL_OBJ } from '../utils/worldwide.js';\nimport { addHandler, maybeInstrument, triggerHandlers } from './handlers.js';\n\n/**\n * Add an instrumentation handler for when a fetch request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addFetchInstrumentationHandler(handler, skipNativeFetchCheck) {\n  const type = 'fetch';\n  addHandler(type, handler);\n  maybeInstrument(type, () => instrumentFetch(undefined, skipNativeFetchCheck));\n}\n\n/**\n * Add an instrumentation handler for long-lived fetch requests, like consuming server-sent events (SSE) via fetch.\n * The handler will resolve the request body and emit the actual `endTimestamp`, so that the\n * span can be updated accordingly.\n *\n * Only used internally\n * @hidden\n */\nfunction addFetchEndInstrumentationHandler(handler) {\n  const type = 'fetch-body-resolved';\n  addHandler(type, handler);\n  maybeInstrument(type, () => instrumentFetch(streamHandler));\n}\nfunction instrumentFetch(onFetchResolved, skipNativeFetchCheck = false) {\n  if (skipNativeFetchCheck && !supportsNativeFetch()) {\n    return;\n  }\n  fill(GLOBAL_OBJ, 'fetch', function (originalFetch) {\n    return function (...args) {\n      // We capture the error right here and not in the Promise error callback because Safari (and probably other\n      // browsers too) will wipe the stack trace up to this point, only leaving us with this file which is useless.\n\n      // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n      //       it means the error, that was caused by your fetch call did not\n      //       have a stack trace, so the SDK backfilled the stack trace so\n      //       you can see which fetch call failed.\n      const virtualError = new Error();\n      const {\n        method,\n        url\n      } = parseFetchArgs(args);\n      const handlerData = {\n        args,\n        fetchData: {\n          method,\n          url\n        },\n        startTimestamp: timestampInSeconds() * 1000,\n        // // Adding the error to be able to fingerprint the failed fetch event in HttpClient instrumentation\n        virtualError,\n        headers: getHeadersFromFetchArgs(args)\n      };\n\n      // if there is no callback, fetch is instrumented directly\n      if (!onFetchResolved) {\n        triggerHandlers('fetch', {\n          ...handlerData\n        });\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return originalFetch.apply(GLOBAL_OBJ, args).then(async response => {\n        if (onFetchResolved) {\n          onFetchResolved(response);\n        } else {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: timestampInSeconds() * 1000,\n            response\n          });\n        }\n        return response;\n      }, error => {\n        triggerHandlers('fetch', {\n          ...handlerData,\n          endTimestamp: timestampInSeconds() * 1000,\n          error\n        });\n        if (isError(error) && error.stack === undefined) {\n          // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n          //       it means the error, that was caused by your fetch call did not\n          //       have a stack trace, so the SDK backfilled the stack trace so\n          //       you can see which fetch call failed.\n          error.stack = virtualError.stack;\n          addNonEnumerableProperty(error, 'framesToPop', 1);\n        }\n\n        // We enhance the not-so-helpful \"Failed to fetch\" error messages with the host\n        // Possible messages we handle here:\n        // * \"Failed to fetch\" (chromium)\n        // * \"Load failed\" (webkit)\n        // * \"NetworkError when attempting to fetch resource.\" (firefox)\n        if (error instanceof TypeError && (error.message === 'Failed to fetch' || error.message === 'Load failed' || error.message === 'NetworkError when attempting to fetch resource.')) {\n          try {\n            const url = new URL(handlerData.fetchData.url);\n            error.message = `${error.message} (${url.host})`;\n          } catch {\n            // ignore it if errors happen here\n          }\n        }\n\n        // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n        //       it means the sentry.javascript SDK caught an error invoking your application code.\n        //       This is expected behavior and NOT indicative of a bug with sentry.javascript.\n        throw error;\n      });\n    };\n  });\n}\nasync function resolveResponse(res, onFinishedResolving) {\n  if (res?.body) {\n    const body = res.body;\n    const responseReader = body.getReader();\n\n    // Define a maximum duration after which we just cancel\n    const maxFetchDurationTimeout = setTimeout(() => {\n      body.cancel().then(null, () => {\n        // noop\n      });\n    }, 90 * 1000 // 90s\n    );\n    let readingActive = true;\n    while (readingActive) {\n      let chunkTimeout;\n      try {\n        // abort reading if read op takes more than 5s\n        chunkTimeout = setTimeout(() => {\n          body.cancel().then(null, () => {\n            // noop on error\n          });\n        }, 5000);\n\n        // This .read() call will reject/throw when we abort due to timeouts through `body.cancel()`\n        const {\n          done\n        } = await responseReader.read();\n        clearTimeout(chunkTimeout);\n        if (done) {\n          onFinishedResolving();\n          readingActive = false;\n        }\n      } catch {\n        readingActive = false;\n      } finally {\n        clearTimeout(chunkTimeout);\n      }\n    }\n    clearTimeout(maxFetchDurationTimeout);\n    responseReader.releaseLock();\n    body.cancel().then(null, () => {\n      // noop on error\n    });\n  }\n}\nfunction streamHandler(response) {\n  // clone response for awaiting stream\n  let clonedResponseForResolving;\n  try {\n    clonedResponseForResolving = response.clone();\n  } catch {\n    return;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  resolveResponse(clonedResponseForResolving, () => {\n    triggerHandlers('fetch-body-resolved', {\n      endTimestamp: timestampInSeconds() * 1000,\n      response\n    });\n  });\n}\nfunction hasProp(obj, prop) {\n  return !!obj && typeof obj === 'object' && !!obj[prop];\n}\nfunction getUrlFromResource(resource) {\n  if (typeof resource === 'string') {\n    return resource;\n  }\n  if (!resource) {\n    return '';\n  }\n  if (hasProp(resource, 'url')) {\n    return resource.url;\n  }\n  if (resource.toString) {\n    return resource.toString();\n  }\n  return '';\n}\n\n/**\n * Parses the fetch arguments to find the used Http method and the url of the request.\n * Exported for tests only.\n */\nfunction parseFetchArgs(fetchArgs) {\n  if (fetchArgs.length === 0) {\n    return {\n      method: 'GET',\n      url: ''\n    };\n  }\n  if (fetchArgs.length === 2) {\n    const [url, options] = fetchArgs;\n    return {\n      url: getUrlFromResource(url),\n      method: hasProp(options, 'method') ? String(options.method).toUpperCase() : 'GET'\n    };\n  }\n  const arg = fetchArgs[0];\n  return {\n    url: getUrlFromResource(arg),\n    method: hasProp(arg, 'method') ? String(arg.method).toUpperCase() : 'GET'\n  };\n}\nfunction getHeadersFromFetchArgs(fetchArgs) {\n  const [requestArgument, optionsArgument] = fetchArgs;\n  try {\n    if (typeof optionsArgument === 'object' && optionsArgument !== null && 'headers' in optionsArgument && optionsArgument.headers) {\n      return new Headers(optionsArgument.headers);\n    }\n    if (isRequest(requestArgument)) {\n      return new Headers(requestArgument.headers);\n    }\n  } catch {\n    // noop\n  }\n  return;\n}\nexport { addFetchEndInstrumentationHandler, addFetchInstrumentationHandler, parseFetchArgs };\n//# sourceMappingURL=fetch.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}