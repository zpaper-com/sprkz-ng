{"ast":null,"code":"import { makeOfflineTransport, parseEnvelope, serializeEnvelope } from '@sentry/core';\nimport { WINDOW } from '../helpers.js';\nimport { makeFetchTransport } from './fetch.js';\n\n// 'Store', 'promisifyRequest' and 'createStore' were originally copied from the 'idb-keyval' package before being\n// modified and simplified: https://github.com/jakearchibald/idb-keyval\n//\n// At commit: 0420a704fd6cbb4225429c536b1f61112d012fca\n// Original license:\n\n// Copyright 2016, Jake Archibald\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nfunction promisifyRequest(request) {\n  return new Promise((resolve, reject) => {\n    // @ts-expect-error - file size hacks\n    request.oncomplete = request.onsuccess = () => resolve(request.result);\n    // @ts-expect-error - file size hacks\n    request.onabort = request.onerror = () => reject(request.error);\n  });\n}\n\n/** Create or open an IndexedDb store */\nfunction createStore(dbName, storeName) {\n  const request = indexedDB.open(dbName);\n  request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n  const dbp = promisifyRequest(request);\n  return callback => dbp.then(db => callback(db.transaction(storeName, 'readwrite').objectStore(storeName)));\n}\nfunction keys(store) {\n  return promisifyRequest(store.getAllKeys());\n}\n\n/** Insert into the end of the store */\nfunction push(store, value, maxQueueSize) {\n  return store(store => {\n    return keys(store).then(keys => {\n      if (keys.length >= maxQueueSize) {\n        return;\n      }\n\n      // We insert with an incremented key so that the entries are popped in order\n      store.put(value, Math.max(...keys, 0) + 1);\n      return promisifyRequest(store.transaction);\n    });\n  });\n}\n\n/** Insert into the front of the store */\nfunction unshift(store, value, maxQueueSize) {\n  return store(store => {\n    return keys(store).then(keys => {\n      if (keys.length >= maxQueueSize) {\n        return;\n      }\n\n      // We insert with an decremented key so that the entries are popped in order\n      store.put(value, Math.min(...keys, 0) - 1);\n      return promisifyRequest(store.transaction);\n    });\n  });\n}\n\n/** Pop the oldest value from the store */\nfunction shift(store) {\n  return store(store => {\n    return keys(store).then(keys => {\n      const firstKey = keys[0];\n      if (firstKey == null) {\n        return undefined;\n      }\n      return promisifyRequest(store.get(firstKey)).then(value => {\n        store.delete(firstKey);\n        return promisifyRequest(store.transaction).then(() => value);\n      });\n    });\n  });\n}\nfunction createIndexedDbStore(options) {\n  let store;\n\n  // Lazily create the store only when it's needed\n  function getStore() {\n    if (store == undefined) {\n      store = createStore(options.dbName || 'sentry-offline', options.storeName || 'queue');\n    }\n    return store;\n  }\n  return {\n    push: async env => {\n      try {\n        const serialized = await serializeEnvelope(env);\n        await push(getStore(), serialized, options.maxQueueSize || 30);\n      } catch {\n        //\n      }\n    },\n    unshift: async env => {\n      try {\n        const serialized = await serializeEnvelope(env);\n        await unshift(getStore(), serialized, options.maxQueueSize || 30);\n      } catch {\n        //\n      }\n    },\n    shift: async () => {\n      try {\n        const deserialized = await shift(getStore());\n        if (deserialized) {\n          return parseEnvelope(deserialized);\n        }\n      } catch {\n        //\n      }\n      return undefined;\n    }\n  };\n}\nfunction makeIndexedDbOfflineTransport(createTransport) {\n  return options => {\n    const transport = createTransport({\n      ...options,\n      createStore: createIndexedDbStore\n    });\n    WINDOW.addEventListener('online', async _ => {\n      await transport.flush();\n    });\n    return transport;\n  };\n}\n\n/**\n * Creates a transport that uses IndexedDb to store events when offline.\n */\nfunction makeBrowserOfflineTransport(createTransport = makeFetchTransport) {\n  return makeIndexedDbOfflineTransport(makeOfflineTransport(createTransport));\n}\nexport { createStore, makeBrowserOfflineTransport, push, shift, unshift };","map":{"version":3,"names":["promisifyRequest","request","Promise","resolve","reject","oncomplete","onsuccess","result","onabort","onerror","error","createStore","dbName","storeName","indexedDB","open","onupgradeneeded","createObjectStore","dbp","callback","then","db","transaction","objectStore","keys","store","getAllKeys","push","value","maxQueueSize","length","put","Math","max","unshift","min","shift","firstKey","undefined","get","delete","createIndexedDbStore","options","getStore","env","serialized","serializeEnvelope","deserialized","parseEnvelope","makeIndexedDbOfflineTransport","createTransport","transport","WINDOW","addEventListener","_","flush","makeBrowserOfflineTransport","makeFetchTransport","makeOfflineTransport"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/browser/src/transports/offline.ts"],"sourcesContent":["import type { BaseTransportOptions, Envelope, OfflineStore, OfflineTransportOptions, Transport } from '@sentry/core';\nimport { makeOfflineTransport, parseEnvelope, serializeEnvelope } from '@sentry/core';\nimport { WINDOW } from '../helpers';\nimport { makeFetchTransport } from './fetch';\n\n// 'Store', 'promisifyRequest' and 'createStore' were originally copied from the 'idb-keyval' package before being\n// modified and simplified: https://github.com/jakearchibald/idb-keyval\n//\n// At commit: 0420a704fd6cbb4225429c536b1f61112d012fca\n// Original license:\n\n// Copyright 2016, Jake Archibald\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\ntype Store = <T>(callback: (store: IDBObjectStore) => T | PromiseLike<T>) => Promise<T>;\n\nfunction promisifyRequest<T = undefined>(request: IDBRequest<T> | IDBTransaction): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    // @ts-expect-error - file size hacks\n    request.oncomplete = request.onsuccess = () => resolve(request.result);\n    // @ts-expect-error - file size hacks\n    request.onabort = request.onerror = () => reject(request.error);\n  });\n}\n\n/** Create or open an IndexedDb store */\nexport function createStore(dbName: string, storeName: string): Store {\n  const request = indexedDB.open(dbName);\n  request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n  const dbp = promisifyRequest(request);\n\n  return callback => dbp.then(db => callback(db.transaction(storeName, 'readwrite').objectStore(storeName)));\n}\n\nfunction keys(store: IDBObjectStore): Promise<number[]> {\n  return promisifyRequest(store.getAllKeys() as IDBRequest<number[]>);\n}\n\n/** Insert into the end of the store */\nexport function push(store: Store, value: Uint8Array | string, maxQueueSize: number): Promise<void> {\n  return store(store => {\n    return keys(store).then(keys => {\n      if (keys.length >= maxQueueSize) {\n        return;\n      }\n\n      // We insert with an incremented key so that the entries are popped in order\n      store.put(value, Math.max(...keys, 0) + 1);\n      return promisifyRequest(store.transaction);\n    });\n  });\n}\n\n/** Insert into the front of the store */\nexport function unshift(store: Store, value: Uint8Array | string, maxQueueSize: number): Promise<void> {\n  return store(store => {\n    return keys(store).then(keys => {\n      if (keys.length >= maxQueueSize) {\n        return;\n      }\n\n      // We insert with an decremented key so that the entries are popped in order\n      store.put(value, Math.min(...keys, 0) - 1);\n      return promisifyRequest(store.transaction);\n    });\n  });\n}\n\n/** Pop the oldest value from the store */\nexport function shift(store: Store): Promise<Uint8Array | string | undefined> {\n  return store(store => {\n    return keys(store).then(keys => {\n      const firstKey = keys[0];\n      if (firstKey == null) {\n        return undefined;\n      }\n\n      return promisifyRequest(store.get(firstKey)).then(value => {\n        store.delete(firstKey);\n        return promisifyRequest(store.transaction).then(() => value);\n      });\n    });\n  });\n}\n\nexport interface BrowserOfflineTransportOptions extends Omit<OfflineTransportOptions, 'createStore'> {\n  /**\n   * Name of indexedDb database to store envelopes in\n   * Default: 'sentry-offline'\n   */\n  dbName?: string;\n  /**\n   * Name of indexedDb object store to store envelopes in\n   * Default: 'queue'\n   */\n  storeName?: string;\n  /**\n   * Maximum number of envelopes to store\n   * Default: 30\n   */\n  maxQueueSize?: number;\n}\n\nfunction createIndexedDbStore(options: BrowserOfflineTransportOptions): OfflineStore {\n  let store: Store | undefined;\n\n  // Lazily create the store only when it's needed\n  function getStore(): Store {\n    if (store == undefined) {\n      store = createStore(options.dbName || 'sentry-offline', options.storeName || 'queue');\n    }\n\n    return store;\n  }\n\n  return {\n    push: async (env: Envelope) => {\n      try {\n        const serialized = await serializeEnvelope(env);\n        await push(getStore(), serialized, options.maxQueueSize || 30);\n      } catch {\n        //\n      }\n    },\n    unshift: async (env: Envelope) => {\n      try {\n        const serialized = await serializeEnvelope(env);\n        await unshift(getStore(), serialized, options.maxQueueSize || 30);\n      } catch {\n        //\n      }\n    },\n    shift: async () => {\n      try {\n        const deserialized = await shift(getStore());\n        if (deserialized) {\n          return parseEnvelope(deserialized);\n        }\n      } catch {\n        //\n      }\n\n      return undefined;\n    },\n  };\n}\n\nfunction makeIndexedDbOfflineTransport<T>(\n  createTransport: (options: T) => Transport,\n): (options: T & BrowserOfflineTransportOptions) => Transport {\n  return options => {\n    const transport = createTransport({ ...options, createStore: createIndexedDbStore });\n\n    WINDOW.addEventListener('online', async _ => {\n      await transport.flush();\n    });\n\n    return transport;\n  };\n}\n\n/**\n * Creates a transport that uses IndexedDb to store events when offline.\n */\nexport function makeBrowserOfflineTransport<T extends BaseTransportOptions>(\n  createTransport: (options: T) => Transport = makeFetchTransport,\n): (options: T & BrowserOfflineTransportOptions) => Transport {\n  return makeIndexedDbOfflineTransport<T>(makeOfflineTransport(createTransport));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}