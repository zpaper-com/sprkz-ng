{"ast":null,"code":"import { browserTracingIntegration, WINDOW, startBrowserTracingPageLoadSpan, startBrowserTracingNavigationSpan } from '@sentry/browser';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, debug, getActiveSpan, getRootSpan, spanToJSON, getCurrentScope, getClient } from '@sentry/core';\nimport * as React from 'react';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { hoistNonReactStatics } from './hoist-non-react-statics.js';\n\n/* eslint-disable max-lines */\n// Inspired from Donnie McNeal's solution:\n// https://gist.github.com/wontondon/e8c4bdf2888875e4c755712e99279536\n\nlet _useEffect;\nlet _useLocation;\nlet _useNavigationType;\nlet _createRoutesFromChildren;\nlet _matchRoutes;\nlet _stripBasename = false;\nconst CLIENTS_WITH_INSTRUMENT_NAVIGATION = new WeakSet();\n\n// Keeping as a global variable for cross-usage in multiple functions\nconst allRoutes = new Set();\n\n/**\n * Creates a wrapCreateBrowserRouter function that can be used with all React Router v6 compatible versions.\n */\nfunction createV6CompatibleWrapCreateBrowserRouter(createRouterFunction, version) {\n  if (!_useEffect || !_useLocation || !_useNavigationType || !_matchRoutes) {\n    DEBUG_BUILD && debug.warn(`reactRouterV${version}Instrumentation was unable to wrap the \\`createRouter\\` function because of one or more missing parameters.`);\n    return createRouterFunction;\n  }\n  return function (routes, opts) {\n    addRoutesToAllRoutes(routes);\n    const router = createRouterFunction(routes, opts);\n    const basename = opts?.basename;\n    const activeRootSpan = getActiveRootSpan();\n\n    // The initial load ends when `createBrowserRouter` is called.\n    // This is the earliest convenient time to update the transaction name.\n    // Callbacks to `router.subscribe` are not called for the initial load.\n    if (router.state.historyAction === 'POP' && activeRootSpan) {\n      updatePageloadTransaction(activeRootSpan, router.state.location, routes, undefined, basename, Array.from(allRoutes));\n    }\n    router.subscribe(state => {\n      if (state.historyAction === 'PUSH' || state.historyAction === 'POP') {\n        // Wait for the next render if loading an unsettled route\n        if (state.navigation.state !== 'idle') {\n          requestAnimationFrame(() => {\n            handleNavigation({\n              location: state.location,\n              routes,\n              navigationType: state.historyAction,\n              version,\n              basename,\n              allRoutes: Array.from(allRoutes)\n            });\n          });\n        } else {\n          handleNavigation({\n            location: state.location,\n            routes,\n            navigationType: state.historyAction,\n            version,\n            basename,\n            allRoutes: Array.from(allRoutes)\n          });\n        }\n      }\n    });\n    return router;\n  };\n}\n\n/**\n * Creates a wrapCreateMemoryRouter function that can be used with all React Router v6 compatible versions.\n */\nfunction createV6CompatibleWrapCreateMemoryRouter(createRouterFunction, version) {\n  if (!_useEffect || !_useLocation || !_useNavigationType || !_matchRoutes) {\n    DEBUG_BUILD && debug.warn(`reactRouterV${version}Instrumentation was unable to wrap the \\`createMemoryRouter\\` function because of one or more missing parameters.`);\n    return createRouterFunction;\n  }\n  return function (routes, opts) {\n    addRoutesToAllRoutes(routes);\n    const router = createRouterFunction(routes, opts);\n    const basename = opts?.basename;\n    const activeRootSpan = getActiveRootSpan();\n    let initialEntry = undefined;\n    const initialEntries = opts?.initialEntries;\n    const initialIndex = opts?.initialIndex;\n    const hasOnlyOneInitialEntry = initialEntries && initialEntries.length === 1;\n    const hasIndexedEntry = initialIndex !== undefined && initialEntries && initialEntries[initialIndex];\n    initialEntry = hasOnlyOneInitialEntry ? initialEntries[0] : hasIndexedEntry ? initialEntries[initialIndex] : undefined;\n    const location = initialEntry ? typeof initialEntry === 'string' ? {\n      pathname: initialEntry\n    } : initialEntry : router.state.location;\n    if (router.state.historyAction === 'POP' && activeRootSpan) {\n      updatePageloadTransaction(activeRootSpan, location, routes, undefined, basename, Array.from(allRoutes));\n    }\n    router.subscribe(state => {\n      const location = state.location;\n      if (state.historyAction === 'PUSH' || state.historyAction === 'POP') {\n        handleNavigation({\n          location,\n          routes,\n          navigationType: state.historyAction,\n          version,\n          basename,\n          allRoutes: Array.from(allRoutes)\n        });\n      }\n    });\n    return router;\n  };\n}\n\n/**\n * Creates a browser tracing integration that can be used with all React Router v6 compatible versions.\n */\nfunction createReactRouterV6CompatibleTracingIntegration(options, version) {\n  const integration = browserTracingIntegration({\n    ...options,\n    instrumentPageLoad: false,\n    instrumentNavigation: false\n  });\n  const {\n    useEffect,\n    useLocation,\n    useNavigationType,\n    createRoutesFromChildren,\n    matchRoutes,\n    stripBasename,\n    instrumentPageLoad = true,\n    instrumentNavigation = true\n  } = options;\n  return {\n    ...integration,\n    setup(client) {\n      integration.setup(client);\n      _useEffect = useEffect;\n      _useLocation = useLocation;\n      _useNavigationType = useNavigationType;\n      _matchRoutes = matchRoutes;\n      _createRoutesFromChildren = createRoutesFromChildren;\n      _stripBasename = stripBasename || false;\n    },\n    afterAllSetup(client) {\n      integration.afterAllSetup(client);\n      const initPathName = WINDOW.location?.pathname;\n      if (instrumentPageLoad && initPathName) {\n        startBrowserTracingPageLoadSpan(client, {\n          name: initPathName,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'pageload',\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: `auto.pageload.react.reactrouter_v${version}`\n          }\n        });\n      }\n      if (instrumentNavigation) {\n        CLIENTS_WITH_INSTRUMENT_NAVIGATION.add(client);\n      }\n    }\n  };\n}\nfunction createV6CompatibleWrapUseRoutes(origUseRoutes, version) {\n  if (!_useEffect || !_useLocation || !_useNavigationType || !_matchRoutes) {\n    DEBUG_BUILD && debug.warn('reactRouterV6Instrumentation was unable to wrap `useRoutes` because of one or more missing parameters.');\n    return origUseRoutes;\n  }\n  const SentryRoutes = props => {\n    const isMountRenderPass = React.useRef(true);\n    const {\n      routes,\n      locationArg\n    } = props;\n    const Routes = origUseRoutes(routes, locationArg);\n    const location = _useLocation();\n    const navigationType = _useNavigationType();\n\n    // A value with stable identity to either pick `locationArg` if available or `location` if not\n    const stableLocationParam = typeof locationArg === 'string' || locationArg?.pathname ? locationArg : location;\n    _useEffect(() => {\n      const normalizedLocation = typeof stableLocationParam === 'string' ? {\n        pathname: stableLocationParam\n      } : stableLocationParam;\n      if (isMountRenderPass.current) {\n        addRoutesToAllRoutes(routes);\n        updatePageloadTransaction(getActiveRootSpan(), normalizedLocation, routes, undefined, undefined, Array.from(allRoutes));\n        isMountRenderPass.current = false;\n      } else {\n        handleNavigation({\n          location: normalizedLocation,\n          routes,\n          navigationType,\n          version,\n          allRoutes: Array.from(allRoutes)\n        });\n      }\n    }, [navigationType, stableLocationParam]);\n    return Routes;\n  };\n\n  // eslint-disable-next-line react/display-name\n  return (routes, locationArg) => {\n    return React.createElement(SentryRoutes, {\n      routes: routes,\n      locationArg: locationArg\n    });\n  };\n}\nfunction handleNavigation(opts) {\n  const {\n    location,\n    routes,\n    navigationType,\n    version,\n    matches,\n    basename,\n    allRoutes\n  } = opts;\n  const branches = Array.isArray(matches) ? matches : _matchRoutes(routes, location, basename);\n  const client = getClient();\n  if (!client || !CLIENTS_WITH_INSTRUMENT_NAVIGATION.has(client)) {\n    return;\n  }\n  if ((navigationType === 'PUSH' || navigationType === 'POP') && branches) {\n    let name,\n      source = 'url';\n    const isInDescendantRoute = locationIsInsideDescendantRoute(location, allRoutes || routes);\n    if (isInDescendantRoute) {\n      name = prefixWithSlash(rebuildRoutePathFromAllRoutes(allRoutes || routes, location));\n      source = 'route';\n    }\n    if (!isInDescendantRoute || !name) {\n      [name, source] = getNormalizedName(routes, location, branches, basename);\n    }\n    const activeSpan = getActiveSpan();\n    const isAlreadyInNavigationSpan = activeSpan && spanToJSON(activeSpan).op === 'navigation';\n\n    // Cross usage can result in multiple navigation spans being created without this check\n    if (isAlreadyInNavigationSpan) {\n      activeSpan?.updateName(name);\n      activeSpan?.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, source);\n    } else {\n      startBrowserTracingNavigationSpan(client, {\n        name,\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,\n          [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'navigation',\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: `auto.navigation.react.reactrouter_v${version}`\n        }\n      });\n    }\n  }\n}\n\n/**\n * Strip the basename from a pathname if exists.\n *\n * Vendored and modified from `react-router`\n * https://github.com/remix-run/react-router/blob/462bb712156a3f739d6139a0f14810b76b002df6/packages/router/utils.ts#L1038\n */\nfunction stripBasenameFromPathname(pathname, basename) {\n  if (!basename || basename === '/') {\n    return pathname;\n  }\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return pathname;\n  }\n\n  // We want to leave trailing slash behavior in the user's control, so if they\n  // specify a basename with a trailing slash, we should support it\n  const startIndex = basename.endsWith('/') ? basename.length - 1 : basename.length;\n  const nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== '/') {\n    // pathname does not start with basename/\n    return pathname;\n  }\n  return pathname.slice(startIndex) || '/';\n}\nfunction sendIndexPath(pathBuilder, pathname, basename) {\n  const reconstructedPath = pathBuilder || _stripBasename ? stripBasenameFromPathname(pathname, basename) : pathname;\n  const formattedPath =\n  // If the path ends with a slash, remove it\n  reconstructedPath[reconstructedPath.length - 1] === '/' ? reconstructedPath.slice(0, -1) :\n  // If the path ends with a wildcard, remove it\n  reconstructedPath.slice(-2) === '/*' ? reconstructedPath.slice(0, -1) : reconstructedPath;\n  return [formattedPath, 'route'];\n}\nfunction pathEndsWithWildcard(path) {\n  return path.endsWith('*');\n}\nfunction pathIsWildcardAndHasChildren(path, branch) {\n  return pathEndsWithWildcard(path) && !!branch.route.children?.length || false;\n}\nfunction routeIsDescendant(route) {\n  return !!(!route.children && route.element && route.path?.endsWith('/*'));\n}\nfunction locationIsInsideDescendantRoute(location, routes) {\n  const matchedRoutes = _matchRoutes(routes, location);\n  if (matchedRoutes) {\n    for (const match of matchedRoutes) {\n      if (routeIsDescendant(match.route) && pickSplat(match)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction addRoutesToAllRoutes(routes) {\n  routes.forEach(route => {\n    const extractedChildRoutes = getChildRoutesRecursively(route);\n    extractedChildRoutes.forEach(r => {\n      allRoutes.add(r);\n    });\n  });\n}\nfunction getChildRoutesRecursively(route, allRoutes = new Set()) {\n  if (!allRoutes.has(route)) {\n    allRoutes.add(route);\n    if (route.children && !route.index) {\n      route.children.forEach(child => {\n        const childRoutes = getChildRoutesRecursively(child, allRoutes);\n        childRoutes.forEach(r => {\n          allRoutes.add(r);\n        });\n      });\n    }\n  }\n  return allRoutes;\n}\nfunction pickPath(match) {\n  return trimWildcard(match.route.path || '');\n}\nfunction pickSplat(match) {\n  return match.params['*'] || '';\n}\nfunction trimWildcard(path) {\n  return path[path.length - 1] === '*' ? path.slice(0, -1) : path;\n}\nfunction trimSlash(path) {\n  return path[path.length - 1] === '/' ? path.slice(0, -1) : path;\n}\nfunction prefixWithSlash(path) {\n  return path[0] === '/' ? path : `/${path}`;\n}\nfunction rebuildRoutePathFromAllRoutes(allRoutes, location) {\n  const matchedRoutes = _matchRoutes(allRoutes, location);\n  if (!matchedRoutes || matchedRoutes.length === 0) {\n    return '';\n  }\n  for (const match of matchedRoutes) {\n    if (match.route.path && match.route.path !== '*') {\n      const path = pickPath(match);\n      const strippedPath = stripBasenameFromPathname(location.pathname, prefixWithSlash(match.pathnameBase));\n      if (location.pathname === strippedPath) {\n        return trimSlash(strippedPath);\n      }\n      return trimSlash(trimSlash(path || '') + prefixWithSlash(rebuildRoutePathFromAllRoutes(allRoutes.filter(route => route !== match.route), {\n        pathname: strippedPath\n      })));\n    }\n  }\n  return '';\n}\nfunction getNormalizedName(routes, location, branches, basename = '') {\n  if (!routes || routes.length === 0) {\n    return [_stripBasename ? stripBasenameFromPathname(location.pathname, basename) : location.pathname, 'url'];\n  }\n  let pathBuilder = '';\n  if (branches) {\n    for (const branch of branches) {\n      const route = branch.route;\n      if (route) {\n        // Early return if index route\n        if (route.index) {\n          return sendIndexPath(pathBuilder, branch.pathname, basename);\n        }\n        const path = route.path;\n\n        // If path is not a wildcard and has no child routes, append the path\n        if (path && !pathIsWildcardAndHasChildren(path, branch)) {\n          const newPath = path[0] === '/' || pathBuilder[pathBuilder.length - 1] === '/' ? path : `/${path}`;\n          pathBuilder = trimSlash(pathBuilder) + prefixWithSlash(newPath);\n\n          // If the path matches the current location, return the path\n          if (trimSlash(location.pathname) === trimSlash(basename + branch.pathname)) {\n            if (\n            // If the route defined on the element is something like\n            // <Route path=\"/stores/:storeId/products/:productId\" element={<div>Product</div>} />\n            // We should check against the branch.pathname for the number of / separators\n            getNumberOfUrlSegments(pathBuilder) !== getNumberOfUrlSegments(branch.pathname) &&\n            // We should not count wildcard operators in the url segments calculation\n            !pathEndsWithWildcard(pathBuilder)) {\n              return [(_stripBasename ? '' : basename) + newPath, 'route'];\n            }\n\n            // if the last character of the pathbuilder is a wildcard and there are children, remove the wildcard\n            if (pathIsWildcardAndHasChildren(pathBuilder, branch)) {\n              pathBuilder = pathBuilder.slice(0, -1);\n            }\n            return [(_stripBasename ? '' : basename) + pathBuilder, 'route'];\n          }\n        }\n      }\n    }\n  }\n  const fallbackTransactionName = _stripBasename ? stripBasenameFromPathname(location.pathname, basename) : location.pathname || '/';\n  return [fallbackTransactionName, 'url'];\n}\nfunction updatePageloadTransaction(activeRootSpan, location, routes, matches, basename, allRoutes) {\n  const branches = Array.isArray(matches) ? matches : _matchRoutes(allRoutes || routes, location, basename);\n  if (branches) {\n    let name,\n      source = 'url';\n    const isInDescendantRoute = locationIsInsideDescendantRoute(location, allRoutes || routes);\n    if (isInDescendantRoute) {\n      name = prefixWithSlash(rebuildRoutePathFromAllRoutes(allRoutes || routes, location));\n      source = 'route';\n    }\n    if (!isInDescendantRoute || !name) {\n      [name, source] = getNormalizedName(routes, location, branches, basename);\n    }\n    getCurrentScope().setTransactionName(name || '/');\n    if (activeRootSpan) {\n      activeRootSpan.updateName(name);\n      activeRootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, source);\n    }\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction createV6CompatibleWithSentryReactRouterRouting(Routes, version) {\n  if (!_useEffect || !_useLocation || !_useNavigationType || !_createRoutesFromChildren || !_matchRoutes) {\n    DEBUG_BUILD && debug.warn(`reactRouterV6Instrumentation was unable to wrap Routes because of one or more missing parameters.\n      useEffect: ${_useEffect}. useLocation: ${_useLocation}. useNavigationType: ${_useNavigationType}.\n      createRoutesFromChildren: ${_createRoutesFromChildren}. matchRoutes: ${_matchRoutes}.`);\n    return Routes;\n  }\n  const SentryRoutes = props => {\n    const isMountRenderPass = React.useRef(true);\n    const location = _useLocation();\n    const navigationType = _useNavigationType();\n    _useEffect(() => {\n      const routes = _createRoutesFromChildren(props.children);\n      if (isMountRenderPass.current) {\n        addRoutesToAllRoutes(routes);\n        updatePageloadTransaction(getActiveRootSpan(), location, routes, undefined, undefined, Array.from(allRoutes));\n        isMountRenderPass.current = false;\n      } else {\n        handleNavigation({\n          location,\n          routes,\n          navigationType,\n          version,\n          allRoutes: Array.from(allRoutes)\n        });\n      }\n    },\n    // `props.children` is purposely not included in the dependency array, because we do not want to re-run this effect\n    // when the children change. We only want to start transactions when the location or navigation type change.\n    [location, navigationType]);\n\n    // @ts-expect-error Setting more specific React Component typing for `R` generic above\n    // will break advanced type inference done by react router params\n    return React.createElement(Routes, {\n      ...props\n    });\n  };\n  hoistNonReactStatics(SentryRoutes, Routes);\n\n  // @ts-expect-error Setting more specific React Component typing for `R` generic above\n  // will break advanced type inference done by react router params\n  return SentryRoutes;\n}\nfunction getActiveRootSpan() {\n  const span = getActiveSpan();\n  const rootSpan = span ? getRootSpan(span) : undefined;\n  if (!rootSpan) {\n    return undefined;\n  }\n  const op = spanToJSON(rootSpan).op;\n\n  // Only use this root span if it is a pageload or navigation span\n  return op === 'navigation' || op === 'pageload' ? rootSpan : undefined;\n}\n\n/**\n * Returns number of URL segments of a passed string URL.\n */\nfunction getNumberOfUrlSegments(url) {\n  // split at '/' or at '\\/' to split regex urls correctly\n  return url.split(/\\\\?\\//).filter(s => s.length > 0 && s !== ',').length;\n}\nexport { createReactRouterV6CompatibleTracingIntegration, createV6CompatibleWithSentryReactRouterRouting, createV6CompatibleWrapCreateBrowserRouter, createV6CompatibleWrapCreateMemoryRouter, createV6CompatibleWrapUseRoutes, getNumberOfUrlSegments, handleNavigation };","map":{"version":3,"names":["_useEffect","_useLocation","_useNavigationType","_createRoutesFromChildren","_matchRoutes","_stripBasename","CLIENTS_WITH_INSTRUMENT_NAVIGATION","WeakSet","allRoutes","Set","createV6CompatibleWrapCreateBrowserRouter","createRouterFunction","version","DEBUG_BUILD","debug","warn","routes","opts","addRoutesToAllRoutes","router","basename","activeRootSpan","getActiveRootSpan","state","historyAction","updatePageloadTransaction","location","undefined","Array","from","subscribe","navigation","requestAnimationFrame","handleNavigation","navigationType","createV6CompatibleWrapCreateMemoryRouter","initialEntry","initialEntries","initialIndex","hasOnlyOneInitialEntry","length","hasIndexedEntry","pathname","createReactRouterV6CompatibleTracingIntegration","options","integration","browserTracingIntegration","instrumentPageLoad","instrumentNavigation","useEffect","useLocation","useNavigationType","createRoutesFromChildren","matchRoutes","stripBasename","setup","client","afterAllSetup","initPathName","WINDOW","startBrowserTracingPageLoadSpan","name","attributes","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","SEMANTIC_ATTRIBUTE_SENTRY_OP","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","add","createV6CompatibleWrapUseRoutes","origUseRoutes","SentryRoutes","props","isMountRenderPass","React","useRef","locationArg","Routes","stableLocationParam","normalizedLocation","current","createElement","matches","branches","isArray","getClient","has","source","isInDescendantRoute","locationIsInsideDescendantRoute","prefixWithSlash","rebuildRoutePathFromAllRoutes","getNormalizedName","activeSpan","getActiveSpan","isAlreadyInNavigationSpan","spanToJSON","op","updateName","setAttribute","startBrowserTracingNavigationSpan","stripBasenameFromPathname","toLowerCase","startsWith","startIndex","endsWith","nextChar","charAt","slice","sendIndexPath","pathBuilder","reconstructedPath","formattedPath","pathEndsWithWildcard","path","pathIsWildcardAndHasChildren","branch","route","children","routeIsDescendant","element","matchedRoutes","match","pickSplat","forEach","extractedChildRoutes","getChildRoutesRecursively","r","index","child","childRoutes","pickPath","trimWildcard","params","trimSlash","strippedPath","pathnameBase","filter","newPath","getNumberOfUrlSegments","fallbackTransactionName","getCurrentScope","setTransactionName","createV6CompatibleWithSentryReactRouterRouting","hoistNonReactStatics","span","rootSpan","getRootSpan","url","split","s"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/react/src/reactrouterv6-compat-utils.tsx"],"sourcesContent":["/* eslint-disable max-lines */\n// Inspired from Donnie McNeal's solution:\n// https://gist.github.com/wontondon/e8c4bdf2888875e4c755712e99279536\n\nimport {\n  browserTracingIntegration,\n  startBrowserTracingNavigationSpan,\n  startBrowserTracingPageLoadSpan,\n  WINDOW,\n} from '@sentry/browser';\nimport type { Client, Integration, Span, TransactionSource } from '@sentry/core';\nimport {\n  debug,\n  getActiveSpan,\n  getClient,\n  getCurrentScope,\n  getRootSpan,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  spanToJSON,\n} from '@sentry/core';\nimport * as React from 'react';\nimport { DEBUG_BUILD } from './debug-build';\nimport { hoistNonReactStatics } from './hoist-non-react-statics';\nimport type {\n  Action,\n  AgnosticDataRouteMatch,\n  CreateRouterFunction,\n  CreateRoutesFromChildren,\n  Location,\n  MatchRoutes,\n  RouteMatch,\n  RouteObject,\n  Router,\n  RouterState,\n  UseEffect,\n  UseLocation,\n  UseNavigationType,\n  UseRoutes,\n} from './types';\n\nlet _useEffect: UseEffect;\nlet _useLocation: UseLocation;\nlet _useNavigationType: UseNavigationType;\nlet _createRoutesFromChildren: CreateRoutesFromChildren;\nlet _matchRoutes: MatchRoutes;\nlet _stripBasename: boolean = false;\n\nconst CLIENTS_WITH_INSTRUMENT_NAVIGATION = new WeakSet<Client>();\n\nexport interface ReactRouterOptions {\n  useEffect: UseEffect;\n  useLocation: UseLocation;\n  useNavigationType: UseNavigationType;\n  createRoutesFromChildren: CreateRoutesFromChildren;\n  matchRoutes: MatchRoutes;\n  stripBasename?: boolean;\n}\n\ntype V6CompatibleVersion = '6' | '7';\n\n// Keeping as a global variable for cross-usage in multiple functions\nconst allRoutes = new Set<RouteObject>();\n\n/**\n * Creates a wrapCreateBrowserRouter function that can be used with all React Router v6 compatible versions.\n */\nexport function createV6CompatibleWrapCreateBrowserRouter<\n  TState extends RouterState = RouterState,\n  TRouter extends Router<TState> = Router<TState>,\n>(\n  createRouterFunction: CreateRouterFunction<TState, TRouter>,\n  version: V6CompatibleVersion,\n): CreateRouterFunction<TState, TRouter> {\n  if (!_useEffect || !_useLocation || !_useNavigationType || !_matchRoutes) {\n    DEBUG_BUILD &&\n      debug.warn(\n        `reactRouterV${version}Instrumentation was unable to wrap the \\`createRouter\\` function because of one or more missing parameters.`,\n      );\n\n    return createRouterFunction;\n  }\n\n  return function (routes: RouteObject[], opts?: Record<string, unknown> & { basename?: string }): TRouter {\n    addRoutesToAllRoutes(routes);\n\n    const router = createRouterFunction(routes, opts);\n    const basename = opts?.basename;\n\n    const activeRootSpan = getActiveRootSpan();\n\n    // The initial load ends when `createBrowserRouter` is called.\n    // This is the earliest convenient time to update the transaction name.\n    // Callbacks to `router.subscribe` are not called for the initial load.\n    if (router.state.historyAction === 'POP' && activeRootSpan) {\n      updatePageloadTransaction(\n        activeRootSpan,\n        router.state.location,\n        routes,\n        undefined,\n        basename,\n        Array.from(allRoutes),\n      );\n    }\n\n    router.subscribe((state: RouterState) => {\n      if (state.historyAction === 'PUSH' || state.historyAction === 'POP') {\n        // Wait for the next render if loading an unsettled route\n        if (state.navigation.state !== 'idle') {\n          requestAnimationFrame(() => {\n            handleNavigation({\n              location: state.location,\n              routes,\n              navigationType: state.historyAction,\n              version,\n              basename,\n              allRoutes: Array.from(allRoutes),\n            });\n          });\n        } else {\n          handleNavigation({\n            location: state.location,\n            routes,\n            navigationType: state.historyAction,\n            version,\n            basename,\n            allRoutes: Array.from(allRoutes),\n          });\n        }\n      }\n    });\n\n    return router;\n  };\n}\n\n/**\n * Creates a wrapCreateMemoryRouter function that can be used with all React Router v6 compatible versions.\n */\nexport function createV6CompatibleWrapCreateMemoryRouter<\n  TState extends RouterState = RouterState,\n  TRouter extends Router<TState> = Router<TState>,\n>(\n  createRouterFunction: CreateRouterFunction<TState, TRouter>,\n  version: V6CompatibleVersion,\n): CreateRouterFunction<TState, TRouter> {\n  if (!_useEffect || !_useLocation || !_useNavigationType || !_matchRoutes) {\n    DEBUG_BUILD &&\n      debug.warn(\n        `reactRouterV${version}Instrumentation was unable to wrap the \\`createMemoryRouter\\` function because of one or more missing parameters.`,\n      );\n\n    return createRouterFunction;\n  }\n\n  return function (\n    routes: RouteObject[],\n    opts?: Record<string, unknown> & {\n      basename?: string;\n      initialEntries?: (string | { pathname: string })[];\n      initialIndex?: number;\n    },\n  ): TRouter {\n    addRoutesToAllRoutes(routes);\n\n    const router = createRouterFunction(routes, opts);\n    const basename = opts?.basename;\n\n    const activeRootSpan = getActiveRootSpan();\n    let initialEntry = undefined;\n\n    const initialEntries = opts?.initialEntries;\n    const initialIndex = opts?.initialIndex;\n\n    const hasOnlyOneInitialEntry = initialEntries && initialEntries.length === 1;\n    const hasIndexedEntry = initialIndex !== undefined && initialEntries && initialEntries[initialIndex];\n\n    initialEntry = hasOnlyOneInitialEntry\n      ? initialEntries[0]\n      : hasIndexedEntry\n        ? initialEntries[initialIndex]\n        : undefined;\n\n    const location = initialEntry\n      ? typeof initialEntry === 'string'\n        ? { pathname: initialEntry }\n        : initialEntry\n      : router.state.location;\n\n    if (router.state.historyAction === 'POP' && activeRootSpan) {\n      updatePageloadTransaction(activeRootSpan, location, routes, undefined, basename, Array.from(allRoutes));\n    }\n\n    router.subscribe((state: RouterState) => {\n      const location = state.location;\n      if (state.historyAction === 'PUSH' || state.historyAction === 'POP') {\n        handleNavigation({\n          location,\n          routes,\n          navigationType: state.historyAction,\n          version,\n          basename,\n          allRoutes: Array.from(allRoutes),\n        });\n      }\n    });\n\n    return router;\n  };\n}\n\n/**\n * Creates a browser tracing integration that can be used with all React Router v6 compatible versions.\n */\nexport function createReactRouterV6CompatibleTracingIntegration(\n  options: Parameters<typeof browserTracingIntegration>[0] & ReactRouterOptions,\n  version: V6CompatibleVersion,\n): Integration {\n  const integration = browserTracingIntegration({\n    ...options,\n    instrumentPageLoad: false,\n    instrumentNavigation: false,\n  });\n\n  const {\n    useEffect,\n    useLocation,\n    useNavigationType,\n    createRoutesFromChildren,\n    matchRoutes,\n    stripBasename,\n    instrumentPageLoad = true,\n    instrumentNavigation = true,\n  } = options;\n\n  return {\n    ...integration,\n    setup(client) {\n      integration.setup(client);\n\n      _useEffect = useEffect;\n      _useLocation = useLocation;\n      _useNavigationType = useNavigationType;\n      _matchRoutes = matchRoutes;\n      _createRoutesFromChildren = createRoutesFromChildren;\n      _stripBasename = stripBasename || false;\n    },\n    afterAllSetup(client) {\n      integration.afterAllSetup(client);\n\n      const initPathName = WINDOW.location?.pathname;\n      if (instrumentPageLoad && initPathName) {\n        startBrowserTracingPageLoadSpan(client, {\n          name: initPathName,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'pageload',\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: `auto.pageload.react.reactrouter_v${version}`,\n          },\n        });\n      }\n\n      if (instrumentNavigation) {\n        CLIENTS_WITH_INSTRUMENT_NAVIGATION.add(client);\n      }\n    },\n  };\n}\n\nexport function createV6CompatibleWrapUseRoutes(origUseRoutes: UseRoutes, version: V6CompatibleVersion): UseRoutes {\n  if (!_useEffect || !_useLocation || !_useNavigationType || !_matchRoutes) {\n    DEBUG_BUILD &&\n      debug.warn(\n        'reactRouterV6Instrumentation was unable to wrap `useRoutes` because of one or more missing parameters.',\n      );\n\n    return origUseRoutes;\n  }\n\n  const SentryRoutes: React.FC<{\n    children?: React.ReactNode;\n    routes: RouteObject[];\n    locationArg?: Partial<Location> | string;\n  }> = (props: { children?: React.ReactNode; routes: RouteObject[]; locationArg?: Partial<Location> | string }) => {\n    const isMountRenderPass = React.useRef(true);\n    const { routes, locationArg } = props;\n\n    const Routes = origUseRoutes(routes, locationArg);\n\n    const location = _useLocation();\n    const navigationType = _useNavigationType();\n\n    // A value with stable identity to either pick `locationArg` if available or `location` if not\n    const stableLocationParam =\n      typeof locationArg === 'string' || locationArg?.pathname ? (locationArg as { pathname: string }) : location;\n\n    _useEffect(() => {\n      const normalizedLocation =\n        typeof stableLocationParam === 'string' ? { pathname: stableLocationParam } : stableLocationParam;\n\n      if (isMountRenderPass.current) {\n        addRoutesToAllRoutes(routes);\n\n        updatePageloadTransaction(\n          getActiveRootSpan(),\n          normalizedLocation,\n          routes,\n          undefined,\n          undefined,\n          Array.from(allRoutes),\n        );\n        isMountRenderPass.current = false;\n      } else {\n        handleNavigation({\n          location: normalizedLocation,\n          routes,\n          navigationType,\n          version,\n          allRoutes: Array.from(allRoutes),\n        });\n      }\n    }, [navigationType, stableLocationParam]);\n\n    return Routes;\n  };\n\n  // eslint-disable-next-line react/display-name\n  return (routes: RouteObject[], locationArg?: Partial<Location> | string): React.ReactElement | null => {\n    return <SentryRoutes routes={routes} locationArg={locationArg} />;\n  };\n}\n\nexport function handleNavigation(opts: {\n  location: Location;\n  routes: RouteObject[];\n  navigationType: Action;\n  version: V6CompatibleVersion;\n  matches?: AgnosticDataRouteMatch;\n  basename?: string;\n  allRoutes?: RouteObject[];\n}): void {\n  const { location, routes, navigationType, version, matches, basename, allRoutes } = opts;\n  const branches = Array.isArray(matches) ? matches : _matchRoutes(routes, location, basename);\n\n  const client = getClient();\n  if (!client || !CLIENTS_WITH_INSTRUMENT_NAVIGATION.has(client)) {\n    return;\n  }\n\n  if ((navigationType === 'PUSH' || navigationType === 'POP') && branches) {\n    let name,\n      source: TransactionSource = 'url';\n    const isInDescendantRoute = locationIsInsideDescendantRoute(location, allRoutes || routes);\n\n    if (isInDescendantRoute) {\n      name = prefixWithSlash(rebuildRoutePathFromAllRoutes(allRoutes || routes, location));\n      source = 'route';\n    }\n\n    if (!isInDescendantRoute || !name) {\n      [name, source] = getNormalizedName(routes, location, branches, basename);\n    }\n\n    const activeSpan = getActiveSpan();\n    const isAlreadyInNavigationSpan = activeSpan && spanToJSON(activeSpan).op === 'navigation';\n\n    // Cross usage can result in multiple navigation spans being created without this check\n    if (isAlreadyInNavigationSpan) {\n      activeSpan?.updateName(name);\n      activeSpan?.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, source);\n    } else {\n      startBrowserTracingNavigationSpan(client, {\n        name,\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,\n          [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'navigation',\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: `auto.navigation.react.reactrouter_v${version}`,\n        },\n      });\n    }\n  }\n}\n\n/**\n * Strip the basename from a pathname if exists.\n *\n * Vendored and modified from `react-router`\n * https://github.com/remix-run/react-router/blob/462bb712156a3f739d6139a0f14810b76b002df6/packages/router/utils.ts#L1038\n */\nfunction stripBasenameFromPathname(pathname: string, basename: string): string {\n  if (!basename || basename === '/') {\n    return pathname;\n  }\n\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return pathname;\n  }\n\n  // We want to leave trailing slash behavior in the user's control, so if they\n  // specify a basename with a trailing slash, we should support it\n  const startIndex = basename.endsWith('/') ? basename.length - 1 : basename.length;\n  const nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== '/') {\n    // pathname does not start with basename/\n    return pathname;\n  }\n\n  return pathname.slice(startIndex) || '/';\n}\n\nfunction sendIndexPath(pathBuilder: string, pathname: string, basename: string): [string, TransactionSource] {\n  const reconstructedPath = pathBuilder || _stripBasename ? stripBasenameFromPathname(pathname, basename) : pathname;\n\n  const formattedPath =\n    // If the path ends with a slash, remove it\n    reconstructedPath[reconstructedPath.length - 1] === '/'\n      ? reconstructedPath.slice(0, -1)\n      : // If the path ends with a wildcard, remove it\n        reconstructedPath.slice(-2) === '/*'\n        ? reconstructedPath.slice(0, -1)\n        : reconstructedPath;\n\n  return [formattedPath, 'route'];\n}\n\nfunction pathEndsWithWildcard(path: string): boolean {\n  return path.endsWith('*');\n}\n\nfunction pathIsWildcardAndHasChildren(path: string, branch: RouteMatch<string>): boolean {\n  return (pathEndsWithWildcard(path) && !!branch.route.children?.length) || false;\n}\n\nfunction routeIsDescendant(route: RouteObject): boolean {\n  return !!(!route.children && route.element && route.path?.endsWith('/*'));\n}\n\nfunction locationIsInsideDescendantRoute(location: Location, routes: RouteObject[]): boolean {\n  const matchedRoutes = _matchRoutes(routes, location) as RouteMatch[];\n\n  if (matchedRoutes) {\n    for (const match of matchedRoutes) {\n      if (routeIsDescendant(match.route) && pickSplat(match)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction addRoutesToAllRoutes(routes: RouteObject[]): void {\n  routes.forEach(route => {\n    const extractedChildRoutes = getChildRoutesRecursively(route);\n\n    extractedChildRoutes.forEach(r => {\n      allRoutes.add(r);\n    });\n  });\n}\n\nfunction getChildRoutesRecursively(route: RouteObject, allRoutes: Set<RouteObject> = new Set()): Set<RouteObject> {\n  if (!allRoutes.has(route)) {\n    allRoutes.add(route);\n\n    if (route.children && !route.index) {\n      route.children.forEach(child => {\n        const childRoutes = getChildRoutesRecursively(child, allRoutes);\n\n        childRoutes.forEach(r => {\n          allRoutes.add(r);\n        });\n      });\n    }\n  }\n\n  return allRoutes;\n}\n\nfunction pickPath(match: RouteMatch): string {\n  return trimWildcard(match.route.path || '');\n}\n\nfunction pickSplat(match: RouteMatch): string {\n  return match.params['*'] || '';\n}\n\nfunction trimWildcard(path: string): string {\n  return path[path.length - 1] === '*' ? path.slice(0, -1) : path;\n}\n\nfunction trimSlash(path: string): string {\n  return path[path.length - 1] === '/' ? path.slice(0, -1) : path;\n}\n\nfunction prefixWithSlash(path: string): string {\n  return path[0] === '/' ? path : `/${path}`;\n}\n\nfunction rebuildRoutePathFromAllRoutes(allRoutes: RouteObject[], location: Location): string {\n  const matchedRoutes = _matchRoutes(allRoutes, location) as RouteMatch[];\n\n  if (!matchedRoutes || matchedRoutes.length === 0) {\n    return '';\n  }\n\n  for (const match of matchedRoutes) {\n    if (match.route.path && match.route.path !== '*') {\n      const path = pickPath(match);\n      const strippedPath = stripBasenameFromPathname(location.pathname, prefixWithSlash(match.pathnameBase));\n\n      if (location.pathname === strippedPath) {\n        return trimSlash(strippedPath);\n      }\n\n      return trimSlash(\n        trimSlash(path || '') +\n          prefixWithSlash(\n            rebuildRoutePathFromAllRoutes(\n              allRoutes.filter(route => route !== match.route),\n              {\n                pathname: strippedPath,\n              },\n            ),\n          ),\n      );\n    }\n  }\n\n  return '';\n}\n\nfunction getNormalizedName(\n  routes: RouteObject[],\n  location: Location,\n  branches: RouteMatch[],\n  basename: string = '',\n): [string, TransactionSource] {\n  if (!routes || routes.length === 0) {\n    return [_stripBasename ? stripBasenameFromPathname(location.pathname, basename) : location.pathname, 'url'];\n  }\n\n  let pathBuilder = '';\n  if (branches) {\n    for (const branch of branches) {\n      const route = branch.route;\n      if (route) {\n        // Early return if index route\n        if (route.index) {\n          return sendIndexPath(pathBuilder, branch.pathname, basename);\n        }\n        const path = route.path;\n\n        // If path is not a wildcard and has no child routes, append the path\n        if (path && !pathIsWildcardAndHasChildren(path, branch)) {\n          const newPath = path[0] === '/' || pathBuilder[pathBuilder.length - 1] === '/' ? path : `/${path}`;\n          pathBuilder = trimSlash(pathBuilder) + prefixWithSlash(newPath);\n\n          // If the path matches the current location, return the path\n          if (trimSlash(location.pathname) === trimSlash(basename + branch.pathname)) {\n            if (\n              // If the route defined on the element is something like\n              // <Route path=\"/stores/:storeId/products/:productId\" element={<div>Product</div>} />\n              // We should check against the branch.pathname for the number of / separators\n              getNumberOfUrlSegments(pathBuilder) !== getNumberOfUrlSegments(branch.pathname) &&\n              // We should not count wildcard operators in the url segments calculation\n              !pathEndsWithWildcard(pathBuilder)\n            ) {\n              return [(_stripBasename ? '' : basename) + newPath, 'route'];\n            }\n\n            // if the last character of the pathbuilder is a wildcard and there are children, remove the wildcard\n            if (pathIsWildcardAndHasChildren(pathBuilder, branch)) {\n              pathBuilder = pathBuilder.slice(0, -1);\n            }\n\n            return [(_stripBasename ? '' : basename) + pathBuilder, 'route'];\n          }\n        }\n      }\n    }\n  }\n\n  const fallbackTransactionName = _stripBasename\n    ? stripBasenameFromPathname(location.pathname, basename)\n    : location.pathname || '/';\n\n  return [fallbackTransactionName, 'url'];\n}\n\nfunction updatePageloadTransaction(\n  activeRootSpan: Span | undefined,\n  location: Location,\n  routes: RouteObject[],\n  matches?: AgnosticDataRouteMatch,\n  basename?: string,\n  allRoutes?: RouteObject[],\n): void {\n  const branches = Array.isArray(matches)\n    ? matches\n    : (_matchRoutes(allRoutes || routes, location, basename) as unknown as RouteMatch[]);\n\n  if (branches) {\n    let name,\n      source: TransactionSource = 'url';\n\n    const isInDescendantRoute = locationIsInsideDescendantRoute(location, allRoutes || routes);\n\n    if (isInDescendantRoute) {\n      name = prefixWithSlash(rebuildRoutePathFromAllRoutes(allRoutes || routes, location));\n      source = 'route';\n    }\n\n    if (!isInDescendantRoute || !name) {\n      [name, source] = getNormalizedName(routes, location, branches, basename);\n    }\n\n    getCurrentScope().setTransactionName(name || '/');\n\n    if (activeRootSpan) {\n      activeRootSpan.updateName(name);\n      activeRootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, source);\n    }\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function createV6CompatibleWithSentryReactRouterRouting<P extends Record<string, any>, R extends React.FC<P>>(\n  Routes: R,\n  version: V6CompatibleVersion,\n): R {\n  if (!_useEffect || !_useLocation || !_useNavigationType || !_createRoutesFromChildren || !_matchRoutes) {\n    DEBUG_BUILD &&\n      debug.warn(`reactRouterV6Instrumentation was unable to wrap Routes because of one or more missing parameters.\n      useEffect: ${_useEffect}. useLocation: ${_useLocation}. useNavigationType: ${_useNavigationType}.\n      createRoutesFromChildren: ${_createRoutesFromChildren}. matchRoutes: ${_matchRoutes}.`);\n\n    return Routes;\n  }\n\n  const SentryRoutes: React.FC<P> = (props: P) => {\n    const isMountRenderPass = React.useRef(true);\n\n    const location = _useLocation();\n    const navigationType = _useNavigationType();\n\n    _useEffect(\n      () => {\n        const routes = _createRoutesFromChildren(props.children) as RouteObject[];\n\n        if (isMountRenderPass.current) {\n          addRoutesToAllRoutes(routes);\n\n          updatePageloadTransaction(getActiveRootSpan(), location, routes, undefined, undefined, Array.from(allRoutes));\n          isMountRenderPass.current = false;\n        } else {\n          handleNavigation({\n            location,\n            routes,\n            navigationType,\n            version,\n            allRoutes: Array.from(allRoutes),\n          });\n        }\n      },\n      // `props.children` is purposely not included in the dependency array, because we do not want to re-run this effect\n      // when the children change. We only want to start transactions when the location or navigation type change.\n      [location, navigationType],\n    );\n\n    // @ts-expect-error Setting more specific React Component typing for `R` generic above\n    // will break advanced type inference done by react router params\n    return <Routes {...props} />;\n  };\n\n  hoistNonReactStatics(SentryRoutes, Routes);\n\n  // @ts-expect-error Setting more specific React Component typing for `R` generic above\n  // will break advanced type inference done by react router params\n  return SentryRoutes;\n}\n\nfunction getActiveRootSpan(): Span | undefined {\n  const span = getActiveSpan();\n  const rootSpan = span ? getRootSpan(span) : undefined;\n\n  if (!rootSpan) {\n    return undefined;\n  }\n\n  const op = spanToJSON(rootSpan).op;\n\n  // Only use this root span if it is a pageload or navigation span\n  return op === 'navigation' || op === 'pageload' ? rootSpan : undefined;\n}\n\n/**\n * Returns number of URL segments of a passed string URL.\n */\nexport function getNumberOfUrlSegments(url: string): number {\n  // split at '/' or at '\\/' to split regex urls correctly\n  return url.split(/\\\\?\\//).filter(s => s.length > 0 && s !== ',').length;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}