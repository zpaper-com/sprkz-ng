{"ast":null,"code":"import { getDefaultCurrentScope, getDefaultIsolationScope } from '../defaultScopes.js';\nimport { Scope } from '../scope.js';\nimport { isThenable } from '../utils/is.js';\nimport { getMainCarrier, getSentryCarrier } from '../carrier.js';\n\n/**\n * This is an object that holds a stack of scopes.\n */\nclass AsyncContextStack {\n  constructor(scope, isolationScope) {\n    let assignedScope;\n    if (!scope) {\n      assignedScope = new Scope();\n    } else {\n      assignedScope = scope;\n    }\n    let assignedIsolationScope;\n    if (!isolationScope) {\n      assignedIsolationScope = new Scope();\n    } else {\n      assignedIsolationScope = isolationScope;\n    }\n\n    // scope stack for domains or the process\n    this._stack = [{\n      scope: assignedScope\n    }];\n    this._isolationScope = assignedIsolationScope;\n  }\n\n  /**\n   * Fork a scope for the stack.\n   */\n  withScope(callback) {\n    const scope = this._pushScope();\n    let maybePromiseResult;\n    try {\n      maybePromiseResult = callback(scope);\n    } catch (e) {\n      this._popScope();\n      throw e;\n    }\n    if (isThenable(maybePromiseResult)) {\n      // @ts-expect-error - isThenable returns the wrong type\n      return maybePromiseResult.then(res => {\n        this._popScope();\n        return res;\n      }, e => {\n        this._popScope();\n        throw e;\n      });\n    }\n    this._popScope();\n    return maybePromiseResult;\n  }\n\n  /**\n   * Get the client of the stack.\n   */\n  getClient() {\n    return this.getStackTop().client;\n  }\n\n  /**\n   * Returns the scope of the top stack.\n   */\n  getScope() {\n    return this.getStackTop().scope;\n  }\n\n  /**\n   * Get the isolation scope for the stack.\n   */\n  getIsolationScope() {\n    return this._isolationScope;\n  }\n\n  /**\n   * Returns the topmost scope layer in the order domain > local > process.\n   */\n  getStackTop() {\n    return this._stack[this._stack.length - 1];\n  }\n\n  /**\n   * Push a scope to the stack.\n   */\n  _pushScope() {\n    // We want to clone the content of prev scope\n    const scope = this.getScope().clone();\n    this._stack.push({\n      client: this.getClient(),\n      scope\n    });\n    return scope;\n  }\n\n  /**\n   * Pop a scope from the stack.\n   */\n  _popScope() {\n    if (this._stack.length <= 1) return false;\n    return !!this._stack.pop();\n  }\n}\n\n/**\n * Get the global async context stack.\n * This will be removed during the v8 cycle and is only here to make migration easier.\n */\nfunction getAsyncContextStack() {\n  const registry = getMainCarrier();\n  const sentry = getSentryCarrier(registry);\n  return sentry.stack = sentry.stack || new AsyncContextStack(getDefaultCurrentScope(), getDefaultIsolationScope());\n}\nfunction withScope(callback) {\n  return getAsyncContextStack().withScope(callback);\n}\nfunction withSetScope(scope, callback) {\n  const stack = getAsyncContextStack();\n  return stack.withScope(() => {\n    stack.getStackTop().scope = scope;\n    return callback(scope);\n  });\n}\nfunction withIsolationScope(callback) {\n  return getAsyncContextStack().withScope(() => {\n    return callback(getAsyncContextStack().getIsolationScope());\n  });\n}\n\n/**\n * Get the stack-based async context strategy.\n */\nfunction getStackAsyncContextStrategy() {\n  return {\n    withIsolationScope,\n    withScope,\n    withSetScope,\n    withSetIsolationScope: (_isolationScope, callback) => {\n      return withIsolationScope(callback);\n    },\n    getCurrentScope: () => getAsyncContextStack().getScope(),\n    getIsolationScope: () => getAsyncContextStack().getIsolationScope()\n  };\n}\nexport { AsyncContextStack, getStackAsyncContextStrategy };","map":{"version":3,"names":["AsyncContextStack","constructor","scope","isolationScope","assignedScope","Scope","assignedIsolationScope","_stack","_isolationScope","withScope","callback","_pushScope","maybePromiseResult","e","_popScope","isThenable","then","res","getClient","getStackTop","client","getScope","getIsolationScope","length","clone","push","pop","getAsyncContextStack","registry","getMainCarrier","sentry","getSentryCarrier","stack","getDefaultCurrentScope","getDefaultIsolationScope","withSetScope","withIsolationScope","getStackAsyncContextStrategy","withSetIsolationScope","getCurrentScope"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/asyncContext/stackStrategy.ts"],"sourcesContent":["import type { Client } from '../client';\nimport { getDefaultCurrentScope, getDefaultIsolationScope } from '../defaultScopes';\nimport { Scope } from '../scope';\nimport { isThenable } from '../utils/is';\nimport { getMainCarrier, getSentryCarrier } from './../carrier';\nimport type { AsyncContextStrategy } from './types';\n\ninterface Layer {\n  client?: Client;\n  scope: Scope;\n}\n\n/**\n * This is an object that holds a stack of scopes.\n */\nexport class AsyncContextStack {\n  private readonly _stack: [Layer, ...Layer[]];\n  private _isolationScope: Scope;\n\n  public constructor(scope?: Scope, isolationScope?: Scope) {\n    let assignedScope;\n    if (!scope) {\n      assignedScope = new Scope();\n    } else {\n      assignedScope = scope;\n    }\n\n    let assignedIsolationScope;\n    if (!isolationScope) {\n      assignedIsolationScope = new Scope();\n    } else {\n      assignedIsolationScope = isolationScope;\n    }\n\n    // scope stack for domains or the process\n    this._stack = [{ scope: assignedScope }];\n    this._isolationScope = assignedIsolationScope;\n  }\n\n  /**\n   * Fork a scope for the stack.\n   */\n  public withScope<T>(callback: (scope: Scope) => T): T {\n    const scope = this._pushScope();\n\n    let maybePromiseResult: T;\n    try {\n      maybePromiseResult = callback(scope);\n    } catch (e) {\n      this._popScope();\n      throw e;\n    }\n\n    if (isThenable(maybePromiseResult)) {\n      // @ts-expect-error - isThenable returns the wrong type\n      return maybePromiseResult.then(\n        res => {\n          this._popScope();\n          return res;\n        },\n        e => {\n          this._popScope();\n          throw e;\n        },\n      );\n    }\n\n    this._popScope();\n    return maybePromiseResult;\n  }\n\n  /**\n   * Get the client of the stack.\n   */\n  public getClient<C extends Client>(): C | undefined {\n    return this.getStackTop().client as C;\n  }\n\n  /**\n   * Returns the scope of the top stack.\n   */\n  public getScope(): Scope {\n    return this.getStackTop().scope;\n  }\n\n  /**\n   * Get the isolation scope for the stack.\n   */\n  public getIsolationScope(): Scope {\n    return this._isolationScope;\n  }\n\n  /**\n   * Returns the topmost scope layer in the order domain > local > process.\n   */\n  public getStackTop(): Layer {\n    return this._stack[this._stack.length - 1] as Layer;\n  }\n\n  /**\n   * Push a scope to the stack.\n   */\n  private _pushScope(): Scope {\n    // We want to clone the content of prev scope\n    const scope = this.getScope().clone();\n    this._stack.push({\n      client: this.getClient(),\n      scope,\n    });\n    return scope;\n  }\n\n  /**\n   * Pop a scope from the stack.\n   */\n  private _popScope(): boolean {\n    if (this._stack.length <= 1) return false;\n    return !!this._stack.pop();\n  }\n}\n\n/**\n * Get the global async context stack.\n * This will be removed during the v8 cycle and is only here to make migration easier.\n */\nfunction getAsyncContextStack(): AsyncContextStack {\n  const registry = getMainCarrier();\n  const sentry = getSentryCarrier(registry);\n\n  return (sentry.stack = sentry.stack || new AsyncContextStack(getDefaultCurrentScope(), getDefaultIsolationScope()));\n}\n\nfunction withScope<T>(callback: (scope: Scope) => T): T {\n  return getAsyncContextStack().withScope(callback);\n}\n\nfunction withSetScope<T>(scope: Scope, callback: (scope: Scope) => T): T {\n  const stack = getAsyncContextStack() as AsyncContextStack;\n  return stack.withScope(() => {\n    stack.getStackTop().scope = scope;\n    return callback(scope);\n  });\n}\n\nfunction withIsolationScope<T>(callback: (isolationScope: Scope) => T): T {\n  return getAsyncContextStack().withScope(() => {\n    return callback(getAsyncContextStack().getIsolationScope());\n  });\n}\n\n/**\n * Get the stack-based async context strategy.\n */\nexport function getStackAsyncContextStrategy(): AsyncContextStrategy {\n  return {\n    withIsolationScope,\n    withScope,\n    withSetScope,\n    withSetIsolationScope: <T>(_isolationScope: Scope, callback: (isolationScope: Scope) => T) => {\n      return withIsolationScope(callback);\n    },\n    getCurrentScope: () => getAsyncContextStack().getScope(),\n    getIsolationScope: () => getAsyncContextStack().getIsolationScope(),\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}