{"ast":null,"code":"import { PDFService } from './pdfService';\nexport class FormFieldService {\n  /**\n   * Extract all form fields from a PDF document\n   */\n  static async extractAllFormFields(pdfDoc, options = {}) {\n    const {\n      excludeReadOnly = false,\n      includeSignatureFields = true,\n      validateFieldNames = true\n    } = options;\n    const documentId = pdfDoc.fingerprints[0];\n\n    // Check cache first\n    if (this.extractedFields.has(documentId)) {\n      let fields = this.extractedFields.get(documentId);\n\n      // Apply filters\n      if (excludeReadOnly) {\n        fields = fields.filter(field => !field.readOnly);\n      }\n      return fields;\n    }\n    const allFields = [];\n    const fieldNameCounts = new Map();\n    try {\n      for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {\n        const page = await PDFService.getPage(pdfDoc, pageNum);\n        const pageFields = await PDFService.extractFormFields(page);\n\n        // Process and enhance each field\n        const processedFields = pageFields.map(field => {\n          let fieldName = field.name;\n\n          // Handle duplicate field names by adding suffix\n          if (validateFieldNames && fieldNameCounts.has(fieldName)) {\n            const count = fieldNameCounts.get(fieldName) + 1;\n            fieldNameCounts.set(fieldName, count);\n            fieldName = `${fieldName}_${count}`;\n          } else {\n            fieldNameCounts.set(fieldName, 1);\n          }\n\n          // Determine field type based on annotation properties\n          const fieldType = this.determineFieldType(field);\n\n          // Enhanced form field object\n          const enhancedField = {\n            name: fieldName,\n            type: fieldType,\n            value: this.getInitialValue(field, fieldType),\n            required: this.isFieldRequired(field),\n            readOnly: field.readOnly || false,\n            page: pageNum,\n            rect: field.rect,\n            isComplete: false,\n            validationErrors: [],\n            options: field.options || undefined,\n            multiline: field.multiline || false,\n            maxLength: field.maxLength || undefined,\n            pattern: this.getValidationPattern(field, fieldType),\n            id: field.id,\n            subtype: field.subtype\n          };\n          return enhancedField;\n        });\n        allFields.push(...processedFields);\n      }\n\n      // Cache the results\n      this.extractedFields.set(documentId, allFields);\n      console.log(`Extracted ${allFields.length} form fields from ${pdfDoc.numPages} pages`);\n\n      // Apply final filters\n      let filteredFields = allFields;\n      if (excludeReadOnly) {\n        filteredFields = filteredFields.filter(field => !field.readOnly);\n      }\n      return filteredFields;\n    } catch (error) {\n      console.error('Error extracting form fields:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Categorize form fields by type and requirements\n   */\n  static categorizeFields(fields) {\n    // Create cache key based on field names and properties\n    const cacheKey = fields.map(f => `${f.name}-${f.type}-${f.required}`).sort().join('|');\n\n    // Check cache first\n    if (this.categorizedCache.has(cacheKey)) {\n      return this.categorizedCache.get(cacheKey);\n    }\n    const categories = {\n      required: [],\n      optional: [],\n      signature: [],\n      readOnly: []\n    };\n    fields.forEach(field => {\n      if (field.readOnly) {\n        categories.readOnly.push(field);\n      } else if (field.type === 'signature') {\n        categories.signature.push(field);\n      } else if (field.required) {\n        categories.required.push(field);\n      } else {\n        categories.optional.push(field);\n      }\n    });\n    console.log('Field categorization:', {\n      required: categories.required.length,\n      optional: categories.optional.length,\n      signature: categories.signature.length,\n      readOnly: categories.readOnly.length\n    });\n    return categories;\n  }\n\n  /**\n   * Get fields that still need completion\n   */\n  static getIncompleteFields(fields) {\n    return fields.filter(field => !field.isComplete && !field.readOnly);\n  }\n\n  /**\n   * Get required fields that still need completion\n   */\n  static getIncompleteRequiredFields(fields) {\n    return fields.filter(field => field.required && !field.isComplete && !field.readOnly);\n  }\n\n  /**\n   * Get signature fields\n   */\n  static getSignatureFields(fields) {\n    return fields.filter(field => field.type === 'signature' || field.name.toLowerCase().includes('signature') || field.name.toLowerCase().includes('sign'));\n  }\n\n  /**\n   * Calculate form completion percentage\n   */\n  static calculateCompletionPercentage(fields) {\n    const requiredFields = fields.filter(field => field.required && !field.readOnly);\n    if (requiredFields.length === 0) return 100;\n    const completedFields = requiredFields.filter(field => field.isComplete);\n    return Math.round(completedFields.length / requiredFields.length * 100);\n  }\n\n  /**\n   * Validate field value based on field type and constraints\n   */\n  static validateFieldValue(field, value) {\n    const errors = [];\n\n    // Required field validation\n    if (field.required && !field.readOnly) {\n      if (value === undefined || value === null || value === '') {\n        errors.push('This field is required');\n      }\n    }\n\n    // Skip further validation if empty and not required\n    if (!value && !field.required) {\n      return errors;\n    }\n\n    // Type-specific validation\n    switch (field.type) {\n      case 'text':\n        if (typeof value !== 'string') {\n          errors.push('Value must be text');\n          break;\n        }\n        if (field.maxLength && value.length > field.maxLength) {\n          errors.push(`Text must be ${field.maxLength} characters or less`);\n        }\n        if (field.pattern) {\n          const regex = new RegExp(field.pattern);\n          if (!regex.test(value)) {\n            errors.push('Invalid format');\n          }\n        }\n        break;\n      case 'checkbox':\n        if (typeof value !== 'boolean') {\n          errors.push('Value must be true or false');\n        }\n        break;\n      case 'radio':\n      case 'dropdown':\n        if (field.options && !field.options.includes(value)) {\n          errors.push('Invalid selection');\n        }\n        break;\n      case 'date':\n        if (typeof value === 'string') {\n          const date = new Date(value);\n          if (isNaN(date.getTime())) {\n            errors.push('Invalid date format');\n          }\n        }\n        break;\n    }\n    return errors;\n  }\n\n  /**\n   * Update field completion status\n   */\n  static updateFieldCompletion(field, value) {\n    const errors = this.validateFieldValue(field, value);\n    const isComplete = errors.length === 0 && this.hasValidValue(field, value);\n    return {\n      ...field,\n      value,\n      isComplete,\n      validationErrors: errors\n    };\n  }\n\n  /**\n   * Private helper methods\n   */\n  static determineFieldType(field) {\n    // Check field name for signature indicators\n    const fieldName = (field.name || '').toLowerCase();\n    if (fieldName.includes('signature') || fieldName.includes('sign')) {\n      return 'signature';\n    }\n\n    // Check annotation subtype and fieldType\n    switch (field.type || field.fieldType) {\n      case 'Tx':\n        // Text field\n        return 'text';\n      case 'Btn':\n        // Button field (could be checkbox or radio)\n        if (field.checkBox || field.radioButton === false) {\n          return 'checkbox';\n        } else {\n          return 'radio';\n        }\n      case 'Ch':\n        // Choice field (dropdown or listbox)\n        return 'dropdown';\n      case 'Sig':\n        // Signature field\n        return 'signature';\n      default:\n        // Fallback based on field properties\n        if (field.options && Array.isArray(field.options)) {\n          return 'dropdown';\n        }\n        if (field.checkBox !== undefined) {\n          return 'checkbox';\n        }\n        return 'text';\n    }\n  }\n  static getInitialValue(field, fieldType) {\n    var _field$options;\n    const existingValue = field.value || field.fieldValue;\n    if (existingValue !== undefined && existingValue !== null) {\n      return existingValue;\n    }\n\n    // Default values based on field type\n    switch (fieldType) {\n      case 'checkbox':\n        return false;\n      case 'radio':\n      case 'dropdown':\n        return ((_field$options = field.options) === null || _field$options === void 0 ? void 0 : _field$options[0]) || '';\n      default:\n        return '';\n    }\n  }\n  static isFieldRequired(field) {\n    // Explicit required flag\n    if (field.required === true) return true;\n    if (field.required === false) return false;\n\n    // Check field flags (PDF specification)\n    if (field.fieldFlags !== undefined) {\n      const REQUIRED_FLAG = 1 << 1; // Bit 2 in field flags\n      return (field.fieldFlags & REQUIRED_FLAG) !== 0;\n    }\n\n    // Heuristic: fields marked with asterisk or \"required\" in name\n    const fieldName = (field.name || '').toLowerCase();\n    return fieldName.includes('required') || fieldName.includes('*');\n  }\n  static getValidationPattern(field, fieldType) {\n    // Return existing pattern if available\n    if (field.pattern) return field.pattern;\n\n    // Common validation patterns based on field name\n    const fieldName = (field.name || '').toLowerCase();\n    if (fieldName.includes('email')) {\n      return '^[^\\\\s@]+@[^\\\\s@]+\\\\.[^\\\\s@]+$';\n    }\n    if (fieldName.includes('phone') || fieldName.includes('tel')) {\n      return '^[\\\\d\\\\s\\\\-\\\\(\\\\)\\\\+]{10,}$';\n    }\n    if (fieldName.includes('zip') || fieldName.includes('postal')) {\n      return '^\\\\d{5}(-\\\\d{4})?$';\n    }\n    if (fieldName.includes('date')) {\n      return '^\\\\d{1,2}/\\\\d{1,2}/\\\\d{4}$|^\\\\d{4}-\\\\d{2}-\\\\d{2}$';\n    }\n    return undefined;\n  }\n  static hasValidValue(field, value) {\n    if (value === undefined || value === null) return false;\n    switch (field.type) {\n      case 'text':\n        return typeof value === 'string' && value.trim().length > 0;\n      case 'checkbox':\n        return typeof value === 'boolean';\n      case 'radio':\n      case 'dropdown':\n        return typeof value === 'string' && value.length > 0;\n      case 'signature':\n        return typeof value === 'string' && value.length > 0;\n      default:\n        return true;\n    }\n  }\n\n  /**\n   * Clear cached form fields\n   */\n  static clearCache(documentId) {\n    if (documentId) {\n      this.extractedFields.delete(documentId);\n    } else {\n      this.extractedFields.clear();\n    }\n  }\n}\nFormFieldService.extractedFields = new Map();\nFormFieldService.categorizedCache = new Map();","map":{"version":3,"names":["PDFService","FormFieldService","extractAllFormFields","pdfDoc","options","excludeReadOnly","includeSignatureFields","validateFieldNames","documentId","fingerprints","extractedFields","has","fields","get","filter","field","readOnly","allFields","fieldNameCounts","Map","pageNum","numPages","page","getPage","pageFields","extractFormFields","processedFields","map","fieldName","name","count","set","fieldType","determineFieldType","enhancedField","type","value","getInitialValue","required","isFieldRequired","rect","isComplete","validationErrors","undefined","multiline","maxLength","pattern","getValidationPattern","id","subtype","push","console","log","length","filteredFields","error","categorizeFields","cacheKey","f","sort","join","categorizedCache","categories","optional","signature","forEach","getIncompleteFields","getIncompleteRequiredFields","getSignatureFields","toLowerCase","includes","calculateCompletionPercentage","requiredFields","completedFields","Math","round","validateFieldValue","errors","regex","RegExp","test","date","Date","isNaN","getTime","updateFieldCompletion","hasValidValue","checkBox","radioButton","Array","isArray","_field$options","existingValue","fieldValue","fieldFlags","REQUIRED_FLAG","trim","clearCache","delete","clear"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/src/services/formFieldService.ts"],"sourcesContent":["import { PDFService } from './pdfService';\nimport { FormField } from '../types/pdf';\nimport type { PDFDocumentProxy, PDFPageProxy } from 'pdfjs-dist';\n\nexport interface FormFieldExtractionOptions {\n  excludeReadOnly?: boolean;\n  includeSignatureFields?: boolean;\n  validateFieldNames?: boolean;\n}\n\nexport interface FormFieldCategory {\n  required: FormField[];\n  optional: FormField[];\n  signature: FormField[];\n  readOnly: FormField[];\n}\n\nexport class FormFieldService {\n  private static extractedFields: Map<string, FormField[]> = new Map();\n  private static categorizedCache: Map<string, FormFieldCategory> = new Map();\n\n  /**\n   * Extract all form fields from a PDF document\n   */\n  static async extractAllFormFields(\n    pdfDoc: PDFDocumentProxy, \n    options: FormFieldExtractionOptions = {}\n  ): Promise<FormField[]> {\n    const {\n      excludeReadOnly = false,\n      includeSignatureFields = true,\n      validateFieldNames = true\n    } = options;\n\n    const documentId = pdfDoc.fingerprints[0];\n    \n    // Check cache first\n    if (this.extractedFields.has(documentId)) {\n      let fields = this.extractedFields.get(documentId)!;\n      \n      // Apply filters\n      if (excludeReadOnly) {\n        fields = fields.filter(field => !field.readOnly);\n      }\n      \n      return fields;\n    }\n\n    const allFields: FormField[] = [];\n    const fieldNameCounts = new Map<string, number>();\n\n    try {\n      for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {\n        const page = await PDFService.getPage(pdfDoc, pageNum);\n        const pageFields = await PDFService.extractFormFields(page);\n        \n        // Process and enhance each field\n        const processedFields = pageFields.map((field: any) => {\n          let fieldName = field.name;\n          \n          // Handle duplicate field names by adding suffix\n          if (validateFieldNames && fieldNameCounts.has(fieldName)) {\n            const count = fieldNameCounts.get(fieldName)! + 1;\n            fieldNameCounts.set(fieldName, count);\n            fieldName = `${fieldName}_${count}`;\n          } else {\n            fieldNameCounts.set(fieldName, 1);\n          }\n\n          // Determine field type based on annotation properties\n          const fieldType = this.determineFieldType(field);\n          \n          // Enhanced form field object\n          const enhancedField: FormField = {\n            name: fieldName,\n            type: fieldType,\n            value: this.getInitialValue(field, fieldType),\n            required: this.isFieldRequired(field),\n            readOnly: field.readOnly || false,\n            page: pageNum,\n            rect: field.rect,\n            isComplete: false,\n            validationErrors: [],\n            options: field.options || undefined,\n            multiline: field.multiline || false,\n            maxLength: field.maxLength || undefined,\n            pattern: this.getValidationPattern(field, fieldType),\n            id: field.id,\n            subtype: field.subtype\n          };\n\n          return enhancedField;\n        });\n\n        allFields.push(...processedFields);\n      }\n\n      // Cache the results\n      this.extractedFields.set(documentId, allFields);\n\n      console.log(`Extracted ${allFields.length} form fields from ${pdfDoc.numPages} pages`);\n\n      // Apply final filters\n      let filteredFields = allFields;\n      if (excludeReadOnly) {\n        filteredFields = filteredFields.filter(field => !field.readOnly);\n      }\n\n      return filteredFields;\n    } catch (error) {\n      console.error('Error extracting form fields:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Categorize form fields by type and requirements\n   */\n  static categorizeFields(fields: FormField[]): FormFieldCategory {\n    // Create cache key based on field names and properties\n    const cacheKey = fields\n      .map(f => `${f.name}-${f.type}-${f.required}`)\n      .sort()\n      .join('|');\n    \n    // Check cache first\n    if (this.categorizedCache.has(cacheKey)) {\n      return this.categorizedCache.get(cacheKey)!;\n    }\n    const categories: FormFieldCategory = {\n      required: [],\n      optional: [],\n      signature: [],\n      readOnly: []\n    };\n\n    fields.forEach(field => {\n      if (field.readOnly) {\n        categories.readOnly.push(field);\n      } else if (field.type === 'signature') {\n        categories.signature.push(field);\n      } else if (field.required) {\n        categories.required.push(field);\n      } else {\n        categories.optional.push(field);\n      }\n    });\n\n    console.log('Field categorization:', {\n      required: categories.required.length,\n      optional: categories.optional.length,\n      signature: categories.signature.length,\n      readOnly: categories.readOnly.length\n    });\n\n    return categories;\n  }\n\n  /**\n   * Get fields that still need completion\n   */\n  static getIncompleteFields(fields: FormField[]): FormField[] {\n    return fields.filter(field => !field.isComplete && !field.readOnly);\n  }\n\n  /**\n   * Get required fields that still need completion\n   */\n  static getIncompleteRequiredFields(fields: FormField[]): FormField[] {\n    return fields.filter(field => field.required && !field.isComplete && !field.readOnly);\n  }\n\n  /**\n   * Get signature fields\n   */\n  static getSignatureFields(fields: FormField[]): FormField[] {\n    return fields.filter(field => \n      field.type === 'signature' || \n      field.name.toLowerCase().includes('signature') ||\n      field.name.toLowerCase().includes('sign')\n    );\n  }\n\n  /**\n   * Calculate form completion percentage\n   */\n  static calculateCompletionPercentage(fields: FormField[]): number {\n    const requiredFields = fields.filter(field => field.required && !field.readOnly);\n    if (requiredFields.length === 0) return 100;\n    \n    const completedFields = requiredFields.filter(field => field.isComplete);\n    return Math.round((completedFields.length / requiredFields.length) * 100);\n  }\n\n  /**\n   * Validate field value based on field type and constraints\n   */\n  static validateFieldValue(field: FormField, value: any): string[] {\n    const errors: string[] = [];\n\n    // Required field validation\n    if (field.required && !field.readOnly) {\n      if (value === undefined || value === null || value === '') {\n        errors.push('This field is required');\n      }\n    }\n\n    // Skip further validation if empty and not required\n    if (!value && !field.required) {\n      return errors;\n    }\n\n    // Type-specific validation\n    switch (field.type) {\n      case 'text':\n        if (typeof value !== 'string') {\n          errors.push('Value must be text');\n          break;\n        }\n        \n        if (field.maxLength && value.length > field.maxLength) {\n          errors.push(`Text must be ${field.maxLength} characters or less`);\n        }\n        \n        if (field.pattern) {\n          const regex = new RegExp(field.pattern);\n          if (!regex.test(value)) {\n            errors.push('Invalid format');\n          }\n        }\n        break;\n\n      case 'checkbox':\n        if (typeof value !== 'boolean') {\n          errors.push('Value must be true or false');\n        }\n        break;\n\n      case 'radio':\n      case 'dropdown':\n        if (field.options && !field.options.includes(value)) {\n          errors.push('Invalid selection');\n        }\n        break;\n\n      case 'date':\n        if (typeof value === 'string') {\n          const date = new Date(value);\n          if (isNaN(date.getTime())) {\n            errors.push('Invalid date format');\n          }\n        }\n        break;\n    }\n\n    return errors;\n  }\n\n  /**\n   * Update field completion status\n   */\n  static updateFieldCompletion(field: FormField, value: any): FormField {\n    const errors = this.validateFieldValue(field, value);\n    const isComplete = errors.length === 0 && this.hasValidValue(field, value);\n\n    return {\n      ...field,\n      value,\n      isComplete,\n      validationErrors: errors\n    };\n  }\n\n  /**\n   * Private helper methods\n   */\n  private static determineFieldType(field: any): FormField['type'] {\n    // Check field name for signature indicators\n    const fieldName = (field.name || '').toLowerCase();\n    if (fieldName.includes('signature') || fieldName.includes('sign')) {\n      return 'signature';\n    }\n\n    // Check annotation subtype and fieldType\n    switch (field.type || field.fieldType) {\n      case 'Tx': // Text field\n        return 'text';\n      case 'Btn': // Button field (could be checkbox or radio)\n        if (field.checkBox || field.radioButton === false) {\n          return 'checkbox';\n        } else {\n          return 'radio';\n        }\n      case 'Ch': // Choice field (dropdown or listbox)\n        return 'dropdown';\n      case 'Sig': // Signature field\n        return 'signature';\n      default:\n        // Fallback based on field properties\n        if (field.options && Array.isArray(field.options)) {\n          return 'dropdown';\n        }\n        if (field.checkBox !== undefined) {\n          return 'checkbox';\n        }\n        return 'text';\n    }\n  }\n\n  private static getInitialValue(field: any, fieldType: FormField['type']): any {\n    const existingValue = field.value || field.fieldValue;\n    \n    if (existingValue !== undefined && existingValue !== null) {\n      return existingValue;\n    }\n\n    // Default values based on field type\n    switch (fieldType) {\n      case 'checkbox':\n        return false;\n      case 'radio':\n      case 'dropdown':\n        return field.options?.[0] || '';\n      default:\n        return '';\n    }\n  }\n\n  private static isFieldRequired(field: any): boolean {\n    // Explicit required flag\n    if (field.required === true) return true;\n    if (field.required === false) return false;\n\n    // Check field flags (PDF specification)\n    if (field.fieldFlags !== undefined) {\n      const REQUIRED_FLAG = 1 << 1; // Bit 2 in field flags\n      return (field.fieldFlags & REQUIRED_FLAG) !== 0;\n    }\n\n    // Heuristic: fields marked with asterisk or \"required\" in name\n    const fieldName = (field.name || '').toLowerCase();\n    return fieldName.includes('required') || fieldName.includes('*');\n  }\n\n  private static getValidationPattern(field: any, fieldType: FormField['type']): string | undefined {\n    // Return existing pattern if available\n    if (field.pattern) return field.pattern;\n\n    // Common validation patterns based on field name\n    const fieldName = (field.name || '').toLowerCase();\n    \n    if (fieldName.includes('email')) {\n      return '^[^\\\\s@]+@[^\\\\s@]+\\\\.[^\\\\s@]+$';\n    }\n    \n    if (fieldName.includes('phone') || fieldName.includes('tel')) {\n      return '^[\\\\d\\\\s\\\\-\\\\(\\\\)\\\\+]{10,}$';\n    }\n    \n    if (fieldName.includes('zip') || fieldName.includes('postal')) {\n      return '^\\\\d{5}(-\\\\d{4})?$';\n    }\n\n    if (fieldName.includes('date')) {\n      return '^\\\\d{1,2}/\\\\d{1,2}/\\\\d{4}$|^\\\\d{4}-\\\\d{2}-\\\\d{2}$';\n    }\n\n    return undefined;\n  }\n\n  private static hasValidValue(field: FormField, value: any): boolean {\n    if (value === undefined || value === null) return false;\n    \n    switch (field.type) {\n      case 'text':\n        return typeof value === 'string' && value.trim().length > 0;\n      case 'checkbox':\n        return typeof value === 'boolean';\n      case 'radio':\n      case 'dropdown':\n        return typeof value === 'string' && value.length > 0;\n      case 'signature':\n        return typeof value === 'string' && value.length > 0;\n      default:\n        return true;\n    }\n  }\n\n  /**\n   * Clear cached form fields\n   */\n  static clearCache(documentId?: string): void {\n    if (documentId) {\n      this.extractedFields.delete(documentId);\n    } else {\n      this.extractedFields.clear();\n    }\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}