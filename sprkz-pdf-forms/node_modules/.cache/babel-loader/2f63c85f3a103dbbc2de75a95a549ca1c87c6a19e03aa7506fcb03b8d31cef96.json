{"ast":null,"code":"import { getEnvelopeEndpointWithUrlEncodedAuth } from '../api.js';\nimport { dsnFromString } from '../utils/dsn.js';\nimport { createEnvelope, forEachEnvelopeItem } from '../utils/envelope.js';\n\n/**\n * Gets an event from an envelope.\n *\n * This is only exported for use in the tests\n */\nfunction eventFromEnvelope(env, types) {\n  let event;\n  forEachEnvelopeItem(env, (item, type) => {\n    if (types.includes(type)) {\n      event = Array.isArray(item) ? item[1] : undefined;\n    }\n    // bail out if we found an event\n    return !!event;\n  });\n  return event;\n}\n\n/**\n * Creates a transport that overrides the release on all events.\n */\nfunction makeOverrideReleaseTransport(createTransport, release) {\n  return options => {\n    const transport = createTransport(options);\n    return {\n      ...transport,\n      send: async envelope => {\n        const event = eventFromEnvelope(envelope, ['event', 'transaction', 'profile', 'replay_event']);\n        if (event) {\n          event.release = release;\n        }\n        return transport.send(envelope);\n      }\n    };\n  };\n}\n\n/** Overrides the DSN in the envelope header  */\nfunction overrideDsn(envelope, dsn) {\n  return createEnvelope(dsn ? {\n    ...envelope[0],\n    dsn\n  } : envelope[0], envelope[1]);\n}\n\n/**\n * Creates a transport that can send events to different DSNs depending on the envelope contents.\n */\nfunction makeMultiplexedTransport(createTransport, matcher) {\n  return options => {\n    const fallbackTransport = createTransport(options);\n    const otherTransports = new Map();\n    function getTransport(dsn, release) {\n      // We create a transport for every unique dsn/release combination as there may be code from multiple releases in\n      // use at the same time\n      const key = release ? `${dsn}:${release}` : dsn;\n      let transport = otherTransports.get(key);\n      if (!transport) {\n        const validatedDsn = dsnFromString(dsn);\n        if (!validatedDsn) {\n          return undefined;\n        }\n        const url = getEnvelopeEndpointWithUrlEncodedAuth(validatedDsn, options.tunnel);\n        transport = release ? makeOverrideReleaseTransport(createTransport, release)({\n          ...options,\n          url\n        }) : createTransport({\n          ...options,\n          url\n        });\n        otherTransports.set(key, transport);\n      }\n      return [dsn, transport];\n    }\n    async function send(envelope) {\n      function getEvent(types) {\n        const eventTypes = types?.length ? types : ['event'];\n        return eventFromEnvelope(envelope, eventTypes);\n      }\n      const transports = matcher({\n        envelope,\n        getEvent\n      }).map(result => {\n        if (typeof result === 'string') {\n          return getTransport(result, undefined);\n        } else {\n          return getTransport(result.dsn, result.release);\n        }\n      }).filter(t => !!t);\n\n      // If we have no transports to send to, use the fallback transport\n      // Don't override the DSN in the header for the fallback transport. '' is falsy\n      const transportsWithFallback = transports.length ? transports : [['', fallbackTransport]];\n      const results = await Promise.all(transportsWithFallback.map(_ref => {\n        let [dsn, transport] = _ref;\n        return transport.send(overrideDsn(envelope, dsn));\n      }));\n      return results[0];\n    }\n    async function flush(timeout) {\n      const allTransports = [...otherTransports.values(), fallbackTransport];\n      const results = await Promise.all(allTransports.map(transport => transport.flush(timeout)));\n      return results.every(r => r);\n    }\n    return {\n      send,\n      flush\n    };\n  };\n}\nexport { eventFromEnvelope, makeMultiplexedTransport };\n//# sourceMappingURL=multiplexed.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}