{"ast":null,"code":"import * as Sentry from '@sentry/react';\nexport class ValidationService {\n  /**\n   * Validate a single form field\n   */\n  static async validateField(field, value, allFields = [], options = {}) {\n    const startTime = performance.now();\n\n    // Check feature flags\n    const enhancedValidation = isFeatureEnabled('ENHANCED_FIELD_VALIDATION');\n    const performanceMonitoring = isFeatureEnabled('PERFORMANCE_MONITORING');\n    const securityAuditLogging = isFeatureEnabled('SECURITY_AUDIT_LOGGING');\n    try {\n      // Use enhanced validation options if feature is enabled\n      const {\n        validateRequired = enhancedValidation ? true : true,\n        validateFormat = enhancedValidation ? true : false,\n        validateDependencies = enhancedValidation ? true : false,\n        excludeReadOnly = true,\n        performanceMode = performanceMonitoring ? false : true\n      } = options;\n\n      // Security audit logging\n      if (securityAuditLogging) {\n        console.log(`Validating field: ${field.name}, type: ${field.type}, value length: ${(value === null || value === void 0 ? void 0 : value.toString().length) || 0}`);\n      }\n\n      // Create cache key\n      const cacheKey = `${field.name}_${JSON.stringify(value)}_${field.type}`;\n\n      // Check cache in performance mode\n      if (performanceMode && this.validationCache.has(cacheKey)) {\n        const cached = this.validationCache.get(cacheKey);\n        // Use cached result if less than 1 minute old\n        if (Date.now() - cached.validatedAt < 60000) {\n          return cached;\n        }\n      }\n      const errors = [];\n      const warnings = [];\n\n      // Skip validation for read-only fields if requested\n      if (excludeReadOnly && field.readOnly) {\n        const result = {\n          isValid: true,\n          errors: [],\n          warnings: [],\n          fieldName: field.name,\n          validatedAt: Date.now()\n        };\n        return result;\n      }\n\n      // Get validation rules for field type\n      const fieldType = this.getFieldValidationType(field);\n      const rules = this.FIELD_VALIDATION_RULES[fieldType] || [];\n\n      // Apply validation rules\n      for (const rule of rules) {\n        // Skip certain validations based on options\n        if (!validateRequired && rule.type === 'required') continue;\n        if (!validateFormat && rule.type === 'format') continue;\n        if (!validateDependencies && rule.type === 'dependency') continue;\n        const ruleValid = await this.applyValidationRule(rule, value, field, allFields);\n        if (!ruleValid) {\n          if (rule.type === 'required' && !field.required) {\n            warnings.push(rule.message);\n          } else {\n            errors.push(rule.message);\n          }\n        }\n      }\n\n      // Additional field-specific validations\n      if (validateDependencies) {\n        const dependencyErrors = await this.validateFieldDependencies(field, value, allFields);\n        errors.push(...dependencyErrors);\n      }\n\n      // Custom business logic validations\n      const customErrors = await this.validateCustomBusinessRules(field, value, allFields);\n      errors.push(...customErrors);\n      const result = {\n        isValid: errors.length === 0,\n        errors,\n        warnings,\n        fieldName: field.name,\n        validatedAt: Date.now()\n      };\n\n      // Cache result\n      this.validationCache.set(cacheKey, result);\n\n      // Performance monitoring\n      const duration = performance.now() - startTime;\n      if (duration > this.performanceTarget) {\n        console.warn(`Validation for field \"${field.name}\" took ${duration.toFixed(2)}ms (target: ${this.performanceTarget}ms)`);\n\n        // Report to Sentry if performance is very poor\n        if (duration > this.performanceTarget * 3) {\n          Sentry.addBreadcrumb({\n            message: 'Slow field validation detected',\n            data: {\n              fieldName: field.name,\n              fieldType: field.type,\n              duration: duration,\n              target: this.performanceTarget\n            },\n            level: 'warning'\n          });\n        }\n      }\n      return result;\n    } catch (error) {\n      console.error(`Validation error for field \"${field.name}\":`, error);\n      Sentry.captureException(error, {\n        tags: {\n          component: 'ValidationService',\n          fieldName: field.name,\n          fieldType: field.type\n        }\n      });\n      return {\n        isValid: false,\n        errors: ['An error occurred while validating this field'],\n        warnings: [],\n        fieldName: field.name,\n        validatedAt: Date.now()\n      };\n    }\n  }\n\n  /**\n   * Validate multiple fields\n   */\n  static async validateFields(fields, values, options = {}) {\n    const results = {};\n\n    // Validate fields in parallel for better performance\n    const validationPromises = fields.map(async field => {\n      const value = values[field.name];\n      const result = await this.validateField(field, value, fields, options);\n      results[field.name] = result;\n    });\n    await Promise.all(validationPromises);\n    return results;\n  }\n\n  /**\n   * Validate all required fields are completed\n   */\n  static validateRequiredFieldsCompletion(fields, values) {\n    const requiredFields = fields.filter(field => field.required && !field.readOnly);\n    const missingFields = [];\n    let completedCount = 0;\n    for (const field of requiredFields) {\n      const value = values[field.name];\n      const hasValue = this.hasValidValue(field, value);\n      if (hasValue) {\n        completedCount++;\n      } else {\n        missingFields.push(field.name);\n      }\n    }\n    const completionPercentage = requiredFields.length > 0 ? Math.round(completedCount / requiredFields.length * 100) : 100;\n    return {\n      isComplete: missingFields.length === 0,\n      missingFields,\n      completionPercentage\n    };\n  }\n\n  /**\n   * Apply a single validation rule\n   */\n  static async applyValidationRule(rule, value, field, allFields) {\n    var _rule$params;\n    switch (rule.type) {\n      case 'required':\n        return this.hasValidValue(field, value);\n      case 'format':\n        if (!value) return true; // Format validation only applies to non-empty values\n        const pattern = (_rule$params = rule.params) === null || _rule$params === void 0 ? void 0 : _rule$params.pattern;\n        if (pattern instanceof RegExp) {\n          return pattern.test(String(value));\n        }\n        return true;\n      case 'length':\n        if (!value) return true;\n        const str = String(value);\n        const {\n          min,\n          max\n        } = rule.params || {};\n        if (min !== undefined && str.length < min) return false;\n        if (max !== undefined && str.length > max) return false;\n        return true;\n      case 'custom':\n        if (rule.validator) {\n          return rule.validator(value, field, allFields);\n        }\n        return true;\n      case 'dependency':\n        return this.validateFieldDependencies(field, value, allFields).then(errors => errors.length === 0);\n      default:\n        return true;\n    }\n  }\n\n  /**\n   * Check if field has a valid value\n   */\n  static hasValidValue(field, value) {\n    if (value === null || value === undefined || value === '') {\n      return false;\n    }\n    switch (field.type) {\n      case 'checkbox':\n        return value === true || value === 'true' || value === 'on';\n      case 'signature':\n        return typeof value === 'string' && value.startsWith('data:image/') && value.length > 100;\n      case 'radio':\n      case 'dropdown':\n        return value !== null && value !== undefined && value !== '';\n      default:\n        return String(value).trim().length > 0;\n    }\n  }\n\n  /**\n   * Get validation type based on field properties\n   */\n  static getFieldValidationType(field) {\n    // Check field name patterns for common types\n    const fieldName = field.name.toLowerCase();\n    if (fieldName.includes('email')) return 'email';\n    if (fieldName.includes('phone') || fieldName.includes('tel')) return 'phone';\n    if (fieldName.includes('date')) return 'date';\n    if (fieldName.includes('number') || fieldName.includes('amount')) return 'number';\n\n    // Use field type\n    return field.type || 'text';\n  }\n\n  /**\n   * Validate field dependencies\n   */\n  static async validateFieldDependencies(field, value, allFields) {\n    const errors = [];\n\n    // Example dependency validation logic\n    // This can be extended based on specific business requirements\n\n    // Check for conditional required fields\n    // Example: If field A is filled, then field B becomes required\n    const fieldName = field.name.toLowerCase();\n    if (fieldName.includes('spouse') && fieldName.includes('name')) {\n      // If marital status is married, spouse name is required\n      const maritalField = allFields.find(f => f.name.toLowerCase().includes('marital') || f.name.toLowerCase().includes('status'));\n      if (maritalField) {\n        const maritalValue = String(value || '').toLowerCase();\n        if ((maritalValue.includes('married') || maritalValue.includes('spouse')) && !value) {\n          errors.push('Spouse name is required when married');\n        }\n      }\n    }\n    return errors;\n  }\n\n  /**\n   * Custom business rule validation\n   */\n  static async validateCustomBusinessRules(field, value, allFields) {\n    const errors = [];\n    try {\n      // Age validation example\n      if (field.name.toLowerCase().includes('age') && value) {\n        const age = parseInt(String(value), 10);\n        if (!isNaN(age)) {\n          if (age < 0 || age > 150) {\n            errors.push('Please enter a valid age');\n          }\n          if (age < 18) {\n            errors.push('Must be 18 or older');\n          }\n        }\n      }\n\n      // Date range validation example\n      if (field.name.toLowerCase().includes('start') && field.name.toLowerCase().includes('date')) {\n        const endDateField = allFields.find(f => f.name.toLowerCase().includes('end') && f.name.toLowerCase().includes('date'));\n        if (endDateField && value) {\n          const startDate = new Date(value);\n          // This would need the end date value from the form state\n          // For now, just validate the start date is not in the far future\n          const oneYearFromNow = new Date();\n          oneYearFromNow.setFullYear(oneYearFromNow.getFullYear() + 1);\n          if (startDate > oneYearFromNow) {\n            errors.push('Start date cannot be more than one year in the future');\n          }\n        }\n      }\n    } catch (error) {\n      console.warn(`Error in custom business rule validation for field \"${field.name}\":`, error);\n    }\n    return errors;\n  }\n\n  /**\n   * Clear validation cache\n   */\n  static clearValidationCache() {\n    this.validationCache.clear();\n  }\n\n  /**\n   * Get validation cache statistics\n   */\n  static getValidationCacheStats() {\n    return {\n      size: this.validationCache.size,\n      entries: Array.from(this.validationCache.keys())\n    };\n  }\n\n  /**\n   * Validate form submission readiness\n   */\n  static async validateFormSubmission(fields, values) {\n    const validationResults = await this.validateFields(fields, values, {\n      validateRequired: true,\n      validateFormat: true,\n      validateDependencies: true,\n      excludeReadOnly: true\n    });\n    const requiredCompletion = this.validateRequiredFieldsCompletion(fields, values);\n    const errors = {};\n    const warnings = {};\n    let validFields = 0;\n    let invalidFields = 0;\n    Object.entries(validationResults).forEach(([fieldName, result]) => {\n      if (result.errors.length > 0) {\n        errors[fieldName] = result.errors;\n        invalidFields++;\n      } else {\n        validFields++;\n      }\n      if (result.warnings.length > 0) {\n        warnings[fieldName] = result.warnings;\n      }\n    });\n    const requiredFields = fields.filter(f => f.required && !f.readOnly);\n    return {\n      canSubmit: requiredCompletion.isComplete && invalidFields === 0,\n      errors,\n      warnings,\n      summary: {\n        totalFields: fields.length,\n        validFields,\n        invalidFields,\n        requiredFields: requiredFields.length,\n        completedRequiredFields: requiredFields.length - requiredCompletion.missingFields.length\n      }\n    };\n  }\n}\nValidationService.validationCache = new Map();\nValidationService.performanceTarget = 10;\n// milliseconds per field\n/**\n * Validation rules for different field types\n */\nValidationService.FIELD_VALIDATION_RULES = {\n  text: [{\n    type: 'required',\n    message: 'This field is required'\n  }, {\n    type: 'length',\n    message: 'Text is too long',\n    params: {\n      max: 1000\n    }\n  }],\n  email: [{\n    type: 'required',\n    message: 'Email address is required'\n  }, {\n    type: 'format',\n    message: 'Please enter a valid email address',\n    params: {\n      pattern: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/\n    }\n  }],\n  phone: [{\n    type: 'required',\n    message: 'Phone number is required'\n  }, {\n    type: 'format',\n    message: 'Please enter a valid phone number',\n    params: {\n      pattern: /^[\\+]?[1-9][\\d]{0,15}$/\n    }\n  }],\n  date: [{\n    type: 'required',\n    message: 'Date is required'\n  }, {\n    type: 'format',\n    message: 'Please enter a valid date',\n    params: {\n      pattern: /^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$|^\\d{4}-\\d{2}-\\d{2}$/\n    }\n  }, {\n    type: 'custom',\n    message: 'Date cannot be in the future',\n    validator: value => {\n      if (!value) return true;\n      const date = new Date(String(value));\n      return !isNaN(date.getTime()) && date <= new Date();\n    }\n  }],\n  number: [{\n    type: 'format',\n    message: 'Please enter a valid number',\n    params: {\n      pattern: /^-?\\d+(\\.\\d+)?$/\n    }\n  }],\n  checkbox: [{\n    type: 'custom',\n    message: 'This checkbox must be checked',\n    validator: value => {\n      return value === true || value === 'true' || value === 'on';\n    }\n  }],\n  radio: [{\n    type: 'required',\n    message: 'Please select an option'\n  }],\n  dropdown: [{\n    type: 'required',\n    message: 'Please select an option'\n  }],\n  signature: [{\n    type: 'required',\n    message: 'Signature is required'\n  }, {\n    type: 'custom',\n    message: 'Please provide a valid signature',\n    validator: value => {\n      return Boolean(value && typeof value === 'string' && value.startsWith('data:image/') && value.length > 100);\n    }\n  }]\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}