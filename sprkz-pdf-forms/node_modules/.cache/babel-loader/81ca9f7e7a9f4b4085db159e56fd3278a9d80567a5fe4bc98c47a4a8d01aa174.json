{"ast":null,"code":"import * as pdfjsLib from 'pdfjs-dist';\nimport { isFeatureEnabled } from './unleashService';\n\n// Configure PDF.js worker\npdfjsLib.GlobalWorkerOptions.workerSrc = process.env.REACT_APP_PDF_WORKER_URL || '/pdf.worker.min.mjs';\nexport class PDFService {\n  // Maximum number of pages to cache\n\n  /**\n   * Load PDF document from URL or data\n   */\n  static async loadDocument(options) {\n    const startTime = performance.now();\n\n    // Check feature flags for PDF processing options\n    const enableLazyLoading = isFeatureEnabled('PDF_LAZY_LOADING');\n    const enablePerformanceMonitoring = isFeatureEnabled('PERFORMANCE_MONITORING');\n    if (enablePerformanceMonitoring) {\n      console.log('PDF loading started:', options);\n    }\n    try {\n      const cacheKey = options.url || 'data-pdf';\n\n      // Check cache first (if lazy loading is enabled)\n      if (enableLazyLoading && options.url && this.loadedDocuments.has(cacheKey)) {\n        if (enablePerformanceMonitoring) {\n          const duration = performance.now() - startTime;\n          console.log(`PDF loaded from cache in ${duration.toFixed(2)}ms`);\n        }\n        return this.loadedDocuments.get(cacheKey);\n      }\n      const loadingTask = options.url ? pdfjsLib.getDocument({\n        url: options.url,\n        withCredentials: options.withCredentials || false\n      }) : pdfjsLib.getDocument({\n        data: options.data\n      });\n      const pdfDoc = await loadingTask.promise;\n\n      // Cache the document (if lazy loading is enabled)\n      if (enableLazyLoading && options.url) {\n        this.loadedDocuments.set(cacheKey, pdfDoc);\n      }\n      if (enablePerformanceMonitoring) {\n        const duration = performance.now() - startTime;\n        console.log(`PDF loaded successfully in ${duration.toFixed(2)}ms. Pages: ${pdfDoc.numPages}`);\n      }\n      return pdfDoc;\n    } catch (error) {\n      const duration = performance.now() - startTime;\n      const pdfError = {\n        type: 'LOADING_FAILED',\n        message: `Failed to load PDF after ${duration.toFixed(2)}ms: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        originalError: error instanceof Error ? error : new Error(String(error))\n      };\n      console.error('PDF loading error:', pdfError);\n      throw pdfError;\n    }\n  }\n\n  /**\n   * Get a specific page from the PDF document\n   */\n  static async getPage(pdfDoc, pageNumber) {\n    const startTime = performance.now();\n    const cacheKey = `${pdfDoc.fingerprints[0]}-page-${pageNumber}`;\n\n    // Feature flags\n    const enableLazyLoading = isFeatureEnabled('PDF_LAZY_LOADING');\n    const enablePerformanceMonitoring = isFeatureEnabled('PERFORMANCE_MONITORING');\n    try {\n      // Check cache first (if lazy loading enabled)\n      if (enableLazyLoading && this.loadedPages.has(cacheKey)) {\n        if (enablePerformanceMonitoring) {\n          const duration = performance.now() - startTime;\n          console.log(`Page ${pageNumber} loaded from cache in ${duration.toFixed(2)}ms`);\n        }\n        return this.loadedPages.get(cacheKey);\n      }\n      if (pageNumber < 1 || pageNumber > pdfDoc.numPages) {\n        throw new Error(`Invalid page number: ${pageNumber}. Document has ${pdfDoc.numPages} pages.`);\n      }\n      const page = await pdfDoc.getPage(pageNumber);\n\n      // Cache the page with size management\n      this.manageCacheSize();\n      this.loadedPages.set(cacheKey, page);\n      const duration = performance.now() - startTime;\n      console.log(`Page ${pageNumber} loaded in ${duration.toFixed(2)}ms`);\n      return page;\n    } catch (error) {\n      const duration = performance.now() - startTime;\n      const pdfError = {\n        type: 'LOADING_FAILED',\n        message: `Failed to load page ${pageNumber} after ${duration.toFixed(2)}ms: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        originalError: error instanceof Error ? error : new Error(String(error))\n      };\n      console.error('Page loading error:', pdfError);\n      throw pdfError;\n    }\n  }\n\n  /**\n   * Render page to canvas with proper scaling\n   */\n  static async renderPageToCanvas(page, canvas, scale = 1) {\n    const startTime = performance.now();\n    try {\n      const viewport = page.getViewport({\n        scale\n      });\n      const context = canvas.getContext('2d');\n      if (!context) {\n        throw new Error('Could not get 2D context from canvas');\n      }\n\n      // Set canvas dimensions\n      canvas.width = viewport.width;\n      canvas.height = viewport.height;\n      canvas.style.width = `${viewport.width}px`;\n      canvas.style.height = `${viewport.height}px`;\n      const renderContext = {\n        canvasContext: context,\n        viewport: viewport\n      };\n      await page.render(renderContext).promise;\n      const duration = performance.now() - startTime;\n      console.log(`Page rendered to canvas in ${duration.toFixed(2)}ms (${viewport.width}x${viewport.height})`);\n    } catch (error) {\n      const duration = performance.now() - startTime;\n      const pdfError = {\n        type: 'RENDERING_FAILED',\n        message: `Failed to render page to canvas after ${duration.toFixed(2)}ms: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        originalError: error instanceof Error ? error : new Error(String(error))\n      };\n      console.error('Canvas rendering error:', pdfError);\n      throw pdfError;\n    }\n  }\n\n  /**\n   * Extract text content from a page\n   */\n  static async extractTextContent(page) {\n    try {\n      const textContent = await page.getTextContent();\n      return textContent.items.map(item => 'str' in item ? item.str : '').join(' ');\n    } catch (error) {\n      const pdfError = {\n        type: 'PARSING_FAILED',\n        message: `Failed to extract text content: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        originalError: error instanceof Error ? error : new Error(String(error))\n      };\n      console.error('Text extraction error:', pdfError);\n      throw pdfError;\n    }\n  }\n\n  /**\n   * Extract form fields from a page using annotation layer\n   */\n  static async extractFormFields(page) {\n    try {\n      const annotations = await page.getAnnotations({\n        intent: 'display'\n      });\n      const formFields = [];\n      for (const annotation of annotations) {\n        if (annotation.subtype === 'Widget') {\n          const field = {\n            name: annotation.fieldName || `field_${annotation.id}`,\n            type: annotation.fieldType || 'unknown',\n            value: annotation.fieldValue || '',\n            required: !annotation.readOnly && (annotation.required || false),\n            readOnly: annotation.readOnly || false,\n            page: page.pageNumber,\n            rect: annotation.rect,\n            options: annotation.options || null,\n            multiline: annotation.multiLine || false,\n            maxLength: annotation.maxLen || null,\n            id: annotation.id,\n            subtype: annotation.subtype\n          };\n          formFields.push(field);\n        }\n      }\n      console.log(`Extracted ${formFields.length} form fields from page ${page.pageNumber}`);\n      return formFields;\n    } catch (error) {\n      const pdfError = {\n        type: 'PARSING_FAILED',\n        message: `Failed to extract form fields: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        originalError: error instanceof Error ? error : new Error(String(error))\n      };\n      console.error('Form field extraction error:', pdfError);\n      throw pdfError;\n    }\n  }\n\n  /**\n   * Generate thumbnail for a page\n   */\n  static async generateThumbnail(page, maxWidth = 150) {\n    const startTime = performance.now();\n    const cacheKey = `${page.pageNumber}-${maxWidth}`;\n\n    // Check thumbnail cache first\n    if (this.thumbnailCache.has(cacheKey)) {\n      const cachedThumbnail = this.thumbnailCache.get(cacheKey);\n      console.log(`Thumbnail loaded from cache in 0ms`);\n      return cachedThumbnail;\n    }\n    try {\n      const viewport = page.getViewport({\n        scale: 1\n      });\n      const scale = maxWidth / viewport.width;\n      const scaledViewport = page.getViewport({\n        scale\n      });\n      const canvas = document.createElement('canvas');\n      const context = canvas.getContext('2d');\n      if (!context) {\n        throw new Error('Could not create canvas context for thumbnail');\n      }\n      canvas.width = scaledViewport.width;\n      canvas.height = scaledViewport.height;\n      await page.render({\n        canvasContext: context,\n        viewport: scaledViewport\n      }).promise;\n      const thumbnailDataUrl = canvas.toDataURL('image/png');\n\n      // Cache the thumbnail\n      this.thumbnailCache.set(cacheKey, thumbnailDataUrl);\n      const duration = performance.now() - startTime;\n      console.log(`Thumbnail generated in ${duration.toFixed(2)}ms (${canvas.width}x${canvas.height})`);\n      return thumbnailDataUrl;\n    } catch (error) {\n      const duration = performance.now() - startTime;\n      const pdfError = {\n        type: 'RENDERING_FAILED',\n        message: `Failed to generate thumbnail after ${duration.toFixed(2)}ms: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        originalError: error instanceof Error ? error : new Error(String(error))\n      };\n      console.error('Thumbnail generation error:', pdfError);\n      throw pdfError;\n    }\n  }\n\n  /**\n   * Preload adjacent pages for smooth navigation\n   */\n  static async preloadAdjacentPages(pdfDoc, currentPage, range = 1) {\n    const pagesToPreload = [];\n    for (let i = Math.max(1, currentPage - range); i <= Math.min(pdfDoc.numPages, currentPage + range); i++) {\n      if (i !== currentPage) {\n        pagesToPreload.push(i);\n      }\n    }\n    const preloadPromises = pagesToPreload.map(async pageNum => {\n      try {\n        await this.getPage(pdfDoc, pageNum);\n        console.log(`Preloaded page ${pageNum}`);\n      } catch (error) {\n        console.warn(`Failed to preload page ${pageNum}:`, error);\n      }\n    });\n    await Promise.allSettled(preloadPromises);\n  }\n\n  /**\n   * Manage cache size to prevent memory leaks\n   */\n  static manageCacheSize() {\n    if (this.loadedPages.size > this.maxCacheSize) {\n      const keysToDelete = Array.from(this.loadedPages.keys()).slice(0, 10); // Remove oldest 10 entries\n      keysToDelete.forEach(key => this.loadedPages.delete(key));\n      console.log(`Cache cleaned up - removed ${keysToDelete.length} pages`);\n    }\n  }\n\n  /**\n   * Clean up cached resources\n   */\n  static cleanup(documentUrl) {\n    if (documentUrl) {\n      this.loadedDocuments.delete(documentUrl);\n      // Clean up related pages\n      const keysToDelete = Array.from(this.loadedPages.keys()).filter(key => key.includes(documentUrl));\n      keysToDelete.forEach(key => this.loadedPages.delete(key));\n    } else {\n      // Clean up all cached resources\n      this.loadedDocuments.clear();\n      this.loadedPages.clear();\n      this.thumbnailCache.clear();\n    }\n    console.log('PDF service cache cleaned up');\n  }\n\n  /**\n   * Get default PDF URL from environment or URL parameter\n   */\n  static getDefaultPDFUrl() {\n    // Check URL parameter first\n    const urlParams = new URLSearchParams(window.location.search);\n    const pdfParam = urlParams.get('f') || urlParams.get('file') || urlParams.get('pdf');\n    if (pdfParam) {\n      // Resolve relative paths to pdfs directory\n      if (!pdfParam.startsWith('http') && !pdfParam.startsWith('/')) {\n        return `/pdfs/${pdfParam}`;\n      }\n      return pdfParam;\n    }\n\n    // Return default PDF from environment\n    return process.env.REACT_APP_DEFAULT_PDF || '/pdfs/makana2025.pdf';\n  }\n}\nPDFService.loadedDocuments = new Map();\nPDFService.loadedPages = new Map();\nPDFService.thumbnailCache = new Map();\nPDFService.maxCacheSize = 50;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}