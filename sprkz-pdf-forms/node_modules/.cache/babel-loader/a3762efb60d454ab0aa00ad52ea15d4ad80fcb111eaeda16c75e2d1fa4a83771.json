{"ast":null,"code":"import { debug, getFunctionName } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { onCLS } from './web-vitals/getCLS.js';\nimport { onFID } from './web-vitals/getFID.js';\nimport { onINP } from './web-vitals/getINP.js';\nimport { onLCP } from './web-vitals/getLCP.js';\nimport { observe } from './web-vitals/lib/observe.js';\nimport { onTTFB } from './web-vitals/onTTFB.js';\nconst handlers = {};\nconst instrumented = {};\nlet _previousCls;\nlet _previousFid;\nlet _previousLcp;\nlet _previousTtfb;\nlet _previousInp;\n\n/**\n * Add a callback that will be triggered when a CLS metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n *\n * Pass `stopOnCallback = true` to stop listening for CLS when the cleanup callback is called.\n * This will lead to the CLS being finalized and frozen.\n */\nfunction addClsInstrumentationHandler(callback) {\n  let stopOnCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return addMetricObserver('cls', callback, instrumentCls, _previousCls, stopOnCallback);\n}\n\n/**\n * Add a callback that will be triggered when a LCP metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n *\n * Pass `stopOnCallback = true` to stop listening for LCP when the cleanup callback is called.\n * This will lead to the LCP being finalized and frozen.\n */\nfunction addLcpInstrumentationHandler(callback) {\n  let stopOnCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return addMetricObserver('lcp', callback, instrumentLcp, _previousLcp, stopOnCallback);\n}\n\n/**\n * Add a callback that will be triggered when a FID metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nfunction addFidInstrumentationHandler(callback) {\n  return addMetricObserver('fid', callback, instrumentFid, _previousFid);\n}\n\n/**\n * Add a callback that will be triggered when a FID metric is available.\n */\nfunction addTtfbInstrumentationHandler(callback) {\n  return addMetricObserver('ttfb', callback, instrumentTtfb, _previousTtfb);\n}\n\n/**\n * Add a callback that will be triggered when a INP metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nfunction addInpInstrumentationHandler(callback) {\n  return addMetricObserver('inp', callback, instrumentInp, _previousInp);\n}\n\n/**\n * Add a callback that will be triggered when a performance observer is triggered,\n * and receives the entries of the observer.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nfunction addPerformanceInstrumentationHandler(type, callback) {\n  addHandler(type, callback);\n  if (!instrumented[type]) {\n    instrumentPerformanceObserver(type);\n    instrumented[type] = true;\n  }\n  return getCleanupCallback(type, callback);\n}\n\n/** Trigger all handlers of a given type. */\nfunction triggerHandlers(type, data) {\n  const typeHandlers = handlers[type];\n  if (!typeHandlers?.length) {\n    return;\n  }\n  for (const handler of typeHandlers) {\n    try {\n      handler(data);\n    } catch (e) {\n      DEBUG_BUILD && debug.error(`Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(handler)}\\nError:`, e);\n    }\n  }\n}\nfunction instrumentCls() {\n  return onCLS(metric => {\n    triggerHandlers('cls', {\n      metric\n    });\n    _previousCls = metric;\n  },\n  // We want the callback to be called whenever the CLS value updates.\n  // By default, the callback is only called when the tab goes to the background.\n  {\n    reportAllChanges: true\n  });\n}\nfunction instrumentFid() {\n  return onFID(metric => {\n    triggerHandlers('fid', {\n      metric\n    });\n    _previousFid = metric;\n  });\n}\nfunction instrumentLcp() {\n  return onLCP(metric => {\n    triggerHandlers('lcp', {\n      metric\n    });\n    _previousLcp = metric;\n  },\n  // We want the callback to be called whenever the LCP value updates.\n  // By default, the callback is only called when the tab goes to the background.\n  {\n    reportAllChanges: true\n  });\n}\nfunction instrumentTtfb() {\n  return onTTFB(metric => {\n    triggerHandlers('ttfb', {\n      metric\n    });\n    _previousTtfb = metric;\n  });\n}\nfunction instrumentInp() {\n  return onINP(metric => {\n    triggerHandlers('inp', {\n      metric\n    });\n    _previousInp = metric;\n  });\n}\nfunction addMetricObserver(type, callback, instrumentFn, previousValue) {\n  let stopOnCallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  addHandler(type, callback);\n  let stopListening;\n  if (!instrumented[type]) {\n    stopListening = instrumentFn();\n    instrumented[type] = true;\n  }\n  if (previousValue) {\n    callback({\n      metric: previousValue\n    });\n  }\n  return getCleanupCallback(type, callback, stopOnCallback ? stopListening : undefined);\n}\nfunction instrumentPerformanceObserver(type) {\n  const options = {};\n\n  // Special per-type options we want to use\n  if (type === 'event') {\n    options.durationThreshold = 0;\n  }\n  observe(type, entries => {\n    triggerHandlers(type, {\n      entries\n    });\n  }, options);\n}\nfunction addHandler(type, handler) {\n  handlers[type] = handlers[type] || [];\n  handlers[type].push(handler);\n}\n\n// Get a callback which can be called to remove the instrumentation handler\nfunction getCleanupCallback(type, callback, stopListening) {\n  return () => {\n    if (stopListening) {\n      stopListening();\n    }\n    const typeHandlers = handlers[type];\n    if (!typeHandlers) {\n      return;\n    }\n    const index = typeHandlers.indexOf(callback);\n    if (index !== -1) {\n      typeHandlers.splice(index, 1);\n    }\n  };\n}\n\n/**\n * Check if a PerformanceEntry is a PerformanceEventTiming by checking for the `duration` property.\n */\nfunction isPerformanceEventTiming(entry) {\n  return 'duration' in entry;\n}\nexport { addClsInstrumentationHandler, addFidInstrumentationHandler, addInpInstrumentationHandler, addLcpInstrumentationHandler, addPerformanceInstrumentationHandler, addTtfbInstrumentationHandler, isPerformanceEventTiming };\n//# sourceMappingURL=instrument.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}