{"ast":null,"code":"import { getClient, getCurrentScope } from '../currentScopes.js';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON } from '../semanticAttributes.js';\nimport { debug } from '../utils/debug-logger.js';\nimport { hasSpansEnabled } from '../utils/hasSpansEnabled.js';\nimport { _setSpanForScope } from '../utils/spanOnScope.js';\nimport { getActiveSpan, spanTimeInputToSeconds, getSpanDescendants, spanToJSON, removeChildSpanFromSpan } from '../utils/spanUtils.js';\nimport { timestampInSeconds } from '../utils/time.js';\nimport { getDynamicSamplingContextFromSpan, freezeDscOnSpan } from './dynamicSamplingContext.js';\nimport { SentryNonRecordingSpan } from './sentryNonRecordingSpan.js';\nimport { SentrySpan } from './sentrySpan.js';\nimport { SPAN_STATUS_ERROR } from './spanstatus.js';\nimport { startInactiveSpan } from './trace.js';\nconst TRACING_DEFAULTS = {\n  idleTimeout: 1000,\n  finalTimeout: 30000,\n  childSpanTimeout: 15000\n};\nconst FINISH_REASON_HEARTBEAT_FAILED = 'heartbeatFailed';\nconst FINISH_REASON_IDLE_TIMEOUT = 'idleTimeout';\nconst FINISH_REASON_FINAL_TIMEOUT = 'finalTimeout';\nconst FINISH_REASON_EXTERNAL_FINISH = 'externalFinish';\n\n/**\n * An idle span is a span that automatically finishes. It does this by tracking child spans as activities.\n * An idle span is always the active span.\n */\nfunction startIdleSpan(startSpanOptions, options = {}) {\n  // Activities store a list of active spans\n  const activities = new Map();\n\n  // We should not use heartbeat if we finished a span\n  let _finished = false;\n\n  // Timer that tracks idleTimeout\n  let _idleTimeoutID;\n\n  // The reason why the span was finished\n  let _finishReason = FINISH_REASON_EXTERNAL_FINISH;\n  let _autoFinishAllowed = !options.disableAutoFinish;\n  const _cleanupHooks = [];\n  const {\n    idleTimeout = TRACING_DEFAULTS.idleTimeout,\n    finalTimeout = TRACING_DEFAULTS.finalTimeout,\n    childSpanTimeout = TRACING_DEFAULTS.childSpanTimeout,\n    beforeSpanEnd\n  } = options;\n  const client = getClient();\n  if (!client || !hasSpansEnabled()) {\n    const span = new SentryNonRecordingSpan();\n    const dsc = {\n      sample_rate: '0',\n      sampled: 'false',\n      ...getDynamicSamplingContextFromSpan(span)\n    };\n    freezeDscOnSpan(span, dsc);\n    return span;\n  }\n  const scope = getCurrentScope();\n  const previousActiveSpan = getActiveSpan();\n  const span = _startIdleSpan(startSpanOptions);\n\n  // We patch span.end to ensure we can run some things before the span is ended\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  span.end = new Proxy(span.end, {\n    apply(target, thisArg, args) {\n      if (beforeSpanEnd) {\n        beforeSpanEnd(span);\n      }\n\n      // If the span is non-recording, nothing more to do here...\n      // This is the case if tracing is enabled but this specific span was not sampled\n      if (thisArg instanceof SentryNonRecordingSpan) {\n        return;\n      }\n\n      // Just ensuring that this keeps working, even if we ever have more arguments here\n      const [definedEndTimestamp, ...rest] = args;\n      const timestamp = definedEndTimestamp || timestampInSeconds();\n      const spanEndTimestamp = spanTimeInputToSeconds(timestamp);\n\n      // Ensure we end with the last span timestamp, if possible\n      const spans = getSpanDescendants(span).filter(child => child !== span);\n\n      // If we have no spans, we just end, nothing else to do here\n      if (!spans.length) {\n        onIdleSpanEnded(spanEndTimestamp);\n        return Reflect.apply(target, thisArg, [spanEndTimestamp, ...rest]);\n      }\n      const childEndTimestamps = spans.map(span => spanToJSON(span).timestamp).filter(timestamp => !!timestamp);\n      const latestSpanEndTimestamp = childEndTimestamps.length ? Math.max(...childEndTimestamps) : undefined;\n\n      // In reality this should always exist here, but type-wise it may be undefined...\n      const spanStartTimestamp = spanToJSON(span).start_timestamp;\n\n      // The final endTimestamp should:\n      // * Never be before the span start timestamp\n      // * Be the latestSpanEndTimestamp, if there is one, and it is smaller than the passed span end timestamp\n      // * Otherwise be the passed end timestamp\n      // Final timestamp can never be after finalTimeout\n      const endTimestamp = Math.min(spanStartTimestamp ? spanStartTimestamp + finalTimeout / 1000 : Infinity, Math.max(spanStartTimestamp || -Infinity, Math.min(spanEndTimestamp, latestSpanEndTimestamp || Infinity)));\n      onIdleSpanEnded(endTimestamp);\n      return Reflect.apply(target, thisArg, [endTimestamp, ...rest]);\n    }\n  });\n\n  /**\n   * Cancels the existing idle timeout, if there is one.\n   */\n  function _cancelIdleTimeout() {\n    if (_idleTimeoutID) {\n      clearTimeout(_idleTimeoutID);\n      _idleTimeoutID = undefined;\n    }\n  }\n\n  /**\n   * Restarts idle timeout, if there is no running idle timeout it will start one.\n   */\n  function _restartIdleTimeout(endTimestamp) {\n    _cancelIdleTimeout();\n    _idleTimeoutID = setTimeout(() => {\n      if (!_finished && activities.size === 0 && _autoFinishAllowed) {\n        _finishReason = FINISH_REASON_IDLE_TIMEOUT;\n        span.end(endTimestamp);\n      }\n    }, idleTimeout);\n  }\n\n  /**\n   * Restarts child span timeout, if there is none running it will start one.\n   */\n  function _restartChildSpanTimeout(endTimestamp) {\n    _idleTimeoutID = setTimeout(() => {\n      if (!_finished && _autoFinishAllowed) {\n        _finishReason = FINISH_REASON_HEARTBEAT_FAILED;\n        span.end(endTimestamp);\n      }\n    }, childSpanTimeout);\n  }\n\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n  function _pushActivity(spanId) {\n    _cancelIdleTimeout();\n    activities.set(spanId, true);\n    const endTimestamp = timestampInSeconds();\n    // We need to add the timeout here to have the real endtimestamp of the idle span\n    // Remember timestampInSeconds is in seconds, timeout is in ms\n    _restartChildSpanTimeout(endTimestamp + childSpanTimeout / 1000);\n  }\n\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n  function _popActivity(spanId) {\n    if (activities.has(spanId)) {\n      activities.delete(spanId);\n    }\n    if (activities.size === 0) {\n      const endTimestamp = timestampInSeconds();\n      // We need to add the timeout here to have the real endtimestamp of the idle span\n      // Remember timestampInSeconds is in seconds, timeout is in ms\n      _restartIdleTimeout(endTimestamp + idleTimeout / 1000);\n    }\n  }\n  function onIdleSpanEnded(endTimestamp) {\n    _finished = true;\n    activities.clear();\n    _cleanupHooks.forEach(cleanup => cleanup());\n    _setSpanForScope(scope, previousActiveSpan);\n    const spanJSON = spanToJSON(span);\n    const {\n      start_timestamp: startTimestamp\n    } = spanJSON;\n    // This should never happen, but to make TS happy...\n    if (!startTimestamp) {\n      return;\n    }\n    const attributes = spanJSON.data;\n    if (!attributes[SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON]) {\n      span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON, _finishReason);\n    }\n    debug.log(`[Tracing] Idle span \"${spanJSON.op}\" finished`);\n    const childSpans = getSpanDescendants(span).filter(child => child !== span);\n    let discardedSpans = 0;\n    childSpans.forEach(childSpan => {\n      // We cancel all pending spans with status \"cancelled\" to indicate the idle span was finished early\n      if (childSpan.isRecording()) {\n        childSpan.setStatus({\n          code: SPAN_STATUS_ERROR,\n          message: 'cancelled'\n        });\n        childSpan.end(endTimestamp);\n        DEBUG_BUILD && debug.log('[Tracing] Cancelling span since span ended early', JSON.stringify(childSpan, undefined, 2));\n      }\n      const childSpanJSON = spanToJSON(childSpan);\n      const {\n        timestamp: childEndTimestamp = 0,\n        start_timestamp: childStartTimestamp = 0\n      } = childSpanJSON;\n      const spanStartedBeforeIdleSpanEnd = childStartTimestamp <= endTimestamp;\n\n      // Add a delta with idle timeout so that we prevent false positives\n      const timeoutWithMarginOfError = (finalTimeout + idleTimeout) / 1000;\n      const spanEndedBeforeFinalTimeout = childEndTimestamp - childStartTimestamp <= timeoutWithMarginOfError;\n      if (DEBUG_BUILD) {\n        const stringifiedSpan = JSON.stringify(childSpan, undefined, 2);\n        if (!spanStartedBeforeIdleSpanEnd) {\n          debug.log('[Tracing] Discarding span since it happened after idle span was finished', stringifiedSpan);\n        } else if (!spanEndedBeforeFinalTimeout) {\n          debug.log('[Tracing] Discarding span since it finished after idle span final timeout', stringifiedSpan);\n        }\n      }\n      if (!spanEndedBeforeFinalTimeout || !spanStartedBeforeIdleSpanEnd) {\n        removeChildSpanFromSpan(span, childSpan);\n        discardedSpans++;\n      }\n    });\n    if (discardedSpans > 0) {\n      span.setAttribute('sentry.idle_span_discarded_spans', discardedSpans);\n    }\n  }\n  _cleanupHooks.push(client.on('spanStart', startedSpan => {\n    // If we already finished the idle span,\n    // or if this is the idle span itself being started,\n    // or if the started span has already been closed,\n    // we don't care about it for activity\n    if (_finished || startedSpan === span || !!spanToJSON(startedSpan).timestamp || startedSpan instanceof SentrySpan && startedSpan.isStandaloneSpan()) {\n      return;\n    }\n    const allSpans = getSpanDescendants(span);\n\n    // If the span that was just started is a child of the idle span, we should track it\n    if (allSpans.includes(startedSpan)) {\n      _pushActivity(startedSpan.spanContext().spanId);\n    }\n  }));\n  _cleanupHooks.push(client.on('spanEnd', endedSpan => {\n    if (_finished) {\n      return;\n    }\n    _popActivity(endedSpan.spanContext().spanId);\n  }));\n  _cleanupHooks.push(client.on('idleSpanEnableAutoFinish', spanToAllowAutoFinish => {\n    if (spanToAllowAutoFinish === span) {\n      _autoFinishAllowed = true;\n      _restartIdleTimeout();\n      if (activities.size) {\n        _restartChildSpanTimeout();\n      }\n    }\n  }));\n\n  // We only start the initial idle timeout if we are not delaying the auto finish\n  if (!options.disableAutoFinish) {\n    _restartIdleTimeout();\n  }\n  setTimeout(() => {\n    if (!_finished) {\n      span.setStatus({\n        code: SPAN_STATUS_ERROR,\n        message: 'deadline_exceeded'\n      });\n      _finishReason = FINISH_REASON_FINAL_TIMEOUT;\n      span.end();\n    }\n  }, finalTimeout);\n  return span;\n}\nfunction _startIdleSpan(options) {\n  const span = startInactiveSpan(options);\n  _setSpanForScope(getCurrentScope(), span);\n  DEBUG_BUILD && debug.log('[Tracing] Started span is an idle span');\n  return span;\n}\nexport { TRACING_DEFAULTS, startIdleSpan };","map":{"version":3,"names":["TRACING_DEFAULTS","idleTimeout","finalTimeout","childSpanTimeout","FINISH_REASON_HEARTBEAT_FAILED","FINISH_REASON_IDLE_TIMEOUT","FINISH_REASON_FINAL_TIMEOUT","FINISH_REASON_EXTERNAL_FINISH","startIdleSpan","startSpanOptions","options","activities","Map","_finished","_idleTimeoutID","_finishReason","_autoFinishAllowed","disableAutoFinish","_cleanupHooks","beforeSpanEnd","client","getClient","hasSpansEnabled","span","SentryNonRecordingSpan","dsc","sample_rate","sampled","getDynamicSamplingContextFromSpan","freezeDscOnSpan","scope","getCurrentScope","previousActiveSpan","getActiveSpan","_startIdleSpan","end","Proxy","apply","target","thisArg","args","definedEndTimestamp","rest","timestamp","timestampInSeconds","spanEndTimestamp","spanTimeInputToSeconds","spans","getSpanDescendants","filter","child","length","onIdleSpanEnded","Reflect","childEndTimestamps","map","spanToJSON","latestSpanEndTimestamp","Math","max","undefined","spanStartTimestamp","start_timestamp","endTimestamp","min","Infinity","_cancelIdleTimeout","clearTimeout","_restartIdleTimeout","setTimeout","size","_restartChildSpanTimeout","_pushActivity","spanId","set","_popActivity","has","delete","clear","forEach","cleanup","_setSpanForScope","spanJSON","startTimestamp","attributes","data","SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON","setAttribute","debug","log","op","childSpans","discardedSpans","childSpan","isRecording","setStatus","code","SPAN_STATUS_ERROR","message","DEBUG_BUILD","JSON","stringify","childSpanJSON","childEndTimestamp","childStartTimestamp","spanStartedBeforeIdleSpanEnd","timeoutWithMarginOfError","spanEndedBeforeFinalTimeout","stringifiedSpan","removeChildSpanFromSpan","push","on","startedSpan","SentrySpan","isStandaloneSpan","allSpans","includes","spanContext","endedSpan","spanToAllowAutoFinish","startInactiveSpan"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/tracing/idleSpan.ts"],"sourcesContent":["import { getClient, getCurrentScope } from '../currentScopes';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON } from '../semanticAttributes';\nimport type { DynamicSamplingContext } from '../types-hoist/envelope';\nimport type { Span } from '../types-hoist/span';\nimport type { StartSpanOptions } from '../types-hoist/startSpanOptions';\nimport { debug } from '../utils/debug-logger';\nimport { hasSpansEnabled } from '../utils/hasSpansEnabled';\nimport { _setSpanForScope } from '../utils/spanOnScope';\nimport {\n  getActiveSpan,\n  getSpanDescendants,\n  removeChildSpanFromSpan,\n  spanTimeInputToSeconds,\n  spanToJSON,\n} from '../utils/spanUtils';\nimport { timestampInSeconds } from '../utils/time';\nimport { freezeDscOnSpan, getDynamicSamplingContextFromSpan } from './dynamicSamplingContext';\nimport { SentryNonRecordingSpan } from './sentryNonRecordingSpan';\nimport { SentrySpan } from './sentrySpan';\nimport { SPAN_STATUS_ERROR } from './spanstatus';\nimport { startInactiveSpan } from './trace';\n\nexport const TRACING_DEFAULTS = {\n  idleTimeout: 1_000,\n  finalTimeout: 30_000,\n  childSpanTimeout: 15_000,\n};\n\nconst FINISH_REASON_HEARTBEAT_FAILED = 'heartbeatFailed';\nconst FINISH_REASON_IDLE_TIMEOUT = 'idleTimeout';\nconst FINISH_REASON_FINAL_TIMEOUT = 'finalTimeout';\nconst FINISH_REASON_EXTERNAL_FINISH = 'externalFinish';\nconst FINISH_REASON_CANCELLED = 'cancelled';\n\n// unused\nconst FINISH_REASON_DOCUMENT_HIDDEN = 'documentHidden';\n\n// unused in this file, but used in BrowserTracing\nconst FINISH_REASON_INTERRUPTED = 'interactionInterrupted';\n\ntype IdleSpanFinishReason =\n  | typeof FINISH_REASON_CANCELLED\n  | typeof FINISH_REASON_DOCUMENT_HIDDEN\n  | typeof FINISH_REASON_EXTERNAL_FINISH\n  | typeof FINISH_REASON_FINAL_TIMEOUT\n  | typeof FINISH_REASON_HEARTBEAT_FAILED\n  | typeof FINISH_REASON_IDLE_TIMEOUT\n  | typeof FINISH_REASON_INTERRUPTED;\n\ninterface IdleSpanOptions {\n  /**\n   * The time that has to pass without any span being created.\n   * If this time is exceeded, the idle span will finish.\n   */\n  idleTimeout: number;\n  /**\n   * The max. time an idle span may run.\n   * If this time is exceeded, the idle span will finish no matter what.\n   */\n  finalTimeout: number;\n  /**\n   * The max. time a child span may run.\n   * If the time since the last span was started exceeds this time, the idle span will finish.\n   */\n  childSpanTimeout?: number;\n  /**\n   * When set to `true`, will disable the idle timeout and child timeout\n   * until the `idleSpanEnableAutoFinish` hook is emitted for the idle span.\n   * The final timeout mechanism will not be affected by this option,\n   * meaning the idle span will definitely be finished when the final timeout is\n   * reached, no matter what this option is configured to.\n   *\n   * Defaults to `false`.\n   */\n  disableAutoFinish?: boolean;\n  /** Allows to configure a hook that is called when the idle span is ended, before it is processed. */\n  beforeSpanEnd?: (span: Span) => void;\n}\n\n/**\n * An idle span is a span that automatically finishes. It does this by tracking child spans as activities.\n * An idle span is always the active span.\n */\nexport function startIdleSpan(startSpanOptions: StartSpanOptions, options: Partial<IdleSpanOptions> = {}): Span {\n  // Activities store a list of active spans\n  const activities = new Map<string, boolean>();\n\n  // We should not use heartbeat if we finished a span\n  let _finished = false;\n\n  // Timer that tracks idleTimeout\n  let _idleTimeoutID: ReturnType<typeof setTimeout> | undefined;\n\n  // Timer that tracks maxSpanTime for child spans\n  let _childSpanTimeoutID: ReturnType<typeof setTimeout> | undefined;\n\n  // The reason why the span was finished\n  let _finishReason: IdleSpanFinishReason = FINISH_REASON_EXTERNAL_FINISH;\n\n  let _autoFinishAllowed: boolean = !options.disableAutoFinish;\n\n  const _cleanupHooks: (() => void)[] = [];\n\n  const {\n    idleTimeout = TRACING_DEFAULTS.idleTimeout,\n    finalTimeout = TRACING_DEFAULTS.finalTimeout,\n    childSpanTimeout = TRACING_DEFAULTS.childSpanTimeout,\n    beforeSpanEnd,\n  } = options;\n\n  const client = getClient();\n\n  if (!client || !hasSpansEnabled()) {\n    const span = new SentryNonRecordingSpan();\n\n    const dsc = {\n      sample_rate: '0',\n      sampled: 'false',\n      ...getDynamicSamplingContextFromSpan(span),\n    } satisfies Partial<DynamicSamplingContext>;\n    freezeDscOnSpan(span, dsc);\n\n    return span;\n  }\n\n  const scope = getCurrentScope();\n  const previousActiveSpan = getActiveSpan();\n  const span = _startIdleSpan(startSpanOptions);\n\n  // We patch span.end to ensure we can run some things before the span is ended\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  span.end = new Proxy(span.end, {\n    apply(target, thisArg, args: Parameters<Span['end']>) {\n      if (beforeSpanEnd) {\n        beforeSpanEnd(span);\n      }\n\n      // If the span is non-recording, nothing more to do here...\n      // This is the case if tracing is enabled but this specific span was not sampled\n      if (thisArg instanceof SentryNonRecordingSpan) {\n        return;\n      }\n\n      // Just ensuring that this keeps working, even if we ever have more arguments here\n      const [definedEndTimestamp, ...rest] = args;\n      const timestamp = definedEndTimestamp || timestampInSeconds();\n      const spanEndTimestamp = spanTimeInputToSeconds(timestamp);\n\n      // Ensure we end with the last span timestamp, if possible\n      const spans = getSpanDescendants(span).filter(child => child !== span);\n\n      // If we have no spans, we just end, nothing else to do here\n      if (!spans.length) {\n        onIdleSpanEnded(spanEndTimestamp);\n        return Reflect.apply(target, thisArg, [spanEndTimestamp, ...rest]);\n      }\n\n      const childEndTimestamps = spans\n        .map(span => spanToJSON(span).timestamp)\n        .filter(timestamp => !!timestamp) as number[];\n      const latestSpanEndTimestamp = childEndTimestamps.length ? Math.max(...childEndTimestamps) : undefined;\n\n      // In reality this should always exist here, but type-wise it may be undefined...\n      const spanStartTimestamp = spanToJSON(span).start_timestamp;\n\n      // The final endTimestamp should:\n      // * Never be before the span start timestamp\n      // * Be the latestSpanEndTimestamp, if there is one, and it is smaller than the passed span end timestamp\n      // * Otherwise be the passed end timestamp\n      // Final timestamp can never be after finalTimeout\n      const endTimestamp = Math.min(\n        spanStartTimestamp ? spanStartTimestamp + finalTimeout / 1000 : Infinity,\n        Math.max(spanStartTimestamp || -Infinity, Math.min(spanEndTimestamp, latestSpanEndTimestamp || Infinity)),\n      );\n\n      onIdleSpanEnded(endTimestamp);\n      return Reflect.apply(target, thisArg, [endTimestamp, ...rest]);\n    },\n  });\n\n  /**\n   * Cancels the existing idle timeout, if there is one.\n   */\n  function _cancelIdleTimeout(): void {\n    if (_idleTimeoutID) {\n      clearTimeout(_idleTimeoutID);\n      _idleTimeoutID = undefined;\n    }\n  }\n\n  /**\n   * Cancels the existing child span timeout, if there is one.\n   */\n  function _cancelChildSpanTimeout(): void {\n    if (_childSpanTimeoutID) {\n      clearTimeout(_childSpanTimeoutID);\n      _childSpanTimeoutID = undefined;\n    }\n  }\n\n  /**\n   * Restarts idle timeout, if there is no running idle timeout it will start one.\n   */\n  function _restartIdleTimeout(endTimestamp?: number): void {\n    _cancelIdleTimeout();\n    _idleTimeoutID = setTimeout(() => {\n      if (!_finished && activities.size === 0 && _autoFinishAllowed) {\n        _finishReason = FINISH_REASON_IDLE_TIMEOUT;\n        span.end(endTimestamp);\n      }\n    }, idleTimeout);\n  }\n\n  /**\n   * Restarts child span timeout, if there is none running it will start one.\n   */\n  function _restartChildSpanTimeout(endTimestamp?: number): void {\n    _cancelChildSpanTimeout();\n    _idleTimeoutID = setTimeout(() => {\n      if (!_finished && _autoFinishAllowed) {\n        _finishReason = FINISH_REASON_HEARTBEAT_FAILED;\n        span.end(endTimestamp);\n      }\n    }, childSpanTimeout);\n  }\n\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n  function _pushActivity(spanId: string): void {\n    _cancelIdleTimeout();\n    activities.set(spanId, true);\n\n    const endTimestamp = timestampInSeconds();\n    // We need to add the timeout here to have the real endtimestamp of the idle span\n    // Remember timestampInSeconds is in seconds, timeout is in ms\n    _restartChildSpanTimeout(endTimestamp + childSpanTimeout / 1000);\n  }\n\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n  function _popActivity(spanId: string): void {\n    if (activities.has(spanId)) {\n      activities.delete(spanId);\n    }\n\n    if (activities.size === 0) {\n      const endTimestamp = timestampInSeconds();\n      // We need to add the timeout here to have the real endtimestamp of the idle span\n      // Remember timestampInSeconds is in seconds, timeout is in ms\n      _restartIdleTimeout(endTimestamp + idleTimeout / 1000);\n      _cancelChildSpanTimeout();\n    }\n  }\n\n  function onIdleSpanEnded(endTimestamp: number): void {\n    _finished = true;\n    activities.clear();\n\n    _cleanupHooks.forEach(cleanup => cleanup());\n\n    _setSpanForScope(scope, previousActiveSpan);\n\n    const spanJSON = spanToJSON(span);\n\n    const { start_timestamp: startTimestamp } = spanJSON;\n    // This should never happen, but to make TS happy...\n    if (!startTimestamp) {\n      return;\n    }\n\n    const attributes = spanJSON.data;\n    if (!attributes[SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON]) {\n      span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON, _finishReason);\n    }\n\n    debug.log(`[Tracing] Idle span \"${spanJSON.op}\" finished`);\n\n    const childSpans = getSpanDescendants(span).filter(child => child !== span);\n\n    let discardedSpans = 0;\n    childSpans.forEach(childSpan => {\n      // We cancel all pending spans with status \"cancelled\" to indicate the idle span was finished early\n      if (childSpan.isRecording()) {\n        childSpan.setStatus({ code: SPAN_STATUS_ERROR, message: 'cancelled' });\n        childSpan.end(endTimestamp);\n        DEBUG_BUILD &&\n          debug.log('[Tracing] Cancelling span since span ended early', JSON.stringify(childSpan, undefined, 2));\n      }\n\n      const childSpanJSON = spanToJSON(childSpan);\n      const { timestamp: childEndTimestamp = 0, start_timestamp: childStartTimestamp = 0 } = childSpanJSON;\n\n      const spanStartedBeforeIdleSpanEnd = childStartTimestamp <= endTimestamp;\n\n      // Add a delta with idle timeout so that we prevent false positives\n      const timeoutWithMarginOfError = (finalTimeout + idleTimeout) / 1000;\n      const spanEndedBeforeFinalTimeout = childEndTimestamp - childStartTimestamp <= timeoutWithMarginOfError;\n\n      if (DEBUG_BUILD) {\n        const stringifiedSpan = JSON.stringify(childSpan, undefined, 2);\n        if (!spanStartedBeforeIdleSpanEnd) {\n          debug.log('[Tracing] Discarding span since it happened after idle span was finished', stringifiedSpan);\n        } else if (!spanEndedBeforeFinalTimeout) {\n          debug.log('[Tracing] Discarding span since it finished after idle span final timeout', stringifiedSpan);\n        }\n      }\n\n      if (!spanEndedBeforeFinalTimeout || !spanStartedBeforeIdleSpanEnd) {\n        removeChildSpanFromSpan(span, childSpan);\n        discardedSpans++;\n      }\n    });\n\n    if (discardedSpans > 0) {\n      span.setAttribute('sentry.idle_span_discarded_spans', discardedSpans);\n    }\n  }\n\n  _cleanupHooks.push(\n    client.on('spanStart', startedSpan => {\n      // If we already finished the idle span,\n      // or if this is the idle span itself being started,\n      // or if the started span has already been closed,\n      // we don't care about it for activity\n      if (\n        _finished ||\n        startedSpan === span ||\n        !!spanToJSON(startedSpan).timestamp ||\n        (startedSpan instanceof SentrySpan && startedSpan.isStandaloneSpan())\n      ) {\n        return;\n      }\n\n      const allSpans = getSpanDescendants(span);\n\n      // If the span that was just started is a child of the idle span, we should track it\n      if (allSpans.includes(startedSpan)) {\n        _pushActivity(startedSpan.spanContext().spanId);\n      }\n    }),\n  );\n\n  _cleanupHooks.push(\n    client.on('spanEnd', endedSpan => {\n      if (_finished) {\n        return;\n      }\n\n      _popActivity(endedSpan.spanContext().spanId);\n    }),\n  );\n\n  _cleanupHooks.push(\n    client.on('idleSpanEnableAutoFinish', spanToAllowAutoFinish => {\n      if (spanToAllowAutoFinish === span) {\n        _autoFinishAllowed = true;\n        _restartIdleTimeout();\n\n        if (activities.size) {\n          _restartChildSpanTimeout();\n        }\n      }\n    }),\n  );\n\n  // We only start the initial idle timeout if we are not delaying the auto finish\n  if (!options.disableAutoFinish) {\n    _restartIdleTimeout();\n  }\n\n  setTimeout(() => {\n    if (!_finished) {\n      span.setStatus({ code: SPAN_STATUS_ERROR, message: 'deadline_exceeded' });\n      _finishReason = FINISH_REASON_FINAL_TIMEOUT;\n      span.end();\n    }\n  }, finalTimeout);\n\n  return span;\n}\n\nfunction _startIdleSpan(options: StartSpanOptions): Span {\n  const span = startInactiveSpan(options);\n\n  _setSpanForScope(getCurrentScope(), span);\n\n  DEBUG_BUILD && debug.log('[Tracing] Started span is an idle span');\n\n  return span;\n}\n"],"mappings":";;;;;;;;;;;;;AAuBO,MAAMA,gBAAA,GAAmB;EAC9BC,WAAW,EAAE,IAAK;EAClBC,YAAY,EAAE,KAAM;EACpBC,gBAAgB,EAAE;AACpB;AAEA,MAAMC,8BAAA,GAAiC,iBAAiB;AACxD,MAAMC,0BAAA,GAA6B,aAAa;AAChD,MAAMC,2BAAA,GAA8B,cAAc;AAClD,MAAMC,6BAAA,GAAgC,gBAAgB;;AAgDtD;AACA;AACA;AACA;AACO,SAASC,aAAaA,CAACC,gBAAgB,EAAoBC,OAAO,GAA6B,EAAE,EAAQ;EAChH;EACE,MAAMC,UAAA,GAAa,IAAIC,GAAG,EAAmB;;EAE/C;EACE,IAAIC,SAAA,GAAY,KAAK;;EAEvB;EACE,IAAIC,cAAc;;EAKpB;EACE,IAAIC,aAAa,GAAyBR,6BAA6B;EAEvE,IAAIS,kBAAkB,GAAY,CAACN,OAAO,CAACO,iBAAiB;EAE5D,MAAMC,aAAa,GAAmB,EAAE;EAExC,MAAM;IACJjB,WAAA,GAAcD,gBAAgB,CAACC,WAAW;IAC1CC,YAAA,GAAeF,gBAAgB,CAACE,YAAY;IAC5CC,gBAAA,GAAmBH,gBAAgB,CAACG,gBAAgB;IACpDgB;EACJ,CAAE,GAAIT,OAAO;EAEX,MAAMU,MAAA,GAASC,SAAS,EAAE;EAE1B,IAAI,CAACD,MAAA,IAAU,CAACE,eAAe,EAAE,EAAE;IACjC,MAAMC,IAAA,GAAO,IAAIC,sBAAsB,EAAE;IAEzC,MAAMC,GAAA,GAAM;MACVC,WAAW,EAAE,GAAG;MAChBC,OAAO,EAAE,OAAO;MAChB,GAAGC,iCAAiC,CAACL,IAAI;IAC/C,CAAI;IACAM,eAAe,CAACN,IAAI,EAAEE,GAAG,CAAC;IAE1B,OAAOF,IAAI;EACf;EAEE,MAAMO,KAAA,GAAQC,eAAe,EAAE;EAC/B,MAAMC,kBAAA,GAAqBC,aAAa,EAAE;EAC1C,MAAMV,IAAA,GAAOW,cAAc,CAACzB,gBAAgB,CAAC;;EAE/C;EACA;EACEc,IAAI,CAACY,GAAA,GAAM,IAAIC,KAAK,CAACb,IAAI,CAACY,GAAG,EAAE;IAC7BE,KAAKA,CAACC,MAAM,EAAEC,OAAO,EAAEC,IAAI,EAA2B;MACpD,IAAIrB,aAAa,EAAE;QACjBA,aAAa,CAACI,IAAI,CAAC;MAC3B;;MAEA;MACA;MACM,IAAIgB,OAAA,YAAmBf,sBAAsB,EAAE;QAC7C;MACR;;MAEA;MACM,MAAM,CAACiB,mBAAmB,EAAE,GAAGC,IAAI,IAAIF,IAAI;MAC3C,MAAMG,SAAA,GAAYF,mBAAA,IAAuBG,kBAAkB,EAAE;MAC7D,MAAMC,gBAAA,GAAmBC,sBAAsB,CAACH,SAAS,CAAC;;MAEhE;MACM,MAAMI,KAAA,GAAQC,kBAAkB,CAACzB,IAAI,CAAC,CAAC0B,MAAM,CAACC,KAAA,IAASA,KAAA,KAAU3B,IAAI,CAAC;;MAE5E;MACM,IAAI,CAACwB,KAAK,CAACI,MAAM,EAAE;QACjBC,eAAe,CAACP,gBAAgB,CAAC;QACjC,OAAOQ,OAAO,CAAChB,KAAK,CAACC,MAAM,EAAEC,OAAO,EAAE,CAACM,gBAAgB,EAAE,GAAGH,IAAI,CAAC,CAAC;MAC1E;MAEM,MAAMY,kBAAA,GAAqBP,KAAA,CACxBQ,GAAG,CAAChC,IAAA,IAAQiC,UAAU,CAACjC,IAAI,CAAC,CAACoB,SAAS,EACtCM,MAAM,CAACN,SAAA,IAAa,CAAC,CAACA,SAAS;MAClC,MAAMc,sBAAA,GAAyBH,kBAAkB,CAACH,MAAA,GAASO,IAAI,CAACC,GAAG,CAAC,GAAGL,kBAAkB,IAAIM,SAAS;;MAE5G;MACM,MAAMC,kBAAA,GAAqBL,UAAU,CAACjC,IAAI,CAAC,CAACuC,eAAe;;MAEjE;MACA;MACA;MACA;MACA;MACM,MAAMC,YAAA,GAAeL,IAAI,CAACM,GAAG,CAC3BH,kBAAA,GAAqBA,kBAAA,GAAqB3D,YAAA,GAAe,OAAO+D,QAAQ,EACxEP,IAAI,CAACC,GAAG,CAACE,kBAAA,IAAsB,CAACI,QAAQ,EAAEP,IAAI,CAACM,GAAG,CAACnB,gBAAgB,EAAEY,sBAAA,IAA0BQ,QAAQ,CAAC,CAChH,CAAO;MAEDb,eAAe,CAACW,YAAY,CAAC;MAC7B,OAAOV,OAAO,CAAChB,KAAK,CAACC,MAAM,EAAEC,OAAO,EAAE,CAACwB,YAAY,EAAE,GAAGrB,IAAI,CAAC,CAAC;IACpE;EACA,CAAG,CAAC;;EAEJ;AACA;AACA;EACE,SAASwB,kBAAkBA,CAAA,EAAS;IAClC,IAAIpD,cAAc,EAAE;MAClBqD,YAAY,CAACrD,cAAc,CAAC;MAC5BA,cAAA,GAAiB8C,SAAS;IAChC;EACA;;EAYA;AACA;AACA;EACE,SAASQ,mBAAmBA,CAACL,YAAY,EAAiB;IACxDG,kBAAkB,EAAE;IACpBpD,cAAA,GAAiBuD,UAAU,CAAC,MAAM;MAChC,IAAI,CAACxD,SAAA,IAAaF,UAAU,CAAC2D,IAAA,KAAS,KAAKtD,kBAAkB,EAAE;QAC7DD,aAAA,GAAgBV,0BAA0B;QAC1CkB,IAAI,CAACY,GAAG,CAAC4B,YAAY,CAAC;MAC9B;IACA,CAAK,EAAE9D,WAAW,CAAC;EACnB;;EAEA;AACA;AACA;EACE,SAASsE,wBAAwBA,CAACR,YAAY,EAAiB;IAE7DjD,cAAA,GAAiBuD,UAAU,CAAC,MAAM;MAChC,IAAI,CAACxD,SAAA,IAAaG,kBAAkB,EAAE;QACpCD,aAAA,GAAgBX,8BAA8B;QAC9CmB,IAAI,CAACY,GAAG,CAAC4B,YAAY,CAAC;MAC9B;IACA,CAAK,EAAE5D,gBAAgB,CAAC;EACxB;;EAEA;AACA;AACA;AACA;EACE,SAASqE,aAAaA,CAACC,MAAM,EAAgB;IAC3CP,kBAAkB,EAAE;IACpBvD,UAAU,CAAC+D,GAAG,CAACD,MAAM,EAAE,IAAI,CAAC;IAE5B,MAAMV,YAAA,GAAenB,kBAAkB,EAAE;IAC7C;IACA;IACI2B,wBAAwB,CAACR,YAAA,GAAe5D,gBAAA,GAAmB,IAAI,CAAC;EACpE;;EAEA;AACA;AACA;AACA;EACE,SAASwE,YAAYA,CAACF,MAAM,EAAgB;IAC1C,IAAI9D,UAAU,CAACiE,GAAG,CAACH,MAAM,CAAC,EAAE;MAC1B9D,UAAU,CAACkE,MAAM,CAACJ,MAAM,CAAC;IAC/B;IAEI,IAAI9D,UAAU,CAAC2D,IAAA,KAAS,CAAC,EAAE;MACzB,MAAMP,YAAA,GAAenB,kBAAkB,EAAE;MAC/C;MACA;MACMwB,mBAAmB,CAACL,YAAA,GAAe9D,WAAA,GAAc,IAAI,CAAC;IAE5D;EACA;EAEE,SAASmD,eAAeA,CAACW,YAAY,EAAgB;IACnDlD,SAAA,GAAY,IAAI;IAChBF,UAAU,CAACmE,KAAK,EAAE;IAElB5D,aAAa,CAAC6D,OAAO,CAACC,OAAA,IAAWA,OAAO,EAAE,CAAC;IAE3CC,gBAAgB,CAACnD,KAAK,EAAEE,kBAAkB,CAAC;IAE3C,MAAMkD,QAAA,GAAW1B,UAAU,CAACjC,IAAI,CAAC;IAEjC,MAAM;MAAEuC,eAAe,EAAEqB;IAAA,CAAe,GAAID,QAAQ;IACxD;IACI,IAAI,CAACC,cAAc,EAAE;MACnB;IACN;IAEI,MAAMC,UAAA,GAAaF,QAAQ,CAACG,IAAI;IAChC,IAAI,CAACD,UAAU,CAACE,iDAAiD,CAAC,EAAE;MAClE/D,IAAI,CAACgE,YAAY,CAACD,iDAAiD,EAAEvE,aAAa,CAAC;IACzF;IAEIyE,KAAK,CAACC,GAAG,CAAC,wBAAwBP,QAAQ,CAACQ,EAAE,YAAY,CAAC;IAE1D,MAAMC,UAAA,GAAa3C,kBAAkB,CAACzB,IAAI,CAAC,CAAC0B,MAAM,CAACC,KAAA,IAASA,KAAA,KAAU3B,IAAI,CAAC;IAE3E,IAAIqE,cAAA,GAAiB,CAAC;IACtBD,UAAU,CAACZ,OAAO,CAACc,SAAA,IAAa;MACpC;MACM,IAAIA,SAAS,CAACC,WAAW,EAAE,EAAE;QAC3BD,SAAS,CAACE,SAAS,CAAC;UAAEC,IAAI,EAAEC,iBAAiB;UAAEC,OAAO,EAAE;QAAA,CAAa,CAAC;QACtEL,SAAS,CAAC1D,GAAG,CAAC4B,YAAY,CAAC;QAC3BoC,WAAA,IACEX,KAAK,CAACC,GAAG,CAAC,kDAAkD,EAAEW,IAAI,CAACC,SAAS,CAACR,SAAS,EAAEjC,SAAS,EAAE,CAAC,CAAC,CAAC;MAChH;MAEM,MAAM0C,aAAA,GAAgB9C,UAAU,CAACqC,SAAS,CAAC;MAC3C,MAAM;QAAElD,SAAS,EAAE4D,iBAAA,GAAoB,CAAC;QAAEzC,eAAe,EAAE0C,mBAAA,GAAsB;MAAA,CAAE,GAAIF,aAAa;MAEpG,MAAMG,4BAAA,GAA+BD,mBAAA,IAAuBzC,YAAY;;MAE9E;MACM,MAAM2C,wBAAA,GAA2B,CAACxG,YAAA,GAAeD,WAAW,IAAI,IAAI;MACpE,MAAM0G,2BAAA,GAA8BJ,iBAAA,GAAoBC,mBAAA,IAAuBE,wBAAwB;MAEvG,IAAIP,WAAW,EAAE;QACf,MAAMS,eAAA,GAAkBR,IAAI,CAACC,SAAS,CAACR,SAAS,EAAEjC,SAAS,EAAE,CAAC,CAAC;QAC/D,IAAI,CAAC6C,4BAA4B,EAAE;UACjCjB,KAAK,CAACC,GAAG,CAAC,0EAA0E,EAAEmB,eAAe,CAAC;QAChH,OAAe,IAAI,CAACD,2BAA2B,EAAE;UACvCnB,KAAK,CAACC,GAAG,CAAC,2EAA2E,EAAEmB,eAAe,CAAC;QACjH;MACA;MAEM,IAAI,CAACD,2BAAA,IAA+B,CAACF,4BAA4B,EAAE;QACjEI,uBAAuB,CAACtF,IAAI,EAAEsE,SAAS,CAAC;QACxCD,cAAc,EAAE;MACxB;IACA,CAAK,CAAC;IAEF,IAAIA,cAAA,GAAiB,CAAC,EAAE;MACtBrE,IAAI,CAACgE,YAAY,CAAC,kCAAkC,EAAEK,cAAc,CAAC;IAC3E;EACA;EAEE1E,aAAa,CAAC4F,IAAI,CAChB1F,MAAM,CAAC2F,EAAE,CAAC,WAAW,EAAEC,WAAA,IAAe;IAC1C;IACA;IACA;IACA;IACM,IACEnG,SAAA,IACAmG,WAAA,KAAgBzF,IAAA,IAChB,CAAC,CAACiC,UAAU,CAACwD,WAAW,CAAC,CAACrE,SAAA,IACzBqE,WAAA,YAAuBC,UAAA,IAAcD,WAAW,CAACE,gBAAgB,EAAE,EACpE;MACA;IACR;IAEM,MAAMC,QAAA,GAAWnE,kBAAkB,CAACzB,IAAI,CAAC;;IAE/C;IACM,IAAI4F,QAAQ,CAACC,QAAQ,CAACJ,WAAW,CAAC,EAAE;MAClCxC,aAAa,CAACwC,WAAW,CAACK,WAAW,EAAE,CAAC5C,MAAM,CAAC;IACvD;EACA,CAAK,CACL,CAAG;EAEDvD,aAAa,CAAC4F,IAAI,CAChB1F,MAAM,CAAC2F,EAAE,CAAC,SAAS,EAAEO,SAAA,IAAa;IAChC,IAAIzG,SAAS,EAAE;MACb;IACR;IAEM8D,YAAY,CAAC2C,SAAS,CAACD,WAAW,EAAE,CAAC5C,MAAM,CAAC;EAClD,CAAK,CACL,CAAG;EAEDvD,aAAa,CAAC4F,IAAI,CAChB1F,MAAM,CAAC2F,EAAE,CAAC,0BAA0B,EAAEQ,qBAAA,IAAyB;IAC7D,IAAIA,qBAAA,KAA0BhG,IAAI,EAAE;MAClCP,kBAAA,GAAqB,IAAI;MACzBoD,mBAAmB,EAAE;MAErB,IAAIzD,UAAU,CAAC2D,IAAI,EAAE;QACnBC,wBAAwB,EAAE;MACpC;IACA;EACA,CAAK,CACL,CAAG;;EAEH;EACE,IAAI,CAAC7D,OAAO,CAACO,iBAAiB,EAAE;IAC9BmD,mBAAmB,EAAE;EACzB;EAEEC,UAAU,CAAC,MAAM;IACf,IAAI,CAACxD,SAAS,EAAE;MACdU,IAAI,CAACwE,SAAS,CAAC;QAAEC,IAAI,EAAEC,iBAAiB;QAAEC,OAAO,EAAE;MAAA,CAAqB,CAAC;MACzEnF,aAAA,GAAgBT,2BAA2B;MAC3CiB,IAAI,CAACY,GAAG,EAAE;IAChB;EACA,CAAG,EAAEjC,YAAY,CAAC;EAEhB,OAAOqB,IAAI;AACb;AAEA,SAASW,cAAcA,CAACxB,OAAO,EAA0B;EACvD,MAAMa,IAAA,GAAOiG,iBAAiB,CAAC9G,OAAO,CAAC;EAEvCuE,gBAAgB,CAAClD,eAAe,EAAE,EAAER,IAAI,CAAC;EAEzC4E,WAAA,IAAeX,KAAK,CAACC,GAAG,CAAC,wCAAwC,CAAC;EAElE,OAAOlE,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}