{"ast":null,"code":"import { GLOBAL_OBJ } from '../utils/worldwide.js';\nimport { addHandler, maybeInstrument, triggerHandlers } from './handlers.js';\nlet _oldOnErrorHandler = null;\n\n/**\n * Add an instrumentation handler for when an error is captured by the global error handler.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addGlobalErrorInstrumentationHandler(handler) {\n  const type = 'error';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentError);\n}\nfunction instrumentError() {\n  _oldOnErrorHandler = GLOBAL_OBJ.onerror;\n\n  // Note: The reason we are doing window.onerror instead of window.addEventListener('error')\n  // is that we are using this handler in the Loader Script, to handle buffered errors consistently\n  GLOBAL_OBJ.onerror = function (msg, url, line, column, error) {\n    const handlerData = {\n      column,\n      error,\n      line,\n      msg,\n      url\n    };\n    triggerHandlers('error', handlerData);\n    if (_oldOnErrorHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnErrorHandler.apply(this, arguments);\n    }\n    return false;\n  };\n  GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = true;\n}\nexport { addGlobalErrorInstrumentationHandler };","map":{"version":3,"names":["_oldOnErrorHandler","addGlobalErrorInstrumentationHandler","handler","type","addHandler","maybeInstrument","instrumentError","GLOBAL_OBJ","onerror","msg","url","line","column","error","handlerData","triggerHandlers","apply","arguments","__SENTRY_INSTRUMENTED__"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/instrument/globalError.ts"],"sourcesContent":["import type { HandlerDataError } from '../types-hoist/instrument';\nimport { GLOBAL_OBJ } from '../utils/worldwide';\nimport { addHandler, maybeInstrument, triggerHandlers } from './handlers';\n\nlet _oldOnErrorHandler: (typeof GLOBAL_OBJ)['onerror'] | null = null;\n\n/**\n * Add an instrumentation handler for when an error is captured by the global error handler.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addGlobalErrorInstrumentationHandler(handler: (data: HandlerDataError) => void): void {\n  const type = 'error';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentError);\n}\n\nfunction instrumentError(): void {\n  _oldOnErrorHandler = GLOBAL_OBJ.onerror;\n\n  // Note: The reason we are doing window.onerror instead of window.addEventListener('error')\n  // is that we are using this handler in the Loader Script, to handle buffered errors consistently\n  GLOBAL_OBJ.onerror = function (\n    msg: string | object,\n    url?: string,\n    line?: number,\n    column?: number,\n    error?: Error,\n  ): boolean {\n    const handlerData: HandlerDataError = {\n      column,\n      error,\n      line,\n      msg,\n      url,\n    };\n    triggerHandlers('error', handlerData);\n\n    if (_oldOnErrorHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnErrorHandler.apply(this, arguments);\n    }\n\n    return false;\n  };\n\n  GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = true;\n}\n"],"mappings":";;AAIA,IAAIA,kBAAkB,GAA0C,IAAI;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,oCAAoCA,CAACC,OAAO,EAA0C;EACpG,MAAMC,IAAA,GAAO,OAAO;EACpBC,UAAU,CAACD,IAAI,EAAED,OAAO,CAAC;EACzBG,eAAe,CAACF,IAAI,EAAEG,eAAe,CAAC;AACxC;AAEA,SAASA,eAAeA,CAAA,EAAS;EAC/BN,kBAAA,GAAqBO,UAAU,CAACC,OAAO;;EAEzC;EACA;EACED,UAAU,CAACC,OAAA,GAAU,UACnBC,GAAG,EACHC,GAAG,EACHC,IAAI,EACJC,MAAM,EACNC,KAAK,EACI;IACT,MAAMC,WAAW,GAAqB;MACpCF,MAAM;MACNC,KAAK;MACLF,IAAI;MACJF,GAAG;MACHC;IACN,CAAK;IACDK,eAAe,CAAC,OAAO,EAAED,WAAW,CAAC;IAErC,IAAId,kBAAkB,EAAE;MAC5B;MACM,OAAOA,kBAAkB,CAACgB,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;IACtD;IAEI,OAAO,KAAK;EAChB,CAAG;EAEDV,UAAU,CAACC,OAAO,CAACU,uBAAA,GAA0B,IAAI;AACnD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}