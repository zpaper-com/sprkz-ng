{"ast":null,"code":"import { DEBUG_BUILD } from '../debug-build.js';\nimport { consoleSandbox, debug } from './debug-logger.js';\n\n/** Regular expression used to extract org ID from a DSN host. */\nconst ORG_ID_REGEX = /^o(\\d+)\\./;\n\n/** Regular expression used to parse a Dsn. */\nconst DSN_REGEX = /^(?:(\\w+):)\\/\\/(?:(\\w+)(?::(\\w+)?)?@)([\\w.-]+)(?::(\\d+))?\\/(.+)/;\nfunction isValidProtocol(protocol) {\n  return protocol === 'http' || protocol === 'https';\n}\n\n/**\n * Renders the string representation of this Dsn.\n *\n * By default, this will render the public representation without the password\n * component. To get the deprecated private representation, set `withPassword`\n * to true.\n *\n * @param withPassword When set to true, the password will be included.\n */\nfunction dsnToString(dsn, withPassword = false) {\n  const {\n    host,\n    path,\n    pass,\n    port,\n    projectId,\n    protocol,\n    publicKey\n  } = dsn;\n  return `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ''}` + `@${host}${port ? `:${port}` : ''}/${path ? `${path}/` : path}${projectId}`;\n}\n\n/**\n * Parses a Dsn from a given string.\n *\n * @param str A Dsn as string\n * @returns Dsn as DsnComponents or undefined if @param str is not a valid DSN string\n */\nfunction dsnFromString(str) {\n  const match = DSN_REGEX.exec(str);\n  if (!match) {\n    // This should be logged to the console\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.error(`Invalid Sentry Dsn: ${str}`);\n    });\n    return undefined;\n  }\n  const [protocol, publicKey, pass = '', host = '', port = '', lastPath = ''] = match.slice(1);\n  let path = '';\n  let projectId = lastPath;\n  const split = projectId.split('/');\n  if (split.length > 1) {\n    path = split.slice(0, -1).join('/');\n    projectId = split.pop();\n  }\n  if (projectId) {\n    const projectMatch = projectId.match(/^\\d+/);\n    if (projectMatch) {\n      projectId = projectMatch[0];\n    }\n  }\n  return dsnFromComponents({\n    host,\n    pass,\n    path,\n    projectId,\n    port,\n    protocol: protocol,\n    publicKey\n  });\n}\nfunction dsnFromComponents(components) {\n  return {\n    protocol: components.protocol,\n    publicKey: components.publicKey || '',\n    pass: components.pass || '',\n    host: components.host,\n    port: components.port || '',\n    path: components.path || '',\n    projectId: components.projectId\n  };\n}\nfunction validateDsn(dsn) {\n  if (!DEBUG_BUILD) {\n    return true;\n  }\n  const {\n    port,\n    projectId,\n    protocol\n  } = dsn;\n  const requiredComponents = ['protocol', 'publicKey', 'host', 'projectId'];\n  const hasMissingRequiredComponent = requiredComponents.find(component => {\n    if (!dsn[component]) {\n      debug.error(`Invalid Sentry Dsn: ${component} missing`);\n      return true;\n    }\n    return false;\n  });\n  if (hasMissingRequiredComponent) {\n    return false;\n  }\n  if (!projectId.match(/^\\d+$/)) {\n    debug.error(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);\n    return false;\n  }\n  if (!isValidProtocol(protocol)) {\n    debug.error(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);\n    return false;\n  }\n  if (port && isNaN(parseInt(port, 10))) {\n    debug.error(`Invalid Sentry Dsn: Invalid port ${port}`);\n    return false;\n  }\n  return true;\n}\n\n/**\n * Extract the org ID from a DSN host.\n *\n * @param host The host from a DSN\n * @returns The org ID if found, undefined otherwise\n */\nfunction extractOrgIdFromDsnHost(host) {\n  const match = host.match(ORG_ID_REGEX);\n  return match?.[1];\n}\n\n/**\n * Creates a valid Sentry Dsn object, identifying a Sentry instance and project.\n * @returns a valid DsnComponents object or `undefined` if @param from is an invalid DSN source\n */\nfunction makeDsn(from) {\n  const components = typeof from === 'string' ? dsnFromString(from) : dsnFromComponents(from);\n  if (!components || !validateDsn(components)) {\n    return undefined;\n  }\n  return components;\n}\nexport { dsnFromString, dsnToString, extractOrgIdFromDsnHost, makeDsn };","map":{"version":3,"names":["ORG_ID_REGEX","DSN_REGEX","isValidProtocol","protocol","dsnToString","dsn","withPassword","host","path","pass","port","projectId","publicKey","dsnFromString","str","match","exec","consoleSandbox","console","error","undefined","lastPath","slice","split","length","join","pop","projectMatch","dsnFromComponents","components","validateDsn","DEBUG_BUILD","requiredComponents","hasMissingRequiredComponent","find","component","debug","isNaN","parseInt","extractOrgIdFromDsnHost","makeDsn","from"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/utils/dsn.ts"],"sourcesContent":["import { DEBUG_BUILD } from '../debug-build';\nimport type { DsnComponents, DsnLike, DsnProtocol } from '../types-hoist/dsn';\nimport { consoleSandbox, debug } from './debug-logger';\n\n/** Regular expression used to extract org ID from a DSN host. */\nconst ORG_ID_REGEX = /^o(\\d+)\\./;\n\n/** Regular expression used to parse a Dsn. */\nconst DSN_REGEX = /^(?:(\\w+):)\\/\\/(?:(\\w+)(?::(\\w+)?)?@)([\\w.-]+)(?::(\\d+))?\\/(.+)/;\n\nfunction isValidProtocol(protocol?: string): protocol is DsnProtocol {\n  return protocol === 'http' || protocol === 'https';\n}\n\n/**\n * Renders the string representation of this Dsn.\n *\n * By default, this will render the public representation without the password\n * component. To get the deprecated private representation, set `withPassword`\n * to true.\n *\n * @param withPassword When set to true, the password will be included.\n */\nexport function dsnToString(dsn: DsnComponents, withPassword: boolean = false): string {\n  const { host, path, pass, port, projectId, protocol, publicKey } = dsn;\n  return (\n    `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ''}` +\n    `@${host}${port ? `:${port}` : ''}/${path ? `${path}/` : path}${projectId}`\n  );\n}\n\n/**\n * Parses a Dsn from a given string.\n *\n * @param str A Dsn as string\n * @returns Dsn as DsnComponents or undefined if @param str is not a valid DSN string\n */\nexport function dsnFromString(str: string): DsnComponents | undefined {\n  const match = DSN_REGEX.exec(str);\n\n  if (!match) {\n    // This should be logged to the console\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.error(`Invalid Sentry Dsn: ${str}`);\n    });\n    return undefined;\n  }\n\n  const [protocol, publicKey, pass = '', host = '', port = '', lastPath = ''] = match.slice(1);\n  let path = '';\n  let projectId = lastPath;\n\n  const split = projectId.split('/');\n  if (split.length > 1) {\n    path = split.slice(0, -1).join('/');\n    projectId = split.pop() as string;\n  }\n\n  if (projectId) {\n    const projectMatch = projectId.match(/^\\d+/);\n    if (projectMatch) {\n      projectId = projectMatch[0];\n    }\n  }\n\n  return dsnFromComponents({ host, pass, path, projectId, port, protocol: protocol as DsnProtocol, publicKey });\n}\n\nfunction dsnFromComponents(components: DsnComponents): DsnComponents {\n  return {\n    protocol: components.protocol,\n    publicKey: components.publicKey || '',\n    pass: components.pass || '',\n    host: components.host,\n    port: components.port || '',\n    path: components.path || '',\n    projectId: components.projectId,\n  };\n}\n\nfunction validateDsn(dsn: DsnComponents): boolean {\n  if (!DEBUG_BUILD) {\n    return true;\n  }\n\n  const { port, projectId, protocol } = dsn;\n\n  const requiredComponents: ReadonlyArray<keyof DsnComponents> = ['protocol', 'publicKey', 'host', 'projectId'];\n  const hasMissingRequiredComponent = requiredComponents.find(component => {\n    if (!dsn[component]) {\n      debug.error(`Invalid Sentry Dsn: ${component} missing`);\n      return true;\n    }\n    return false;\n  });\n\n  if (hasMissingRequiredComponent) {\n    return false;\n  }\n\n  if (!projectId.match(/^\\d+$/)) {\n    debug.error(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);\n    return false;\n  }\n\n  if (!isValidProtocol(protocol)) {\n    debug.error(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);\n    return false;\n  }\n\n  if (port && isNaN(parseInt(port, 10))) {\n    debug.error(`Invalid Sentry Dsn: Invalid port ${port}`);\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Extract the org ID from a DSN host.\n *\n * @param host The host from a DSN\n * @returns The org ID if found, undefined otherwise\n */\nexport function extractOrgIdFromDsnHost(host: string): string | undefined {\n  const match = host.match(ORG_ID_REGEX);\n\n  return match?.[1];\n}\n\n/**\n * Creates a valid Sentry Dsn object, identifying a Sentry instance and project.\n * @returns a valid DsnComponents object or `undefined` if @param from is an invalid DSN source\n */\nexport function makeDsn(from: DsnLike): DsnComponents | undefined {\n  const components = typeof from === 'string' ? dsnFromString(from) : dsnFromComponents(from);\n  if (!components || !validateDsn(components)) {\n    return undefined;\n  }\n  return components;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}