{"ast":null,"code":"import { getGlobalSingleton } from '../carrier.js';\nimport { _getTraceInfoFromScope } from '../client.js';\nimport { getClient, getCurrentScope, getGlobalScope, getIsolationScope } from '../currentScopes.js';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { mergeScopeData } from '../utils/applyScopeDataToEvent.js';\nimport { debug, consoleSandbox } from '../utils/debug-logger.js';\nimport { isParameterizedString } from '../utils/is.js';\nimport { _getSpanForScope } from '../utils/spanOnScope.js';\nimport { timestampInSeconds } from '../utils/time.js';\nimport { SEVERITY_TEXT_TO_SEVERITY_NUMBER } from './constants.js';\nimport { createLogEnvelope } from './envelope.js';\nconst MAX_LOG_BUFFER_SIZE = 100;\n\n/**\n * Converts a log attribute to a serialized log attribute.\n *\n * @param key - The key of the log attribute.\n * @param value - The value of the log attribute.\n * @returns The serialized log attribute.\n */\nfunction logAttributeToSerializedLogAttribute(value) {\n  switch (typeof value) {\n    case 'number':\n      if (Number.isInteger(value)) {\n        return {\n          value,\n          type: 'integer'\n        };\n      }\n      return {\n        value,\n        type: 'double'\n      };\n    case 'boolean':\n      return {\n        value,\n        type: 'boolean'\n      };\n    case 'string':\n      return {\n        value,\n        type: 'string'\n      };\n    default:\n      {\n        let stringValue = '';\n        try {\n          stringValue = JSON.stringify(value) ?? '';\n        } catch {\n          // Do nothing\n        }\n        return {\n          value: stringValue,\n          type: 'string'\n        };\n      }\n  }\n}\n\n/**\n * Sets a log attribute if the value exists and the attribute key is not already present.\n *\n * @param logAttributes - The log attributes object to modify.\n * @param key - The attribute key to set.\n * @param value - The value to set (only sets if truthy and key not present).\n * @param setEvenIfPresent - Whether to set the attribute if it is present. Defaults to true.\n */\nfunction setLogAttribute(logAttributes, key, value, setEvenIfPresent = true) {\n  if (value && (!logAttributes[key] || setEvenIfPresent)) {\n    logAttributes[key] = value;\n  }\n}\n\n/**\n * Captures a serialized log event and adds it to the log buffer for the given client.\n *\n * @param client - A client. Uses the current client if not provided.\n * @param serializedLog - The serialized log event to capture.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nfunction _INTERNAL_captureSerializedLog(client, serializedLog) {\n  const bufferMap = _getBufferMap();\n  const logBuffer = _INTERNAL_getLogBuffer(client);\n  if (logBuffer === undefined) {\n    bufferMap.set(client, [serializedLog]);\n  } else {\n    bufferMap.set(client, [...logBuffer, serializedLog]);\n    if (logBuffer.length >= MAX_LOG_BUFFER_SIZE) {\n      _INTERNAL_flushLogsBuffer(client, logBuffer);\n    }\n  }\n}\n\n/**\n * Captures a log event and sends it to Sentry.\n *\n * @param log - The log event to capture.\n * @param scope - A scope. Uses the current scope if not provided.\n * @param client - A client. Uses the current client if not provided.\n * @param captureSerializedLog - A function to capture the serialized log.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nfunction _INTERNAL_captureLog(beforeLog, client = getClient(), currentScope = getCurrentScope(), captureSerializedLog = _INTERNAL_captureSerializedLog) {\n  if (!client) {\n    DEBUG_BUILD && debug.warn('No client available to capture log.');\n    return;\n  }\n  const {\n    _experiments,\n    release,\n    environment\n  } = client.getOptions();\n  const {\n    enableLogs = false,\n    beforeSendLog\n  } = _experiments ?? {};\n  if (!enableLogs) {\n    DEBUG_BUILD && debug.warn('logging option not enabled, log will not be captured.');\n    return;\n  }\n  const [, traceContext] = _getTraceInfoFromScope(client, currentScope);\n  const processedLogAttributes = {\n    ...beforeLog.attributes\n  };\n  const {\n    user: {\n      id,\n      email,\n      username\n    }\n  } = getMergedScopeData(currentScope);\n  setLogAttribute(processedLogAttributes, 'user.id', id, false);\n  setLogAttribute(processedLogAttributes, 'user.email', email, false);\n  setLogAttribute(processedLogAttributes, 'user.name', username, false);\n  setLogAttribute(processedLogAttributes, 'sentry.release', release);\n  setLogAttribute(processedLogAttributes, 'sentry.environment', environment);\n  const {\n    name,\n    version\n  } = client.getSdkMetadata()?.sdk ?? {};\n  setLogAttribute(processedLogAttributes, 'sentry.sdk.name', name);\n  setLogAttribute(processedLogAttributes, 'sentry.sdk.version', version);\n  const beforeLogMessage = beforeLog.message;\n  if (isParameterizedString(beforeLogMessage)) {\n    const {\n      __sentry_template_string__,\n      __sentry_template_values__ = []\n    } = beforeLogMessage;\n    processedLogAttributes['sentry.message.template'] = __sentry_template_string__;\n    __sentry_template_values__.forEach((param, index) => {\n      processedLogAttributes[`sentry.message.parameter.${index}`] = param;\n    });\n  }\n  const span = _getSpanForScope(currentScope);\n  // Add the parent span ID to the log attributes for trace context\n  setLogAttribute(processedLogAttributes, 'sentry.trace.parent_span_id', span?.spanContext().spanId);\n  const processedLog = {\n    ...beforeLog,\n    attributes: processedLogAttributes\n  };\n  client.emit('beforeCaptureLog', processedLog);\n\n  // We need to wrap this in `consoleSandbox` to avoid recursive calls to `beforeSendLog`\n  const log = beforeSendLog ? consoleSandbox(() => beforeSendLog(processedLog)) : processedLog;\n  if (!log) {\n    client.recordDroppedEvent('before_send', 'log_item', 1);\n    DEBUG_BUILD && debug.warn('beforeSendLog returned null, log will not be captured.');\n    return;\n  }\n  const {\n    level,\n    message,\n    attributes = {},\n    severityNumber\n  } = log;\n  const serializedLog = {\n    timestamp: timestampInSeconds(),\n    level,\n    body: message,\n    trace_id: traceContext?.trace_id,\n    severity_number: severityNumber ?? SEVERITY_TEXT_TO_SEVERITY_NUMBER[level],\n    attributes: Object.keys(attributes).reduce((acc, key) => {\n      acc[key] = logAttributeToSerializedLogAttribute(attributes[key]);\n      return acc;\n    }, {})\n  };\n  captureSerializedLog(client, serializedLog);\n  client.emit('afterCaptureLog', log);\n}\n\n/**\n * Flushes the logs buffer to Sentry.\n *\n * @param client - A client.\n * @param maybeLogBuffer - A log buffer. Uses the log buffer for the given client if not provided.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nfunction _INTERNAL_flushLogsBuffer(client, maybeLogBuffer) {\n  const logBuffer = maybeLogBuffer ?? _INTERNAL_getLogBuffer(client) ?? [];\n  if (logBuffer.length === 0) {\n    return;\n  }\n  const clientOptions = client.getOptions();\n  const envelope = createLogEnvelope(logBuffer, clientOptions._metadata, clientOptions.tunnel, client.getDsn());\n\n  // Clear the log buffer after envelopes have been constructed.\n  _getBufferMap().set(client, []);\n  client.emit('flushLogs');\n\n  // sendEnvelope should not throw\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  client.sendEnvelope(envelope);\n}\n\n/**\n * Returns the log buffer for a given client.\n *\n * Exported for testing purposes.\n *\n * @param client - The client to get the log buffer for.\n * @returns The log buffer for the given client.\n */\nfunction _INTERNAL_getLogBuffer(client) {\n  return _getBufferMap().get(client);\n}\n\n/**\n * Get the scope data for the current scope after merging with the\n * global scope and isolation scope.\n *\n * @param currentScope - The current scope.\n * @returns The scope data.\n */\nfunction getMergedScopeData(currentScope) {\n  const scopeData = getGlobalScope().getScopeData();\n  mergeScopeData(scopeData, getIsolationScope().getScopeData());\n  mergeScopeData(scopeData, currentScope.getScopeData());\n  return scopeData;\n}\nfunction _getBufferMap() {\n  // The reference to the Client <> LogBuffer map is stored on the carrier to ensure it's always the same\n  return getGlobalSingleton('clientToLogBufferMap', () => new WeakMap());\n}\nexport { _INTERNAL_captureLog, _INTERNAL_captureSerializedLog, _INTERNAL_flushLogsBuffer, _INTERNAL_getLogBuffer, logAttributeToSerializedLogAttribute };","map":{"version":3,"names":["MAX_LOG_BUFFER_SIZE","logAttributeToSerializedLogAttribute","value","Number","isInteger","type","stringValue","JSON","stringify","setLogAttribute","logAttributes","key","setEvenIfPresent","_INTERNAL_captureSerializedLog","client","serializedLog","bufferMap","_getBufferMap","logBuffer","_INTERNAL_getLogBuffer","undefined","set","length","_INTERNAL_flushLogsBuffer","_INTERNAL_captureLog","beforeLog","getClient","currentScope","getCurrentScope","captureSerializedLog","DEBUG_BUILD","debug","warn","_experiments","release","environment","getOptions","enableLogs","beforeSendLog","traceContext","_getTraceInfoFromScope","processedLogAttributes","attributes","user","id","email","username","getMergedScopeData","name","version","getSdkMetadata","sdk","beforeLogMessage","message","isParameterizedString","__sentry_template_string__","__sentry_template_values__","forEach","param","index","span","_getSpanForScope","spanContext","spanId","processedLog","emit","log","consoleSandbox","recordDroppedEvent","level","severityNumber","timestamp","timestampInSeconds","body","trace_id","severity_number","SEVERITY_TEXT_TO_SEVERITY_NUMBER","Object","keys","reduce","acc","maybeLogBuffer","clientOptions","envelope","createLogEnvelope","_metadata","tunnel","getDsn","sendEnvelope","get","scopeData","getGlobalScope","getScopeData","mergeScopeData","getIsolationScope","getGlobalSingleton","WeakMap"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/logs/exports.ts"],"sourcesContent":["import { getGlobalSingleton } from '../carrier';\nimport type { Client } from '../client';\nimport { _getTraceInfoFromScope } from '../client';\nimport { getClient, getCurrentScope, getGlobalScope, getIsolationScope } from '../currentScopes';\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { Scope, ScopeData } from '../scope';\nimport type { Log, SerializedLog, SerializedLogAttributeValue } from '../types-hoist/log';\nimport { mergeScopeData } from '../utils/applyScopeDataToEvent';\nimport { consoleSandbox, debug } from '../utils/debug-logger';\nimport { isParameterizedString } from '../utils/is';\nimport { _getSpanForScope } from '../utils/spanOnScope';\nimport { timestampInSeconds } from '../utils/time';\nimport { SEVERITY_TEXT_TO_SEVERITY_NUMBER } from './constants';\nimport { createLogEnvelope } from './envelope';\n\nconst MAX_LOG_BUFFER_SIZE = 100;\n\n/**\n * Converts a log attribute to a serialized log attribute.\n *\n * @param key - The key of the log attribute.\n * @param value - The value of the log attribute.\n * @returns The serialized log attribute.\n */\nexport function logAttributeToSerializedLogAttribute(value: unknown): SerializedLogAttributeValue {\n  switch (typeof value) {\n    case 'number':\n      if (Number.isInteger(value)) {\n        return {\n          value,\n          type: 'integer',\n        };\n      }\n      return {\n        value,\n        type: 'double',\n      };\n    case 'boolean':\n      return {\n        value,\n        type: 'boolean',\n      };\n    case 'string':\n      return {\n        value,\n        type: 'string',\n      };\n    default: {\n      let stringValue = '';\n      try {\n        stringValue = JSON.stringify(value) ?? '';\n      } catch {\n        // Do nothing\n      }\n      return {\n        value: stringValue,\n        type: 'string',\n      };\n    }\n  }\n}\n\n/**\n * Sets a log attribute if the value exists and the attribute key is not already present.\n *\n * @param logAttributes - The log attributes object to modify.\n * @param key - The attribute key to set.\n * @param value - The value to set (only sets if truthy and key not present).\n * @param setEvenIfPresent - Whether to set the attribute if it is present. Defaults to true.\n */\nfunction setLogAttribute(\n  logAttributes: Record<string, unknown>,\n  key: string,\n  value: unknown,\n  setEvenIfPresent = true,\n): void {\n  if (value && (!logAttributes[key] || setEvenIfPresent)) {\n    logAttributes[key] = value;\n  }\n}\n\n/**\n * Captures a serialized log event and adds it to the log buffer for the given client.\n *\n * @param client - A client. Uses the current client if not provided.\n * @param serializedLog - The serialized log event to capture.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nexport function _INTERNAL_captureSerializedLog(client: Client, serializedLog: SerializedLog): void {\n  const bufferMap = _getBufferMap();\n\n  const logBuffer = _INTERNAL_getLogBuffer(client);\n  if (logBuffer === undefined) {\n    bufferMap.set(client, [serializedLog]);\n  } else {\n    bufferMap.set(client, [...logBuffer, serializedLog]);\n    if (logBuffer.length >= MAX_LOG_BUFFER_SIZE) {\n      _INTERNAL_flushLogsBuffer(client, logBuffer);\n    }\n  }\n}\n\n/**\n * Captures a log event and sends it to Sentry.\n *\n * @param log - The log event to capture.\n * @param scope - A scope. Uses the current scope if not provided.\n * @param client - A client. Uses the current client if not provided.\n * @param captureSerializedLog - A function to capture the serialized log.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nexport function _INTERNAL_captureLog(\n  beforeLog: Log,\n  client: Client | undefined = getClient(),\n  currentScope = getCurrentScope(),\n  captureSerializedLog: (client: Client, log: SerializedLog) => void = _INTERNAL_captureSerializedLog,\n): void {\n  if (!client) {\n    DEBUG_BUILD && debug.warn('No client available to capture log.');\n    return;\n  }\n\n  const { _experiments, release, environment } = client.getOptions();\n  const { enableLogs = false, beforeSendLog } = _experiments ?? {};\n  if (!enableLogs) {\n    DEBUG_BUILD && debug.warn('logging option not enabled, log will not be captured.');\n    return;\n  }\n\n  const [, traceContext] = _getTraceInfoFromScope(client, currentScope);\n\n  const processedLogAttributes = {\n    ...beforeLog.attributes,\n  };\n\n  const {\n    user: { id, email, username },\n  } = getMergedScopeData(currentScope);\n  setLogAttribute(processedLogAttributes, 'user.id', id, false);\n  setLogAttribute(processedLogAttributes, 'user.email', email, false);\n  setLogAttribute(processedLogAttributes, 'user.name', username, false);\n\n  setLogAttribute(processedLogAttributes, 'sentry.release', release);\n  setLogAttribute(processedLogAttributes, 'sentry.environment', environment);\n\n  const { name, version } = client.getSdkMetadata()?.sdk ?? {};\n  setLogAttribute(processedLogAttributes, 'sentry.sdk.name', name);\n  setLogAttribute(processedLogAttributes, 'sentry.sdk.version', version);\n\n  const beforeLogMessage = beforeLog.message;\n  if (isParameterizedString(beforeLogMessage)) {\n    const { __sentry_template_string__, __sentry_template_values__ = [] } = beforeLogMessage;\n    processedLogAttributes['sentry.message.template'] = __sentry_template_string__;\n    __sentry_template_values__.forEach((param, index) => {\n      processedLogAttributes[`sentry.message.parameter.${index}`] = param;\n    });\n  }\n\n  const span = _getSpanForScope(currentScope);\n  // Add the parent span ID to the log attributes for trace context\n  setLogAttribute(processedLogAttributes, 'sentry.trace.parent_span_id', span?.spanContext().spanId);\n\n  const processedLog = { ...beforeLog, attributes: processedLogAttributes };\n\n  client.emit('beforeCaptureLog', processedLog);\n\n  // We need to wrap this in `consoleSandbox` to avoid recursive calls to `beforeSendLog`\n  const log = beforeSendLog ? consoleSandbox(() => beforeSendLog(processedLog)) : processedLog;\n  if (!log) {\n    client.recordDroppedEvent('before_send', 'log_item', 1);\n    DEBUG_BUILD && debug.warn('beforeSendLog returned null, log will not be captured.');\n    return;\n  }\n\n  const { level, message, attributes = {}, severityNumber } = log;\n\n  const serializedLog: SerializedLog = {\n    timestamp: timestampInSeconds(),\n    level,\n    body: message,\n    trace_id: traceContext?.trace_id,\n    severity_number: severityNumber ?? SEVERITY_TEXT_TO_SEVERITY_NUMBER[level],\n    attributes: Object.keys(attributes).reduce(\n      (acc, key) => {\n        acc[key] = logAttributeToSerializedLogAttribute(attributes[key]);\n        return acc;\n      },\n      {} as Record<string, SerializedLogAttributeValue>,\n    ),\n  };\n\n  captureSerializedLog(client, serializedLog);\n\n  client.emit('afterCaptureLog', log);\n}\n\n/**\n * Flushes the logs buffer to Sentry.\n *\n * @param client - A client.\n * @param maybeLogBuffer - A log buffer. Uses the log buffer for the given client if not provided.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nexport function _INTERNAL_flushLogsBuffer(client: Client, maybeLogBuffer?: Array<SerializedLog>): void {\n  const logBuffer = maybeLogBuffer ?? _INTERNAL_getLogBuffer(client) ?? [];\n  if (logBuffer.length === 0) {\n    return;\n  }\n\n  const clientOptions = client.getOptions();\n  const envelope = createLogEnvelope(logBuffer, clientOptions._metadata, clientOptions.tunnel, client.getDsn());\n\n  // Clear the log buffer after envelopes have been constructed.\n  _getBufferMap().set(client, []);\n\n  client.emit('flushLogs');\n\n  // sendEnvelope should not throw\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  client.sendEnvelope(envelope);\n}\n\n/**\n * Returns the log buffer for a given client.\n *\n * Exported for testing purposes.\n *\n * @param client - The client to get the log buffer for.\n * @returns The log buffer for the given client.\n */\nexport function _INTERNAL_getLogBuffer(client: Client): Array<SerializedLog> | undefined {\n  return _getBufferMap().get(client);\n}\n\n/**\n * Get the scope data for the current scope after merging with the\n * global scope and isolation scope.\n *\n * @param currentScope - The current scope.\n * @returns The scope data.\n */\nfunction getMergedScopeData(currentScope: Scope): ScopeData {\n  const scopeData = getGlobalScope().getScopeData();\n  mergeScopeData(scopeData, getIsolationScope().getScopeData());\n  mergeScopeData(scopeData, currentScope.getScopeData());\n  return scopeData;\n}\n\nfunction _getBufferMap(): WeakMap<Client, Array<SerializedLog>> {\n  // The reference to the Client <> LogBuffer map is stored on the carrier to ensure it's always the same\n  return getGlobalSingleton('clientToLogBufferMap', () => new WeakMap<Client, Array<SerializedLog>>());\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}