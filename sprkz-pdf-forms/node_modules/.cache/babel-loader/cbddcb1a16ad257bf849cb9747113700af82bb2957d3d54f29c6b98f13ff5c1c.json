{"ast":null,"code":"import { addBreadcrumb } from '../breadcrumbs.js';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { captureException } from '../exports.js';\nimport { defineIntegration } from '../integration.js';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '../semanticAttributes.js';\nimport { debug } from '../utils/debug-logger.js';\nimport { isPlainObject } from '../utils/is.js';\nimport { SPAN_STATUS_ERROR, SPAN_STATUS_OK, setHttpStatus } from '../tracing/spanstatus.js';\nimport { startSpan } from '../tracing/trace.js';\n\n// Based on Kamil OgÃ³rek's work on:\n// https://github.com/supabase-community/sentry-integration-js\n\nconst AUTH_OPERATIONS_TO_INSTRUMENT = ['reauthenticate', 'signInAnonymously', 'signInWithOAuth', 'signInWithIdToken', 'signInWithOtp', 'signInWithPassword', 'signInWithSSO', 'signOut', 'signUp', 'verifyOtp'];\nconst AUTH_ADMIN_OPERATIONS_TO_INSTRUMENT = ['createUser', 'deleteUser', 'listUsers', 'getUserById', 'updateUserById', 'inviteUserByEmail'];\nconst FILTER_MAPPINGS = {\n  eq: 'eq',\n  neq: 'neq',\n  gt: 'gt',\n  gte: 'gte',\n  lt: 'lt',\n  lte: 'lte',\n  like: 'like',\n  'like(all)': 'likeAllOf',\n  'like(any)': 'likeAnyOf',\n  ilike: 'ilike',\n  'ilike(all)': 'ilikeAllOf',\n  'ilike(any)': 'ilikeAnyOf',\n  is: 'is',\n  in: 'in',\n  cs: 'contains',\n  cd: 'containedBy',\n  sr: 'rangeGt',\n  nxl: 'rangeGte',\n  sl: 'rangeLt',\n  nxr: 'rangeLte',\n  adj: 'rangeAdjacent',\n  ov: 'overlaps',\n  fts: '',\n  plfts: 'plain',\n  phfts: 'phrase',\n  wfts: 'websearch',\n  not: 'not'\n};\nconst DB_OPERATIONS_TO_INSTRUMENT = ['select', 'insert', 'upsert', 'update', 'delete'];\nfunction markAsInstrumented(fn) {\n  try {\n    fn.__SENTRY_INSTRUMENTED__ = true;\n  } catch {\n    // ignore errors here\n  }\n}\nfunction isInstrumented(fn) {\n  try {\n    return fn.__SENTRY_INSTRUMENTED__;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Extracts the database operation type from the HTTP method and headers\n * @param method - The HTTP method of the request\n * @param headers - The request headers\n * @returns The database operation type ('select', 'insert', 'upsert', 'update', or 'delete')\n */\nfunction extractOperation(method) {\n  let headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  switch (method) {\n    case 'GET':\n      {\n        return 'select';\n      }\n    case 'POST':\n      {\n        if (headers['Prefer']?.includes('resolution=')) {\n          return 'upsert';\n        } else {\n          return 'insert';\n        }\n      }\n    case 'PATCH':\n      {\n        return 'update';\n      }\n    case 'DELETE':\n      {\n        return 'delete';\n      }\n    default:\n      {\n        return '<unknown-op>';\n      }\n  }\n}\n\n/**\n * Translates Supabase filter parameters into readable method names for tracing\n * @param key - The filter key from the URL search parameters\n * @param query - The filter value from the URL search parameters\n * @returns A string representation of the filter as a method call\n */\nfunction translateFiltersIntoMethods(key, query) {\n  if (query === '' || query === '*') {\n    return 'select(*)';\n  }\n  if (key === 'select') {\n    return `select(${query})`;\n  }\n  if (key === 'or' || key.endsWith('.or')) {\n    return `${key}${query}`;\n  }\n  const [filter, ...value] = query.split('.');\n  let method;\n  // Handle optional `configPart` of the filter\n  if (filter?.startsWith('fts')) {\n    method = 'textSearch';\n  } else if (filter?.startsWith('plfts')) {\n    method = 'textSearch[plain]';\n  } else if (filter?.startsWith('phfts')) {\n    method = 'textSearch[phrase]';\n  } else if (filter?.startsWith('wfts')) {\n    method = 'textSearch[websearch]';\n  } else {\n    method = filter && FILTER_MAPPINGS[filter] || 'filter';\n  }\n  return `${method}(${key}, ${value.join('.')})`;\n}\nfunction instrumentAuthOperation(operation) {\n  let isAdmin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return new Proxy(operation, {\n    apply(target, thisArg, argumentsList) {\n      return startSpan({\n        name: `auth ${isAdmin ? '(admin) ' : ''}${operation.name}`,\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.db.supabase',\n          [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'db',\n          'db.system': 'postgresql',\n          'db.operation': `auth.${isAdmin ? 'admin.' : ''}${operation.name}`\n        }\n      }, span => {\n        return Reflect.apply(target, thisArg, argumentsList).then(res => {\n          if (res && typeof res === 'object' && 'error' in res && res.error) {\n            span.setStatus({\n              code: SPAN_STATUS_ERROR\n            });\n            captureException(res.error, {\n              mechanism: {\n                handled: false\n              }\n            });\n          } else {\n            span.setStatus({\n              code: SPAN_STATUS_OK\n            });\n          }\n          span.end();\n          return res;\n        }).catch(err => {\n          span.setStatus({\n            code: SPAN_STATUS_ERROR\n          });\n          span.end();\n          captureException(err, {\n            mechanism: {\n              handled: false\n            }\n          });\n          throw err;\n        }).then(...argumentsList);\n      });\n    }\n  });\n}\nfunction instrumentSupabaseAuthClient(supabaseClientInstance) {\n  const auth = supabaseClientInstance.auth;\n  if (!auth || isInstrumented(supabaseClientInstance.auth)) {\n    return;\n  }\n  for (const operation of AUTH_OPERATIONS_TO_INSTRUMENT) {\n    const authOperation = auth[operation];\n    if (!authOperation) {\n      continue;\n    }\n    if (typeof supabaseClientInstance.auth[operation] === 'function') {\n      supabaseClientInstance.auth[operation] = instrumentAuthOperation(authOperation);\n    }\n  }\n  for (const operation of AUTH_ADMIN_OPERATIONS_TO_INSTRUMENT) {\n    const authOperation = auth.admin[operation];\n    if (!authOperation) {\n      continue;\n    }\n    if (typeof supabaseClientInstance.auth.admin[operation] === 'function') {\n      supabaseClientInstance.auth.admin[operation] = instrumentAuthOperation(authOperation, true);\n    }\n  }\n  markAsInstrumented(supabaseClientInstance.auth);\n}\nfunction instrumentSupabaseClientConstructor(SupabaseClient) {\n  if (isInstrumented(SupabaseClient.prototype.from)) {\n    return;\n  }\n  SupabaseClient.prototype.from = new Proxy(SupabaseClient.prototype.from, {\n    apply(target, thisArg, argumentsList) {\n      const rv = Reflect.apply(target, thisArg, argumentsList);\n      const PostgRESTQueryBuilder = rv.constructor;\n      instrumentPostgRESTQueryBuilder(PostgRESTQueryBuilder);\n      return rv;\n    }\n  });\n  markAsInstrumented(SupabaseClient.prototype.from);\n}\nfunction instrumentPostgRESTFilterBuilder(PostgRESTFilterBuilder) {\n  if (isInstrumented(PostgRESTFilterBuilder.prototype.then)) {\n    return;\n  }\n  PostgRESTFilterBuilder.prototype.then = new Proxy(PostgRESTFilterBuilder.prototype.then, {\n    apply(target, thisArg, argumentsList) {\n      const operations = DB_OPERATIONS_TO_INSTRUMENT;\n      const typedThis = thisArg;\n      const operation = extractOperation(typedThis.method, typedThis.headers);\n      if (!operations.includes(operation)) {\n        return Reflect.apply(target, thisArg, argumentsList);\n      }\n      if (!typedThis?.url?.pathname || typeof typedThis.url.pathname !== 'string') {\n        return Reflect.apply(target, thisArg, argumentsList);\n      }\n      const pathParts = typedThis.url.pathname.split('/');\n      const table = pathParts.length > 0 ? pathParts[pathParts.length - 1] : '';\n      const queryItems = [];\n      for (const [key, value] of typedThis.url.searchParams.entries()) {\n        // It's possible to have multiple entries for the same key, eg. `id=eq.7&id=eq.3`,\n        // so we need to use array instead of object to collect them.\n        queryItems.push(translateFiltersIntoMethods(key, value));\n      }\n      const body = Object.create(null);\n      if (isPlainObject(typedThis.body)) {\n        for (const [key, value] of Object.entries(typedThis.body)) {\n          body[key] = value;\n        }\n      }\n\n      // Adding operation to the beginning of the description if it's not a `select` operation\n      // For example, it can be an `insert` or `update` operation but the query can be `select(...)`\n      // For `select` operations, we don't need repeat it in the description\n      const description = `${operation === 'select' ? '' : `${operation}${body ? '(...) ' : ''}`}${queryItems.join(' ')} from(${table})`;\n      const attributes = {\n        'db.table': table,\n        'db.schema': typedThis.schema,\n        'db.url': typedThis.url.origin,\n        'db.sdk': typedThis.headers['X-Client-Info'],\n        'db.system': 'postgresql',\n        'db.operation': operation,\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.db.supabase',\n        [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'db'\n      };\n      if (queryItems.length) {\n        attributes['db.query'] = queryItems;\n      }\n      if (Object.keys(body).length) {\n        attributes['db.body'] = body;\n      }\n      return startSpan({\n        name: description,\n        attributes\n      }, span => {\n        return Reflect.apply(target, thisArg, []).then(res => {\n          if (span) {\n            if (res && typeof res === 'object' && 'status' in res) {\n              setHttpStatus(span, res.status || 500);\n            }\n            span.end();\n          }\n          if (res.error) {\n            const err = new Error(res.error.message);\n            if (res.error.code) {\n              err.code = res.error.code;\n            }\n            if (res.error.details) {\n              err.details = res.error.details;\n            }\n            const supabaseContext = {};\n            if (queryItems.length) {\n              supabaseContext.query = queryItems;\n            }\n            if (Object.keys(body).length) {\n              supabaseContext.body = body;\n            }\n            captureException(err, {\n              contexts: {\n                supabase: supabaseContext\n              }\n            });\n          }\n          const breadcrumb = {\n            type: 'supabase',\n            category: `db.${operation}`,\n            message: description\n          };\n          const data = {};\n          if (queryItems.length) {\n            data.query = queryItems;\n          }\n          if (Object.keys(body).length) {\n            data.body = body;\n          }\n          if (Object.keys(data).length) {\n            breadcrumb.data = data;\n          }\n          addBreadcrumb(breadcrumb);\n          return res;\n        }, err => {\n          if (span) {\n            setHttpStatus(span, 500);\n            span.end();\n          }\n          throw err;\n        }).then(...argumentsList);\n      });\n    }\n  });\n  markAsInstrumented(PostgRESTFilterBuilder.prototype.then);\n}\nfunction instrumentPostgRESTQueryBuilder(PostgRESTQueryBuilder) {\n  // We need to wrap _all_ operations despite them sharing the same `PostgRESTFilterBuilder`\n  // constructor, as we don't know which method will be called first, and we don't want to miss any calls.\n  for (const operation of DB_OPERATIONS_TO_INSTRUMENT) {\n    if (isInstrumented(PostgRESTQueryBuilder.prototype[operation])) {\n      continue;\n    }\n    PostgRESTQueryBuilder.prototype[operation] = new Proxy(PostgRESTQueryBuilder.prototype[operation], {\n      apply(target, thisArg, argumentsList) {\n        const rv = Reflect.apply(target, thisArg, argumentsList);\n        const PostgRESTFilterBuilder = rv.constructor;\n        DEBUG_BUILD && debug.log(`Instrumenting ${operation} operation's PostgRESTFilterBuilder`);\n        instrumentPostgRESTFilterBuilder(PostgRESTFilterBuilder);\n        return rv;\n      }\n    });\n    markAsInstrumented(PostgRESTQueryBuilder.prototype[operation]);\n  }\n}\nconst instrumentSupabaseClient = supabaseClient => {\n  if (!supabaseClient) {\n    DEBUG_BUILD && debug.warn('Supabase integration was not installed because no Supabase client was provided.');\n    return;\n  }\n  const SupabaseClientConstructor = supabaseClient.constructor === Function ? supabaseClient : supabaseClient.constructor;\n  instrumentSupabaseClientConstructor(SupabaseClientConstructor);\n  instrumentSupabaseAuthClient(supabaseClient);\n};\nconst INTEGRATION_NAME = 'Supabase';\nconst _supabaseIntegration = supabaseClient => {\n  return {\n    setupOnce() {\n      instrumentSupabaseClient(supabaseClient);\n    },\n    name: INTEGRATION_NAME\n  };\n};\nconst supabaseIntegration = defineIntegration(options => {\n  return _supabaseIntegration(options.supabaseClient);\n});\nexport { DB_OPERATIONS_TO_INSTRUMENT, FILTER_MAPPINGS, extractOperation, instrumentSupabaseClient, supabaseIntegration, translateFiltersIntoMethods };\n//# sourceMappingURL=supabase.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}