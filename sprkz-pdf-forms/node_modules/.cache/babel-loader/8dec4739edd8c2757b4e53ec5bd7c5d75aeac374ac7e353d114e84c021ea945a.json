{"ast":null,"code":"import { getDynamicSamplingContextFromSpan } from '../tracing/dynamicSamplingContext.js';\nimport { merge } from './merge.js';\nimport { spanToTraceContext, getRootSpan, spanToJSON } from './spanUtils.js';\n\n/**\n * Applies data from the scope to the event and runs all event processors on it.\n */\nfunction applyScopeDataToEvent(event, data) {\n  const {\n    fingerprint,\n    span,\n    breadcrumbs,\n    sdkProcessingMetadata\n  } = data;\n\n  // Apply general data\n  applyDataToEvent(event, data);\n\n  // We want to set the trace context for normal events only if there isn't already\n  // a trace context on the event. There is a product feature in place where we link\n  // errors with transaction and it relies on that.\n  if (span) {\n    applySpanToEvent(event, span);\n  }\n  applyFingerprintToEvent(event, fingerprint);\n  applyBreadcrumbsToEvent(event, breadcrumbs);\n  applySdkMetadataToEvent(event, sdkProcessingMetadata);\n}\n\n/** Merge data of two scopes together. */\nfunction mergeScopeData(data, mergeData) {\n  const {\n    extra,\n    tags,\n    user,\n    contexts,\n    level,\n    sdkProcessingMetadata,\n    breadcrumbs,\n    fingerprint,\n    eventProcessors,\n    attachments,\n    propagationContext,\n    transactionName,\n    span\n  } = mergeData;\n  mergeAndOverwriteScopeData(data, 'extra', extra);\n  mergeAndOverwriteScopeData(data, 'tags', tags);\n  mergeAndOverwriteScopeData(data, 'user', user);\n  mergeAndOverwriteScopeData(data, 'contexts', contexts);\n  data.sdkProcessingMetadata = merge(data.sdkProcessingMetadata, sdkProcessingMetadata, 2);\n  if (level) {\n    data.level = level;\n  }\n  if (transactionName) {\n    data.transactionName = transactionName;\n  }\n  if (span) {\n    data.span = span;\n  }\n  if (breadcrumbs.length) {\n    data.breadcrumbs = [...data.breadcrumbs, ...breadcrumbs];\n  }\n  if (fingerprint.length) {\n    data.fingerprint = [...data.fingerprint, ...fingerprint];\n  }\n  if (eventProcessors.length) {\n    data.eventProcessors = [...data.eventProcessors, ...eventProcessors];\n  }\n  if (attachments.length) {\n    data.attachments = [...data.attachments, ...attachments];\n  }\n  data.propagationContext = {\n    ...data.propagationContext,\n    ...propagationContext\n  };\n}\n\n/**\n * Merges certain scope data. Undefined values will overwrite any existing values.\n * Exported only for tests.\n */\nfunction mergeAndOverwriteScopeData(data, prop, mergeVal) {\n  data[prop] = merge(data[prop], mergeVal, 1);\n}\nfunction applyDataToEvent(event, data) {\n  const {\n    extra,\n    tags,\n    user,\n    contexts,\n    level,\n    transactionName\n  } = data;\n  if (Object.keys(extra).length) {\n    event.extra = {\n      ...extra,\n      ...event.extra\n    };\n  }\n  if (Object.keys(tags).length) {\n    event.tags = {\n      ...tags,\n      ...event.tags\n    };\n  }\n  if (Object.keys(user).length) {\n    event.user = {\n      ...user,\n      ...event.user\n    };\n  }\n  if (Object.keys(contexts).length) {\n    event.contexts = {\n      ...contexts,\n      ...event.contexts\n    };\n  }\n  if (level) {\n    event.level = level;\n  }\n\n  // transaction events get their `transaction` from the root span name\n  if (transactionName && event.type !== 'transaction') {\n    event.transaction = transactionName;\n  }\n}\nfunction applyBreadcrumbsToEvent(event, breadcrumbs) {\n  const mergedBreadcrumbs = [...(event.breadcrumbs || []), ...breadcrumbs];\n  event.breadcrumbs = mergedBreadcrumbs.length ? mergedBreadcrumbs : undefined;\n}\nfunction applySdkMetadataToEvent(event, sdkProcessingMetadata) {\n  event.sdkProcessingMetadata = {\n    ...event.sdkProcessingMetadata,\n    ...sdkProcessingMetadata\n  };\n}\nfunction applySpanToEvent(event, span) {\n  event.contexts = {\n    trace: spanToTraceContext(span),\n    ...event.contexts\n  };\n  event.sdkProcessingMetadata = {\n    dynamicSamplingContext: getDynamicSamplingContextFromSpan(span),\n    ...event.sdkProcessingMetadata\n  };\n  const rootSpan = getRootSpan(span);\n  const transactionName = spanToJSON(rootSpan).description;\n  if (transactionName && !event.transaction && event.type === 'transaction') {\n    event.transaction = transactionName;\n  }\n}\n\n/**\n * Applies fingerprint from the scope to the event if there's one,\n * uses message if there's one instead or get rid of empty fingerprint\n */\nfunction applyFingerprintToEvent(event, fingerprint) {\n  // Make sure it's an array first and we actually have something in place\n  event.fingerprint = event.fingerprint ? Array.isArray(event.fingerprint) ? event.fingerprint : [event.fingerprint] : [];\n\n  // If we have something on the scope, then merge it with event\n  if (fingerprint) {\n    event.fingerprint = event.fingerprint.concat(fingerprint);\n  }\n\n  // If we have no data at all, remove empty array default\n  if (!event.fingerprint.length) {\n    delete event.fingerprint;\n  }\n}\nexport { applyScopeDataToEvent, mergeAndOverwriteScopeData, mergeScopeData };","map":{"version":3,"names":["applyScopeDataToEvent","event","data","fingerprint","span","breadcrumbs","sdkProcessingMetadata","applyDataToEvent","applySpanToEvent","applyFingerprintToEvent","applyBreadcrumbsToEvent","applySdkMetadataToEvent","mergeScopeData","mergeData","extra","tags","user","contexts","level","eventProcessors","attachments","propagationContext","transactionName","mergeAndOverwriteScopeData","merge","length","prop","mergeVal","Object","keys","type","transaction","mergedBreadcrumbs","undefined","trace","spanToTraceContext","dynamicSamplingContext","getDynamicSamplingContextFromSpan","rootSpan","getRootSpan","spanToJSON","description","Array","isArray","concat"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/utils/applyScopeDataToEvent.ts"],"sourcesContent":["import type { ScopeData } from '../scope';\nimport { getDynamicSamplingContextFromSpan } from '../tracing/dynamicSamplingContext';\nimport type { Breadcrumb } from '../types-hoist/breadcrumb';\nimport type { Event } from '../types-hoist/event';\nimport type { Span } from '../types-hoist/span';\nimport { merge } from './merge';\nimport { getRootSpan, spanToJSON, spanToTraceContext } from './spanUtils';\n\n/**\n * Applies data from the scope to the event and runs all event processors on it.\n */\nexport function applyScopeDataToEvent(event: Event, data: ScopeData): void {\n  const { fingerprint, span, breadcrumbs, sdkProcessingMetadata } = data;\n\n  // Apply general data\n  applyDataToEvent(event, data);\n\n  // We want to set the trace context for normal events only if there isn't already\n  // a trace context on the event. There is a product feature in place where we link\n  // errors with transaction and it relies on that.\n  if (span) {\n    applySpanToEvent(event, span);\n  }\n\n  applyFingerprintToEvent(event, fingerprint);\n  applyBreadcrumbsToEvent(event, breadcrumbs);\n  applySdkMetadataToEvent(event, sdkProcessingMetadata);\n}\n\n/** Merge data of two scopes together. */\nexport function mergeScopeData(data: ScopeData, mergeData: ScopeData): void {\n  const {\n    extra,\n    tags,\n    user,\n    contexts,\n    level,\n    sdkProcessingMetadata,\n    breadcrumbs,\n    fingerprint,\n    eventProcessors,\n    attachments,\n    propagationContext,\n    transactionName,\n    span,\n  } = mergeData;\n\n  mergeAndOverwriteScopeData(data, 'extra', extra);\n  mergeAndOverwriteScopeData(data, 'tags', tags);\n  mergeAndOverwriteScopeData(data, 'user', user);\n  mergeAndOverwriteScopeData(data, 'contexts', contexts);\n\n  data.sdkProcessingMetadata = merge(data.sdkProcessingMetadata, sdkProcessingMetadata, 2);\n\n  if (level) {\n    data.level = level;\n  }\n\n  if (transactionName) {\n    data.transactionName = transactionName;\n  }\n\n  if (span) {\n    data.span = span;\n  }\n\n  if (breadcrumbs.length) {\n    data.breadcrumbs = [...data.breadcrumbs, ...breadcrumbs];\n  }\n\n  if (fingerprint.length) {\n    data.fingerprint = [...data.fingerprint, ...fingerprint];\n  }\n\n  if (eventProcessors.length) {\n    data.eventProcessors = [...data.eventProcessors, ...eventProcessors];\n  }\n\n  if (attachments.length) {\n    data.attachments = [...data.attachments, ...attachments];\n  }\n\n  data.propagationContext = { ...data.propagationContext, ...propagationContext };\n}\n\n/**\n * Merges certain scope data. Undefined values will overwrite any existing values.\n * Exported only for tests.\n */\nexport function mergeAndOverwriteScopeData<\n  Prop extends 'extra' | 'tags' | 'user' | 'contexts' | 'sdkProcessingMetadata',\n  Data extends ScopeData,\n>(data: Data, prop: Prop, mergeVal: Data[Prop]): void {\n  data[prop] = merge(data[prop], mergeVal, 1);\n}\n\n/** Exported only for tests */\nexport function mergeArray<Prop extends 'breadcrumbs' | 'fingerprint'>(\n  event: Event,\n  prop: Prop,\n  mergeVal: ScopeData[Prop],\n): void {\n  const prevVal = event[prop];\n  // If we are not merging any new values,\n  // we only need to proceed if there was an empty array before (as we want to replace it with undefined)\n  if (!mergeVal.length && (!prevVal || prevVal.length)) {\n    return;\n  }\n\n  const merged = [...(prevVal || []), ...mergeVal] as ScopeData[Prop];\n  event[prop] = merged.length ? merged : undefined;\n}\n\nfunction applyDataToEvent(event: Event, data: ScopeData): void {\n  const { extra, tags, user, contexts, level, transactionName } = data;\n\n  if (Object.keys(extra).length) {\n    event.extra = { ...extra, ...event.extra };\n  }\n\n  if (Object.keys(tags).length) {\n    event.tags = { ...tags, ...event.tags };\n  }\n\n  if (Object.keys(user).length) {\n    event.user = { ...user, ...event.user };\n  }\n\n  if (Object.keys(contexts).length) {\n    event.contexts = { ...contexts, ...event.contexts };\n  }\n\n  if (level) {\n    event.level = level;\n  }\n\n  // transaction events get their `transaction` from the root span name\n  if (transactionName && event.type !== 'transaction') {\n    event.transaction = transactionName;\n  }\n}\n\nfunction applyBreadcrumbsToEvent(event: Event, breadcrumbs: Breadcrumb[]): void {\n  const mergedBreadcrumbs = [...(event.breadcrumbs || []), ...breadcrumbs];\n  event.breadcrumbs = mergedBreadcrumbs.length ? mergedBreadcrumbs : undefined;\n}\n\nfunction applySdkMetadataToEvent(event: Event, sdkProcessingMetadata: ScopeData['sdkProcessingMetadata']): void {\n  event.sdkProcessingMetadata = {\n    ...event.sdkProcessingMetadata,\n    ...sdkProcessingMetadata,\n  };\n}\n\nfunction applySpanToEvent(event: Event, span: Span): void {\n  event.contexts = {\n    trace: spanToTraceContext(span),\n    ...event.contexts,\n  };\n\n  event.sdkProcessingMetadata = {\n    dynamicSamplingContext: getDynamicSamplingContextFromSpan(span),\n    ...event.sdkProcessingMetadata,\n  };\n\n  const rootSpan = getRootSpan(span);\n  const transactionName = spanToJSON(rootSpan).description;\n  if (transactionName && !event.transaction && event.type === 'transaction') {\n    event.transaction = transactionName;\n  }\n}\n\n/**\n * Applies fingerprint from the scope to the event if there's one,\n * uses message if there's one instead or get rid of empty fingerprint\n */\nfunction applyFingerprintToEvent(event: Event, fingerprint: ScopeData['fingerprint'] | undefined): void {\n  // Make sure it's an array first and we actually have something in place\n  event.fingerprint = event.fingerprint\n    ? Array.isArray(event.fingerprint)\n      ? event.fingerprint\n      : [event.fingerprint]\n    : [];\n\n  // If we have something on the scope, then merge it with event\n  if (fingerprint) {\n    event.fingerprint = event.fingerprint.concat(fingerprint);\n  }\n\n  // If we have no data at all, remove empty array default\n  if (!event.fingerprint.length) {\n    delete event.fingerprint;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}