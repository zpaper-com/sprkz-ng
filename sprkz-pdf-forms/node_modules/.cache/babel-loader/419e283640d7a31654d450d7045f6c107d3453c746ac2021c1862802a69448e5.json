{"ast":null,"code":"import { timestampInSeconds, debug, spanToJSON, uuid4, getCurrentScope } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { WINDOW } from '../helpers.js';\nimport { isAutomatedPageLoadSpan, startJSSelfProfile, MAX_PROFILE_DURATION_MS, addProfileToGlobalCache } from './utils.js';\n\n/**\n * Wraps startTransaction and stopTransaction with profiling related logic.\n * startProfileForTransaction is called after the call to startTransaction in order to avoid our own code from\n * being profiled. Because of that same reason, stopProfiling is called before the call to stopTransaction.\n */\nfunction startProfileForSpan(span) {\n  // Start the profiler and get the profiler instance.\n  let startTimestamp;\n  if (isAutomatedPageLoadSpan(span)) {\n    startTimestamp = timestampInSeconds() * 1000;\n  }\n  const profiler = startJSSelfProfile();\n\n  // We failed to construct the profiler, so we skip.\n  // No need to log anything as this has already been logged in startProfile.\n  if (!profiler) {\n    return;\n  }\n  if (DEBUG_BUILD) {\n    debug.log(`[Profiling] started profiling span: ${spanToJSON(span).description}`);\n  }\n\n  // We create \"unique\" span names to avoid concurrent spans with same names\n  // from being ignored by the profiler. From here on, only this span name should be used when\n  // calling the profiler methods. Note: we log the original name to the user to avoid confusion.\n  const profileId = uuid4();\n  getCurrentScope().setContext('profile', {\n    profile_id: profileId,\n    start_timestamp: startTimestamp\n  });\n\n  /**\n   * Idempotent handler for profile stop\n   */\n  async function onProfileHandler() {\n    // Check if the profile exists and return it the behavior has to be idempotent as users may call span.finish multiple times.\n    if (!span) {\n      return;\n    }\n    // Satisfy the type checker, but profiler will always be defined here.\n    if (!profiler) {\n      return;\n    }\n    return profiler.stop().then(profile => {\n      if (maxDurationTimeoutID) {\n        WINDOW.clearTimeout(maxDurationTimeoutID);\n        maxDurationTimeoutID = undefined;\n      }\n      if (DEBUG_BUILD) {\n        debug.log(`[Profiling] stopped profiling of span: ${spanToJSON(span).description}`);\n      }\n\n      // In case of an overlapping span, stopProfiling may return null and silently ignore the overlapping profile.\n      if (!profile) {\n        if (DEBUG_BUILD) {\n          debug.log(`[Profiling] profiler returned null profile for: ${spanToJSON(span).description}`, 'this may indicate an overlapping span or a call to stopProfiling with a profile title that was never started');\n        }\n        return;\n      }\n      addProfileToGlobalCache(profileId, profile);\n    }).catch(error => {\n      if (DEBUG_BUILD) {\n        debug.log('[Profiling] error while stopping profiler:', error);\n      }\n    });\n  }\n\n  // Enqueue a timeout to prevent profiles from running over max duration.\n  let maxDurationTimeoutID = WINDOW.setTimeout(() => {\n    if (DEBUG_BUILD) {\n      debug.log('[Profiling] max profile duration elapsed, stopping profiling for:', spanToJSON(span).description);\n    }\n    // If the timeout exceeds, we want to stop profiling, but not finish the span\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    onProfileHandler();\n  }, MAX_PROFILE_DURATION_MS);\n\n  // We need to reference the original end call to avoid creating an infinite loop\n  const originalEnd = span.end.bind(span);\n\n  /**\n   * Wraps span `end()` with profiling related logic.\n   * startProfiling is called after the call to spanStart in order to avoid our own code from\n   * being profiled. Because of that same reason, stopProfiling is called before the call to spanEnd.\n   */\n  function profilingWrappedSpanEnd() {\n    if (!span) {\n      return originalEnd();\n    }\n    // onProfileHandler should always return the same profile even if this is called multiple times.\n    // Always call onProfileHandler to ensure stopProfiling is called and the timeout is cleared.\n    void onProfileHandler().then(() => {\n      originalEnd();\n    }, () => {\n      // If onProfileHandler fails, we still want to call the original finish method.\n      originalEnd();\n    });\n    return span;\n  }\n  span.end = profilingWrappedSpanEnd;\n}\nexport { startProfileForSpan };\n//# sourceMappingURL=startProfileForSpan.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}