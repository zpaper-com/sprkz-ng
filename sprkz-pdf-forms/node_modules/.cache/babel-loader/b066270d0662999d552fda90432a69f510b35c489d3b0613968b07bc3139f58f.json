{"ast":null,"code":"import { debug, browserPerformanceTimeOrigin, getCurrentScope, htmlTreeAsString, SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE, SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT, SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME, SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { addLcpInstrumentationHandler } from './instrument.js';\nimport { supportsWebVital, listenForWebVitalReportEvents, msToSec, startStandaloneWebVitalSpan } from './utils.js';\n\n/**\n * Starts tracking the Largest Contentful Paint on the current page and collects the value once\n *\n * - the page visibility is hidden\n * - a navigation span is started (to stop LCP measurement for SPA soft navigations)\n *\n * Once either of these events triggers, the LCP value is sent as a standalone span and we stop\n * measuring LCP for subsequent routes.\n */\nfunction trackLcpAsStandaloneSpan(client) {\n  let standaloneLcpValue = 0;\n  let standaloneLcpEntry;\n  if (!supportsWebVital('largest-contentful-paint')) {\n    return;\n  }\n  const cleanupLcpHandler = addLcpInstrumentationHandler(({\n    metric\n  }) => {\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n    standaloneLcpValue = metric.value;\n    standaloneLcpEntry = entry;\n  }, true);\n  listenForWebVitalReportEvents(client, (reportEvent, pageloadSpanId) => {\n    _sendStandaloneLcpSpan(standaloneLcpValue, standaloneLcpEntry, pageloadSpanId, reportEvent);\n    cleanupLcpHandler();\n  });\n}\n\n/**\n * Exported only for testing!\n */\nfunction _sendStandaloneLcpSpan(lcpValue, entry, pageloadSpanId, reportEvent) {\n  DEBUG_BUILD && debug.log(`Sending LCP span (${lcpValue})`);\n  const startTime = msToSec((browserPerformanceTimeOrigin() || 0) + (entry?.startTime || 0));\n  const routeName = getCurrentScope().getScopeData().transactionName;\n  const name = entry ? htmlTreeAsString(entry.element) : 'Largest contentful paint';\n  const attributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.browser.lcp',\n    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'ui.webvital.lcp',\n    [SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME]: 0,\n    // LCP is a point-in-time metric\n    // attach the pageload span id to the LCP span so that we can link them in the UI\n    'sentry.pageload.span_id': pageloadSpanId,\n    // describes what triggered the web vital to be reported\n    'sentry.report_event': reportEvent\n  };\n  if (entry) {\n    entry.element && (attributes['lcp.element'] = htmlTreeAsString(entry.element));\n    entry.id && (attributes['lcp.id'] = entry.id);\n\n    // Trim URL to the first 200 characters.\n    entry.url && (attributes['lcp.url'] = entry.url.trim().slice(0, 200));\n\n    // loadTime is the time of LCP that's related to receiving the LCP element response..\n    entry.loadTime != null && (attributes['lcp.loadTime'] = entry.loadTime);\n\n    // renderTime is loadTime + rendering time\n    // it's 0 if the LCP element is loaded from a 3rd party origin that doesn't send the\n    // `Timing-Allow-Origin` header.\n    entry.renderTime != null && (attributes['lcp.renderTime'] = entry.renderTime);\n    entry.size != null && (attributes['lcp.size'] = entry.size);\n  }\n  const span = startStandaloneWebVitalSpan({\n    name,\n    transaction: routeName,\n    attributes,\n    startTime\n  });\n  if (span) {\n    span.addEvent('lcp', {\n      [SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT]: 'millisecond',\n      [SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE]: lcpValue\n    });\n\n    // LCP is a point-in-time metric, so we end the span immediately\n    span.end(startTime);\n  }\n}\nexport { _sendStandaloneLcpSpan, trackLcpAsStandaloneSpan };","map":{"version":3,"names":["trackLcpAsStandaloneSpan","client","standaloneLcpValue","standaloneLcpEntry","supportsWebVital","cleanupLcpHandler","addLcpInstrumentationHandler","metric","entry","entries","length","value","listenForWebVitalReportEvents","reportEvent","pageloadSpanId","_sendStandaloneLcpSpan","lcpValue","DEBUG_BUILD","debug","log","startTime","msToSec","browserPerformanceTimeOrigin","routeName","getCurrentScope","getScopeData","transactionName","name","htmlTreeAsString","element","attributes","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMANTIC_ATTRIBUTE_SENTRY_OP","SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME","id","url","trim","slice","loadTime","renderTime","size","span","startStandaloneWebVitalSpan","transaction","addEvent","SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT","SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE","end"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry-internal/browser-utils/src/metrics/lcp.ts"],"sourcesContent":["import type { Client, SpanAttributes } from '@sentry/core';\nimport {\n  browserPerformanceTimeOrigin,\n  debug,\n  getCurrentScope,\n  htmlTreeAsString,\n  SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME,\n  SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT,\n  SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n} from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { addLcpInstrumentationHandler } from './instrument';\nimport type { WebVitalReportEvent } from './utils';\nimport { listenForWebVitalReportEvents, msToSec, startStandaloneWebVitalSpan, supportsWebVital } from './utils';\n\n/**\n * Starts tracking the Largest Contentful Paint on the current page and collects the value once\n *\n * - the page visibility is hidden\n * - a navigation span is started (to stop LCP measurement for SPA soft navigations)\n *\n * Once either of these events triggers, the LCP value is sent as a standalone span and we stop\n * measuring LCP for subsequent routes.\n */\nexport function trackLcpAsStandaloneSpan(client: Client): void {\n  let standaloneLcpValue = 0;\n  let standaloneLcpEntry: LargestContentfulPaint | undefined;\n\n  if (!supportsWebVital('largest-contentful-paint')) {\n    return;\n  }\n\n  const cleanupLcpHandler = addLcpInstrumentationHandler(({ metric }) => {\n    const entry = metric.entries[metric.entries.length - 1] as LargestContentfulPaint | undefined;\n    if (!entry) {\n      return;\n    }\n    standaloneLcpValue = metric.value;\n    standaloneLcpEntry = entry;\n  }, true);\n\n  listenForWebVitalReportEvents(client, (reportEvent, pageloadSpanId) => {\n    _sendStandaloneLcpSpan(standaloneLcpValue, standaloneLcpEntry, pageloadSpanId, reportEvent);\n    cleanupLcpHandler();\n  });\n}\n\n/**\n * Exported only for testing!\n */\nexport function _sendStandaloneLcpSpan(\n  lcpValue: number,\n  entry: LargestContentfulPaint | undefined,\n  pageloadSpanId: string,\n  reportEvent: WebVitalReportEvent,\n) {\n  DEBUG_BUILD && debug.log(`Sending LCP span (${lcpValue})`);\n\n  const startTime = msToSec((browserPerformanceTimeOrigin() || 0) + (entry?.startTime || 0));\n  const routeName = getCurrentScope().getScopeData().transactionName;\n\n  const name = entry ? htmlTreeAsString(entry.element) : 'Largest contentful paint';\n\n  const attributes: SpanAttributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.browser.lcp',\n    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'ui.webvital.lcp',\n    [SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME]: 0, // LCP is a point-in-time metric\n    // attach the pageload span id to the LCP span so that we can link them in the UI\n    'sentry.pageload.span_id': pageloadSpanId,\n    // describes what triggered the web vital to be reported\n    'sentry.report_event': reportEvent,\n  };\n\n  if (entry) {\n    entry.element && (attributes['lcp.element'] = htmlTreeAsString(entry.element));\n    entry.id && (attributes['lcp.id'] = entry.id);\n\n    // Trim URL to the first 200 characters.\n    entry.url && (attributes['lcp.url'] = entry.url.trim().slice(0, 200));\n\n    // loadTime is the time of LCP that's related to receiving the LCP element response..\n    entry.loadTime != null && (attributes['lcp.loadTime'] = entry.loadTime);\n\n    // renderTime is loadTime + rendering time\n    // it's 0 if the LCP element is loaded from a 3rd party origin that doesn't send the\n    // `Timing-Allow-Origin` header.\n    entry.renderTime != null && (attributes['lcp.renderTime'] = entry.renderTime);\n\n    entry.size != null && (attributes['lcp.size'] = entry.size);\n  }\n\n  const span = startStandaloneWebVitalSpan({\n    name,\n    transaction: routeName,\n    attributes,\n    startTime,\n  });\n\n  if (span) {\n    span.addEvent('lcp', {\n      [SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT]: 'millisecond',\n      [SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE]: lcpValue,\n    });\n\n    // LCP is a point-in-time metric, so we end the span immediately\n    span.end(startTime);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}