{"ast":null,"code":"import { createTransport, rejectedSyncPromise } from '@sentry/core';\nimport { getNativeImplementation, clearCachedImplementation } from '@sentry-internal/browser-utils';\n\n/**\n * Creates a Transport that uses the Fetch API to send events to Sentry.\n */\nfunction makeFetchTransport(options, nativeFetch = getNativeImplementation('fetch')) {\n  let pendingBodySize = 0;\n  let pendingCount = 0;\n  function makeRequest(request) {\n    const requestSize = request.body.length;\n    pendingBodySize += requestSize;\n    pendingCount++;\n    const requestOptions = {\n      body: request.body,\n      method: 'POST',\n      referrerPolicy: 'strict-origin',\n      headers: options.headers,\n      // Outgoing requests are usually cancelled when navigating to a different page, causing a \"TypeError: Failed to\n      // fetch\" error and sending a \"network_error\" client-outcome - in Chrome, the request status shows \"(cancelled)\".\n      // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're\n      // frequently sending events right before the user is switching pages (eg. when finishing navigation transactions).\n      // Gotchas:\n      // - `keepalive` isn't supported by Firefox\n      // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch):\n      //   If the sum of contentLength and inflightKeepaliveBytes is greater than 64 kibibytes, then return a network error.\n      //   We will therefore only activate the flag when we're below that limit.\n      // There is also a limit of requests that can be open at the same time, so we also limit this to 15\n      // See https://github.com/getsentry/sentry-javascript/pull/7553 for details\n      keepalive: pendingBodySize <= 60000 && pendingCount < 15,\n      ...options.fetchOptions\n    };\n    if (!nativeFetch) {\n      clearCachedImplementation('fetch');\n      return rejectedSyncPromise('No fetch implementation available');\n    }\n    try {\n      // Note: We do not need to suppress tracing here, becasue we are using the native fetch, instead of our wrapped one.\n      return nativeFetch(options.url, requestOptions).then(response => {\n        pendingBodySize -= requestSize;\n        pendingCount--;\n        return {\n          statusCode: response.status,\n          headers: {\n            'x-sentry-rate-limits': response.headers.get('X-Sentry-Rate-Limits'),\n            'retry-after': response.headers.get('Retry-After')\n          }\n        };\n      });\n    } catch (e) {\n      clearCachedImplementation('fetch');\n      pendingBodySize -= requestSize;\n      pendingCount--;\n      return rejectedSyncPromise(e);\n    }\n  }\n  return createTransport(options, makeRequest);\n}\nexport { makeFetchTransport };","map":{"version":3,"names":["makeFetchTransport","options","nativeFetch","getNativeImplementation","pendingBodySize","pendingCount","makeRequest","request","requestSize","body","length","requestOptions","method","referrerPolicy","headers","keepalive","fetchOptions","clearCachedImplementation","rejectedSyncPromise","url","then","response","statusCode","status","get","e","createTransport"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/browser/src/transports/fetch.ts"],"sourcesContent":["import type { Transport, TransportMakeRequestResponse, TransportRequest } from '@sentry/core';\nimport { createTransport, rejectedSyncPromise } from '@sentry/core';\nimport { clearCachedImplementation, getNativeImplementation } from '@sentry-internal/browser-utils';\nimport type { WINDOW } from '../helpers';\nimport type { BrowserTransportOptions } from './types';\n\n/**\n * Creates a Transport that uses the Fetch API to send events to Sentry.\n */\nexport function makeFetchTransport(\n  options: BrowserTransportOptions,\n  nativeFetch: typeof WINDOW.fetch | undefined = getNativeImplementation('fetch'),\n): Transport {\n  let pendingBodySize = 0;\n  let pendingCount = 0;\n\n  function makeRequest(request: TransportRequest): PromiseLike<TransportMakeRequestResponse> {\n    const requestSize = request.body.length;\n    pendingBodySize += requestSize;\n    pendingCount++;\n\n    const requestOptions: RequestInit = {\n      body: request.body,\n      method: 'POST',\n      referrerPolicy: 'strict-origin',\n      headers: options.headers,\n      // Outgoing requests are usually cancelled when navigating to a different page, causing a \"TypeError: Failed to\n      // fetch\" error and sending a \"network_error\" client-outcome - in Chrome, the request status shows \"(cancelled)\".\n      // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're\n      // frequently sending events right before the user is switching pages (eg. when finishing navigation transactions).\n      // Gotchas:\n      // - `keepalive` isn't supported by Firefox\n      // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch):\n      //   If the sum of contentLength and inflightKeepaliveBytes is greater than 64 kibibytes, then return a network error.\n      //   We will therefore only activate the flag when we're below that limit.\n      // There is also a limit of requests that can be open at the same time, so we also limit this to 15\n      // See https://github.com/getsentry/sentry-javascript/pull/7553 for details\n      keepalive: pendingBodySize <= 60_000 && pendingCount < 15,\n      ...options.fetchOptions,\n    };\n\n    if (!nativeFetch) {\n      clearCachedImplementation('fetch');\n      return rejectedSyncPromise('No fetch implementation available');\n    }\n\n    try {\n      // Note: We do not need to suppress tracing here, becasue we are using the native fetch, instead of our wrapped one.\n      return nativeFetch(options.url, requestOptions).then(response => {\n        pendingBodySize -= requestSize;\n        pendingCount--;\n        return {\n          statusCode: response.status,\n          headers: {\n            'x-sentry-rate-limits': response.headers.get('X-Sentry-Rate-Limits'),\n            'retry-after': response.headers.get('Retry-After'),\n          },\n        };\n      });\n    } catch (e) {\n      clearCachedImplementation('fetch');\n      pendingBodySize -= requestSize;\n      pendingCount--;\n      return rejectedSyncPromise(e);\n    }\n  }\n\n  return createTransport(options, makeRequest);\n}\n"],"mappings":";;;AAMA;AACA;AACA;AACO,SAASA,kBAAkBA,CAChCC,OAAO,EACPC,WAAW,GAAoCC,uBAAuB,CAAC,OAAO,CAAC,EACpE;EACX,IAAIC,eAAA,GAAkB,CAAC;EACvB,IAAIC,YAAA,GAAe,CAAC;EAEpB,SAASC,WAAWA,CAACC,OAAO,EAA+D;IACzF,MAAMC,WAAA,GAAcD,OAAO,CAACE,IAAI,CAACC,MAAM;IACvCN,eAAA,IAAmBI,WAAW;IAC9BH,YAAY,EAAE;IAEd,MAAMM,cAAc,GAAgB;MAClCF,IAAI,EAAEF,OAAO,CAACE,IAAI;MAClBG,MAAM,EAAE,MAAM;MACdC,cAAc,EAAE,eAAe;MAC/BC,OAAO,EAAEb,OAAO,CAACa,OAAO;MAC9B;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACMC,SAAS,EAAEX,eAAA,IAAmB,SAAUC,YAAA,GAAe,EAAE;MACzD,GAAGJ,OAAO,CAACe;IACjB,CAAK;IAED,IAAI,CAACd,WAAW,EAAE;MAChBe,yBAAyB,CAAC,OAAO,CAAC;MAClC,OAAOC,mBAAmB,CAAC,mCAAmC,CAAC;IACrE;IAEI,IAAI;MACR;MACM,OAAOhB,WAAW,CAACD,OAAO,CAACkB,GAAG,EAAER,cAAc,CAAC,CAACS,IAAI,CAACC,QAAA,IAAY;QAC/DjB,eAAA,IAAmBI,WAAW;QAC9BH,YAAY,EAAE;QACd,OAAO;UACLiB,UAAU,EAAED,QAAQ,CAACE,MAAM;UAC3BT,OAAO,EAAE;YACP,sBAAsB,EAAEO,QAAQ,CAACP,OAAO,CAACU,GAAG,CAAC,sBAAsB,CAAC;YACpE,aAAa,EAAEH,QAAQ,CAACP,OAAO,CAACU,GAAG,CAAC,aAAa;UAC7D;QACA,CAAS;MACT,CAAO,CAAC;IACR,CAAI,CAAE,OAAOC,CAAC,EAAE;MACVR,yBAAyB,CAAC,OAAO,CAAC;MAClCb,eAAA,IAAmBI,WAAW;MAC9BH,YAAY,EAAE;MACd,OAAOa,mBAAmB,CAACO,CAAC,CAAC;IACnC;EACA;EAEE,OAAOC,eAAe,CAACzB,OAAO,EAAEK,WAAW,CAAC;AAC9C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}