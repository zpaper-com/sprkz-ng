{"ast":null,"code":"import { makeOfflineTransport, parseEnvelope, serializeEnvelope } from '@sentry/core';\nimport { WINDOW } from '../helpers.js';\nimport { makeFetchTransport } from './fetch.js';\n\n// 'Store', 'promisifyRequest' and 'createStore' were originally copied from the 'idb-keyval' package before being\n// modified and simplified: https://github.com/jakearchibald/idb-keyval\n//\n// At commit: 0420a704fd6cbb4225429c536b1f61112d012fca\n// Original license:\n\n// Copyright 2016, Jake Archibald\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nfunction promisifyRequest(request) {\n  return new Promise((resolve, reject) => {\n    // @ts-expect-error - file size hacks\n    request.oncomplete = request.onsuccess = () => resolve(request.result);\n    // @ts-expect-error - file size hacks\n    request.onabort = request.onerror = () => reject(request.error);\n  });\n}\n\n/** Create or open an IndexedDb store */\nfunction createStore(dbName, storeName) {\n  const request = indexedDB.open(dbName);\n  request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n  const dbp = promisifyRequest(request);\n  return callback => dbp.then(db => callback(db.transaction(storeName, 'readwrite').objectStore(storeName)));\n}\nfunction keys(store) {\n  return promisifyRequest(store.getAllKeys());\n}\n\n/** Insert into the end of the store */\nfunction push(store, value, maxQueueSize) {\n  return store(store => {\n    return keys(store).then(keys => {\n      if (keys.length >= maxQueueSize) {\n        return;\n      }\n\n      // We insert with an incremented key so that the entries are popped in order\n      store.put(value, Math.max(...keys, 0) + 1);\n      return promisifyRequest(store.transaction);\n    });\n  });\n}\n\n/** Insert into the front of the store */\nfunction unshift(store, value, maxQueueSize) {\n  return store(store => {\n    return keys(store).then(keys => {\n      if (keys.length >= maxQueueSize) {\n        return;\n      }\n\n      // We insert with an decremented key so that the entries are popped in order\n      store.put(value, Math.min(...keys, 0) - 1);\n      return promisifyRequest(store.transaction);\n    });\n  });\n}\n\n/** Pop the oldest value from the store */\nfunction shift(store) {\n  return store(store => {\n    return keys(store).then(keys => {\n      const firstKey = keys[0];\n      if (firstKey == null) {\n        return undefined;\n      }\n      return promisifyRequest(store.get(firstKey)).then(value => {\n        store.delete(firstKey);\n        return promisifyRequest(store.transaction).then(() => value);\n      });\n    });\n  });\n}\nfunction createIndexedDbStore(options) {\n  let store;\n\n  // Lazily create the store only when it's needed\n  function getStore() {\n    if (store == undefined) {\n      store = createStore(options.dbName || 'sentry-offline', options.storeName || 'queue');\n    }\n    return store;\n  }\n  return {\n    push: async env => {\n      try {\n        const serialized = await serializeEnvelope(env);\n        await push(getStore(), serialized, options.maxQueueSize || 30);\n      } catch {\n        //\n      }\n    },\n    unshift: async env => {\n      try {\n        const serialized = await serializeEnvelope(env);\n        await unshift(getStore(), serialized, options.maxQueueSize || 30);\n      } catch {\n        //\n      }\n    },\n    shift: async () => {\n      try {\n        const deserialized = await shift(getStore());\n        if (deserialized) {\n          return parseEnvelope(deserialized);\n        }\n      } catch {\n        //\n      }\n      return undefined;\n    }\n  };\n}\nfunction makeIndexedDbOfflineTransport(createTransport) {\n  return options => {\n    const transport = createTransport({\n      ...options,\n      createStore: createIndexedDbStore\n    });\n    WINDOW.addEventListener('online', async _ => {\n      await transport.flush();\n    });\n    return transport;\n  };\n}\n\n/**\n * Creates a transport that uses IndexedDb to store events when offline.\n */\nfunction makeBrowserOfflineTransport() {\n  let createTransport = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : makeFetchTransport;\n  return makeIndexedDbOfflineTransport(makeOfflineTransport(createTransport));\n}\nexport { createStore, makeBrowserOfflineTransport, push, shift, unshift };\n//# sourceMappingURL=offline.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}