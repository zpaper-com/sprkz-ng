{"ast":null,"code":"import { createStackParser, UNKNOWN_FUNCTION } from '@sentry/core';\nconst OPERA10_PRIORITY = 10;\nconst OPERA11_PRIORITY = 20;\nconst CHROME_PRIORITY = 30;\nconst WINJS_PRIORITY = 40;\nconst GECKO_PRIORITY = 50;\nfunction createFrame(filename, func, lineno, colno) {\n  const frame = {\n    filename,\n    function: func === '<anonymous>' ? UNKNOWN_FUNCTION : func,\n    in_app: true // All browser frames are considered in_app\n  };\n  if (lineno !== undefined) {\n    frame.lineno = lineno;\n  }\n  if (colno !== undefined) {\n    frame.colno = colno;\n  }\n  return frame;\n}\n\n// This regex matches frames that have no function name (ie. are at the top level of a module).\n// For example \"at http://localhost:5000//script.js:1:126\"\n// Frames _with_ function names usually look as follows: \"at commitLayoutEffects (react-dom.development.js:23426:1)\"\nconst chromeRegexNoFnName = /^\\s*at (\\S+?)(?::(\\d+))(?::(\\d+))\\s*$/i;\n\n// This regex matches all the frames that have a function name.\nconst chromeRegex = /^\\s*at (?:(.+?\\)(?: \\[.+\\])?|.*?) ?\\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\\/)?.*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\nconst chromeEvalRegex = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\n\n// Chromium based browsers: Chrome, Brave, new Opera, new Edge\n// We cannot call this variable `chrome` because it can conflict with global `chrome` variable in certain environments\n// See: https://github.com/getsentry/sentry-javascript/issues/6880\nconst chromeStackParserFn = line => {\n  // If the stack line has no function name, we need to parse it differently\n  const noFnParts = chromeRegexNoFnName.exec(line);\n  if (noFnParts) {\n    const [, filename, line, col] = noFnParts;\n    return createFrame(filename, UNKNOWN_FUNCTION, +line, +col);\n  }\n  const parts = chromeRegex.exec(line);\n  if (parts) {\n    const isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n\n    if (isEval) {\n      const subMatch = chromeEvalRegex.exec(parts[2]);\n      if (subMatch) {\n        // throw out eval line/column and use top-most line/column number\n        parts[2] = subMatch[1]; // url\n        parts[3] = subMatch[2]; // line\n        parts[4] = subMatch[3]; // column\n      }\n    }\n\n    // Kamil: One more hack won't hurt us right? Understanding and adding more rules on top of these regexps right now\n    // would be way too time consuming. (TODO: Rewrite whole RegExp to be more readable)\n    const [func, filename] = extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]);\n    return createFrame(filename, func, parts[3] ? +parts[3] : undefined, parts[4] ? +parts[4] : undefined);\n  }\n  return;\n};\nconst chromeStackLineParser = [CHROME_PRIORITY, chromeStackParserFn];\n\n// gecko regex: `(?:bundle|\\d+\\.js)`: `bundle` is for react native, `\\d+\\.js` also but specifically for ram bundles because it\n// generates filenames without a prefix like `file://` the filenames in the stacktrace are just 42.js\n// We need this specific case for now because we want no other regex to match.\nconst geckoREgex = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)?((?:[-a-z]+)?:\\/.*?|\\[native code\\]|[^@]*(?:bundle|\\d+\\.js)|\\/[\\w\\-. /=]+)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\nconst geckoEvalRegex = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\nconst gecko = line => {\n  const parts = geckoREgex.exec(line);\n  if (parts) {\n    const isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n    if (isEval) {\n      const subMatch = geckoEvalRegex.exec(parts[3]);\n      if (subMatch) {\n        // throw out eval line/column and use top-most line number\n        parts[1] = parts[1] || 'eval';\n        parts[3] = subMatch[1];\n        parts[4] = subMatch[2];\n        parts[5] = ''; // no column when eval\n      }\n    }\n    let filename = parts[3];\n    let func = parts[1] || UNKNOWN_FUNCTION;\n    [func, filename] = extractSafariExtensionDetails(func, filename);\n    return createFrame(filename, func, parts[4] ? +parts[4] : undefined, parts[5] ? +parts[5] : undefined);\n  }\n  return;\n};\nconst geckoStackLineParser = [GECKO_PRIORITY, gecko];\nconst winjsRegex = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:[-a-z]+):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\nconst winjs = line => {\n  const parts = winjsRegex.exec(line);\n  return parts ? createFrame(parts[2], parts[1] || UNKNOWN_FUNCTION, +parts[3], parts[4] ? +parts[4] : undefined) : undefined;\n};\nconst winjsStackLineParser = [WINJS_PRIORITY, winjs];\nconst opera10Regex = / line (\\d+).*script (?:in )?(\\S+)(?:: in function (\\S+))?$/i;\nconst opera10 = line => {\n  const parts = opera10Regex.exec(line);\n  return parts ? createFrame(parts[2], parts[3] || UNKNOWN_FUNCTION, +parts[1]) : undefined;\n};\nconst opera10StackLineParser = [OPERA10_PRIORITY, opera10];\nconst opera11Regex = / line (\\d+), column (\\d+)\\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\\(.*\\))? in (.*):\\s*$/i;\nconst opera11 = line => {\n  const parts = opera11Regex.exec(line);\n  return parts ? createFrame(parts[5], parts[3] || parts[4] || UNKNOWN_FUNCTION, +parts[1], +parts[2]) : undefined;\n};\nconst opera11StackLineParser = [OPERA11_PRIORITY, opera11];\nconst defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser];\nconst defaultStackParser = createStackParser(...defaultStackLineParsers);\n\n/**\n * Safari web extensions, starting version unknown, can produce \"frames-only\" stacktraces.\n * What it means, is that instead of format like:\n *\n * Error: wat\n *   at function@url:row:col\n *   at function@url:row:col\n *   at function@url:row:col\n *\n * it produces something like:\n *\n *   function@url:row:col\n *   function@url:row:col\n *   function@url:row:col\n *\n * Because of that, it won't be captured by `chrome` RegExp and will fall into `Gecko` branch.\n * This function is extracted so that we can use it in both places without duplicating the logic.\n * Unfortunately \"just\" changing RegExp is too complicated now and making it pass all tests\n * and fix this case seems like an impossible, or at least way too time-consuming task.\n */\nconst extractSafariExtensionDetails = (func, filename) => {\n  const isSafariExtension = func.indexOf('safari-extension') !== -1;\n  const isSafariWebExtension = func.indexOf('safari-web-extension') !== -1;\n  return isSafariExtension || isSafariWebExtension ? [func.indexOf('@') !== -1 ? func.split('@')[0] : UNKNOWN_FUNCTION, isSafariExtension ? `safari-extension:${filename}` : `safari-web-extension:${filename}`] : [func, filename];\n};\nexport { chromeStackLineParser, defaultStackLineParsers, defaultStackParser, geckoStackLineParser, opera10StackLineParser, opera11StackLineParser, winjsStackLineParser };","map":{"version":3,"names":["OPERA10_PRIORITY","OPERA11_PRIORITY","CHROME_PRIORITY","WINJS_PRIORITY","GECKO_PRIORITY","createFrame","filename","func","lineno","colno","frame","function","UNKNOWN_FUNCTION","in_app","undefined","chromeRegexNoFnName","chromeRegex","chromeEvalRegex","chromeStackParserFn","line","noFnParts","exec","col","parts","isEval","indexOf","subMatch","extractSafariExtensionDetails","chromeStackLineParser","geckoREgex","geckoEvalRegex","gecko","geckoStackLineParser","winjsRegex","winjs","winjsStackLineParser","opera10Regex","opera10","opera10StackLineParser","opera11Regex","opera11","opera11StackLineParser","defaultStackLineParsers","defaultStackParser","createStackParser","isSafariExtension","isSafariWebExtension","split"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/browser/src/stack-parsers.ts"],"sourcesContent":["// This was originally forked from https://github.com/csnover/TraceKit, and was largely\n// re - written as part of raven - js.\n//\n// This code was later copied to the JavaScript mono - repo and further modified and\n// refactored over the years.\n\n// Copyright (c) 2013 Onur Can Cakmak onur.cakmak@gmail.com and all TraceKit contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files(the 'Software'), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n// merge, publish, distribute, sublicense, and / or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n// The above copyright notice and this permission notice shall be included in all copies\n// or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nimport type { StackFrame, StackLineParser, StackLineParserFn } from '@sentry/core';\nimport { createStackParser, UNKNOWN_FUNCTION } from '@sentry/core';\n\nconst OPERA10_PRIORITY = 10;\nconst OPERA11_PRIORITY = 20;\nconst CHROME_PRIORITY = 30;\nconst WINJS_PRIORITY = 40;\nconst GECKO_PRIORITY = 50;\n\nfunction createFrame(filename: string, func: string, lineno?: number, colno?: number): StackFrame {\n  const frame: StackFrame = {\n    filename,\n    function: func === '<anonymous>' ? UNKNOWN_FUNCTION : func,\n    in_app: true, // All browser frames are considered in_app\n  };\n\n  if (lineno !== undefined) {\n    frame.lineno = lineno;\n  }\n\n  if (colno !== undefined) {\n    frame.colno = colno;\n  }\n\n  return frame;\n}\n\n// This regex matches frames that have no function name (ie. are at the top level of a module).\n// For example \"at http://localhost:5000//script.js:1:126\"\n// Frames _with_ function names usually look as follows: \"at commitLayoutEffects (react-dom.development.js:23426:1)\"\nconst chromeRegexNoFnName = /^\\s*at (\\S+?)(?::(\\d+))(?::(\\d+))\\s*$/i;\n\n// This regex matches all the frames that have a function name.\nconst chromeRegex =\n  /^\\s*at (?:(.+?\\)(?: \\[.+\\])?|.*?) ?\\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\\/)?.*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\n\nconst chromeEvalRegex = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\n\n// Chromium based browsers: Chrome, Brave, new Opera, new Edge\n// We cannot call this variable `chrome` because it can conflict with global `chrome` variable in certain environments\n// See: https://github.com/getsentry/sentry-javascript/issues/6880\nconst chromeStackParserFn: StackLineParserFn = line => {\n  // If the stack line has no function name, we need to parse it differently\n  const noFnParts = chromeRegexNoFnName.exec(line) as null | [string, string, string, string];\n\n  if (noFnParts) {\n    const [, filename, line, col] = noFnParts;\n    return createFrame(filename, UNKNOWN_FUNCTION, +line, +col);\n  }\n\n  const parts = chromeRegex.exec(line) as null | [string, string, string, string, string];\n\n  if (parts) {\n    const isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n\n    if (isEval) {\n      const subMatch = chromeEvalRegex.exec(parts[2]) as null | [string, string, string, string];\n\n      if (subMatch) {\n        // throw out eval line/column and use top-most line/column number\n        parts[2] = subMatch[1]; // url\n        parts[3] = subMatch[2]; // line\n        parts[4] = subMatch[3]; // column\n      }\n    }\n\n    // Kamil: One more hack won't hurt us right? Understanding and adding more rules on top of these regexps right now\n    // would be way too time consuming. (TODO: Rewrite whole RegExp to be more readable)\n    const [func, filename] = extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]);\n\n    return createFrame(filename, func, parts[3] ? +parts[3] : undefined, parts[4] ? +parts[4] : undefined);\n  }\n\n  return;\n};\n\nexport const chromeStackLineParser: StackLineParser = [CHROME_PRIORITY, chromeStackParserFn];\n\n// gecko regex: `(?:bundle|\\d+\\.js)`: `bundle` is for react native, `\\d+\\.js` also but specifically for ram bundles because it\n// generates filenames without a prefix like `file://` the filenames in the stacktrace are just 42.js\n// We need this specific case for now because we want no other regex to match.\nconst geckoREgex =\n  /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)?((?:[-a-z]+)?:\\/.*?|\\[native code\\]|[^@]*(?:bundle|\\d+\\.js)|\\/[\\w\\-. /=]+)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\nconst geckoEvalRegex = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\n\nconst gecko: StackLineParserFn = line => {\n  const parts = geckoREgex.exec(line) as null | [string, string, string, string, string, string];\n\n  if (parts) {\n    const isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n    if (isEval) {\n      const subMatch = geckoEvalRegex.exec(parts[3]) as null | [string, string, string];\n\n      if (subMatch) {\n        // throw out eval line/column and use top-most line number\n        parts[1] = parts[1] || 'eval';\n        parts[3] = subMatch[1];\n        parts[4] = subMatch[2];\n        parts[5] = ''; // no column when eval\n      }\n    }\n\n    let filename = parts[3];\n    let func = parts[1] || UNKNOWN_FUNCTION;\n    [func, filename] = extractSafariExtensionDetails(func, filename);\n\n    return createFrame(filename, func, parts[4] ? +parts[4] : undefined, parts[5] ? +parts[5] : undefined);\n  }\n\n  return;\n};\n\nexport const geckoStackLineParser: StackLineParser = [GECKO_PRIORITY, gecko];\n\nconst winjsRegex = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:[-a-z]+):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n\nconst winjs: StackLineParserFn = line => {\n  const parts = winjsRegex.exec(line) as null | [string, string, string, string, string];\n\n  return parts\n    ? createFrame(parts[2], parts[1] || UNKNOWN_FUNCTION, +parts[3], parts[4] ? +parts[4] : undefined)\n    : undefined;\n};\n\nexport const winjsStackLineParser: StackLineParser = [WINJS_PRIORITY, winjs];\n\nconst opera10Regex = / line (\\d+).*script (?:in )?(\\S+)(?:: in function (\\S+))?$/i;\n\nconst opera10: StackLineParserFn = line => {\n  const parts = opera10Regex.exec(line) as null | [string, string, string, string];\n  return parts ? createFrame(parts[2], parts[3] || UNKNOWN_FUNCTION, +parts[1]) : undefined;\n};\n\nexport const opera10StackLineParser: StackLineParser = [OPERA10_PRIORITY, opera10];\n\nconst opera11Regex =\n  / line (\\d+), column (\\d+)\\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\\(.*\\))? in (.*):\\s*$/i;\n\nconst opera11: StackLineParserFn = line => {\n  const parts = opera11Regex.exec(line) as null | [string, string, string, string, string, string];\n  return parts ? createFrame(parts[5], parts[3] || parts[4] || UNKNOWN_FUNCTION, +parts[1], +parts[2]) : undefined;\n};\n\nexport const opera11StackLineParser: StackLineParser = [OPERA11_PRIORITY, opera11];\n\nexport const defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser];\n\nexport const defaultStackParser = createStackParser(...defaultStackLineParsers);\n\n/**\n * Safari web extensions, starting version unknown, can produce \"frames-only\" stacktraces.\n * What it means, is that instead of format like:\n *\n * Error: wat\n *   at function@url:row:col\n *   at function@url:row:col\n *   at function@url:row:col\n *\n * it produces something like:\n *\n *   function@url:row:col\n *   function@url:row:col\n *   function@url:row:col\n *\n * Because of that, it won't be captured by `chrome` RegExp and will fall into `Gecko` branch.\n * This function is extracted so that we can use it in both places without duplicating the logic.\n * Unfortunately \"just\" changing RegExp is too complicated now and making it pass all tests\n * and fix this case seems like an impossible, or at least way too time-consuming task.\n */\nconst extractSafariExtensionDetails = (func: string, filename: string): [string, string] => {\n  const isSafariExtension = func.indexOf('safari-extension') !== -1;\n  const isSafariWebExtension = func.indexOf('safari-web-extension') !== -1;\n\n  return isSafariExtension || isSafariWebExtension\n    ? [\n        func.indexOf('@') !== -1 ? (func.split('@')[0] as string) : UNKNOWN_FUNCTION,\n        isSafariExtension ? `safari-extension:${filename}` : `safari-web-extension:${filename}`,\n      ]\n    : [func, filename];\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}