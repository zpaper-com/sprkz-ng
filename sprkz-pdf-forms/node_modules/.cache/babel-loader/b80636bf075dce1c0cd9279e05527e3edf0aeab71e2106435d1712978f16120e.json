{"ast":null,"code":"import{PDFService}from'./pdfService';export class FormFieldService{/**\n   * Extract all form fields from a PDF document\n   */static async extractAllFormFields(pdfDoc){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const{excludeReadOnly=false,includeSignatureFields=true,validateFieldNames=true}=options;const documentId=pdfDoc.fingerprints[0];// Check cache first\nif(this.extractedFields.has(documentId)){let fields=this.extractedFields.get(documentId);// Apply filters\nif(excludeReadOnly){fields=fields.filter(field=>!field.readOnly);}return fields;}const allFields=[];const fieldNameCounts=new Map();try{for(let pageNum=1;pageNum<=pdfDoc.numPages;pageNum++){const page=await PDFService.getPage(pdfDoc,pageNum);const pageFields=await PDFService.extractFormFields(page);// Process and enhance each field\nconst processedFields=pageFields.map(field=>{let fieldName=field.name;// Handle duplicate field names by adding suffix\nif(validateFieldNames&&fieldNameCounts.has(fieldName)){const count=fieldNameCounts.get(fieldName)+1;fieldNameCounts.set(fieldName,count);fieldName=`${fieldName}_${count}`;}else{fieldNameCounts.set(fieldName,1);}// Determine field type based on annotation properties\nconst fieldType=this.determineFieldType(field);// Enhanced form field object\nconst enhancedField={name:fieldName,type:fieldType,value:this.getInitialValue(field,fieldType),required:this.isFieldRequired(field),readOnly:field.readOnly||false,page:pageNum,rect:field.rect,isComplete:false,validationErrors:[],options:field.options||undefined,multiline:field.multiline||false,maxLength:field.maxLength||undefined,pattern:this.getValidationPattern(field,fieldType),id:field.id,subtype:field.subtype};return enhancedField;});allFields.push(...processedFields);}// Cache the results\nthis.extractedFields.set(documentId,allFields);console.log(`Extracted ${allFields.length} form fields from ${pdfDoc.numPages} pages`);// Apply final filters\nlet filteredFields=allFields;if(excludeReadOnly){filteredFields=filteredFields.filter(field=>!field.readOnly);}return filteredFields;}catch(error){console.error('Error extracting form fields:',error);throw error;}}/**\n   * Categorize form fields by type and requirements\n   */static categorizeFields(fields){// Create cache key based on field names and properties\nconst cacheKey=fields.map(f=>`${f.name}-${f.type}-${f.required}`).sort().join('|');// Check cache first\nif(this.categorizedCache.has(cacheKey)){return this.categorizedCache.get(cacheKey);}const categories={required:[],optional:[],signature:[],readOnly:[]};fields.forEach(field=>{if(field.readOnly){categories.readOnly.push(field);}else if(field.type==='signature'){categories.signature.push(field);}else if(field.required){categories.required.push(field);}else{categories.optional.push(field);}});console.log('Field categorization:',{required:categories.required.length,optional:categories.optional.length,signature:categories.signature.length,readOnly:categories.readOnly.length});// Cache the result\nthis.categorizedCache.set(cacheKey,categories);return categories;}/**\n   * Get fields that still need completion\n   */static getIncompleteFields(fields){return fields.filter(field=>!field.isComplete&&!field.readOnly);}/**\n   * Get required fields that still need completion\n   */static getIncompleteRequiredFields(fields){return fields.filter(field=>field.required&&!field.isComplete&&!field.readOnly);}/**\n   * Get signature fields\n   */static getSignatureFields(fields){return fields.filter(field=>field.type==='signature'||field.name.toLowerCase().includes('signature')||field.name.toLowerCase().includes('sign'));}/**\n   * Calculate form completion percentage\n   */static calculateCompletionPercentage(fields){const requiredFields=fields.filter(field=>field.required&&!field.readOnly);if(requiredFields.length===0)return 100;const completedFields=requiredFields.filter(field=>field.isComplete);return Math.round(completedFields.length/requiredFields.length*100);}/**\n   * Validate field value based on field type and constraints\n   */static validateFieldValue(field,value){const errors=[];// Required field validation\nif(field.required&&!field.readOnly){if(value===undefined||value===null||value===''){errors.push('This field is required');}}// Skip further validation if empty and not required\nif(!value&&!field.required){return errors;}// Type-specific validation\nswitch(field.type){case'text':if(typeof value!=='string'){errors.push('Value must be text');break;}if(field.maxLength&&value.length>field.maxLength){errors.push(`Text must be ${field.maxLength} characters or less`);}if(field.pattern){const regex=new RegExp(field.pattern);if(!regex.test(value)){errors.push('Invalid format');}}break;case'checkbox':if(typeof value!=='boolean'){errors.push('Value must be true or false');}break;case'radio':case'dropdown':if(field.options&&!field.options.includes(value)){errors.push('Invalid selection');}break;case'date':if(typeof value==='string'){const date=new Date(value);if(isNaN(date.getTime())){errors.push('Invalid date format');}}break;}return errors;}/**\n   * Update field completion status\n   */static updateFieldCompletion(field,value){const errors=this.validateFieldValue(field,value);const isComplete=errors.length===0&&this.hasValidValue(field,value);return{...field,value,isComplete,validationErrors:errors};}/**\n   * Private helper methods\n   */static determineFieldType(field){// Check field name for signature indicators\nconst fieldName=(field.name||'').toLowerCase();if(fieldName.includes('signature')||fieldName.includes('sign')){return'signature';}// Check annotation subtype and fieldType\nswitch(field.type||field.fieldType){case'Tx':// Text field\nreturn'text';case'Btn':// Button field (could be checkbox or radio)\nif(field.checkBox||field.radioButton===false){return'checkbox';}else{return'radio';}case'Ch':// Choice field (dropdown or listbox)\nreturn'dropdown';case'Sig':// Signature field\nreturn'signature';default:// Fallback based on field properties\nif(field.options&&Array.isArray(field.options)){return'dropdown';}if(field.checkBox!==undefined){return'checkbox';}return'text';}}static getInitialValue(field,fieldType){var _field$options;const existingValue=field.value||field.fieldValue;if(existingValue!==undefined&&existingValue!==null){return existingValue;}// Default values based on field type\nswitch(fieldType){case'checkbox':return false;case'radio':case'dropdown':return((_field$options=field.options)===null||_field$options===void 0?void 0:_field$options[0])||'';default:return'';}}static isFieldRequired(field){// Explicit required flag\nif(field.required===true)return true;if(field.required===false)return false;// Check field flags (PDF specification)\nif(field.fieldFlags!==undefined){const REQUIRED_FLAG=1<<1;// Bit 2 in field flags\nreturn(field.fieldFlags&REQUIRED_FLAG)!==0;}// Heuristic: fields marked with asterisk or \"required\" in name\nconst fieldName=(field.name||'').toLowerCase();return fieldName.includes('required')||fieldName.includes('*');}static getValidationPattern(field,fieldType){// Return existing pattern if available\nif(field.pattern)return field.pattern;// Common validation patterns based on field name\nconst fieldName=(field.name||'').toLowerCase();if(fieldName.includes('email')){return'^[^\\\\s@]+@[^\\\\s@]+\\\\.[^\\\\s@]+$';}if(fieldName.includes('phone')||fieldName.includes('tel')){return'^[\\\\d\\\\s\\\\-\\\\(\\\\)\\\\+]{10,}$';}if(fieldName.includes('zip')||fieldName.includes('postal')){return'^\\\\d{5}(-\\\\d{4})?$';}if(fieldName.includes('date')){return'^\\\\d{1,2}/\\\\d{1,2}/\\\\d{4}$|^\\\\d{4}-\\\\d{2}-\\\\d{2}$';}return undefined;}static hasValidValue(field,value){if(value===undefined||value===null)return false;switch(field.type){case'text':return typeof value==='string'&&value.trim().length>0;case'checkbox':return typeof value==='boolean';case'radio':case'dropdown':return typeof value==='string'&&value.length>0;case'signature':return typeof value==='string'&&value.length>0;default:return true;}}/**\n   * Clear cached form fields\n   */static clearCache(documentId){if(documentId){this.extractedFields.delete(documentId);}else{this.extractedFields.clear();}}}FormFieldService.extractedFields=new Map();FormFieldService.categorizedCache=new Map();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}