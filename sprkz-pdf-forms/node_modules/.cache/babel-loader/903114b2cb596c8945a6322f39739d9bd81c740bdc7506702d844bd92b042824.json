{"ast":null,"code":"import { spanToJSON, debug, getClient, forEachEnvelopeItem, timestampInSeconds, uuid4, DEFAULT_ENVIRONMENT, getDebugImagesForResources, browserPerformanceTimeOrigin } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { WINDOW } from '../helpers.js';\nconst MS_TO_NS = 1e6;\n// Use 0 as main thread id which is identical to threadId in node:worker_threads\n// where main logs 0 and workers seem to log in increments of 1\nconst THREAD_ID_STRING = String(0);\nconst THREAD_NAME = 'main';\n\n// We force make this optional to be on the safe side...\nconst navigator = WINDOW.navigator;\n\n// Machine properties (eval only once)\nlet OS_PLATFORM = '';\nlet OS_PLATFORM_VERSION = '';\nlet OS_ARCH = '';\nlet OS_BROWSER = navigator?.userAgent || '';\nlet OS_MODEL = '';\nconst OS_LOCALE = navigator?.language || navigator?.languages?.[0] || '';\nfunction isUserAgentData(data) {\n  return typeof data === 'object' && data !== null && 'getHighEntropyValues' in data;\n}\n\n// @ts-expect-error userAgentData is not part of the navigator interface yet\nconst userAgentData = navigator?.userAgentData;\nif (isUserAgentData(userAgentData)) {\n  userAgentData.getHighEntropyValues(['architecture', 'model', 'platform', 'platformVersion', 'fullVersionList']).then(ua => {\n    OS_PLATFORM = ua.platform || '';\n    OS_ARCH = ua.architecture || '';\n    OS_MODEL = ua.model || '';\n    OS_PLATFORM_VERSION = ua.platformVersion || '';\n    if (ua.fullVersionList?.length) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const firstUa = ua.fullVersionList[ua.fullVersionList.length - 1];\n      OS_BROWSER = `${firstUa.brand} ${firstUa.version}`;\n    }\n  }).catch(e => void 0);\n}\nfunction isProcessedJSSelfProfile(profile) {\n  return !('thread_metadata' in profile);\n}\n\n// Enriches the profile with threadId of the current thread.\n// This is done in node as we seem to not be able to get the info from C native code.\n/**\n *\n */\nfunction enrichWithThreadInformation(profile) {\n  if (!isProcessedJSSelfProfile(profile)) {\n    return profile;\n  }\n  return convertJSSelfProfileToSampledFormat(profile);\n}\n\n// Profile is marked as optional because it is deleted from the metadata\n// by the integration before the event is processed by other integrations.\n\nfunction getTraceId(event) {\n  const traceId = event.contexts?.trace?.trace_id;\n  // Log a warning if the profile has an invalid traceId (should be uuidv4).\n  // All profiles and transactions are rejected if this is the case and we want to\n  // warn users that this is happening if they enable debug flag\n  if (typeof traceId === 'string' && traceId.length !== 32) {\n    if (DEBUG_BUILD) {\n      debug.log(`[Profiling] Invalid traceId: ${traceId} on profiled event`);\n    }\n  }\n  if (typeof traceId !== 'string') {\n    return '';\n  }\n  return traceId;\n}\n/**\n * Creates a profiling event envelope from a Sentry event. If profile does not pass\n * validation, returns null.\n * @param event\n * @param dsn\n * @param metadata\n * @param tunnel\n * @returns {EventEnvelope | null}\n */\n\n/**\n * Creates a profiling event envelope from a Sentry event.\n */\nfunction createProfilePayload(profile_id, start_timestamp, processed_profile, event) {\n  if (event.type !== 'transaction') {\n    // createProfilingEventEnvelope should only be called for transactions,\n    // we type guard this behavior with isProfiledTransactionEvent.\n    throw new TypeError('Profiling events may only be attached to transactions, this should never occur.');\n  }\n  if (processed_profile === undefined || processed_profile === null) {\n    throw new TypeError(`Cannot construct profiling event envelope without a valid profile. Got ${processed_profile} instead.`);\n  }\n  const traceId = getTraceId(event);\n  const enrichedThreadProfile = enrichWithThreadInformation(processed_profile);\n  const transactionStartMs = start_timestamp ? start_timestamp : typeof event.start_timestamp === 'number' ? event.start_timestamp * 1000 : timestampInSeconds() * 1000;\n  const transactionEndMs = typeof event.timestamp === 'number' ? event.timestamp * 1000 : timestampInSeconds() * 1000;\n  const profile = {\n    event_id: profile_id,\n    timestamp: new Date(transactionStartMs).toISOString(),\n    platform: 'javascript',\n    version: '1',\n    release: event.release || '',\n    environment: event.environment || DEFAULT_ENVIRONMENT,\n    runtime: {\n      name: 'javascript',\n      version: WINDOW.navigator.userAgent\n    },\n    os: {\n      name: OS_PLATFORM,\n      version: OS_PLATFORM_VERSION,\n      build_number: OS_BROWSER\n    },\n    device: {\n      locale: OS_LOCALE,\n      model: OS_MODEL,\n      manufacturer: OS_BROWSER,\n      architecture: OS_ARCH,\n      is_emulator: false\n    },\n    debug_meta: {\n      images: applyDebugMetadata(processed_profile.resources)\n    },\n    profile: enrichedThreadProfile,\n    transactions: [{\n      name: event.transaction || '',\n      id: event.event_id || uuid4(),\n      trace_id: traceId,\n      active_thread_id: THREAD_ID_STRING,\n      relative_start_ns: '0',\n      relative_end_ns: ((transactionEndMs - transactionStartMs) * 1e6).toFixed(0)\n    }]\n  };\n  return profile;\n}\n\n/*\n  See packages/browser-utils/src/browser/router.ts\n*/\n/**\n *\n */\nfunction isAutomatedPageLoadSpan(span) {\n  return spanToJSON(span).op === 'pageload';\n}\n\n/**\n * Converts a JSSelfProfile to a our sampled format.\n * Does not currently perform stack indexing.\n */\nfunction convertJSSelfProfileToSampledFormat(input) {\n  let EMPTY_STACK_ID = undefined;\n  let STACK_ID = 0;\n\n  // Initialize the profile that we will fill with data\n  const profile = {\n    samples: [],\n    stacks: [],\n    frames: [],\n    thread_metadata: {\n      [THREAD_ID_STRING]: {\n        name: THREAD_NAME\n      }\n    }\n  };\n  const firstSample = input.samples[0];\n  if (!firstSample) {\n    return profile;\n  }\n\n  // We assert samples.length > 0 above and timestamp should always be present\n  const start = firstSample.timestamp;\n  // The JS SDK might change it's time origin based on some heuristic (see See packages/utils/src/time.ts)\n  // when that happens, we need to ensure we are correcting the profile timings so the two timelines stay in sync.\n  // Since JS self profiling time origin is always initialized to performance.timeOrigin, we need to adjust for\n  // the drift between the SDK selected value and our profile time origin.\n  const perfOrigin = browserPerformanceTimeOrigin();\n  const origin = typeof performance.timeOrigin === 'number' ? performance.timeOrigin : perfOrigin || 0;\n  const adjustForOriginChange = origin - (perfOrigin || origin);\n  input.samples.forEach((jsSample, i) => {\n    // If sample has no stack, add an empty sample\n    if (jsSample.stackId === undefined) {\n      if (EMPTY_STACK_ID === undefined) {\n        EMPTY_STACK_ID = STACK_ID;\n        profile.stacks[EMPTY_STACK_ID] = [];\n        STACK_ID++;\n      }\n      profile['samples'][i] = {\n        // convert ms timestamp to ns\n        elapsed_since_start_ns: ((jsSample.timestamp + adjustForOriginChange - start) * MS_TO_NS).toFixed(0),\n        stack_id: EMPTY_STACK_ID,\n        thread_id: THREAD_ID_STRING\n      };\n      return;\n    }\n    let stackTop = input.stacks[jsSample.stackId];\n\n    // Functions in top->down order (root is last)\n    // We follow the stackTop.parentId trail and collect each visited frameId\n    const stack = [];\n    while (stackTop) {\n      stack.push(stackTop.frameId);\n      const frame = input.frames[stackTop.frameId];\n\n      // If our frame has not been indexed yet, index it\n      if (frame && profile.frames[stackTop.frameId] === undefined) {\n        profile.frames[stackTop.frameId] = {\n          function: frame.name,\n          abs_path: typeof frame.resourceId === 'number' ? input.resources[frame.resourceId] : undefined,\n          lineno: frame.line,\n          colno: frame.column\n        };\n      }\n      stackTop = stackTop.parentId === undefined ? undefined : input.stacks[stackTop.parentId];\n    }\n    const sample = {\n      // convert ms timestamp to ns\n      elapsed_since_start_ns: ((jsSample.timestamp + adjustForOriginChange - start) * MS_TO_NS).toFixed(0),\n      stack_id: STACK_ID,\n      thread_id: THREAD_ID_STRING\n    };\n    profile['stacks'][STACK_ID] = stack;\n    profile['samples'][i] = sample;\n    STACK_ID++;\n  });\n  return profile;\n}\n\n/**\n * Adds items to envelope if they are not already present - mutates the envelope.\n * @param envelope\n */\nfunction addProfilesToEnvelope(envelope, profiles) {\n  if (!profiles.length) {\n    return envelope;\n  }\n  for (const profile of profiles) {\n    envelope[1].push([{\n      type: 'profile'\n    }, profile]);\n  }\n  return envelope;\n}\n\n/**\n * Finds transactions with profile_id context in the envelope\n * @param envelope\n * @returns\n */\nfunction findProfiledTransactionsFromEnvelope(envelope) {\n  const events = [];\n  forEachEnvelopeItem(envelope, (item, type) => {\n    if (type !== 'transaction') {\n      return;\n    }\n    for (let j = 1; j < item.length; j++) {\n      const event = item[j];\n      if (event?.contexts?.profile?.profile_id) {\n        events.push(item[j]);\n      }\n    }\n  });\n  return events;\n}\n\n/**\n * Applies debug meta data to an event from a list of paths to resources (sourcemaps)\n */\nfunction applyDebugMetadata(resource_paths) {\n  const client = getClient();\n  const options = client?.getOptions();\n  const stackParser = options?.stackParser;\n  if (!stackParser) {\n    return [];\n  }\n  return getDebugImagesForResources(stackParser, resource_paths);\n}\n\n/**\n * Checks the given sample rate to make sure it is valid type and value (a boolean, or a number between 0 and 1).\n */\nfunction isValidSampleRate(rate) {\n  // we need to check NaN explicitly because it's of type 'number' and therefore wouldn't get caught by this typecheck\n  if (typeof rate !== 'number' && typeof rate !== 'boolean' || typeof rate === 'number' && isNaN(rate)) {\n    DEBUG_BUILD && debug.warn(`[Profiling] Invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(rate)} of type ${JSON.stringify(typeof rate)}.`);\n    return false;\n  }\n\n  // Boolean sample rates are always valid\n  if (rate === true || rate === false) {\n    return true;\n  }\n\n  // in case sampleRate is a boolean, it will get automatically cast to 1 if it's true and 0 if it's false\n  if (rate < 0 || rate > 1) {\n    DEBUG_BUILD && debug.warn(`[Profiling] Invalid sample rate. Sample rate must be between 0 and 1. Got ${rate}.`);\n    return false;\n  }\n  return true;\n}\nfunction isValidProfile(profile) {\n  if (profile.samples.length < 2) {\n    if (DEBUG_BUILD) {\n      // Log a warning if the profile has less than 2 samples so users can know why\n      // they are not seeing any profiling data and we cant avoid the back and forth\n      // of asking them to provide us with a dump of the profile data.\n      debug.log('[Profiling] Discarding profile because it contains less than 2 samples');\n    }\n    return false;\n  }\n  if (!profile.frames.length) {\n    if (DEBUG_BUILD) {\n      debug.log('[Profiling] Discarding profile because it contains no frames');\n    }\n    return false;\n  }\n  return true;\n}\n\n// Keep a flag value to avoid re-initializing the profiler constructor. If it fails\n// once, it will always fail and this allows us to early return.\nlet PROFILING_CONSTRUCTOR_FAILED = false;\nconst MAX_PROFILE_DURATION_MS = 30000;\n\n/**\n * Check if profiler constructor is available.\n * @param maybeProfiler\n */\nfunction isJSProfilerSupported(maybeProfiler) {\n  return typeof maybeProfiler === 'function';\n}\n\n/**\n * Starts the profiler and returns the profiler instance.\n */\nfunction startJSSelfProfile() {\n  // Feature support check first\n  const JSProfilerConstructor = WINDOW.Profiler;\n  if (!isJSProfilerSupported(JSProfilerConstructor)) {\n    if (DEBUG_BUILD) {\n      debug.log('[Profiling] Profiling is not supported by this browser, Profiler interface missing on window object.');\n    }\n    return;\n  }\n\n  // From initial testing, it seems that the minimum value for sampleInterval is 10ms.\n  const samplingIntervalMS = 10;\n  // Start the profiler\n  const maxSamples = Math.floor(MAX_PROFILE_DURATION_MS / samplingIntervalMS);\n\n  // Attempt to initialize the profiler constructor, if it fails, we disable profiling for the current user session.\n  // This is likely due to a missing 'Document-Policy': 'js-profiling' header. We do not want to throw an error if this happens\n  // as we risk breaking the user's application, so just disable profiling and log an error.\n  try {\n    return new JSProfilerConstructor({\n      sampleInterval: samplingIntervalMS,\n      maxBufferSize: maxSamples\n    });\n  } catch (e) {\n    if (DEBUG_BUILD) {\n      debug.log(\"[Profiling] Failed to initialize the Profiling constructor, this is likely due to a missing 'Document-Policy': 'js-profiling' header.\");\n      debug.log('[Profiling] Disabling profiling for current user session.');\n    }\n    PROFILING_CONSTRUCTOR_FAILED = true;\n  }\n  return;\n}\n\n/**\n * Determine if a profile should be profiled.\n */\nfunction shouldProfileSpan(span) {\n  // If constructor failed once, it will always fail, so we can early return.\n  if (PROFILING_CONSTRUCTOR_FAILED) {\n    if (DEBUG_BUILD) {\n      debug.log('[Profiling] Profiling has been disabled for the duration of the current user session.');\n    }\n    return false;\n  }\n  if (!span.isRecording()) {\n    if (DEBUG_BUILD) {\n      debug.log('[Profiling] Discarding profile because transaction was not sampled.');\n    }\n    return false;\n  }\n  const client = getClient();\n  const options = client?.getOptions();\n  if (!options) {\n    DEBUG_BUILD && debug.log('[Profiling] Profiling disabled, no options found.');\n    return false;\n  }\n\n  // @ts-expect-error profilesSampleRate is not part of the browser options yet\n  const profilesSampleRate = options.profilesSampleRate;\n\n  // Since this is coming from the user (or from a function provided by the user), who knows what we might get. (The\n  // only valid values are booleans or numbers between 0 and 1.)\n  if (!isValidSampleRate(profilesSampleRate)) {\n    DEBUG_BUILD && debug.warn('[Profiling] Discarding profile because of invalid sample rate.');\n    return false;\n  }\n\n  // if the function returned 0 (or false), or if `profileSampleRate` is 0, it's a sign the profile should be dropped\n  if (!profilesSampleRate) {\n    DEBUG_BUILD && debug.log('[Profiling] Discarding profile because a negative sampling decision was inherited or profileSampleRate is set to 0');\n    return false;\n  }\n\n  // Now we roll the dice. Math.random is inclusive of 0, but not of 1, so strict < is safe here. In case sampleRate is\n  // a boolean, the < comparison will cause it to be automatically cast to 1 if it's true and 0 if it's false.\n  const sampled = profilesSampleRate === true ? true : Math.random() < profilesSampleRate;\n  // Check if we should sample this profile\n  if (!sampled) {\n    DEBUG_BUILD && debug.log(`[Profiling] Discarding profile because it's not included in the random sample (sampling rate = ${Number(profilesSampleRate)})`);\n    return false;\n  }\n  return true;\n}\n\n/**\n * Creates a profiling envelope item, if the profile does not pass validation, returns null.\n * @param event\n * @returns {Profile | null}\n */\nfunction createProfilingEvent(profile_id, start_timestamp, profile, event) {\n  if (!isValidProfile(profile)) {\n    return null;\n  }\n  return createProfilePayload(profile_id, start_timestamp, profile, event);\n}\n\n// TODO (v8): We need to obtain profile ids in @sentry-internal/tracing,\n// but we don't have access to this map because importing this map would\n// cause a circular dependency. We need to resolve this in v8.\nconst PROFILE_MAP = new Map();\n/**\n *\n */\nfunction getActiveProfilesCount() {\n  return PROFILE_MAP.size;\n}\n\n/**\n * Retrieves profile from global cache and removes it.\n */\nfunction takeProfileFromGlobalCache(profile_id) {\n  const profile = PROFILE_MAP.get(profile_id);\n  if (profile) {\n    PROFILE_MAP.delete(profile_id);\n  }\n  return profile;\n}\n/**\n * Adds profile to global cache and evicts the oldest profile if the cache is full.\n */\nfunction addProfileToGlobalCache(profile_id, profile) {\n  PROFILE_MAP.set(profile_id, profile);\n  if (PROFILE_MAP.size > 30) {\n    const last = PROFILE_MAP.keys().next().value;\n    PROFILE_MAP.delete(last);\n  }\n}\nexport { MAX_PROFILE_DURATION_MS, addProfileToGlobalCache, addProfilesToEnvelope, applyDebugMetadata, convertJSSelfProfileToSampledFormat, createProfilePayload, createProfilingEvent, enrichWithThreadInformation, findProfiledTransactionsFromEnvelope, getActiveProfilesCount, isAutomatedPageLoadSpan, isValidSampleRate, shouldProfileSpan, startJSSelfProfile, takeProfileFromGlobalCache };","map":{"version":3,"names":["MS_TO_NS","THREAD_ID_STRING","String","THREAD_NAME","navigator","WINDOW","OS_PLATFORM","OS_PLATFORM_VERSION","OS_ARCH","OS_BROWSER","userAgent","OS_MODEL","OS_LOCALE","language","languages","isUserAgentData","data","userAgentData","getHighEntropyValues","then","ua","platform","architecture","model","platformVersion","fullVersionList","length","firstUa","brand","version","catch","e","isProcessedJSSelfProfile","profile","enrichWithThreadInformation","convertJSSelfProfileToSampledFormat","getTraceId","event","traceId","contexts","trace","trace_id","DEBUG_BUILD","debug","log","createProfilePayload","profile_id","start_timestamp","processed_profile","type","TypeError","undefined","enrichedThreadProfile","transactionStartMs","timestampInSeconds","transactionEndMs","timestamp","event_id","Date","toISOString","release","environment","DEFAULT_ENVIRONMENT","runtime","name","os","build_number","device","locale","manufacturer","is_emulator","debug_meta","images","applyDebugMetadata","resources","transactions","transaction","id","uuid4","active_thread_id","relative_start_ns","relative_end_ns","toFixed","isAutomatedPageLoadSpan","span","spanToJSON","op","input","EMPTY_STACK_ID","STACK_ID","samples","stacks","frames","thread_metadata","firstSample","start","perfOrigin","browserPerformanceTimeOrigin","origin","performance","timeOrigin","adjustForOriginChange","forEach","jsSample","i","stackId","elapsed_since_start_ns","stack_id","thread_id","stackTop","stack","push","frameId","frame","function","abs_path","resourceId","lineno","line","colno","column","parentId","sample","addProfilesToEnvelope","envelope","profiles","findProfiledTransactionsFromEnvelope","events","forEachEnvelopeItem","item","j","resource_paths","client","getClient","options","getOptions","stackParser","getDebugImagesForResources","isValidSampleRate","rate","isNaN","warn","JSON","stringify","isValidProfile","PROFILING_CONSTRUCTOR_FAILED","MAX_PROFILE_DURATION_MS","isJSProfilerSupported","maybeProfiler","startJSSelfProfile","JSProfilerConstructor","Profiler","samplingIntervalMS","maxSamples","Math","floor","sampleInterval","maxBufferSize","shouldProfileSpan","isRecording","profilesSampleRate","sampled","random","Number","createProfilingEvent","PROFILE_MAP","Map","getActiveProfilesCount","size","takeProfileFromGlobalCache","get","delete","addProfileToGlobalCache","set","last","keys","next","value"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/browser/src/profiling/utils.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport type { DebugImage, Envelope, Event, EventEnvelope, Profile, Span, ThreadCpuProfile } from '@sentry/core';\nimport {\n  browserPerformanceTimeOrigin,\n  debug,\n  DEFAULT_ENVIRONMENT,\n  forEachEnvelopeItem,\n  getClient,\n  getDebugImagesForResources,\n  spanToJSON,\n  timestampInSeconds,\n  uuid4,\n} from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { WINDOW } from '../helpers';\nimport type { JSSelfProfile, JSSelfProfiler, JSSelfProfilerConstructor, JSSelfProfileStack } from './jsSelfProfiling';\n\nconst MS_TO_NS = 1e6;\n// Use 0 as main thread id which is identical to threadId in node:worker_threads\n// where main logs 0 and workers seem to log in increments of 1\nconst THREAD_ID_STRING = String(0);\nconst THREAD_NAME = 'main';\n\n// We force make this optional to be on the safe side...\nconst navigator = WINDOW.navigator as typeof WINDOW.navigator | undefined;\n\n// Machine properties (eval only once)\nlet OS_PLATFORM = '';\nlet OS_PLATFORM_VERSION = '';\nlet OS_ARCH = '';\nlet OS_BROWSER = navigator?.userAgent || '';\nlet OS_MODEL = '';\nconst OS_LOCALE = navigator?.language || navigator?.languages?.[0] || '';\n\ntype UAData = {\n  platform?: string;\n  architecture?: string;\n  model?: string;\n  platformVersion?: string;\n  fullVersionList?: {\n    brand: string;\n    version: string;\n  }[];\n};\n\ninterface UserAgentData {\n  getHighEntropyValues: (keys: string[]) => Promise<UAData>;\n}\n\nfunction isUserAgentData(data: unknown): data is UserAgentData {\n  return typeof data === 'object' && data !== null && 'getHighEntropyValues' in data;\n}\n\n// @ts-expect-error userAgentData is not part of the navigator interface yet\nconst userAgentData = navigator?.userAgentData;\n\nif (isUserAgentData(userAgentData)) {\n  userAgentData\n    .getHighEntropyValues(['architecture', 'model', 'platform', 'platformVersion', 'fullVersionList'])\n    .then((ua: UAData) => {\n      OS_PLATFORM = ua.platform || '';\n      OS_ARCH = ua.architecture || '';\n      OS_MODEL = ua.model || '';\n      OS_PLATFORM_VERSION = ua.platformVersion || '';\n\n      if (ua.fullVersionList?.length) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const firstUa = ua.fullVersionList[ua.fullVersionList.length - 1]!;\n        OS_BROWSER = `${firstUa.brand} ${firstUa.version}`;\n      }\n    })\n    .catch(e => void e);\n}\n\nfunction isProcessedJSSelfProfile(profile: ThreadCpuProfile | JSSelfProfile): profile is JSSelfProfile {\n  return !('thread_metadata' in profile);\n}\n\n// Enriches the profile with threadId of the current thread.\n// This is done in node as we seem to not be able to get the info from C native code.\n/**\n *\n */\nexport function enrichWithThreadInformation(profile: ThreadCpuProfile | JSSelfProfile): ThreadCpuProfile {\n  if (!isProcessedJSSelfProfile(profile)) {\n    return profile;\n  }\n\n  return convertJSSelfProfileToSampledFormat(profile);\n}\n\n// Profile is marked as optional because it is deleted from the metadata\n// by the integration before the event is processed by other integrations.\nexport interface ProfiledEvent extends Event {\n  sdkProcessingMetadata: {\n    profile?: JSSelfProfile;\n  };\n}\n\nfunction getTraceId(event: Event): string {\n  const traceId: unknown = event.contexts?.trace?.trace_id;\n  // Log a warning if the profile has an invalid traceId (should be uuidv4).\n  // All profiles and transactions are rejected if this is the case and we want to\n  // warn users that this is happening if they enable debug flag\n  if (typeof traceId === 'string' && traceId.length !== 32) {\n    if (DEBUG_BUILD) {\n      debug.log(`[Profiling] Invalid traceId: ${traceId} on profiled event`);\n    }\n  }\n  if (typeof traceId !== 'string') {\n    return '';\n  }\n\n  return traceId;\n}\n/**\n * Creates a profiling event envelope from a Sentry event. If profile does not pass\n * validation, returns null.\n * @param event\n * @param dsn\n * @param metadata\n * @param tunnel\n * @returns {EventEnvelope | null}\n */\n\n/**\n * Creates a profiling event envelope from a Sentry event.\n */\nexport function createProfilePayload(\n  profile_id: string,\n  start_timestamp: number | undefined,\n  processed_profile: JSSelfProfile,\n  event: ProfiledEvent,\n): Profile {\n  if (event.type !== 'transaction') {\n    // createProfilingEventEnvelope should only be called for transactions,\n    // we type guard this behavior with isProfiledTransactionEvent.\n    throw new TypeError('Profiling events may only be attached to transactions, this should never occur.');\n  }\n\n  if (processed_profile === undefined || processed_profile === null) {\n    throw new TypeError(\n      `Cannot construct profiling event envelope without a valid profile. Got ${processed_profile} instead.`,\n    );\n  }\n\n  const traceId = getTraceId(event);\n  const enrichedThreadProfile = enrichWithThreadInformation(processed_profile);\n  const transactionStartMs = start_timestamp\n    ? start_timestamp\n    : typeof event.start_timestamp === 'number'\n      ? event.start_timestamp * 1000\n      : timestampInSeconds() * 1000;\n  const transactionEndMs = typeof event.timestamp === 'number' ? event.timestamp * 1000 : timestampInSeconds() * 1000;\n\n  const profile: Profile = {\n    event_id: profile_id,\n    timestamp: new Date(transactionStartMs).toISOString(),\n    platform: 'javascript',\n    version: '1',\n    release: event.release || '',\n    environment: event.environment || DEFAULT_ENVIRONMENT,\n    runtime: {\n      name: 'javascript',\n      version: WINDOW.navigator.userAgent,\n    },\n    os: {\n      name: OS_PLATFORM,\n      version: OS_PLATFORM_VERSION,\n      build_number: OS_BROWSER,\n    },\n    device: {\n      locale: OS_LOCALE,\n      model: OS_MODEL,\n      manufacturer: OS_BROWSER,\n      architecture: OS_ARCH,\n      is_emulator: false,\n    },\n    debug_meta: {\n      images: applyDebugMetadata(processed_profile.resources),\n    },\n    profile: enrichedThreadProfile,\n    transactions: [\n      {\n        name: event.transaction || '',\n        id: event.event_id || uuid4(),\n        trace_id: traceId,\n        active_thread_id: THREAD_ID_STRING,\n        relative_start_ns: '0',\n        relative_end_ns: ((transactionEndMs - transactionStartMs) * 1e6).toFixed(0),\n      },\n    ],\n  };\n\n  return profile;\n}\n\n/**\n *\n */\nexport function isProfiledTransactionEvent(event: Event): event is ProfiledEvent {\n  return !!event.sdkProcessingMetadata?.profile;\n}\n\n/*\n  See packages/browser-utils/src/browser/router.ts\n*/\n/**\n *\n */\nexport function isAutomatedPageLoadSpan(span: Span): boolean {\n  return spanToJSON(span).op === 'pageload';\n}\n\n/**\n * Converts a JSSelfProfile to a our sampled format.\n * Does not currently perform stack indexing.\n */\nexport function convertJSSelfProfileToSampledFormat(input: JSSelfProfile): Profile['profile'] {\n  let EMPTY_STACK_ID: undefined | number = undefined;\n  let STACK_ID = 0;\n\n  // Initialize the profile that we will fill with data\n  const profile: Profile['profile'] = {\n    samples: [],\n    stacks: [],\n    frames: [],\n    thread_metadata: {\n      [THREAD_ID_STRING]: { name: THREAD_NAME },\n    },\n  };\n\n  const firstSample = input.samples[0];\n  if (!firstSample) {\n    return profile;\n  }\n\n  // We assert samples.length > 0 above and timestamp should always be present\n  const start = firstSample.timestamp;\n  // The JS SDK might change it's time origin based on some heuristic (see See packages/utils/src/time.ts)\n  // when that happens, we need to ensure we are correcting the profile timings so the two timelines stay in sync.\n  // Since JS self profiling time origin is always initialized to performance.timeOrigin, we need to adjust for\n  // the drift between the SDK selected value and our profile time origin.\n  const perfOrigin = browserPerformanceTimeOrigin();\n  const origin = typeof performance.timeOrigin === 'number' ? performance.timeOrigin : perfOrigin || 0;\n  const adjustForOriginChange = origin - (perfOrigin || origin);\n\n  input.samples.forEach((jsSample, i) => {\n    // If sample has no stack, add an empty sample\n    if (jsSample.stackId === undefined) {\n      if (EMPTY_STACK_ID === undefined) {\n        EMPTY_STACK_ID = STACK_ID;\n        profile.stacks[EMPTY_STACK_ID] = [];\n        STACK_ID++;\n      }\n\n      profile['samples'][i] = {\n        // convert ms timestamp to ns\n        elapsed_since_start_ns: ((jsSample.timestamp + adjustForOriginChange - start) * MS_TO_NS).toFixed(0),\n        stack_id: EMPTY_STACK_ID,\n        thread_id: THREAD_ID_STRING,\n      };\n      return;\n    }\n\n    let stackTop: JSSelfProfileStack | undefined = input.stacks[jsSample.stackId];\n\n    // Functions in top->down order (root is last)\n    // We follow the stackTop.parentId trail and collect each visited frameId\n    const stack: number[] = [];\n\n    while (stackTop) {\n      stack.push(stackTop.frameId);\n\n      const frame = input.frames[stackTop.frameId];\n\n      // If our frame has not been indexed yet, index it\n      if (frame && profile.frames[stackTop.frameId] === undefined) {\n        profile.frames[stackTop.frameId] = {\n          function: frame.name,\n          abs_path: typeof frame.resourceId === 'number' ? input.resources[frame.resourceId] : undefined,\n          lineno: frame.line,\n          colno: frame.column,\n        };\n      }\n\n      stackTop = stackTop.parentId === undefined ? undefined : input.stacks[stackTop.parentId];\n    }\n\n    const sample: Profile['profile']['samples'][0] = {\n      // convert ms timestamp to ns\n      elapsed_since_start_ns: ((jsSample.timestamp + adjustForOriginChange - start) * MS_TO_NS).toFixed(0),\n      stack_id: STACK_ID,\n      thread_id: THREAD_ID_STRING,\n    };\n\n    profile['stacks'][STACK_ID] = stack;\n    profile['samples'][i] = sample;\n    STACK_ID++;\n  });\n\n  return profile;\n}\n\n/**\n * Adds items to envelope if they are not already present - mutates the envelope.\n * @param envelope\n */\nexport function addProfilesToEnvelope(envelope: EventEnvelope, profiles: Profile[]): Envelope {\n  if (!profiles.length) {\n    return envelope;\n  }\n\n  for (const profile of profiles) {\n    envelope[1].push([{ type: 'profile' }, profile]);\n  }\n  return envelope;\n}\n\n/**\n * Finds transactions with profile_id context in the envelope\n * @param envelope\n * @returns\n */\nexport function findProfiledTransactionsFromEnvelope(envelope: Envelope): Event[] {\n  const events: Event[] = [];\n\n  forEachEnvelopeItem(envelope, (item, type) => {\n    if (type !== 'transaction') {\n      return;\n    }\n\n    for (let j = 1; j < item.length; j++) {\n      const event = item[j] as Event;\n\n      if (event?.contexts?.profile?.profile_id) {\n        events.push(item[j] as Event);\n      }\n    }\n  });\n\n  return events;\n}\n\n/**\n * Applies debug meta data to an event from a list of paths to resources (sourcemaps)\n */\nexport function applyDebugMetadata(resource_paths: ReadonlyArray<string>): DebugImage[] {\n  const client = getClient();\n  const options = client?.getOptions();\n  const stackParser = options?.stackParser;\n\n  if (!stackParser) {\n    return [];\n  }\n\n  return getDebugImagesForResources(stackParser, resource_paths);\n}\n\n/**\n * Checks the given sample rate to make sure it is valid type and value (a boolean, or a number between 0 and 1).\n */\nexport function isValidSampleRate(rate: unknown): boolean {\n  // we need to check NaN explicitly because it's of type 'number' and therefore wouldn't get caught by this typecheck\n  if ((typeof rate !== 'number' && typeof rate !== 'boolean') || (typeof rate === 'number' && isNaN(rate))) {\n    DEBUG_BUILD &&\n      debug.warn(\n        `[Profiling] Invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(\n          rate,\n        )} of type ${JSON.stringify(typeof rate)}.`,\n      );\n    return false;\n  }\n\n  // Boolean sample rates are always valid\n  if (rate === true || rate === false) {\n    return true;\n  }\n\n  // in case sampleRate is a boolean, it will get automatically cast to 1 if it's true and 0 if it's false\n  if (rate < 0 || rate > 1) {\n    DEBUG_BUILD && debug.warn(`[Profiling] Invalid sample rate. Sample rate must be between 0 and 1. Got ${rate}.`);\n    return false;\n  }\n  return true;\n}\n\nfunction isValidProfile(profile: JSSelfProfile): profile is JSSelfProfile & { profile_id: string } {\n  if (profile.samples.length < 2) {\n    if (DEBUG_BUILD) {\n      // Log a warning if the profile has less than 2 samples so users can know why\n      // they are not seeing any profiling data and we cant avoid the back and forth\n      // of asking them to provide us with a dump of the profile data.\n      debug.log('[Profiling] Discarding profile because it contains less than 2 samples');\n    }\n    return false;\n  }\n\n  if (!profile.frames.length) {\n    if (DEBUG_BUILD) {\n      debug.log('[Profiling] Discarding profile because it contains no frames');\n    }\n    return false;\n  }\n\n  return true;\n}\n\n// Keep a flag value to avoid re-initializing the profiler constructor. If it fails\n// once, it will always fail and this allows us to early return.\nlet PROFILING_CONSTRUCTOR_FAILED: boolean = false;\nexport const MAX_PROFILE_DURATION_MS = 30_000;\n\n/**\n * Check if profiler constructor is available.\n * @param maybeProfiler\n */\nfunction isJSProfilerSupported(maybeProfiler: unknown): maybeProfiler is typeof JSSelfProfilerConstructor {\n  return typeof maybeProfiler === 'function';\n}\n\n/**\n * Starts the profiler and returns the profiler instance.\n */\nexport function startJSSelfProfile(): JSSelfProfiler | undefined {\n  // Feature support check first\n  const JSProfilerConstructor = WINDOW.Profiler;\n\n  if (!isJSProfilerSupported(JSProfilerConstructor)) {\n    if (DEBUG_BUILD) {\n      debug.log('[Profiling] Profiling is not supported by this browser, Profiler interface missing on window object.');\n    }\n    return;\n  }\n\n  // From initial testing, it seems that the minimum value for sampleInterval is 10ms.\n  const samplingIntervalMS = 10;\n  // Start the profiler\n  const maxSamples = Math.floor(MAX_PROFILE_DURATION_MS / samplingIntervalMS);\n\n  // Attempt to initialize the profiler constructor, if it fails, we disable profiling for the current user session.\n  // This is likely due to a missing 'Document-Policy': 'js-profiling' header. We do not want to throw an error if this happens\n  // as we risk breaking the user's application, so just disable profiling and log an error.\n  try {\n    return new JSProfilerConstructor({ sampleInterval: samplingIntervalMS, maxBufferSize: maxSamples });\n  } catch (e) {\n    if (DEBUG_BUILD) {\n      debug.log(\n        \"[Profiling] Failed to initialize the Profiling constructor, this is likely due to a missing 'Document-Policy': 'js-profiling' header.\",\n      );\n      debug.log('[Profiling] Disabling profiling for current user session.');\n    }\n    PROFILING_CONSTRUCTOR_FAILED = true;\n  }\n\n  return;\n}\n\n/**\n * Determine if a profile should be profiled.\n */\nexport function shouldProfileSpan(span: Span): boolean {\n  // If constructor failed once, it will always fail, so we can early return.\n  if (PROFILING_CONSTRUCTOR_FAILED) {\n    if (DEBUG_BUILD) {\n      debug.log('[Profiling] Profiling has been disabled for the duration of the current user session.');\n    }\n    return false;\n  }\n\n  if (!span.isRecording()) {\n    if (DEBUG_BUILD) {\n      debug.log('[Profiling] Discarding profile because transaction was not sampled.');\n    }\n    return false;\n  }\n\n  const client = getClient();\n  const options = client?.getOptions();\n  if (!options) {\n    DEBUG_BUILD && debug.log('[Profiling] Profiling disabled, no options found.');\n    return false;\n  }\n\n  // @ts-expect-error profilesSampleRate is not part of the browser options yet\n  const profilesSampleRate: number | boolean | undefined = options.profilesSampleRate;\n\n  // Since this is coming from the user (or from a function provided by the user), who knows what we might get. (The\n  // only valid values are booleans or numbers between 0 and 1.)\n  if (!isValidSampleRate(profilesSampleRate)) {\n    DEBUG_BUILD && debug.warn('[Profiling] Discarding profile because of invalid sample rate.');\n    return false;\n  }\n\n  // if the function returned 0 (or false), or if `profileSampleRate` is 0, it's a sign the profile should be dropped\n  if (!profilesSampleRate) {\n    DEBUG_BUILD &&\n      debug.log(\n        '[Profiling] Discarding profile because a negative sampling decision was inherited or profileSampleRate is set to 0',\n      );\n    return false;\n  }\n\n  // Now we roll the dice. Math.random is inclusive of 0, but not of 1, so strict < is safe here. In case sampleRate is\n  // a boolean, the < comparison will cause it to be automatically cast to 1 if it's true and 0 if it's false.\n  const sampled = profilesSampleRate === true ? true : Math.random() < profilesSampleRate;\n  // Check if we should sample this profile\n  if (!sampled) {\n    DEBUG_BUILD &&\n      debug.log(\n        `[Profiling] Discarding profile because it's not included in the random sample (sampling rate = ${Number(\n          profilesSampleRate,\n        )})`,\n      );\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Creates a profiling envelope item, if the profile does not pass validation, returns null.\n * @param event\n * @returns {Profile | null}\n */\nexport function createProfilingEvent(\n  profile_id: string,\n  start_timestamp: number | undefined,\n  profile: JSSelfProfile,\n  event: ProfiledEvent,\n): Profile | null {\n  if (!isValidProfile(profile)) {\n    return null;\n  }\n\n  return createProfilePayload(profile_id, start_timestamp, profile, event);\n}\n\n// TODO (v8): We need to obtain profile ids in @sentry-internal/tracing,\n// but we don't have access to this map because importing this map would\n// cause a circular dependency. We need to resolve this in v8.\nconst PROFILE_MAP: Map<string, JSSelfProfile> = new Map();\n/**\n *\n */\nexport function getActiveProfilesCount(): number {\n  return PROFILE_MAP.size;\n}\n\n/**\n * Retrieves profile from global cache and removes it.\n */\nexport function takeProfileFromGlobalCache(profile_id: string): JSSelfProfile | undefined {\n  const profile = PROFILE_MAP.get(profile_id);\n  if (profile) {\n    PROFILE_MAP.delete(profile_id);\n  }\n  return profile;\n}\n/**\n * Adds profile to global cache and evicts the oldest profile if the cache is full.\n */\nexport function addProfileToGlobalCache(profile_id: string, profile: JSSelfProfile): void {\n  PROFILE_MAP.set(profile_id, profile);\n\n  if (PROFILE_MAP.size > 30) {\n    const last: string = PROFILE_MAP.keys().next().value;\n    PROFILE_MAP.delete(last);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}