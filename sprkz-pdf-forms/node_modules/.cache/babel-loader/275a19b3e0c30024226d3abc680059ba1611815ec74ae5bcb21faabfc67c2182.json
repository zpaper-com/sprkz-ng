{"ast":null,"code":"import { SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '../semanticAttributes.js';\nimport { spanToJSON } from './spanUtils.js';\nimport { AI_TOOL_CALL_NAME_ATTRIBUTE, AI_TOOL_CALL_ID_ATTRIBUTE, AI_MODEL_ID_ATTRIBUTE, AI_MODEL_PROVIDER_ATTRIBUTE, AI_TELEMETRY_FUNCTION_ID_ATTRIBUTE, AI_PROMPT_ATTRIBUTE, GEN_AI_RESPONSE_MODEL_ATTRIBUTE, GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE, GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE, AI_RESPONSE_PROVIDER_METADATA_ATTRIBUTE, AI_USAGE_COMPLETION_TOKENS_ATTRIBUTE, AI_USAGE_PROMPT_TOKENS_ATTRIBUTE, AI_PROMPT_MESSAGES_ATTRIBUTE, AI_RESPONSE_TEXT_ATTRIBUTE, AI_RESPONSE_TOOL_CALLS_ATTRIBUTE, AI_PROMPT_TOOLS_ATTRIBUTE, AI_TOOL_CALL_ARGS_ATTRIBUTE, AI_TOOL_CALL_RESULT_ATTRIBUTE } from './vercel-ai-attributes.js';\nfunction addOriginToSpan(span, origin) {\n  span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, origin);\n}\n\n/**\n * Post-process spans emitted by the Vercel AI SDK.\n * This is supposed to be used in `client.on('spanStart', ...)\n */\nfunction onVercelAiSpanStart(span) {\n  const {\n    data: attributes,\n    description: name\n  } = spanToJSON(span);\n  if (!name) {\n    return;\n  }\n\n  // Tool call spans\n  // https://ai-sdk.dev/docs/ai-sdk-core/telemetry#tool-call-spans\n  if (attributes[AI_TOOL_CALL_NAME_ATTRIBUTE] && attributes[AI_TOOL_CALL_ID_ATTRIBUTE] && name === 'ai.toolCall') {\n    processToolCallSpan(span, attributes);\n    return;\n  }\n\n  // The AI and Provider must be defined for generate, stream, and embed spans.\n  // The id of the model\n  const aiModelId = attributes[AI_MODEL_ID_ATTRIBUTE];\n  // the provider of the model\n  const aiModelProvider = attributes[AI_MODEL_PROVIDER_ATTRIBUTE];\n  if (typeof aiModelId !== 'string' || typeof aiModelProvider !== 'string' || !aiModelId || !aiModelProvider) {\n    return;\n  }\n  processGenerateSpan(span, name, attributes);\n}\nfunction vercelAiEventProcessor(event) {\n  if (event.type === 'transaction' && event.spans) {\n    for (const span of event.spans) {\n      // this mutates spans in-place\n      processEndedVercelAiSpan(span);\n    }\n  }\n  return event;\n}\n/**\n * Post-process spans emitted by the Vercel AI SDK.\n */\nfunction processEndedVercelAiSpan(span) {\n  const {\n    data: attributes,\n    origin\n  } = span;\n  if (origin !== 'auto.vercelai.otel') {\n    return;\n  }\n  renameAttributeKey(attributes, AI_USAGE_COMPLETION_TOKENS_ATTRIBUTE, GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE);\n  renameAttributeKey(attributes, AI_USAGE_PROMPT_TOKENS_ATTRIBUTE, GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE);\n  if (typeof attributes[GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE] === 'number' && typeof attributes[GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE] === 'number') {\n    attributes['gen_ai.usage.total_tokens'] = attributes[GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE] + attributes[GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE];\n  }\n\n  // Rename AI SDK attributes to standardized gen_ai attributes\n  renameAttributeKey(attributes, AI_PROMPT_MESSAGES_ATTRIBUTE, 'gen_ai.request.messages');\n  renameAttributeKey(attributes, AI_RESPONSE_TEXT_ATTRIBUTE, 'gen_ai.response.text');\n  renameAttributeKey(attributes, AI_RESPONSE_TOOL_CALLS_ATTRIBUTE, 'gen_ai.response.tool_calls');\n  renameAttributeKey(attributes, AI_PROMPT_TOOLS_ATTRIBUTE, 'gen_ai.request.available_tools');\n  renameAttributeKey(attributes, AI_TOOL_CALL_ARGS_ATTRIBUTE, 'gen_ai.tool.input');\n  renameAttributeKey(attributes, AI_TOOL_CALL_RESULT_ATTRIBUTE, 'gen_ai.tool.output');\n  addProviderMetadataToAttributes(attributes);\n\n  // Change attributes namespaced with `ai.X` to `vercel.ai.X`\n  for (const key of Object.keys(attributes)) {\n    if (key.startsWith('ai.')) {\n      renameAttributeKey(attributes, key, `vercel.${key}`);\n    }\n  }\n}\n\n/**\n * Renames an attribute key in the provided attributes object if the old key exists.\n * This function safely handles null and undefined values.\n */\nfunction renameAttributeKey(attributes, oldKey, newKey) {\n  if (attributes[oldKey] != null) {\n    attributes[newKey] = attributes[oldKey];\n    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n    delete attributes[oldKey];\n  }\n}\nfunction processToolCallSpan(span, attributes) {\n  addOriginToSpan(span, 'auto.vercelai.otel');\n  span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.execute_tool');\n  renameAttributeKey(attributes, AI_TOOL_CALL_NAME_ATTRIBUTE, 'gen_ai.tool.name');\n  renameAttributeKey(attributes, AI_TOOL_CALL_ID_ATTRIBUTE, 'gen_ai.tool.call.id');\n  // https://opentelemetry.io/docs/specs/semconv/registry/attributes/gen-ai/#gen-ai-tool-type\n  if (!attributes['gen_ai.tool.type']) {\n    span.setAttribute('gen_ai.tool.type', 'function');\n  }\n  const toolName = attributes['gen_ai.tool.name'];\n  if (toolName) {\n    span.updateName(`execute_tool ${toolName}`);\n  }\n}\nfunction processGenerateSpan(span, name, attributes) {\n  addOriginToSpan(span, 'auto.vercelai.otel');\n  const nameWthoutAi = name.replace('ai.', '');\n  span.setAttribute('ai.pipeline.name', nameWthoutAi);\n  span.updateName(nameWthoutAi);\n\n  // If a Telemetry name is set and it is a pipeline span, use that as the operation name\n  const functionId = attributes[AI_TELEMETRY_FUNCTION_ID_ATTRIBUTE];\n  if (functionId && typeof functionId === 'string' && name.split('.').length - 1 === 1) {\n    span.updateName(`${nameWthoutAi} ${functionId}`);\n    span.setAttribute('gen_ai.function_id', functionId);\n  }\n  if (attributes[AI_PROMPT_ATTRIBUTE]) {\n    span.setAttribute('gen_ai.prompt', attributes[AI_PROMPT_ATTRIBUTE]);\n  }\n  if (attributes[AI_MODEL_ID_ATTRIBUTE] && !attributes[GEN_AI_RESPONSE_MODEL_ATTRIBUTE]) {\n    span.setAttribute(GEN_AI_RESPONSE_MODEL_ATTRIBUTE, attributes[AI_MODEL_ID_ATTRIBUTE]);\n  }\n  span.setAttribute('ai.streaming', name.includes('stream'));\n\n  // Generate Spans\n  if (name === 'ai.generateText') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');\n    return;\n  }\n  if (name === 'ai.generateText.doGenerate') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.generate_text');\n    span.updateName(`generate_text ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);\n    return;\n  }\n  if (name === 'ai.streamText') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');\n    return;\n  }\n  if (name === 'ai.streamText.doStream') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.stream_text');\n    span.updateName(`stream_text ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);\n    return;\n  }\n  if (name === 'ai.generateObject') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');\n    return;\n  }\n  if (name === 'ai.generateObject.doGenerate') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.generate_object');\n    span.updateName(`generate_object ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);\n    return;\n  }\n  if (name === 'ai.streamObject') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');\n    return;\n  }\n  if (name === 'ai.streamObject.doStream') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.stream_object');\n    span.updateName(`stream_object ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);\n    return;\n  }\n  if (name === 'ai.embed') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');\n    return;\n  }\n  if (name === 'ai.embed.doEmbed') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.embed');\n    span.updateName(`embed ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);\n    return;\n  }\n  if (name === 'ai.embedMany') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');\n    return;\n  }\n  if (name === 'ai.embedMany.doEmbed') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.embed_many');\n    span.updateName(`embed_many ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);\n    return;\n  }\n  if (name.startsWith('ai.stream')) {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'ai.run');\n    return;\n  }\n}\n\n/**\n * Add event processors to the given client to process Vercel AI spans.\n */\nfunction addVercelAiProcessors(client) {\n  client.on('spanStart', onVercelAiSpanStart);\n  // Note: We cannot do this on `spanEnd`, because the span cannot be mutated anymore at this point\n  client.addEventProcessor(Object.assign(vercelAiEventProcessor, {\n    id: 'VercelAiEventProcessor'\n  }));\n}\nfunction addProviderMetadataToAttributes(attributes) {\n  const providerMetadata = attributes[AI_RESPONSE_PROVIDER_METADATA_ATTRIBUTE];\n  if (providerMetadata) {\n    try {\n      const providerMetadataObject = JSON.parse(providerMetadata);\n      if (providerMetadataObject.openai) {\n        setAttributeIfDefined(attributes, 'gen_ai.usage.input_tokens.cached', providerMetadataObject.openai.cachedPromptTokens);\n        setAttributeIfDefined(attributes, 'gen_ai.usage.output_tokens.reasoning', providerMetadataObject.openai.reasoningTokens);\n        setAttributeIfDefined(attributes, 'gen_ai.usage.output_tokens.prediction_accepted', providerMetadataObject.openai.acceptedPredictionTokens);\n        setAttributeIfDefined(attributes, 'gen_ai.usage.output_tokens.prediction_rejected', providerMetadataObject.openai.rejectedPredictionTokens);\n        setAttributeIfDefined(attributes, 'gen_ai.conversation.id', providerMetadataObject.openai.responseId);\n      }\n      if (providerMetadataObject.anthropic) {\n        setAttributeIfDefined(attributes, 'gen_ai.usage.input_tokens.cached', providerMetadataObject.anthropic.cacheReadInputTokens);\n        setAttributeIfDefined(attributes, 'gen_ai.usage.input_tokens.cache_write', providerMetadataObject.anthropic.cacheCreationInputTokens);\n      }\n      if (providerMetadataObject.bedrock?.usage) {\n        setAttributeIfDefined(attributes, 'gen_ai.usage.input_tokens.cached', providerMetadataObject.bedrock.usage.cacheReadInputTokens);\n        setAttributeIfDefined(attributes, 'gen_ai.usage.input_tokens.cache_write', providerMetadataObject.bedrock.usage.cacheWriteInputTokens);\n      }\n      if (providerMetadataObject.deepseek) {\n        setAttributeIfDefined(attributes, 'gen_ai.usage.input_tokens.cached', providerMetadataObject.deepseek.promptCacheHitTokens);\n        setAttributeIfDefined(attributes, 'gen_ai.usage.input_tokens.cache_miss', providerMetadataObject.deepseek.promptCacheMissTokens);\n      }\n    } catch {\n      // Ignore\n    }\n  }\n}\n\n/**\n * Sets an attribute only if the value is not null or undefined.\n */\nfunction setAttributeIfDefined(attributes, key, value) {\n  if (value != null) {\n    attributes[key] = value;\n  }\n}\nexport { addVercelAiProcessors };\n//# sourceMappingURL=vercel-ai.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}