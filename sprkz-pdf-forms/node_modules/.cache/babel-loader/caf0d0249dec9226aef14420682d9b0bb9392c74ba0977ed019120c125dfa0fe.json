{"ast":null,"code":"import React,{createContext,useContext,useReducer,useCallback,useEffect}from'react';import{FormFieldService}from'../services/formFieldService';import{ValidationService}from'../services/validationService';// Form Actions\n// Form State Context\nimport{jsx as _jsx}from\"react/jsx-runtime\";const FormContext=/*#__PURE__*/createContext(undefined);// Initial state\nconst initialState={fields:new Map(),currentFieldIndex:-1,completedFields:[],requiredFields:[],totalRequiredFields:0,completionPercentage:0,isValid:false,validationResults:new Map()};// Form reducer\nfunction formReducer(state,action){switch(action.type){case'INITIALIZE_FIELDS':{const fields=action.payload;const fieldMap=new Map();const requiredFields=[];fields.forEach(field=>{fieldMap.set(field.name,{fieldName:field.name,value:field.value,page:field.page,isValid:!field.required||field.isComplete,errors:field.validationErrors});if(field.required&&!field.readOnly){requiredFields.push(field.name);}});return{...state,fields:fieldMap,requiredFields,totalRequiredFields:requiredFields.length,completedFields:fields.filter(f=>f.isComplete).map(f=>f.name),completionPercentage:FormFieldService.calculateCompletionPercentage(fields),currentFieldIndex:0};}case'UPDATE_FIELD_VALUE':{const{fieldName,value,page}=action.payload;const newFields=new Map(state.fields);const existingField=newFields.get(fieldName);if(existingField){const updatedField={...existingField,value,page,isValid:true,// Will be validated separately\nerrors:[]};newFields.set(fieldName,updatedField);}return{...state,fields:newFields};}case'SET_CURRENT_FIELD':{return{...state,currentFieldIndex:action.payload};}case'MARK_FIELD_COMPLETE':{const fieldName=action.payload;const completedFields=[...state.completedFields];if(!completedFields.includes(fieldName)){completedFields.push(fieldName);}return{...state,completedFields,completionPercentage:Math.round(completedFields.length/Math.max(state.totalRequiredFields,1)*100)};}case'SET_FIELD_ERRORS':{const{fieldName,errors}=action.payload;const newFields=new Map(state.fields);const field=newFields.get(fieldName);if(field){newFields.set(fieldName,{...field,errors,isValid:errors.length===0});}return{...state,fields:newFields};}case'SET_FIELD_VALIDATION':{const{fieldName,validation}=action.payload;const newValidationResults=new Map(state.validationResults);const newFields=new Map(state.fields);const field=newFields.get(fieldName);newValidationResults.set(fieldName,validation);if(field){newFields.set(fieldName,{...field,errors:validation.errors,isValid:validation.isValid});}return{...state,fields:newFields,validationResults:newValidationResults};}case'CALCULATE_PROGRESS':{const completedRequiredFields=state.completedFields.filter(fieldName=>state.requiredFields.includes(fieldName));return{...state,completionPercentage:Math.round(completedRequiredFields.length/Math.max(state.totalRequiredFields,1)*100)};}case'RESET_FORM':{return{...initialState,fields:new Map(Array.from(state.fields.entries()).map(_ref=>{let[key,field]=_ref;return[key,{...field,value:field.fieldName.includes('checkbox')?false:'',isValid:!state.requiredFields.includes(field.fieldName),errors:[]}];})),requiredFields:state.requiredFields,totalRequiredFields:state.totalRequiredFields};}default:return state;}}// Form Provider\nexport const FormProvider=_ref2=>{let{children}=_ref2;const[state,dispatch]=useReducer(formReducer,initialState);// Initialize fields\nconst initializeFields=useCallback(fields=>{dispatch({type:'INITIALIZE_FIELDS',payload:fields});},[]);// Update field value\nconst updateFieldValue=useCallback((fieldName,value,page)=>{dispatch({type:'UPDATE_FIELD_VALUE',payload:{fieldName,value,page}});// Auto-validate the field after a short delay\nsetTimeout(async()=>{await validateField(fieldName);},100);},[]);// Set current field\nconst setCurrentField=useCallback(index=>{dispatch({type:'SET_CURRENT_FIELD',payload:index});},[]);// Mark field as complete\nconst markFieldComplete=useCallback(fieldName=>{dispatch({type:'MARK_FIELD_COMPLETE',payload:fieldName});dispatch({type:'CALCULATE_PROGRESS'});},[]);// Validate field using ValidationService\nconst validateField=useCallback(async fieldName=>{const fieldValue=state.fields.get(fieldName);if(!fieldValue){const emptyResult={isValid:false,errors:['Field not found'],warnings:[],fieldName,validatedAt:Date.now()};return emptyResult;}// Create a temporary FormField for validation\nconst tempField={name:fieldName,type:'text',// Default type, should be enhanced based on field analysis\nvalue:fieldValue.value,required:state.requiredFields.includes(fieldName),readOnly:false,page:fieldValue.page,rect:[0,0,0,0],isComplete:state.completedFields.includes(fieldName),validationErrors:[],id:fieldName,subtype:''};// Get all fields for dependency validation\nconst allFields=Array.from(state.fields.entries()).map(_ref3=>{let[name,value]=_ref3;return{name,type:'text',value:value.value,required:state.requiredFields.includes(name),readOnly:false,page:value.page,rect:[0,0,0,0],isComplete:state.completedFields.includes(name),validationErrors:value.errors,id:name,subtype:''};});try{const validationResult=await ValidationService.validateField(tempField,fieldValue.value,allFields,{validateRequired:true,validateFormat:true,validateDependencies:true,excludeReadOnly:true});// Update state with validation result\ndispatch({type:'SET_FIELD_VALIDATION',payload:{fieldName,validation:validationResult}});// Mark field as complete if valid\nif(validationResult.isValid&&!state.completedFields.includes(fieldName)){markFieldComplete(fieldName);}return validationResult;}catch(error){console.error(`Validation failed for field \"${fieldName}\":`,error);const errorResult={isValid:false,errors:['Validation error occurred'],warnings:[],fieldName,validatedAt:Date.now()};dispatch({type:'SET_FIELD_VALIDATION',payload:{fieldName,validation:errorResult}});return errorResult;}},[state.fields,state.requiredFields,state.completedFields,markFieldComplete]);// Validate all fields\nconst validateAllFields=useCallback(async()=>{const allFields=Array.from(state.fields.entries()).map(_ref4=>{let[name,value]=_ref4;return{name,type:'text',value:value.value,required:state.requiredFields.includes(name),readOnly:false,page:value.page,rect:[0,0,0,0],isComplete:state.completedFields.includes(name),validationErrors:value.errors,id:name,subtype:''};});const fieldValues={};state.fields.forEach((value,name)=>{fieldValues[name]=value.value;});try{const validationResults=await ValidationService.validateFields(allFields,fieldValues,{validateRequired:true,validateFormat:true,validateDependencies:true,excludeReadOnly:true});// Update all validation results in state\nObject.entries(validationResults).forEach(_ref5=>{let[fieldName,result]=_ref5;dispatch({type:'SET_FIELD_VALIDATION',payload:{fieldName,validation:result}});});return validationResults;}catch(error){console.error('Bulk validation failed:',error);return{};}},[state.fields,state.requiredFields,state.completedFields]);// Get next incomplete field\nconst getNextIncompleteField=useCallback(()=>{const incompleteFields=Array.from(state.fields.entries()).filter(_ref6=>{let[fieldName]=_ref6;return!state.completedFields.includes(fieldName)&&state.requiredFields.includes(fieldName);});if(incompleteFields.length===0)return null;return{name:incompleteFields[0][0],type:'text',value:incompleteFields[0][1].value,required:true,readOnly:false,page:incompleteFields[0][1].page,rect:[0,0,0,0],isComplete:false,validationErrors:incompleteFields[0][1].errors,id:incompleteFields[0][0],subtype:''};},[state.fields,state.completedFields,state.requiredFields]);// Get current field\nconst getCurrentField=useCallback(()=>{const fieldsArray=Array.from(state.fields.keys());if(state.currentFieldIndex<0||state.currentFieldIndex>=fieldsArray.length){return null;}const fieldName=fieldsArray[state.currentFieldIndex];const fieldValue=state.fields.get(fieldName);if(!fieldValue)return null;return{name:fieldName,type:'text',value:fieldValue.value,required:state.requiredFields.includes(fieldName),readOnly:false,page:fieldValue.page,rect:[0,0,0,0],isComplete:state.completedFields.includes(fieldName),validationErrors:fieldValue.errors,id:fieldName,subtype:''};},[state.fields,state.currentFieldIndex,state.requiredFields,state.completedFields]);// Get field by name\nconst getFieldByName=useCallback(fieldName=>{const fieldValue=state.fields.get(fieldName);if(!fieldValue)return null;return{name:fieldName,type:'text',value:fieldValue.value,required:state.requiredFields.includes(fieldName),readOnly:false,page:fieldValue.page,rect:[0,0,0,0],isComplete:state.completedFields.includes(fieldName),validationErrors:fieldValue.errors,id:fieldName,subtype:''};},[state.fields,state.requiredFields,state.completedFields]);// Get completion percentage\nconst getCompletionPercentage=useCallback(()=>{return state.completionPercentage;},[state.completionPercentage]);// Get required fields status\nconst getRequiredFieldsStatus=useCallback(()=>{const completedRequired=state.completedFields.filter(fieldName=>state.requiredFields.includes(fieldName));return{completed:completedRequired.length,total:state.totalRequiredFields};},[state.completedFields,state.requiredFields,state.totalRequiredFields]);// Check if form is valid\nconst isFormValid=useCallback(()=>{const allRequiredCompleted=state.requiredFields.every(fieldName=>state.completedFields.includes(fieldName));const noErrors=Array.from(state.fields.values()).every(field=>field.errors.length===0);return allRequiredCompleted&&noErrors;},[state.requiredFields,state.completedFields,state.fields]);// Get all form errors\nconst getFormErrors=useCallback(()=>{const errors={};state.fields.forEach((field,fieldName)=>{if(field.errors.length>0){errors[fieldName]=field.errors;}});return errors;},[state.fields]);// Get field validation result\nconst getFieldValidation=useCallback(fieldName=>{return state.validationResults.get(fieldName)||null;},[state.validationResults]);// Reset form\nconst resetForm=useCallback(()=>{dispatch({type:'RESET_FORM'});ValidationService.clearValidationCache();console.log('Form has been reset to initial state');},[]);// Reset form after successful submission\nconst resetAfterSubmission=useCallback(()=>{resetForm();// Additional cleanup for post-submission reset\nsetTimeout(()=>{// Clear any temporary data\nsessionStorage.removeItem('sprkz-form-draft');console.log('Post-submission cleanup completed');},100);},[resetForm]);// Update isValid when state changes\nuseEffect(()=>{const formValid=isFormValid();if(state.isValid!==formValid){// Update state.isValid if needed (would require additional action)\n}},[state.fields,state.completedFields,state.requiredFields,isFormValid,state.isValid]);const contextValue={state,updateFieldValue,setCurrentField,markFieldComplete,validateField,validateAllFields,getNextIncompleteField,getCurrentField,getFieldByName,getCompletionPercentage,getRequiredFieldsStatus,isFormValid,getFormErrors,getFieldValidation,resetForm,resetAfterSubmission,initializeFields};return/*#__PURE__*/_jsx(FormContext.Provider,{value:contextValue,children:children});};// Hook to use form context\nexport const useForm=()=>{const context=useContext(FormContext);if(context===undefined){throw new Error('useForm must be used within a FormProvider');}return context;};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}