{"ast":null,"code":"import { useState, useEffect, useCallback, useContext } from 'react';\nimport { unleashService } from '../services/unleashService';\nimport { FeatureFlagsContext } from '../contexts/FeatureFlagsContext';\n\n// Hook for accessing feature flags\nexport const useFeatureFlags = () => {\n  const context = useContext(FeatureFlagsContext);\n  if (!context) {\n    throw new Error('useFeatureFlags must be used within a FeatureFlagsProvider');\n  }\n  return context;\n};\n\n// Hook for checking a single feature flag\nexport const useFeatureFlag = (flagName, context) => {\n  const [isEnabled, setIsEnabled] = useState(() => unleashService.isEnabled(flagName, context));\n  const [variant, setVariant] = useState(() => unleashService.getVariant(flagName, context));\n  useEffect(() => {\n    // Update when flags change\n    const updateFlag = () => {\n      setIsEnabled(unleashService.isEnabled(flagName, context));\n      setVariant(unleashService.getVariant(flagName, context));\n    };\n\n    // Subscribe to changes\n    const unsubscribe = unleashService.subscribe(updateFlag);\n\n    // Initial update\n    updateFlag();\n    return unsubscribe;\n  }, [flagName, context]);\n  return {\n    isEnabled,\n    variant\n  };\n};\n\n// Hook for checking multiple feature flags\nexport const useFeatureFlags_Multiple = (flagNames, context) => {\n  const [flags, setFlags] = useState(() => {\n    const initialFlags = {};\n    flagNames.forEach(flagName => {\n      initialFlags[flagName] = unleashService.isEnabled(flagName, context);\n    });\n    return initialFlags;\n  });\n  useEffect(() => {\n    const updateFlags = () => {\n      const updatedFlags = {};\n      flagNames.forEach(flagName => {\n        updatedFlags[flagName] = unleashService.isEnabled(flagName, context);\n      });\n      setFlags(updatedFlags);\n    };\n\n    // Subscribe to changes\n    const unsubscribe = unleashService.subscribe(updateFlags);\n\n    // Initial update\n    updateFlags();\n    return unsubscribe;\n  }, [flagNames, context]);\n  return flags;\n};\n\n// Hook for conditional feature rendering\nexport const useConditionalFeature = (flagName, context) => {\n  const {\n    isEnabled\n  } = useFeatureFlag(flagName, context);\n  const ConditionalComponent = useCallback(({\n    children,\n    fallback = null\n  }) => {\n    if (isEnabled) {\n      return React.createElement(React.Fragment, null, children);\n    }\n    return React.createElement(React.Fragment, null, fallback);\n  }, [isEnabled]);\n  return {\n    isEnabled,\n    ConditionalComponent\n  };\n};\n\n// Hook for feature flag variants with type safety\nexport const useFeatureVariant = (flagName, defaultValue, context) => {\n  const [variant, setVariant] = useState(() => {\n    var _flagVariant$payload$, _flagVariant$payload;\n    const flagVariant = unleashService.getVariant(flagName, context);\n    return (_flagVariant$payload$ = flagVariant === null || flagVariant === void 0 ? void 0 : (_flagVariant$payload = flagVariant.payload) === null || _flagVariant$payload === void 0 ? void 0 : _flagVariant$payload.value) !== null && _flagVariant$payload$ !== void 0 ? _flagVariant$payload$ : defaultValue;\n  });\n  useEffect(() => {\n    const updateVariant = () => {\n      var _flagVariant$payload$2, _flagVariant$payload2;\n      const flagVariant = unleashService.getVariant(flagName, context);\n      setVariant((_flagVariant$payload$2 = flagVariant === null || flagVariant === void 0 ? void 0 : (_flagVariant$payload2 = flagVariant.payload) === null || _flagVariant$payload2 === void 0 ? void 0 : _flagVariant$payload2.value) !== null && _flagVariant$payload$2 !== void 0 ? _flagVariant$payload$2 : defaultValue);\n    };\n    const unsubscribe = unleashService.subscribe(updateVariant);\n    updateVariant();\n    return unsubscribe;\n  }, [flagName, defaultValue, context]);\n  return variant;\n};\n\n// Hook for feature flag experimentation\nexport const useExperiment = (experimentName, variants, context) => {\n  const [activeVariant, setActiveVariant] = useState(() => {\n    const variant = unleashService.getVariant(experimentName, context);\n    return variants[variant === null || variant === void 0 ? void 0 : variant.name] || variants.default || null;\n  });\n  useEffect(() => {\n    const updateExperiment = () => {\n      const variant = unleashService.getVariant(experimentName, context);\n      setActiveVariant(variants[variant === null || variant === void 0 ? void 0 : variant.name] || variants.default || null);\n    };\n    const unsubscribe = unleashService.subscribe(updateExperiment);\n    updateExperiment();\n    return unsubscribe;\n  }, [experimentName, variants, context]);\n  return activeVariant;\n};\n\n// Hook for gradual rollouts\nexport const useGradualRollout = (flagName, userId, context) => {\n  const rolloutContext = userId ? {\n    ...context,\n    userId\n  } : context;\n  const {\n    isEnabled\n  } = useFeatureFlag(flagName, rolloutContext);\n  return isEnabled;\n};\n\n// Hook for A/B testing\nexport const useABTest = (experimentFlag, variants, context) => {\n  const [activeVariant, setActiveVariant] = useState('A');\n  const [variantData, setVariantData] = useState(variants.A);\n  useEffect(() => {\n    const updateTest = () => {\n      const variant = unleashService.getVariant(experimentFlag, context);\n      const variantName = variant === null || variant === void 0 ? void 0 : variant.name;\n      if (variantName && variants[variantName]) {\n        setActiveVariant(variantName);\n        setVariantData(variants[variantName]);\n      } else {\n        // Default to A if variant not found\n        setActiveVariant('A');\n        setVariantData(variants.A);\n      }\n    };\n    const unsubscribe = unleashService.subscribe(updateTest);\n    updateTest();\n    return unsubscribe;\n  }, [experimentFlag, variants, context]);\n  return {\n    variant: activeVariant,\n    data: variantData\n  };\n};\n\n// Hook for debugging feature flags\nexport const useFeatureFlagsDebug = () => {\n  const [debugInfo, setDebugInfo] = useState(() => unleashService.getStatus());\n  const [allFlags, setAllFlags] = useState(() => unleashService.getAllFlags());\n  useEffect(() => {\n    const updateDebugInfo = () => {\n      setDebugInfo(unleashService.getStatus());\n      setAllFlags(unleashService.getAllFlags());\n    };\n    const unsubscribe = unleashService.subscribe(updateDebugInfo);\n    updateDebugInfo();\n    return unsubscribe;\n  }, []);\n  const refreshFlags = useCallback(() => {\n    setDebugInfo(unleashService.getStatus());\n    setAllFlags(unleashService.getAllFlags());\n  }, []);\n  return {\n    status: debugInfo,\n    flags: allFlags,\n    refresh: refreshFlags\n  };\n};\n\n// Utility hook for performance-sensitive feature checks\nexport const useOptimizedFeatureFlag = (flagName, context) => {\n  // Use a ref to avoid unnecessary re-renders\n  const [isEnabled, setIsEnabled] = useState(() => unleashService.isEnabled(flagName, context));\n  useEffect(() => {\n    let timeoutId;\n    const updateFlag = () => {\n      // Debounce updates to avoid excessive re-renders\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => {\n        const newValue = unleashService.isEnabled(flagName, context);\n        setIsEnabled(current => current !== newValue ? newValue : current);\n      }, 100);\n    };\n    const unsubscribe = unleashService.subscribe(updateFlag);\n    updateFlag();\n    return () => {\n      clearTimeout(timeoutId);\n      unsubscribe();\n    };\n  }, [flagName, context]);\n  return isEnabled;\n};\nexport default useFeatureFlags;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}