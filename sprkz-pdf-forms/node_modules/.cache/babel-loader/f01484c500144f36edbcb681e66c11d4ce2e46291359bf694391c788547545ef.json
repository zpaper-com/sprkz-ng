{"ast":null,"code":"import { getClient, showReportDialog, withScope } from '@sentry/browser';\nimport { debug } from '@sentry/core';\nimport * as React from 'react';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { captureReactException } from './error.js';\nimport { hoistNonReactStatics } from './hoist-non-react-statics.js';\nconst UNKNOWN_COMPONENT = 'unknown';\nconst INITIAL_STATE = {\n  componentStack: null,\n  error: null,\n  eventId: null\n};\n\n/**\n * A ErrorBoundary component that logs errors to Sentry.\n * NOTE: If you are a Sentry user, and you are seeing this stack frame, it means the\n * Sentry React SDK ErrorBoundary caught an error invoking your application code. This\n * is expected behavior and NOT indicative of a bug with the Sentry React SDK.\n */\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = INITIAL_STATE;\n    this._openFallbackReportDialog = true;\n    const client = getClient();\n    if (client && props.showDialog) {\n      this._openFallbackReportDialog = false;\n      this._cleanupHook = client.on('afterSendEvent', event => {\n        if (!event.type && this._lastEventId && event.event_id === this._lastEventId) {\n          showReportDialog({\n            ...props.dialogOptions,\n            eventId: this._lastEventId\n          });\n        }\n      });\n    }\n  }\n  componentDidCatch(error, errorInfo) {\n    const {\n      componentStack\n    } = errorInfo;\n    const {\n      beforeCapture,\n      onError,\n      showDialog,\n      dialogOptions\n    } = this.props;\n    withScope(scope => {\n      if (beforeCapture) {\n        beforeCapture(scope, error, componentStack);\n      }\n      const handled = this.props.handled != null ? this.props.handled : !!this.props.fallback;\n      const eventId = captureReactException(error, errorInfo, {\n        mechanism: {\n          handled\n        }\n      });\n      if (onError) {\n        onError(error, componentStack, eventId);\n      }\n      if (showDialog) {\n        this._lastEventId = eventId;\n        if (this._openFallbackReportDialog) {\n          showReportDialog({\n            ...dialogOptions,\n            eventId\n          });\n        }\n      }\n\n      // componentDidCatch is used over getDerivedStateFromError\n      // so that componentStack is accessible through state.\n      this.setState({\n        error,\n        componentStack,\n        eventId\n      });\n    });\n  }\n  componentDidMount() {\n    const {\n      onMount\n    } = this.props;\n    if (onMount) {\n      onMount();\n    }\n  }\n  componentWillUnmount() {\n    const {\n      error,\n      componentStack,\n      eventId\n    } = this.state;\n    const {\n      onUnmount\n    } = this.props;\n    if (onUnmount) {\n      if (this.state === INITIAL_STATE) {\n        // If the error boundary never encountered an error, call onUnmount with null values\n        onUnmount(null, null, null);\n      } else {\n        // `componentStack` and `eventId` are guaranteed to be non-null here because `onUnmount` is only called\n        // when the error boundary has already encountered an error.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        onUnmount(error, componentStack, eventId);\n      }\n    }\n    if (this._cleanupHook) {\n      this._cleanupHook();\n      this._cleanupHook = undefined;\n    }\n  }\n  resetErrorBoundary() {\n    const {\n      onReset\n    } = this.props;\n    const {\n      error,\n      componentStack,\n      eventId\n    } = this.state;\n    if (onReset) {\n      // `componentStack` and `eventId` are guaranteed to be non-null here because `onReset` is only called\n      // when the error boundary has already encountered an error.\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      onReset(error, componentStack, eventId);\n    }\n    this.setState(INITIAL_STATE);\n  }\n  render() {\n    const {\n      fallback,\n      children\n    } = this.props;\n    const state = this.state;\n\n    // `componentStack` is only null in the initial state, when no error has been captured.\n    // If an error has been captured, `componentStack` will be a string.\n    // We cannot check `state.error` because null can be thrown as an error.\n    if (state.componentStack === null) {\n      return typeof children === 'function' ? children() : children;\n    }\n    const element = typeof fallback === 'function' ? React.createElement(fallback, {\n      error: state.error,\n      componentStack: state.componentStack,\n      resetError: () => this.resetErrorBoundary(),\n      eventId: state.eventId\n    }) : fallback;\n    if (React.isValidElement(element)) {\n      return element;\n    }\n    if (fallback) {\n      DEBUG_BUILD && debug.warn('fallback did not produce a valid ReactElement');\n    }\n\n    // Fail gracefully if no fallback provided or is not valid\n    return null;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction withErrorBoundary(WrappedComponent, errorBoundaryOptions) {\n  const componentDisplayName = WrappedComponent.displayName || WrappedComponent.name || UNKNOWN_COMPONENT;\n  const Wrapped = props => React.createElement(ErrorBoundary, {\n    ...errorBoundaryOptions\n  }, React.createElement(WrappedComponent, {\n    ...props\n  }));\n  Wrapped.displayName = `errorBoundary(${componentDisplayName})`;\n\n  // Copy over static methods from Wrapped component to Profiler HOC\n  // See: https://reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over\n  hoistNonReactStatics(Wrapped, WrappedComponent);\n  return Wrapped;\n}\nexport { ErrorBoundary, UNKNOWN_COMPONENT, withErrorBoundary };\n//# sourceMappingURL=errorboundary.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}