{"ast":null,"code":"import { getAsyncContextStrategy } from '../asyncContext/index.js';\nimport { getMainCarrier } from '../carrier.js';\nimport { getCurrentScope } from '../currentScopes.js';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE } from '../semanticAttributes.js';\nimport { SPAN_STATUS_UNSET, SPAN_STATUS_OK } from '../tracing/spanstatus.js';\nimport { getCapturedScopesOnSpan } from '../tracing/utils.js';\nimport { addNonEnumerableProperty } from './object.js';\nimport { generateSpanId } from './propagationContext.js';\nimport { timestampInSeconds } from './time.js';\nimport { generateSentryTraceHeader } from './tracing.js';\nimport { consoleSandbox } from './debug-logger.js';\nimport { _getSpanForScope } from './spanOnScope.js';\n\n// These are aligned with OpenTelemetry trace flags\nconst TRACE_FLAG_NONE = 0x0;\nconst TRACE_FLAG_SAMPLED = 0x1;\nlet hasShownSpanDropWarning = false;\n\n/**\n * Convert a span to a trace context, which can be sent as the `trace` context in an event.\n * By default, this will only include trace_id, span_id & parent_span_id.\n * If `includeAllData` is true, it will also include data, op, status & origin.\n */\nfunction spanToTransactionTraceContext(span) {\n  const {\n    spanId: span_id,\n    traceId: trace_id\n  } = span.spanContext();\n  const {\n    data,\n    op,\n    parent_span_id,\n    status,\n    origin,\n    links\n  } = spanToJSON(span);\n  return {\n    parent_span_id,\n    span_id,\n    trace_id,\n    data,\n    op,\n    status,\n    origin,\n    links\n  };\n}\n\n/**\n * Convert a span to a trace context, which can be sent as the `trace` context in a non-transaction event.\n */\nfunction spanToTraceContext(span) {\n  const {\n    spanId,\n    traceId: trace_id,\n    isRemote\n  } = span.spanContext();\n\n  // If the span is remote, we use a random/virtual span as span_id to the trace context,\n  // and the remote span as parent_span_id\n  const parent_span_id = isRemote ? spanId : spanToJSON(span).parent_span_id;\n  const scope = getCapturedScopesOnSpan(span).scope;\n  const span_id = isRemote ? scope?.getPropagationContext().propagationSpanId || generateSpanId() : spanId;\n  return {\n    parent_span_id,\n    span_id,\n    trace_id\n  };\n}\n\n/**\n * Convert a Span to a Sentry trace header.\n */\nfunction spanToTraceHeader(span) {\n  const {\n    traceId,\n    spanId\n  } = span.spanContext();\n  const sampled = spanIsSampled(span);\n  return generateSentryTraceHeader(traceId, spanId, sampled);\n}\n\n/**\n *  Converts the span links array to a flattened version to be sent within an envelope.\n *\n *  If the links array is empty, it returns `undefined` so the empty value can be dropped before it's sent.\n */\nfunction convertSpanLinksForEnvelope(links) {\n  if (links && links.length > 0) {\n    return links.map(({\n      context: {\n        spanId,\n        traceId,\n        traceFlags,\n        ...restContext\n      },\n      attributes\n    }) => ({\n      span_id: spanId,\n      trace_id: traceId,\n      sampled: traceFlags === TRACE_FLAG_SAMPLED,\n      attributes,\n      ...restContext\n    }));\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Convert a span time input into a timestamp in seconds.\n */\nfunction spanTimeInputToSeconds(input) {\n  if (typeof input === 'number') {\n    return ensureTimestampInSeconds(input);\n  }\n  if (Array.isArray(input)) {\n    // See {@link HrTime} for the array-based time format\n    return input[0] + input[1] / 1e9;\n  }\n  if (input instanceof Date) {\n    return ensureTimestampInSeconds(input.getTime());\n  }\n  return timestampInSeconds();\n}\n\n/**\n * Converts a timestamp to second, if it was in milliseconds, or keeps it as second.\n */\nfunction ensureTimestampInSeconds(timestamp) {\n  const isMs = timestamp > 9999999999;\n  return isMs ? timestamp / 1000 : timestamp;\n}\n\n/**\n * Convert a span to a JSON representation.\n */\n// Note: Because of this, we currently have a circular type dependency (which we opted out of in package.json).\n// This is not avoidable as we need `spanToJSON` in `spanUtils.ts`, which in turn is needed by `span.ts` for backwards compatibility.\n// And `spanToJSON` needs the Span class from `span.ts` to check here.\nfunction spanToJSON(span) {\n  if (spanIsSentrySpan(span)) {\n    return span.getSpanJSON();\n  }\n  const {\n    spanId: span_id,\n    traceId: trace_id\n  } = span.spanContext();\n\n  // Handle a span from @opentelemetry/sdk-base-trace's `Span` class\n  if (spanIsOpenTelemetrySdkTraceBaseSpan(span)) {\n    const {\n      attributes,\n      startTime,\n      name,\n      endTime,\n      status,\n      links\n    } = span;\n\n    // In preparation for the next major of OpenTelemetry, we want to support\n    // looking up the parent span id according to the new API\n    // In OTel v1, the parent span id is accessed as `parentSpanId`\n    // In OTel v2, the parent span id is accessed as `spanId` on the `parentSpanContext`\n    const parentSpanId = 'parentSpanId' in span ? span.parentSpanId : 'parentSpanContext' in span ? span.parentSpanContext?.spanId : undefined;\n    return {\n      span_id,\n      trace_id,\n      data: attributes,\n      description: name,\n      parent_span_id: parentSpanId,\n      start_timestamp: spanTimeInputToSeconds(startTime),\n      // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time\n      timestamp: spanTimeInputToSeconds(endTime) || undefined,\n      status: getStatusMessage(status),\n      op: attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP],\n      origin: attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN],\n      links: convertSpanLinksForEnvelope(links)\n    };\n  }\n\n  // Finally, at least we have `spanContext()`....\n  // This should not actually happen in reality, but we need to handle it for type safety.\n  return {\n    span_id,\n    trace_id,\n    start_timestamp: 0,\n    data: {}\n  };\n}\nfunction spanIsOpenTelemetrySdkTraceBaseSpan(span) {\n  const castSpan = span;\n  return !!castSpan.attributes && !!castSpan.startTime && !!castSpan.name && !!castSpan.endTime && !!castSpan.status;\n}\n\n/** Exported only for tests. */\n\n/**\n * Sadly, due to circular dependency checks we cannot actually import the Span class here and check for instanceof.\n * :( So instead we approximate this by checking if it has the `getSpanJSON` method.\n */\nfunction spanIsSentrySpan(span) {\n  return typeof span.getSpanJSON === 'function';\n}\n\n/**\n * Returns true if a span is sampled.\n * In most cases, you should just use `span.isRecording()` instead.\n * However, this has a slightly different semantic, as it also returns false if the span is finished.\n * So in the case where this distinction is important, use this method.\n */\nfunction spanIsSampled(span) {\n  // We align our trace flags with the ones OpenTelemetry use\n  // So we also check for sampled the same way they do.\n  const {\n    traceFlags\n  } = span.spanContext();\n  return traceFlags === TRACE_FLAG_SAMPLED;\n}\n\n/** Get the status message to use for a JSON representation of a span. */\nfunction getStatusMessage(status) {\n  if (!status || status.code === SPAN_STATUS_UNSET) {\n    return undefined;\n  }\n  if (status.code === SPAN_STATUS_OK) {\n    return 'ok';\n  }\n  return status.message || 'unknown_error';\n}\nconst CHILD_SPANS_FIELD = '_sentryChildSpans';\nconst ROOT_SPAN_FIELD = '_sentryRootSpan';\n\n/**\n * Adds an opaque child span reference to a span.\n */\nfunction addChildSpanToSpan(span, childSpan) {\n  // We store the root span reference on the child span\n  // We need this for `getRootSpan()` to work\n  const rootSpan = span[ROOT_SPAN_FIELD] || span;\n  addNonEnumerableProperty(childSpan, ROOT_SPAN_FIELD, rootSpan);\n\n  // We store a list of child spans on the parent span\n  // We need this for `getSpanDescendants()` to work\n  if (span[CHILD_SPANS_FIELD]) {\n    span[CHILD_SPANS_FIELD].add(childSpan);\n  } else {\n    addNonEnumerableProperty(span, CHILD_SPANS_FIELD, new Set([childSpan]));\n  }\n}\n\n/** This is only used internally by Idle Spans. */\nfunction removeChildSpanFromSpan(span, childSpan) {\n  if (span[CHILD_SPANS_FIELD]) {\n    span[CHILD_SPANS_FIELD].delete(childSpan);\n  }\n}\n\n/**\n * Returns an array of the given span and all of its descendants.\n */\nfunction getSpanDescendants(span) {\n  const resultSet = new Set();\n  function addSpanChildren(span) {\n    // This exit condition is required to not infinitely loop in case of a circular dependency.\n    if (resultSet.has(span)) {\n      return;\n      // We want to ignore unsampled spans (e.g. non recording spans)\n    } else if (spanIsSampled(span)) {\n      resultSet.add(span);\n      const childSpans = span[CHILD_SPANS_FIELD] ? Array.from(span[CHILD_SPANS_FIELD]) : [];\n      for (const childSpan of childSpans) {\n        addSpanChildren(childSpan);\n      }\n    }\n  }\n  addSpanChildren(span);\n  return Array.from(resultSet);\n}\n\n/**\n * Returns the root span of a given span.\n */\nfunction getRootSpan(span) {\n  return span[ROOT_SPAN_FIELD] || span;\n}\n\n/**\n * Returns the currently active span.\n */\nfunction getActiveSpan() {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  if (acs.getActiveSpan) {\n    return acs.getActiveSpan();\n  }\n  return _getSpanForScope(getCurrentScope());\n}\n\n/**\n * Logs a warning once if `beforeSendSpan` is used to drop spans.\n */\nfunction showSpanDropWarning() {\n  if (!hasShownSpanDropWarning) {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn('[Sentry] Returning null from `beforeSendSpan` is disallowed. To drop certain spans, configure the respective integrations directly.');\n    });\n    hasShownSpanDropWarning = true;\n  }\n}\n\n/**\n * Updates the name of the given span and ensures that the span name is not\n * overwritten by the Sentry SDK.\n *\n * Use this function instead of `span.updateName()` if you want to make sure that\n * your name is kept. For some spans, for example root `http.server` spans the\n * Sentry SDK would otherwise overwrite the span name with a high-quality name\n * it infers when the span ends.\n *\n * Use this function in server code or when your span is started on the server\n * and on the client (browser). If you only update a span name on the client,\n * you can also use `span.updateName()` the SDK does not overwrite the name.\n *\n * @param span - The span to update the name of.\n * @param name - The name to set on the span.\n */\nfunction updateSpanName(span, name) {\n  span.updateName(name);\n  span.setAttributes({\n    [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'custom',\n    [SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME]: name\n  });\n}\nexport { TRACE_FLAG_NONE, TRACE_FLAG_SAMPLED, addChildSpanToSpan, convertSpanLinksForEnvelope, getActiveSpan, getRootSpan, getSpanDescendants, getStatusMessage, removeChildSpanFromSpan, showSpanDropWarning, spanIsSampled, spanTimeInputToSeconds, spanToJSON, spanToTraceContext, spanToTraceHeader, spanToTransactionTraceContext, updateSpanName };","map":{"version":3,"names":["TRACE_FLAG_NONE","TRACE_FLAG_SAMPLED","hasShownSpanDropWarning","spanToTransactionTraceContext","span","spanId","span_id","traceId","trace_id","spanContext","data","op","parent_span_id","status","origin","links","spanToJSON","spanToTraceContext","isRemote","scope","getCapturedScopesOnSpan","getPropagationContext","propagationSpanId","generateSpanId","spanToTraceHeader","sampled","spanIsSampled","generateSentryTraceHeader","convertSpanLinksForEnvelope","length","map","context","traceFlags","restContext","attributes","undefined","spanTimeInputToSeconds","input","ensureTimestampInSeconds","Array","isArray","Date","getTime","timestampInSeconds","timestamp","isMs","spanIsSentrySpan","getSpanJSON","spanIsOpenTelemetrySdkTraceBaseSpan","startTime","name","endTime","parentSpanId","parentSpanContext","description","start_timestamp","getStatusMessage","SEMANTIC_ATTRIBUTE_SENTRY_OP","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","castSpan","code","SPAN_STATUS_UNSET","SPAN_STATUS_OK","message","CHILD_SPANS_FIELD","ROOT_SPAN_FIELD","addChildSpanToSpan","childSpan","rootSpan","addNonEnumerableProperty","add","Set","removeChildSpanFromSpan","delete","getSpanDescendants","resultSet","addSpanChildren","has","childSpans","from","getRootSpan","getActiveSpan","carrier","getMainCarrier","acs","getAsyncContextStrategy","_getSpanForScope","getCurrentScope","showSpanDropWarning","consoleSandbox","console","warn","updateSpanName","updateName","setAttributes","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/utils/spanUtils.ts"],"sourcesContent":["import { getAsyncContextStrategy } from '../asyncContext';\nimport { getMainCarrier } from '../carrier';\nimport { getCurrentScope } from '../currentScopes';\nimport {\n  SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n} from '../semanticAttributes';\nimport type { SentrySpan } from '../tracing/sentrySpan';\nimport { SPAN_STATUS_OK, SPAN_STATUS_UNSET } from '../tracing/spanstatus';\nimport { getCapturedScopesOnSpan } from '../tracing/utils';\nimport type { TraceContext } from '../types-hoist/context';\nimport type { SpanLink, SpanLinkJSON } from '../types-hoist/link';\nimport type { Span, SpanAttributes, SpanJSON, SpanOrigin, SpanTimeInput } from '../types-hoist/span';\nimport type { SpanStatus } from '../types-hoist/spanStatus';\nimport { addNonEnumerableProperty } from '../utils/object';\nimport { generateSpanId } from '../utils/propagationContext';\nimport { timestampInSeconds } from '../utils/time';\nimport { generateSentryTraceHeader } from '../utils/tracing';\nimport { consoleSandbox } from './debug-logger';\nimport { _getSpanForScope } from './spanOnScope';\n\n// These are aligned with OpenTelemetry trace flags\nexport const TRACE_FLAG_NONE = 0x0;\nexport const TRACE_FLAG_SAMPLED = 0x1;\n\nlet hasShownSpanDropWarning = false;\n\n/**\n * Convert a span to a trace context, which can be sent as the `trace` context in an event.\n * By default, this will only include trace_id, span_id & parent_span_id.\n * If `includeAllData` is true, it will also include data, op, status & origin.\n */\nexport function spanToTransactionTraceContext(span: Span): TraceContext {\n  const { spanId: span_id, traceId: trace_id } = span.spanContext();\n  const { data, op, parent_span_id, status, origin, links } = spanToJSON(span);\n\n  return {\n    parent_span_id,\n    span_id,\n    trace_id,\n    data,\n    op,\n    status,\n    origin,\n    links,\n  };\n}\n\n/**\n * Convert a span to a trace context, which can be sent as the `trace` context in a non-transaction event.\n */\nexport function spanToTraceContext(span: Span): TraceContext {\n  const { spanId, traceId: trace_id, isRemote } = span.spanContext();\n\n  // If the span is remote, we use a random/virtual span as span_id to the trace context,\n  // and the remote span as parent_span_id\n  const parent_span_id = isRemote ? spanId : spanToJSON(span).parent_span_id;\n  const scope = getCapturedScopesOnSpan(span).scope;\n\n  const span_id = isRemote ? scope?.getPropagationContext().propagationSpanId || generateSpanId() : spanId;\n\n  return {\n    parent_span_id,\n    span_id,\n    trace_id,\n  };\n}\n\n/**\n * Convert a Span to a Sentry trace header.\n */\nexport function spanToTraceHeader(span: Span): string {\n  const { traceId, spanId } = span.spanContext();\n  const sampled = spanIsSampled(span);\n  return generateSentryTraceHeader(traceId, spanId, sampled);\n}\n\n/**\n *  Converts the span links array to a flattened version to be sent within an envelope.\n *\n *  If the links array is empty, it returns `undefined` so the empty value can be dropped before it's sent.\n */\nexport function convertSpanLinksForEnvelope(links?: SpanLink[]): SpanLinkJSON[] | undefined {\n  if (links && links.length > 0) {\n    return links.map(({ context: { spanId, traceId, traceFlags, ...restContext }, attributes }) => ({\n      span_id: spanId,\n      trace_id: traceId,\n      sampled: traceFlags === TRACE_FLAG_SAMPLED,\n      attributes,\n      ...restContext,\n    }));\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Convert a span time input into a timestamp in seconds.\n */\nexport function spanTimeInputToSeconds(input: SpanTimeInput | undefined): number {\n  if (typeof input === 'number') {\n    return ensureTimestampInSeconds(input);\n  }\n\n  if (Array.isArray(input)) {\n    // See {@link HrTime} for the array-based time format\n    return input[0] + input[1] / 1e9;\n  }\n\n  if (input instanceof Date) {\n    return ensureTimestampInSeconds(input.getTime());\n  }\n\n  return timestampInSeconds();\n}\n\n/**\n * Converts a timestamp to second, if it was in milliseconds, or keeps it as second.\n */\nfunction ensureTimestampInSeconds(timestamp: number): number {\n  const isMs = timestamp > 9999999999;\n  return isMs ? timestamp / 1000 : timestamp;\n}\n\n/**\n * Convert a span to a JSON representation.\n */\n// Note: Because of this, we currently have a circular type dependency (which we opted out of in package.json).\n// This is not avoidable as we need `spanToJSON` in `spanUtils.ts`, which in turn is needed by `span.ts` for backwards compatibility.\n// And `spanToJSON` needs the Span class from `span.ts` to check here.\nexport function spanToJSON(span: Span): SpanJSON {\n  if (spanIsSentrySpan(span)) {\n    return span.getSpanJSON();\n  }\n\n  const { spanId: span_id, traceId: trace_id } = span.spanContext();\n\n  // Handle a span from @opentelemetry/sdk-base-trace's `Span` class\n  if (spanIsOpenTelemetrySdkTraceBaseSpan(span)) {\n    const { attributes, startTime, name, endTime, status, links } = span;\n\n    // In preparation for the next major of OpenTelemetry, we want to support\n    // looking up the parent span id according to the new API\n    // In OTel v1, the parent span id is accessed as `parentSpanId`\n    // In OTel v2, the parent span id is accessed as `spanId` on the `parentSpanContext`\n    const parentSpanId =\n      'parentSpanId' in span\n        ? span.parentSpanId\n        : 'parentSpanContext' in span\n          ? (span.parentSpanContext as { spanId?: string } | undefined)?.spanId\n          : undefined;\n\n    return {\n      span_id,\n      trace_id,\n      data: attributes,\n      description: name,\n      parent_span_id: parentSpanId,\n      start_timestamp: spanTimeInputToSeconds(startTime),\n      // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time\n      timestamp: spanTimeInputToSeconds(endTime) || undefined,\n      status: getStatusMessage(status),\n      op: attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP],\n      origin: attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] as SpanOrigin | undefined,\n      links: convertSpanLinksForEnvelope(links),\n    };\n  }\n\n  // Finally, at least we have `spanContext()`....\n  // This should not actually happen in reality, but we need to handle it for type safety.\n  return {\n    span_id,\n    trace_id,\n    start_timestamp: 0,\n    data: {},\n  };\n}\n\nfunction spanIsOpenTelemetrySdkTraceBaseSpan(span: Span): span is OpenTelemetrySdkTraceBaseSpan {\n  const castSpan = span as Partial<OpenTelemetrySdkTraceBaseSpan>;\n  return !!castSpan.attributes && !!castSpan.startTime && !!castSpan.name && !!castSpan.endTime && !!castSpan.status;\n}\n\n/** Exported only for tests. */\nexport interface OpenTelemetrySdkTraceBaseSpan extends Span {\n  attributes: SpanAttributes;\n  startTime: SpanTimeInput;\n  name: string;\n  status: SpanStatus;\n  endTime: SpanTimeInput;\n  parentSpanId?: string;\n  links?: SpanLink[];\n}\n\n/**\n * Sadly, due to circular dependency checks we cannot actually import the Span class here and check for instanceof.\n * :( So instead we approximate this by checking if it has the `getSpanJSON` method.\n */\nfunction spanIsSentrySpan(span: Span): span is SentrySpan {\n  return typeof (span as SentrySpan).getSpanJSON === 'function';\n}\n\n/**\n * Returns true if a span is sampled.\n * In most cases, you should just use `span.isRecording()` instead.\n * However, this has a slightly different semantic, as it also returns false if the span is finished.\n * So in the case where this distinction is important, use this method.\n */\nexport function spanIsSampled(span: Span): boolean {\n  // We align our trace flags with the ones OpenTelemetry use\n  // So we also check for sampled the same way they do.\n  const { traceFlags } = span.spanContext();\n  return traceFlags === TRACE_FLAG_SAMPLED;\n}\n\n/** Get the status message to use for a JSON representation of a span. */\nexport function getStatusMessage(status: SpanStatus | undefined): string | undefined {\n  if (!status || status.code === SPAN_STATUS_UNSET) {\n    return undefined;\n  }\n\n  if (status.code === SPAN_STATUS_OK) {\n    return 'ok';\n  }\n\n  return status.message || 'unknown_error';\n}\n\nconst CHILD_SPANS_FIELD = '_sentryChildSpans';\nconst ROOT_SPAN_FIELD = '_sentryRootSpan';\n\ntype SpanWithPotentialChildren = Span & {\n  [CHILD_SPANS_FIELD]?: Set<Span>;\n  [ROOT_SPAN_FIELD]?: Span;\n};\n\n/**\n * Adds an opaque child span reference to a span.\n */\nexport function addChildSpanToSpan(span: SpanWithPotentialChildren, childSpan: Span): void {\n  // We store the root span reference on the child span\n  // We need this for `getRootSpan()` to work\n  const rootSpan = span[ROOT_SPAN_FIELD] || span;\n  addNonEnumerableProperty(childSpan as SpanWithPotentialChildren, ROOT_SPAN_FIELD, rootSpan);\n\n  // We store a list of child spans on the parent span\n  // We need this for `getSpanDescendants()` to work\n  if (span[CHILD_SPANS_FIELD]) {\n    span[CHILD_SPANS_FIELD].add(childSpan);\n  } else {\n    addNonEnumerableProperty(span, CHILD_SPANS_FIELD, new Set([childSpan]));\n  }\n}\n\n/** This is only used internally by Idle Spans. */\nexport function removeChildSpanFromSpan(span: SpanWithPotentialChildren, childSpan: Span): void {\n  if (span[CHILD_SPANS_FIELD]) {\n    span[CHILD_SPANS_FIELD].delete(childSpan);\n  }\n}\n\n/**\n * Returns an array of the given span and all of its descendants.\n */\nexport function getSpanDescendants(span: SpanWithPotentialChildren): Span[] {\n  const resultSet = new Set<Span>();\n\n  function addSpanChildren(span: SpanWithPotentialChildren): void {\n    // This exit condition is required to not infinitely loop in case of a circular dependency.\n    if (resultSet.has(span)) {\n      return;\n      // We want to ignore unsampled spans (e.g. non recording spans)\n    } else if (spanIsSampled(span)) {\n      resultSet.add(span);\n      const childSpans = span[CHILD_SPANS_FIELD] ? Array.from(span[CHILD_SPANS_FIELD]) : [];\n      for (const childSpan of childSpans) {\n        addSpanChildren(childSpan);\n      }\n    }\n  }\n\n  addSpanChildren(span);\n\n  return Array.from(resultSet);\n}\n\n/**\n * Returns the root span of a given span.\n */\nexport function getRootSpan(span: SpanWithPotentialChildren): Span {\n  return span[ROOT_SPAN_FIELD] || span;\n}\n\n/**\n * Returns the currently active span.\n */\nexport function getActiveSpan(): Span | undefined {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  if (acs.getActiveSpan) {\n    return acs.getActiveSpan();\n  }\n\n  return _getSpanForScope(getCurrentScope());\n}\n\n/**\n * Logs a warning once if `beforeSendSpan` is used to drop spans.\n */\nexport function showSpanDropWarning(): void {\n  if (!hasShownSpanDropWarning) {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn(\n        '[Sentry] Returning null from `beforeSendSpan` is disallowed. To drop certain spans, configure the respective integrations directly.',\n      );\n    });\n    hasShownSpanDropWarning = true;\n  }\n}\n\n/**\n * Updates the name of the given span and ensures that the span name is not\n * overwritten by the Sentry SDK.\n *\n * Use this function instead of `span.updateName()` if you want to make sure that\n * your name is kept. For some spans, for example root `http.server` spans the\n * Sentry SDK would otherwise overwrite the span name with a high-quality name\n * it infers when the span ends.\n *\n * Use this function in server code or when your span is started on the server\n * and on the client (browser). If you only update a span name on the client,\n * you can also use `span.updateName()` the SDK does not overwrite the name.\n *\n * @param span - The span to update the name of.\n * @param name - The name to set on the span.\n */\nexport function updateSpanName(span: Span, name: string): void {\n  span.updateName(name);\n  span.setAttributes({\n    [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'custom',\n    [SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME]: name,\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}