{"ast":null,"code":"import { defineIntegration, spanToJSON, SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_URL_FULL, SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD, isString, stringMatchesSomePattern } from '@sentry/core';\nimport { SENTRY_XHR_DATA_KEY, getBodyString, getFetchRequestArgBody } from '@sentry-internal/browser-utils';\nconst INTEGRATION_NAME = 'GraphQLClient';\nconst _graphqlClientIntegration = options => {\n  return {\n    name: INTEGRATION_NAME,\n    setup(client) {\n      _updateSpanWithGraphQLData(client, options);\n      _updateBreadcrumbWithGraphQLData(client, options);\n    }\n  };\n};\nfunction _updateSpanWithGraphQLData(client, options) {\n  client.on('beforeOutgoingRequestSpan', (span, hint) => {\n    const spanJSON = spanToJSON(span);\n    const spanAttributes = spanJSON.data || {};\n    const spanOp = spanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_OP];\n    const isHttpClientSpan = spanOp === 'http.client';\n    if (!isHttpClientSpan) {\n      return;\n    }\n    const httpUrl = spanAttributes[SEMANTIC_ATTRIBUTE_URL_FULL] || spanAttributes['http.url'];\n    const httpMethod = spanAttributes[SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD] || spanAttributes['http.method'];\n    if (!isString(httpUrl) || !isString(httpMethod)) {\n      return;\n    }\n    const {\n      endpoints\n    } = options;\n    const isTracedGraphqlEndpoint = stringMatchesSomePattern(httpUrl, endpoints);\n    const payload = getRequestPayloadXhrOrFetch(hint);\n    if (isTracedGraphqlEndpoint && payload) {\n      const graphqlBody = getGraphQLRequestPayload(payload);\n      if (graphqlBody) {\n        const operationInfo = _getGraphQLOperation(graphqlBody);\n        span.updateName(`${httpMethod} ${httpUrl} (${operationInfo})`);\n        span.setAttribute('graphql.document', payload);\n      }\n    }\n  });\n}\nfunction _updateBreadcrumbWithGraphQLData(client, options) {\n  client.on('beforeOutgoingRequestBreadcrumb', (breadcrumb, handlerData) => {\n    const {\n      category,\n      type,\n      data\n    } = breadcrumb;\n    const isFetch = category === 'fetch';\n    const isXhr = category === 'xhr';\n    const isHttpBreadcrumb = type === 'http';\n    if (isHttpBreadcrumb && (isFetch || isXhr)) {\n      const httpUrl = data?.url;\n      const {\n        endpoints\n      } = options;\n      const isTracedGraphqlEndpoint = stringMatchesSomePattern(httpUrl, endpoints);\n      const payload = getRequestPayloadXhrOrFetch(handlerData);\n      if (isTracedGraphqlEndpoint && data && payload) {\n        const graphqlBody = getGraphQLRequestPayload(payload);\n        if (!data.graphql && graphqlBody) {\n          const operationInfo = _getGraphQLOperation(graphqlBody);\n          data['graphql.document'] = graphqlBody.query;\n          data['graphql.operation'] = operationInfo;\n        }\n      }\n    }\n  });\n}\n\n/**\n * @param requestBody - GraphQL request\n * @returns A formatted version of the request: 'TYPE NAME' or 'TYPE'\n */\nfunction _getGraphQLOperation(requestBody) {\n  const {\n    query: graphqlQuery,\n    operationName: graphqlOperationName\n  } = requestBody;\n  const {\n    operationName = graphqlOperationName,\n    operationType\n  } = parseGraphQLQuery(graphqlQuery);\n  const operationInfo = operationName ? `${operationType} ${operationName}` : `${operationType}`;\n  return operationInfo;\n}\n\n/**\n * Get the request body/payload based on the shape of the hint.\n *\n * Exported for tests only.\n */\nfunction getRequestPayloadXhrOrFetch(hint) {\n  const isXhr = 'xhr' in hint;\n  let body;\n  if (isXhr) {\n    const sentryXhrData = hint.xhr[SENTRY_XHR_DATA_KEY];\n    body = sentryXhrData && getBodyString(sentryXhrData.body)[0];\n  } else {\n    const sentryFetchData = getFetchRequestArgBody(hint.input);\n    body = getBodyString(sentryFetchData)[0];\n  }\n  return body;\n}\n\n/**\n * Extract the name and type of the operation from the GraphQL query.\n *\n * Exported for tests only.\n */\nfunction parseGraphQLQuery(query) {\n  const namedQueryRe = /^(?:\\s*)(query|mutation|subscription)(?:\\s*)(\\w+)(?:\\s*)[{(]/;\n  const unnamedQueryRe = /^(?:\\s*)(query|mutation|subscription)(?:\\s*)[{(]/;\n  const namedMatch = query.match(namedQueryRe);\n  if (namedMatch) {\n    return {\n      operationType: namedMatch[1],\n      operationName: namedMatch[2]\n    };\n  }\n  const unnamedMatch = query.match(unnamedQueryRe);\n  if (unnamedMatch) {\n    return {\n      operationType: unnamedMatch[1],\n      operationName: undefined\n    };\n  }\n  return {\n    operationType: undefined,\n    operationName: undefined\n  };\n}\n\n/**\n * Extract the payload of a request if it's GraphQL.\n * Exported for tests only.\n * @param payload - A valid JSON string\n * @returns A POJO or undefined\n */\nfunction getGraphQLRequestPayload(payload) {\n  let graphqlBody = undefined;\n  try {\n    const requestBody = JSON.parse(payload);\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const isGraphQLRequest = !!requestBody['query'];\n    if (isGraphQLRequest) {\n      graphqlBody = requestBody;\n    }\n  } finally {\n    // Fallback to undefined if payload is an invalid JSON (SyntaxError)\n\n    /* eslint-disable no-unsafe-finally */\n    return graphqlBody;\n  }\n}\n\n/**\n * This integration ensures that GraphQL requests made in the browser\n * have their GraphQL-specific data captured and attached to spans and breadcrumbs.\n */\nconst graphqlClientIntegration = defineIntegration(_graphqlClientIntegration);\nexport { getGraphQLRequestPayload, getRequestPayloadXhrOrFetch, graphqlClientIntegration, parseGraphQLQuery };\n//# sourceMappingURL=graphqlClient.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}