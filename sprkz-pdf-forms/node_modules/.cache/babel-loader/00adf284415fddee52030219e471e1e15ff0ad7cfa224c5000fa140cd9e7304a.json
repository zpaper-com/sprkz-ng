{"ast":null,"code":"import { browserTracingIntegration, WINDOW, startBrowserTracingPageLoadSpan, startBrowserTracingNavigationSpan } from '@sentry/browser';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_OP } from '@sentry/core';\n\n// Many of the types below had to be mocked out to prevent typescript issues\n// these types are required for correct functionality.\n\n/**\n * A browser tracing integration that uses React Router v3 to instrument navigations.\n * Expects `history` (and optionally `routes` and `matchPath`) to be passed as options.\n */\nfunction reactRouterV3BrowserTracingIntegration(options) {\n  const integration = browserTracingIntegration({\n    ...options,\n    instrumentPageLoad: false,\n    instrumentNavigation: false\n  });\n  const {\n    history,\n    routes,\n    match,\n    instrumentPageLoad = true,\n    instrumentNavigation = true\n  } = options;\n  return {\n    ...integration,\n    afterAllSetup(client) {\n      integration.afterAllSetup(client);\n      if (instrumentPageLoad && WINDOW.location) {\n        normalizeTransactionName(routes, WINDOW.location, match, (localName, source = 'url') => {\n          startBrowserTracingPageLoadSpan(client, {\n            name: localName,\n            attributes: {\n              [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'pageload',\n              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.pageload.react.reactrouter_v3',\n              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source\n            }\n          });\n        });\n      }\n      if (instrumentNavigation && history.listen) {\n        history.listen(location => {\n          if (location.action === 'PUSH' || location.action === 'POP') {\n            normalizeTransactionName(routes, location, match, (localName, source = 'url') => {\n              startBrowserTracingNavigationSpan(client, {\n                name: localName,\n                attributes: {\n                  [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'navigation',\n                  [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.react.reactrouter_v3',\n                  [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source\n                }\n              });\n            });\n          }\n        });\n      }\n    }\n  };\n}\n\n/**\n * Normalize transaction names using `Router.match`\n */\nfunction normalizeTransactionName(appRoutes, location, match, callback) {\n  let name = location.pathname;\n  match({\n    location,\n    routes: appRoutes\n  }, (error, _redirectLocation, renderProps) => {\n    if (error || !renderProps) {\n      return callback(name);\n    }\n    const routePath = getRouteStringFromRoutes(renderProps.routes || []);\n    if (routePath.length === 0 || routePath === '/*') {\n      return callback(name);\n    }\n    name = routePath;\n    return callback(name, 'route');\n  });\n}\n\n/**\n * Generate route name from array of routes\n */\nfunction getRouteStringFromRoutes(routes) {\n  if (!Array.isArray(routes) || routes.length === 0) {\n    return '';\n  }\n  const routesWithPaths = routes.filter(route => !!route.path);\n  let index = -1;\n  for (let x = routesWithPaths.length - 1; x >= 0; x--) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const route = routesWithPaths[x];\n    if (route.path?.startsWith('/')) {\n      index = x;\n      break;\n    }\n  }\n  return routesWithPaths.slice(index).reduce((acc, {\n    path\n  }) => {\n    const pathSegment = acc === '/' || acc === '' ? path : `/${path}`;\n    return `${acc}${pathSegment}`;\n  }, '');\n}\nexport { reactRouterV3BrowserTracingIntegration };\n//# sourceMappingURL=reactrouterv3.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}