{"ast":null,"code":"import { getClient } from './currentScopes.js';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { debug } from './utils/debug-logger.js';\nconst installedIntegrations = [];\n\n/** Map of integrations assigned to a client */\n\n/**\n * Remove duplicates from the given array, preferring the last instance of any duplicate. Not guaranteed to\n * preserve the order of integrations in the array.\n *\n * @private\n */\nfunction filterDuplicates(integrations) {\n  const integrationsByName = {};\n  integrations.forEach(currentInstance => {\n    const {\n      name\n    } = currentInstance;\n    const existingInstance = integrationsByName[name];\n\n    // We want integrations later in the array to overwrite earlier ones of the same type, except that we never want a\n    // default instance to overwrite an existing user instance\n    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {\n      return;\n    }\n    integrationsByName[name] = currentInstance;\n  });\n  return Object.values(integrationsByName);\n}\n\n/** Gets integrations to install */\nfunction getIntegrationsToSetup(options) {\n  const defaultIntegrations = options.defaultIntegrations || [];\n  const userIntegrations = options.integrations;\n\n  // We flag default instances, so that later we can tell them apart from any user-created instances of the same class\n  defaultIntegrations.forEach(integration => {\n    integration.isDefaultInstance = true;\n  });\n  let integrations;\n  if (Array.isArray(userIntegrations)) {\n    integrations = [...defaultIntegrations, ...userIntegrations];\n  } else if (typeof userIntegrations === 'function') {\n    const resolvedUserIntegrations = userIntegrations(defaultIntegrations);\n    integrations = Array.isArray(resolvedUserIntegrations) ? resolvedUserIntegrations : [resolvedUserIntegrations];\n  } else {\n    integrations = defaultIntegrations;\n  }\n  return filterDuplicates(integrations);\n}\n\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nfunction setupIntegrations(client, integrations) {\n  const integrationIndex = {};\n  integrations.forEach(integration => {\n    // guard against empty provided integrations\n    if (integration) {\n      setupIntegration(client, integration, integrationIndex);\n    }\n  });\n  return integrationIndex;\n}\n\n/**\n * Execute the `afterAllSetup` hooks of the given integrations.\n */\nfunction afterSetupIntegrations(client, integrations) {\n  for (const integration of integrations) {\n    // guard against empty provided integrations\n    if (integration?.afterAllSetup) {\n      integration.afterAllSetup(client);\n    }\n  }\n}\n\n/** Setup a single integration.  */\nfunction setupIntegration(client, integration, integrationIndex) {\n  if (integrationIndex[integration.name]) {\n    DEBUG_BUILD && debug.log(`Integration skipped because it was already installed: ${integration.name}`);\n    return;\n  }\n  integrationIndex[integration.name] = integration;\n\n  // `setupOnce` is only called the first time\n  if (installedIntegrations.indexOf(integration.name) === -1 && typeof integration.setupOnce === 'function') {\n    integration.setupOnce();\n    installedIntegrations.push(integration.name);\n  }\n\n  // `setup` is run for each client\n  if (integration.setup && typeof integration.setup === 'function') {\n    integration.setup(client);\n  }\n  if (typeof integration.preprocessEvent === 'function') {\n    const callback = integration.preprocessEvent.bind(integration);\n    client.on('preprocessEvent', (event, hint) => callback(event, hint, client));\n  }\n  if (typeof integration.processEvent === 'function') {\n    const callback = integration.processEvent.bind(integration);\n    const processor = Object.assign((event, hint) => callback(event, hint, client), {\n      id: integration.name\n    });\n    client.addEventProcessor(processor);\n  }\n  DEBUG_BUILD && debug.log(`Integration installed: ${integration.name}`);\n}\n\n/** Add an integration to the current scope's client. */\nfunction addIntegration(integration) {\n  const client = getClient();\n  if (!client) {\n    DEBUG_BUILD && debug.warn(`Cannot add integration \"${integration.name}\" because no SDK Client is available.`);\n    return;\n  }\n  client.addIntegration(integration);\n}\n\n/**\n * Define an integration function that can be used to create an integration instance.\n * Note that this by design hides the implementation details of the integration, as they are considered internal.\n */\nfunction defineIntegration(fn) {\n  return fn;\n}\nexport { addIntegration, afterSetupIntegrations, defineIntegration, getIntegrationsToSetup, installedIntegrations, setupIntegration, setupIntegrations };","map":{"version":3,"names":["installedIntegrations","filterDuplicates","integrations","integrationsByName","forEach","currentInstance","name","existingInstance","isDefaultInstance","Object","values","getIntegrationsToSetup","options","defaultIntegrations","userIntegrations","integration","Array","isArray","resolvedUserIntegrations","setupIntegrations","client","integrationIndex","setupIntegration","afterSetupIntegrations","afterAllSetup","DEBUG_BUILD","debug","log","indexOf","setupOnce","push","setup","preprocessEvent","callback","bind","on","event","hint","processEvent","processor","assign","id","addEventProcessor","addIntegration","getClient","warn","defineIntegration","fn"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/integration.ts"],"sourcesContent":["import type { Client } from './client';\nimport { getClient } from './currentScopes';\nimport { DEBUG_BUILD } from './debug-build';\nimport type { Event, EventHint } from './types-hoist/event';\nimport type { Integration, IntegrationFn } from './types-hoist/integration';\nimport type { Options } from './types-hoist/options';\nimport { debug } from './utils/debug-logger';\n\nexport const installedIntegrations: string[] = [];\n\n/** Map of integrations assigned to a client */\nexport type IntegrationIndex = {\n  [key: string]: Integration;\n};\n\ntype IntegrationWithDefaultInstance = Integration & { isDefaultInstance?: true };\n\n/**\n * Remove duplicates from the given array, preferring the last instance of any duplicate. Not guaranteed to\n * preserve the order of integrations in the array.\n *\n * @private\n */\nfunction filterDuplicates(integrations: Integration[]): Integration[] {\n  const integrationsByName: { [key: string]: Integration } = {};\n\n  integrations.forEach((currentInstance: IntegrationWithDefaultInstance) => {\n    const { name } = currentInstance;\n\n    const existingInstance: IntegrationWithDefaultInstance | undefined = integrationsByName[name];\n\n    // We want integrations later in the array to overwrite earlier ones of the same type, except that we never want a\n    // default instance to overwrite an existing user instance\n    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {\n      return;\n    }\n\n    integrationsByName[name] = currentInstance;\n  });\n\n  return Object.values(integrationsByName);\n}\n\n/** Gets integrations to install */\nexport function getIntegrationsToSetup(options: Pick<Options, 'defaultIntegrations' | 'integrations'>): Integration[] {\n  const defaultIntegrations = options.defaultIntegrations || [];\n  const userIntegrations = options.integrations;\n\n  // We flag default instances, so that later we can tell them apart from any user-created instances of the same class\n  defaultIntegrations.forEach((integration: IntegrationWithDefaultInstance) => {\n    integration.isDefaultInstance = true;\n  });\n\n  let integrations: Integration[];\n\n  if (Array.isArray(userIntegrations)) {\n    integrations = [...defaultIntegrations, ...userIntegrations];\n  } else if (typeof userIntegrations === 'function') {\n    const resolvedUserIntegrations = userIntegrations(defaultIntegrations);\n    integrations = Array.isArray(resolvedUserIntegrations) ? resolvedUserIntegrations : [resolvedUserIntegrations];\n  } else {\n    integrations = defaultIntegrations;\n  }\n\n  return filterDuplicates(integrations);\n}\n\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nexport function setupIntegrations(client: Client, integrations: Integration[]): IntegrationIndex {\n  const integrationIndex: IntegrationIndex = {};\n\n  integrations.forEach((integration: Integration | undefined) => {\n    // guard against empty provided integrations\n    if (integration) {\n      setupIntegration(client, integration, integrationIndex);\n    }\n  });\n\n  return integrationIndex;\n}\n\n/**\n * Execute the `afterAllSetup` hooks of the given integrations.\n */\nexport function afterSetupIntegrations(client: Client, integrations: Integration[]): void {\n  for (const integration of integrations) {\n    // guard against empty provided integrations\n    if (integration?.afterAllSetup) {\n      integration.afterAllSetup(client);\n    }\n  }\n}\n\n/** Setup a single integration.  */\nexport function setupIntegration(client: Client, integration: Integration, integrationIndex: IntegrationIndex): void {\n  if (integrationIndex[integration.name]) {\n    DEBUG_BUILD && debug.log(`Integration skipped because it was already installed: ${integration.name}`);\n    return;\n  }\n  integrationIndex[integration.name] = integration;\n\n  // `setupOnce` is only called the first time\n  if (installedIntegrations.indexOf(integration.name) === -1 && typeof integration.setupOnce === 'function') {\n    integration.setupOnce();\n    installedIntegrations.push(integration.name);\n  }\n\n  // `setup` is run for each client\n  if (integration.setup && typeof integration.setup === 'function') {\n    integration.setup(client);\n  }\n\n  if (typeof integration.preprocessEvent === 'function') {\n    const callback = integration.preprocessEvent.bind(integration) as typeof integration.preprocessEvent;\n    client.on('preprocessEvent', (event, hint) => callback(event, hint, client));\n  }\n\n  if (typeof integration.processEvent === 'function') {\n    const callback = integration.processEvent.bind(integration) as typeof integration.processEvent;\n\n    const processor = Object.assign((event: Event, hint: EventHint) => callback(event, hint, client), {\n      id: integration.name,\n    });\n\n    client.addEventProcessor(processor);\n  }\n\n  DEBUG_BUILD && debug.log(`Integration installed: ${integration.name}`);\n}\n\n/** Add an integration to the current scope's client. */\nexport function addIntegration(integration: Integration): void {\n  const client = getClient();\n\n  if (!client) {\n    DEBUG_BUILD && debug.warn(`Cannot add integration \"${integration.name}\" because no SDK Client is available.`);\n    return;\n  }\n\n  client.addIntegration(integration);\n}\n\n/**\n * Define an integration function that can be used to create an integration instance.\n * Note that this by design hides the implementation details of the integration, as they are considered internal.\n */\nexport function defineIntegration<Fn extends IntegrationFn>(fn: Fn): (...args: Parameters<Fn>) => Integration {\n  return fn;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}