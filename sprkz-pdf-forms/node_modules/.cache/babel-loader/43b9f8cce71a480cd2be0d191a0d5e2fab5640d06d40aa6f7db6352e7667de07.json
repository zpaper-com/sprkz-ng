{"ast":null,"code":"import React,{createContext,useContext,useEffect,useState,useCallback,useRef}from'react';import{unleashService,DEFAULT_FEATURE_FLAGS,FEATURE_CATEGORIES}from'../services/unleashService';// Enhanced context interface with full feature flag support\nimport{jsx as _jsx}from\"react/jsx-runtime\";// Default context value\nconst defaultContext={isFeatureEnabled:()=>false,getFeatureVariant:()=>null,getAllFlags:()=>DEFAULT_FEATURE_FLAGS,getFlagsByCategory:()=>({}),updateContext:()=>{},isReady:false,isInitialized:false,status:{initialized:false,clientReady:false,flagCount:0},refresh:()=>{}};export const FeatureFlagsContext=/*#__PURE__*/createContext(defaultContext);export const FeatureFlagsProvider=_ref=>{let{children,config={},fallbackFlags={},enableLogging=process.env.NODE_ENV==='development'}=_ref;const[isReady,setIsReady]=useState(false);const[isInitialized,setIsInitialized]=useState(false);const[flags,setFlags]=useState({...DEFAULT_FEATURE_FLAGS,...fallbackFlags});const[status,setStatus]=useState({initialized:false,clientReady:false,flagCount:0});const[currentContext,setCurrentContext]=useState(config.context||{});const initializationRef=useRef(false);// Initialize Unleash service\nuseEffect(()=>{if(initializationRef.current)return;initializationRef.current=true;const initializeUnleash=async()=>{try{if(enableLogging){console.log('Initializing Unleash service with config:',config);}// Initialize with configuration\nawait unleashService.initialize({userId:config.userId,environment:config.environment,...config.context});// Update initial state\nsetIsInitialized(true);setIsReady(true);setFlags(unleashService.getAllFlags(currentContext));setStatus(unleashService.getStatus());if(enableLogging){console.log('Unleash service initialized successfully');console.log('Initial flags:',unleashService.getAllFlags(currentContext));}}catch(error){console.error('Failed to initialize Unleash service:',error);// Continue with fallback flags\nsetIsInitialized(false);setIsReady(true);// Still ready, just using defaults\nsetFlags({...DEFAULT_FEATURE_FLAGS,...fallbackFlags});}};initializeUnleash();},[]);// Run once on mount\n// Subscribe to flag updates\nuseEffect(()=>{const unsubscribe=unleashService.subscribe(()=>{if(enableLogging){console.log('Feature flags updated');}setFlags(unleashService.getAllFlags(currentContext));setStatus(unleashService.getStatus());});return unsubscribe;},[currentContext,enableLogging]);// Memoized flag checking function\nconst isFeatureEnabled=useCallback((flagName,context)=>{const mergedContext={...currentContext,...context};if(!isInitialized){var _fallbackFlags$flagNa;const fallbackValue=(_fallbackFlags$flagNa=fallbackFlags[flagName])!==null&&_fallbackFlags$flagNa!==void 0?_fallbackFlags$flagNa:DEFAULT_FEATURE_FLAGS[flagName];if(enableLogging){console.log(`Feature flag ${flagName} checked (fallback): ${fallbackValue}`);}return fallbackValue;}const isEnabled=unleashService.isEnabled(flagName,mergedContext);if(enableLogging){console.log(`Feature flag ${flagName} checked: ${isEnabled}`);}return isEnabled;},[isInitialized,currentContext,fallbackFlags,enableLogging]);// Memoized variant getting function\nconst getFeatureVariant=useCallback((flagName,context)=>{const mergedContext={...currentContext,...context};if(!isInitialized){if(enableLogging){console.log(`Feature variant ${flagName} requested (fallback): null`);}return null;}const variant=unleashService.getVariant(flagName,mergedContext);if(enableLogging){console.log(`Feature variant ${flagName} requested:`,variant);}return variant;},[isInitialized,currentContext,enableLogging]);// Get all flags\nconst getAllFlags=useCallback(context=>{const mergedContext={...currentContext,...context};if(!isInitialized){return{...DEFAULT_FEATURE_FLAGS,...fallbackFlags};}return unleashService.getAllFlags(mergedContext);},[isInitialized,currentContext,fallbackFlags]);// Get flags by category\nconst getFlagsByCategory=useCallback((category,context)=>{const mergedContext={...currentContext,...context};if(!isInitialized){const categoryFlags=FEATURE_CATEGORIES[category];const result={};categoryFlags.forEach(flagName=>{var _fallbackFlags$key;const key=flagName;result[key]=(_fallbackFlags$key=fallbackFlags[key])!==null&&_fallbackFlags$key!==void 0?_fallbackFlags$key:DEFAULT_FEATURE_FLAGS[key];});return result;}return unleashService.getFlagsByCategory(category,mergedContext);},[isInitialized,currentContext,fallbackFlags]);// Update context\nconst updateContext=useCallback(newContext=>{setCurrentContext(prev=>({...prev,...newContext}));if(isInitialized){unleashService.updateContext(newContext);}if(enableLogging){console.log('Feature flags context updated:',newContext);}},[isInitialized,enableLogging]);// Refresh flags manually\nconst refresh=useCallback(()=>{if(isInitialized){setFlags(unleashService.getAllFlags(currentContext));setStatus(unleashService.getStatus());}if(enableLogging){console.log('Feature flags refreshed manually');}},[isInitialized,currentContext,enableLogging]);// Context value\nconst contextValue={isFeatureEnabled,getFeatureVariant,getAllFlags,getFlagsByCategory,updateContext,isReady,isInitialized,status,refresh};// Log provider status changes\nuseEffect(()=>{if(enableLogging){console.log('FeatureFlagsProvider status:',{isReady,isInitialized,flagCount:Object.keys(flags).length,status});}},[isReady,isInitialized,flags,status,enableLogging]);return/*#__PURE__*/_jsx(FeatureFlagsContext.Provider,{value:contextValue,children:children});};// Enhanced hook with better error handling\nexport const useFeatureFlags=()=>{const context=useContext(FeatureFlagsContext);if(context===undefined){throw new Error('useFeatureFlags must be used within a FeatureFlagsProvider');}return context;};// Convenience hooks for common patterns\nexport const useFeatureFlag=(flagName,context)=>{const{isFeatureEnabled,getFeatureVariant}=useFeatureFlags();return{isEnabled:isFeatureEnabled(flagName,context),variant:getFeatureVariant(flagName,context)};};export const useFeatureFlagWithFallback=function(flagName){let fallback=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let context=arguments.length>2?arguments[2]:undefined;const{isFeatureEnabled,isReady}=useFeatureFlags();if(!isReady){return fallback;}return isFeatureEnabled(flagName,context);};// Clean up on unmount\nexport const FeatureFlagsCleanup=()=>{useEffect(()=>{return()=>{unleashService.destroy();};},[]);return null;};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}