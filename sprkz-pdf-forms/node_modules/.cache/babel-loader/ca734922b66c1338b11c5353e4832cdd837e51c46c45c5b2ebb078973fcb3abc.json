{"ast":null,"code":"import { getClient, withIsolationScope } from './currentScopes.js';\nimport { captureException } from './exports.js';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE } from './semanticAttributes.js';\nimport { addNonEnumerableProperty } from './utils/object.js';\nimport { normalize } from './utils/normalize.js';\nimport { startSpanManual } from './tracing/trace.js';\nconst trpcCaptureContext = {\n  mechanism: {\n    handled: false,\n    data: {\n      function: 'trpcMiddleware'\n    }\n  }\n};\nfunction captureIfError(nextResult) {\n  // TODO: Set span status based on what TRPCError was encountered\n  if (typeof nextResult === 'object' && nextResult !== null && 'ok' in nextResult && !nextResult.ok && 'error' in nextResult) {\n    captureException(nextResult.error, trpcCaptureContext);\n  }\n}\n\n/**\n * Sentry tRPC middleware that captures errors and creates spans for tRPC procedures.\n */\nfunction trpcMiddleware() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return async function (opts) {\n    const {\n      path,\n      type,\n      next,\n      rawInput,\n      getRawInput\n    } = opts;\n    const client = getClient();\n    const clientOptions = client?.getOptions();\n    const trpcContext = {\n      procedure_path: path,\n      procedure_type: type\n    };\n    addNonEnumerableProperty(trpcContext, '__sentry_override_normalization_depth__', 1 + (\n    // 1 for context.input + the normal normalization depth\n    clientOptions?.normalizeDepth ?? 5) // 5 is a sane depth\n    );\n    if (options.attachRpcInput !== undefined ? options.attachRpcInput : clientOptions?.sendDefaultPii) {\n      if (rawInput !== undefined) {\n        trpcContext.input = normalize(rawInput);\n      }\n      if (getRawInput !== undefined && typeof getRawInput === 'function') {\n        try {\n          const rawRes = await getRawInput();\n          trpcContext.input = normalize(rawRes);\n        } catch {\n          // noop\n        }\n      }\n    }\n    return withIsolationScope(scope => {\n      scope.setContext('trpc', trpcContext);\n      return startSpanManual({\n        name: `trpc/${path}`,\n        op: 'rpc.server',\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.rpc.trpc'\n        },\n        forceTransaction: !!options.forceTransaction\n      }, async span => {\n        try {\n          const nextResult = await next();\n          captureIfError(nextResult);\n          span.end();\n          return nextResult;\n        } catch (e) {\n          captureException(e, trpcCaptureContext);\n          span.end();\n          throw e;\n        }\n      });\n    });\n  };\n}\nexport { trpcMiddleware };\n//# sourceMappingURL=trpc.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}