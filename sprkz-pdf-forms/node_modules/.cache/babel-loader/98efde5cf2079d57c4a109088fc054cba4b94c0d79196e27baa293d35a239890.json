{"ast":null,"code":"import { defineIntegration, spanToJSON, SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_URL_FULL, SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD, isString, stringMatchesSomePattern } from '@sentry/core';\nimport { SENTRY_XHR_DATA_KEY, getBodyString, getFetchRequestArgBody } from '@sentry-internal/browser-utils';\nconst INTEGRATION_NAME = 'GraphQLClient';\nconst _graphqlClientIntegration = options => {\n  return {\n    name: INTEGRATION_NAME,\n    setup(client) {\n      _updateSpanWithGraphQLData(client, options);\n      _updateBreadcrumbWithGraphQLData(client, options);\n    }\n  };\n};\nfunction _updateSpanWithGraphQLData(client, options) {\n  client.on('beforeOutgoingRequestSpan', (span, hint) => {\n    const spanJSON = spanToJSON(span);\n    const spanAttributes = spanJSON.data || {};\n    const spanOp = spanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_OP];\n    const isHttpClientSpan = spanOp === 'http.client';\n    if (!isHttpClientSpan) {\n      return;\n    }\n    const httpUrl = spanAttributes[SEMANTIC_ATTRIBUTE_URL_FULL] || spanAttributes['http.url'];\n    const httpMethod = spanAttributes[SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD] || spanAttributes['http.method'];\n    if (!isString(httpUrl) || !isString(httpMethod)) {\n      return;\n    }\n    const {\n      endpoints\n    } = options;\n    const isTracedGraphqlEndpoint = stringMatchesSomePattern(httpUrl, endpoints);\n    const payload = getRequestPayloadXhrOrFetch(hint);\n    if (isTracedGraphqlEndpoint && payload) {\n      const graphqlBody = getGraphQLRequestPayload(payload);\n      if (graphqlBody) {\n        const operationInfo = _getGraphQLOperation(graphqlBody);\n        span.updateName(`${httpMethod} ${httpUrl} (${operationInfo})`);\n        span.setAttribute('graphql.document', payload);\n      }\n    }\n  });\n}\nfunction _updateBreadcrumbWithGraphQLData(client, options) {\n  client.on('beforeOutgoingRequestBreadcrumb', (breadcrumb, handlerData) => {\n    const {\n      category,\n      type,\n      data\n    } = breadcrumb;\n    const isFetch = category === 'fetch';\n    const isXhr = category === 'xhr';\n    const isHttpBreadcrumb = type === 'http';\n    if (isHttpBreadcrumb && (isFetch || isXhr)) {\n      const httpUrl = data?.url;\n      const {\n        endpoints\n      } = options;\n      const isTracedGraphqlEndpoint = stringMatchesSomePattern(httpUrl, endpoints);\n      const payload = getRequestPayloadXhrOrFetch(handlerData);\n      if (isTracedGraphqlEndpoint && data && payload) {\n        const graphqlBody = getGraphQLRequestPayload(payload);\n        if (!data.graphql && graphqlBody) {\n          const operationInfo = _getGraphQLOperation(graphqlBody);\n          data['graphql.document'] = graphqlBody.query;\n          data['graphql.operation'] = operationInfo;\n        }\n      }\n    }\n  });\n}\n\n/**\n * @param requestBody - GraphQL request\n * @returns A formatted version of the request: 'TYPE NAME' or 'TYPE'\n */\nfunction _getGraphQLOperation(requestBody) {\n  const {\n    query: graphqlQuery,\n    operationName: graphqlOperationName\n  } = requestBody;\n  const {\n    operationName = graphqlOperationName,\n    operationType\n  } = parseGraphQLQuery(graphqlQuery);\n  const operationInfo = operationName ? `${operationType} ${operationName}` : `${operationType}`;\n  return operationInfo;\n}\n\n/**\n * Get the request body/payload based on the shape of the hint.\n *\n * Exported for tests only.\n */\nfunction getRequestPayloadXhrOrFetch(hint) {\n  const isXhr = 'xhr' in hint;\n  let body;\n  if (isXhr) {\n    const sentryXhrData = hint.xhr[SENTRY_XHR_DATA_KEY];\n    body = sentryXhrData && getBodyString(sentryXhrData.body)[0];\n  } else {\n    const sentryFetchData = getFetchRequestArgBody(hint.input);\n    body = getBodyString(sentryFetchData)[0];\n  }\n  return body;\n}\n\n/**\n * Extract the name and type of the operation from the GraphQL query.\n *\n * Exported for tests only.\n */\nfunction parseGraphQLQuery(query) {\n  const namedQueryRe = /^(?:\\s*)(query|mutation|subscription)(?:\\s*)(\\w+)(?:\\s*)[{(]/;\n  const unnamedQueryRe = /^(?:\\s*)(query|mutation|subscription)(?:\\s*)[{(]/;\n  const namedMatch = query.match(namedQueryRe);\n  if (namedMatch) {\n    return {\n      operationType: namedMatch[1],\n      operationName: namedMatch[2]\n    };\n  }\n  const unnamedMatch = query.match(unnamedQueryRe);\n  if (unnamedMatch) {\n    return {\n      operationType: unnamedMatch[1],\n      operationName: undefined\n    };\n  }\n  return {\n    operationType: undefined,\n    operationName: undefined\n  };\n}\n\n/**\n * Extract the payload of a request if it's GraphQL.\n * Exported for tests only.\n * @param payload - A valid JSON string\n * @returns A POJO or undefined\n */\nfunction getGraphQLRequestPayload(payload) {\n  let graphqlBody = undefined;\n  try {\n    const requestBody = JSON.parse(payload);\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const isGraphQLRequest = !!requestBody['query'];\n    if (isGraphQLRequest) {\n      graphqlBody = requestBody;\n    }\n  } finally {\n    // Fallback to undefined if payload is an invalid JSON (SyntaxError)\n\n    /* eslint-disable no-unsafe-finally */\n    return graphqlBody;\n  }\n}\n\n/**\n * This integration ensures that GraphQL requests made in the browser\n * have their GraphQL-specific data captured and attached to spans and breadcrumbs.\n */\nconst graphqlClientIntegration = defineIntegration(_graphqlClientIntegration);\nexport { getGraphQLRequestPayload, getRequestPayloadXhrOrFetch, graphqlClientIntegration, parseGraphQLQuery };","map":{"version":3,"names":["INTEGRATION_NAME","_graphqlClientIntegration","options","name","setup","client","_updateSpanWithGraphQLData","_updateBreadcrumbWithGraphQLData","on","span","hint","spanJSON","spanToJSON","spanAttributes","data","spanOp","SEMANTIC_ATTRIBUTE_SENTRY_OP","isHttpClientSpan","httpUrl","SEMANTIC_ATTRIBUTE_URL_FULL","httpMethod","SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD","isString","endpoints","isTracedGraphqlEndpoint","stringMatchesSomePattern","payload","getRequestPayloadXhrOrFetch","graphqlBody","getGraphQLRequestPayload","operationInfo","_getGraphQLOperation","updateName","setAttribute","breadcrumb","handlerData","category","type","isFetch","isXhr","isHttpBreadcrumb","url","graphql","query","requestBody","graphqlQuery","operationName","graphqlOperationName","operationType","parseGraphQLQuery","body","sentryXhrData","xhr","SENTRY_XHR_DATA_KEY","getBodyString","sentryFetchData","getFetchRequestArgBody","input","namedQueryRe","unnamedQueryRe","namedMatch","match","unnamedMatch","undefined","JSON","parse","isGraphQLRequest","graphqlClientIntegration","defineIntegration"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/browser/src/integrations/graphqlClient.ts"],"sourcesContent":["import type { Client, IntegrationFn } from '@sentry/core';\nimport {\n  defineIntegration,\n  isString,\n  SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_URL_FULL,\n  spanToJSON,\n  stringMatchesSomePattern,\n} from '@sentry/core';\nimport type { FetchHint, XhrHint } from '@sentry-internal/browser-utils';\nimport { getBodyString, getFetchRequestArgBody, SENTRY_XHR_DATA_KEY } from '@sentry-internal/browser-utils';\n\ninterface GraphQLClientOptions {\n  endpoints: Array<string | RegExp>;\n}\n\n/** Standard graphql request shape: https://graphql.org/learn/serving-over-http/#post-request-and-body */\ninterface GraphQLRequestPayload {\n  query: string;\n  operationName?: string;\n  variables?: Record<string, unknown>;\n  extensions?: Record<string, unknown>;\n}\n\ninterface GraphQLOperation {\n  operationType?: string;\n  operationName?: string;\n}\n\nconst INTEGRATION_NAME = 'GraphQLClient';\n\nconst _graphqlClientIntegration = ((options: GraphQLClientOptions) => {\n  return {\n    name: INTEGRATION_NAME,\n    setup(client) {\n      _updateSpanWithGraphQLData(client, options);\n      _updateBreadcrumbWithGraphQLData(client, options);\n    },\n  };\n}) satisfies IntegrationFn;\n\nfunction _updateSpanWithGraphQLData(client: Client, options: GraphQLClientOptions): void {\n  client.on('beforeOutgoingRequestSpan', (span, hint) => {\n    const spanJSON = spanToJSON(span);\n\n    const spanAttributes = spanJSON.data || {};\n    const spanOp = spanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_OP];\n\n    const isHttpClientSpan = spanOp === 'http.client';\n\n    if (!isHttpClientSpan) {\n      return;\n    }\n\n    const httpUrl = spanAttributes[SEMANTIC_ATTRIBUTE_URL_FULL] || spanAttributes['http.url'];\n    const httpMethod = spanAttributes[SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD] || spanAttributes['http.method'];\n\n    if (!isString(httpUrl) || !isString(httpMethod)) {\n      return;\n    }\n\n    const { endpoints } = options;\n    const isTracedGraphqlEndpoint = stringMatchesSomePattern(httpUrl, endpoints);\n    const payload = getRequestPayloadXhrOrFetch(hint as XhrHint | FetchHint);\n\n    if (isTracedGraphqlEndpoint && payload) {\n      const graphqlBody = getGraphQLRequestPayload(payload);\n\n      if (graphqlBody) {\n        const operationInfo = _getGraphQLOperation(graphqlBody);\n        span.updateName(`${httpMethod} ${httpUrl} (${operationInfo})`);\n        span.setAttribute('graphql.document', payload);\n      }\n    }\n  });\n}\n\nfunction _updateBreadcrumbWithGraphQLData(client: Client, options: GraphQLClientOptions): void {\n  client.on('beforeOutgoingRequestBreadcrumb', (breadcrumb, handlerData) => {\n    const { category, type, data } = breadcrumb;\n\n    const isFetch = category === 'fetch';\n    const isXhr = category === 'xhr';\n    const isHttpBreadcrumb = type === 'http';\n\n    if (isHttpBreadcrumb && (isFetch || isXhr)) {\n      const httpUrl = data?.url;\n      const { endpoints } = options;\n\n      const isTracedGraphqlEndpoint = stringMatchesSomePattern(httpUrl, endpoints);\n      const payload = getRequestPayloadXhrOrFetch(handlerData as XhrHint | FetchHint);\n\n      if (isTracedGraphqlEndpoint && data && payload) {\n        const graphqlBody = getGraphQLRequestPayload(payload);\n\n        if (!data.graphql && graphqlBody) {\n          const operationInfo = _getGraphQLOperation(graphqlBody);\n          data['graphql.document'] = graphqlBody.query;\n          data['graphql.operation'] = operationInfo;\n        }\n      }\n    }\n  });\n}\n\n/**\n * @param requestBody - GraphQL request\n * @returns A formatted version of the request: 'TYPE NAME' or 'TYPE'\n */\nfunction _getGraphQLOperation(requestBody: GraphQLRequestPayload): string {\n  const { query: graphqlQuery, operationName: graphqlOperationName } = requestBody;\n\n  const { operationName = graphqlOperationName, operationType } = parseGraphQLQuery(graphqlQuery);\n  const operationInfo = operationName ? `${operationType} ${operationName}` : `${operationType}`;\n\n  return operationInfo;\n}\n\n/**\n * Get the request body/payload based on the shape of the hint.\n *\n * Exported for tests only.\n */\nexport function getRequestPayloadXhrOrFetch(hint: XhrHint | FetchHint): string | undefined {\n  const isXhr = 'xhr' in hint;\n\n  let body: string | undefined;\n\n  if (isXhr) {\n    const sentryXhrData = hint.xhr[SENTRY_XHR_DATA_KEY];\n    body = sentryXhrData && getBodyString(sentryXhrData.body)[0];\n  } else {\n    const sentryFetchData = getFetchRequestArgBody(hint.input);\n    body = getBodyString(sentryFetchData)[0];\n  }\n\n  return body;\n}\n\n/**\n * Extract the name and type of the operation from the GraphQL query.\n *\n * Exported for tests only.\n */\nexport function parseGraphQLQuery(query: string): GraphQLOperation {\n  const namedQueryRe = /^(?:\\s*)(query|mutation|subscription)(?:\\s*)(\\w+)(?:\\s*)[{(]/;\n  const unnamedQueryRe = /^(?:\\s*)(query|mutation|subscription)(?:\\s*)[{(]/;\n\n  const namedMatch = query.match(namedQueryRe);\n  if (namedMatch) {\n    return {\n      operationType: namedMatch[1],\n      operationName: namedMatch[2],\n    };\n  }\n\n  const unnamedMatch = query.match(unnamedQueryRe);\n  if (unnamedMatch) {\n    return {\n      operationType: unnamedMatch[1],\n      operationName: undefined,\n    };\n  }\n  return {\n    operationType: undefined,\n    operationName: undefined,\n  };\n}\n\n/**\n * Extract the payload of a request if it's GraphQL.\n * Exported for tests only.\n * @param payload - A valid JSON string\n * @returns A POJO or undefined\n */\nexport function getGraphQLRequestPayload(payload: string): GraphQLRequestPayload | undefined {\n  let graphqlBody = undefined;\n  try {\n    const requestBody = JSON.parse(payload) satisfies GraphQLRequestPayload;\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const isGraphQLRequest = !!requestBody['query'];\n    if (isGraphQLRequest) {\n      graphqlBody = requestBody;\n    }\n  } finally {\n    // Fallback to undefined if payload is an invalid JSON (SyntaxError)\n\n    /* eslint-disable no-unsafe-finally */\n    return graphqlBody;\n  }\n}\n\n/**\n * This integration ensures that GraphQL requests made in the browser\n * have their GraphQL-specific data captured and attached to spans and breadcrumbs.\n */\nexport const graphqlClientIntegration = defineIntegration(_graphqlClientIntegration);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}