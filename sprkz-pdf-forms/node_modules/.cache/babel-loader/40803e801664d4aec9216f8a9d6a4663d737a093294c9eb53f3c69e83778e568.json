{"ast":null,"code":"import { DEBUG_BUILD } from '../debug-build.js';\nimport { debug } from '../utils/debug-logger.js';\nimport { envelopeContainsItemType } from '../utils/envelope.js';\nimport { parseRetryAfterHeader } from '../utils/ratelimit.js';\nconst MIN_DELAY = 100; // 100 ms\nconst START_DELAY = 5000; // 5 seconds\nconst MAX_DELAY = 3.6e6; // 1 hour\n\n/**\n * Wraps a transport and stores and retries events when they fail to send.\n *\n * @param createTransport The transport to wrap.\n */\nfunction makeOfflineTransport(createTransport) {\n  function log(...args) {\n    DEBUG_BUILD && debug.log('[Offline]:', ...args);\n  }\n  return options => {\n    const transport = createTransport(options);\n    if (!options.createStore) {\n      throw new Error('No `createStore` function was provided');\n    }\n    const store = options.createStore(options);\n    let retryDelay = START_DELAY;\n    let flushTimer;\n    function shouldQueue(env, error, retryDelay) {\n      // We want to drop client reports because they can be generated when we retry sending events while offline.\n      if (envelopeContainsItemType(env, ['client_report'])) {\n        return false;\n      }\n      if (options.shouldStore) {\n        return options.shouldStore(env, error, retryDelay);\n      }\n      return true;\n    }\n    function flushIn(delay) {\n      if (flushTimer) {\n        clearTimeout(flushTimer);\n      }\n      flushTimer = setTimeout(async () => {\n        flushTimer = undefined;\n        const found = await store.shift();\n        if (found) {\n          log('Attempting to send previously queued event');\n\n          // We should to update the sent_at timestamp to the current time.\n          found[0].sent_at = new Date().toISOString();\n          void send(found, true).catch(e => {\n            log('Failed to retry sending', e);\n          });\n        }\n      }, delay);\n\n      // We need to unref the timer in node.js, otherwise the node process never exit.\n      if (typeof flushTimer !== 'number' && flushTimer.unref) {\n        flushTimer.unref();\n      }\n    }\n    function flushWithBackOff() {\n      if (flushTimer) {\n        return;\n      }\n      flushIn(retryDelay);\n      retryDelay = Math.min(retryDelay * 2, MAX_DELAY);\n    }\n    async function send(envelope, isRetry = false) {\n      // We queue all replay envelopes to avoid multiple replay envelopes being sent at the same time. If one fails, we\n      // need to retry them in order.\n      if (!isRetry && envelopeContainsItemType(envelope, ['replay_event', 'replay_recording'])) {\n        await store.push(envelope);\n        flushIn(MIN_DELAY);\n        return {};\n      }\n      try {\n        if (options.shouldSend && (await options.shouldSend(envelope)) === false) {\n          throw new Error('Envelope not sent because `shouldSend` callback returned false');\n        }\n        const result = await transport.send(envelope);\n        let delay = MIN_DELAY;\n        if (result) {\n          // If there's a retry-after header, use that as the next delay.\n          if (result.headers?.['retry-after']) {\n            delay = parseRetryAfterHeader(result.headers['retry-after']);\n          } else if (result.headers?.['x-sentry-rate-limits']) {\n            delay = 60000; // 60 seconds\n          } // If we have a server error, return now so we don't flush the queue.\n          else if ((result.statusCode || 0) >= 400) {\n            return result;\n          }\n        }\n        flushIn(delay);\n        retryDelay = START_DELAY;\n        return result;\n      } catch (e) {\n        if (await shouldQueue(envelope, e, retryDelay)) {\n          // If this envelope was a retry, we want to add it to the front of the queue so it's retried again first.\n          if (isRetry) {\n            await store.unshift(envelope);\n          } else {\n            await store.push(envelope);\n          }\n          flushWithBackOff();\n          log('Error sending. Event queued.', e);\n          return {};\n        } else {\n          throw e;\n        }\n      }\n    }\n    if (options.flushAtStartup) {\n      flushWithBackOff();\n    }\n    return {\n      send,\n      flush: timeout => {\n        // If there's no timeout, we should attempt to flush the offline queue.\n        if (timeout === undefined) {\n          retryDelay = START_DELAY;\n          flushIn(MIN_DELAY);\n        }\n        return transport.flush(timeout);\n      }\n    };\n  };\n}\nexport { MIN_DELAY, START_DELAY, makeOfflineTransport };","map":{"version":3,"names":["MIN_DELAY","START_DELAY","MAX_DELAY","makeOfflineTransport","createTransport","log","args","DEBUG_BUILD","debug","options","transport","createStore","Error","store","retryDelay","flushTimer","shouldQueue","env","error","envelopeContainsItemType","shouldStore","flushIn","delay","clearTimeout","setTimeout","undefined","found","shift","sent_at","Date","toISOString","send","catch","e","unref","flushWithBackOff","Math","min","envelope","isRetry","push","shouldSend","result","headers","parseRetryAfterHeader","statusCode","unshift","flushAtStartup","flush","timeout"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/transports/offline.ts"],"sourcesContent":["import { DEBUG_BUILD } from '../debug-build';\nimport type { Envelope } from '../types-hoist/envelope';\nimport type { InternalBaseTransportOptions, Transport, TransportMakeRequestResponse } from '../types-hoist/transport';\nimport { debug } from '../utils/debug-logger';\nimport { envelopeContainsItemType } from '../utils/envelope';\nimport { parseRetryAfterHeader } from '../utils/ratelimit';\n\nexport const MIN_DELAY = 100; // 100 ms\nexport const START_DELAY = 5_000; // 5 seconds\nconst MAX_DELAY = 3.6e6; // 1 hour\n\nexport interface OfflineStore {\n  push(env: Envelope): Promise<void>;\n  unshift(env: Envelope): Promise<void>;\n  shift(): Promise<Envelope | undefined>;\n}\n\nexport type CreateOfflineStore = (options: OfflineTransportOptions) => OfflineStore;\n\nexport interface OfflineTransportOptions extends InternalBaseTransportOptions {\n  /**\n   * A function that creates the offline store instance.\n   */\n  createStore?: CreateOfflineStore;\n\n  /**\n   * Flush the offline store shortly after startup.\n   *\n   * Defaults: false\n   */\n  flushAtStartup?: boolean;\n\n  /**\n   * Called before an event is stored.\n   *\n   * Return false to drop the envelope rather than store it.\n   *\n   * @param envelope The envelope that failed to send.\n   * @param error The error that occurred.\n   * @param retryDelay The current retry delay in milliseconds.\n   * @returns Whether the envelope should be stored.\n   */\n  shouldStore?: (envelope: Envelope, error: Error, retryDelay: number) => boolean | Promise<boolean>;\n\n  /**\n   * Should an attempt be made to send the envelope to Sentry.\n   *\n   * If this function is supplied and returns false, `shouldStore` will be called to determine if the envelope should be stored.\n   *\n   * @param envelope The envelope that will be sent.\n   * @returns Whether we should attempt to send the envelope\n   */\n  shouldSend?: (envelope: Envelope) => boolean | Promise<boolean>;\n}\n\ntype Timer = number | { unref?: () => void };\n\n/**\n * Wraps a transport and stores and retries events when they fail to send.\n *\n * @param createTransport The transport to wrap.\n */\nexport function makeOfflineTransport<TO>(\n  createTransport: (options: TO) => Transport,\n): (options: TO & OfflineTransportOptions) => Transport {\n  function log(...args: unknown[]): void {\n    DEBUG_BUILD && debug.log('[Offline]:', ...args);\n  }\n\n  return options => {\n    const transport = createTransport(options);\n\n    if (!options.createStore) {\n      throw new Error('No `createStore` function was provided');\n    }\n\n    const store = options.createStore(options);\n\n    let retryDelay = START_DELAY;\n    let flushTimer: Timer | undefined;\n\n    function shouldQueue(env: Envelope, error: Error, retryDelay: number): boolean | Promise<boolean> {\n      // We want to drop client reports because they can be generated when we retry sending events while offline.\n      if (envelopeContainsItemType(env, ['client_report'])) {\n        return false;\n      }\n\n      if (options.shouldStore) {\n        return options.shouldStore(env, error, retryDelay);\n      }\n\n      return true;\n    }\n\n    function flushIn(delay: number): void {\n      if (flushTimer) {\n        clearTimeout(flushTimer as ReturnType<typeof setTimeout>);\n      }\n\n      flushTimer = setTimeout(async () => {\n        flushTimer = undefined;\n\n        const found = await store.shift();\n        if (found) {\n          log('Attempting to send previously queued event');\n\n          // We should to update the sent_at timestamp to the current time.\n          found[0].sent_at = new Date().toISOString();\n\n          void send(found, true).catch(e => {\n            log('Failed to retry sending', e);\n          });\n        }\n      }, delay) as Timer;\n\n      // We need to unref the timer in node.js, otherwise the node process never exit.\n      if (typeof flushTimer !== 'number' && flushTimer.unref) {\n        flushTimer.unref();\n      }\n    }\n\n    function flushWithBackOff(): void {\n      if (flushTimer) {\n        return;\n      }\n\n      flushIn(retryDelay);\n\n      retryDelay = Math.min(retryDelay * 2, MAX_DELAY);\n    }\n\n    async function send(envelope: Envelope, isRetry: boolean = false): Promise<TransportMakeRequestResponse> {\n      // We queue all replay envelopes to avoid multiple replay envelopes being sent at the same time. If one fails, we\n      // need to retry them in order.\n      if (!isRetry && envelopeContainsItemType(envelope, ['replay_event', 'replay_recording'])) {\n        await store.push(envelope);\n        flushIn(MIN_DELAY);\n        return {};\n      }\n\n      try {\n        if (options.shouldSend && (await options.shouldSend(envelope)) === false) {\n          throw new Error('Envelope not sent because `shouldSend` callback returned false');\n        }\n\n        const result = await transport.send(envelope);\n\n        let delay = MIN_DELAY;\n\n        if (result) {\n          // If there's a retry-after header, use that as the next delay.\n          if (result.headers?.['retry-after']) {\n            delay = parseRetryAfterHeader(result.headers['retry-after']);\n          } else if (result.headers?.['x-sentry-rate-limits']) {\n            delay = 60_000; // 60 seconds\n          } // If we have a server error, return now so we don't flush the queue.\n          else if ((result.statusCode || 0) >= 400) {\n            return result;\n          }\n        }\n\n        flushIn(delay);\n        retryDelay = START_DELAY;\n        return result;\n      } catch (e) {\n        if (await shouldQueue(envelope, e as Error, retryDelay)) {\n          // If this envelope was a retry, we want to add it to the front of the queue so it's retried again first.\n          if (isRetry) {\n            await store.unshift(envelope);\n          } else {\n            await store.push(envelope);\n          }\n          flushWithBackOff();\n          log('Error sending. Event queued.', e as Error);\n          return {};\n        } else {\n          throw e;\n        }\n      }\n    }\n\n    if (options.flushAtStartup) {\n      flushWithBackOff();\n    }\n\n    return {\n      send,\n      flush: timeout => {\n        // If there's no timeout, we should attempt to flush the offline queue.\n        if (timeout === undefined) {\n          retryDelay = START_DELAY;\n          flushIn(MIN_DELAY);\n        }\n\n        return transport.flush(timeout);\n      },\n    };\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}