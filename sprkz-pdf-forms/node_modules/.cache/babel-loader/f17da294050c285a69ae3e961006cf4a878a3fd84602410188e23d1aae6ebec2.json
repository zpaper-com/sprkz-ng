{"ast":null,"code":"import { defineIntegration } from '../integration.js';\nimport { relative, basename } from '../utils/path.js';\nimport { GLOBAL_OBJ } from '../utils/worldwide.js';\nconst INTEGRATION_NAME = 'RewriteFrames';\n\n/**\n * Rewrite event frames paths.\n */\nconst rewriteFramesIntegration = defineIntegration(function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const root = options.root;\n  const prefix = options.prefix || 'app:///';\n  const isBrowser = 'window' in GLOBAL_OBJ && !!GLOBAL_OBJ.window;\n  const iteratee = options.iteratee || generateIteratee({\n    isBrowser,\n    root,\n    prefix\n  });\n\n  /** Process an exception event. */\n  function _processExceptionsEvent(event) {\n    try {\n      return {\n        ...event,\n        exception: {\n          ...event.exception,\n          // The check for this is performed inside `process` call itself, safe to skip here\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          values: event.exception.values.map(value => ({\n            ...value,\n            ...(value.stacktrace && {\n              stacktrace: _processStacktrace(value.stacktrace)\n            })\n          }))\n        }\n      };\n    } catch {\n      return event;\n    }\n  }\n\n  /** Process a stack trace. */\n  function _processStacktrace(stacktrace) {\n    return {\n      ...stacktrace,\n      frames: stacktrace?.frames?.map(f => iteratee(f))\n    };\n  }\n  return {\n    name: INTEGRATION_NAME,\n    processEvent(originalEvent) {\n      let processedEvent = originalEvent;\n      if (originalEvent.exception && Array.isArray(originalEvent.exception.values)) {\n        processedEvent = _processExceptionsEvent(processedEvent);\n      }\n      return processedEvent;\n    }\n  };\n});\n\n/**\n * Exported only for tests.\n */\nfunction generateIteratee(_ref) {\n  let {\n    isBrowser,\n    root,\n    prefix\n  } = _ref;\n  return frame => {\n    if (!frame.filename) {\n      return frame;\n    }\n\n    // Determine if this is a Windows frame by checking for a Windows-style prefix such as `C:\\`\n    const isWindowsFrame = /^[a-zA-Z]:\\\\/.test(frame.filename) ||\n    // or the presence of a backslash without a forward slash (which are not allowed on Windows)\n    frame.filename.includes('\\\\') && !frame.filename.includes('/');\n\n    // Check if the frame filename begins with `/`\n    const startsWithSlash = /^\\//.test(frame.filename);\n    if (isBrowser) {\n      if (root) {\n        const oldFilename = frame.filename;\n        if (oldFilename.indexOf(root) === 0) {\n          frame.filename = oldFilename.replace(root, prefix);\n        }\n      }\n    } else {\n      if (isWindowsFrame || startsWithSlash) {\n        const filename = isWindowsFrame ? frame.filename.replace(/^[a-zA-Z]:/, '') // remove Windows-style prefix\n        .replace(/\\\\/g, '/') // replace all `\\\\` instances with `/`\n        : frame.filename;\n        const base = root ? relative(root, filename) : basename(filename);\n        frame.filename = `${prefix}${base}`;\n      }\n    }\n    return frame;\n  };\n}\nexport { generateIteratee, rewriteFramesIntegration };\n//# sourceMappingURL=rewriteframes.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}