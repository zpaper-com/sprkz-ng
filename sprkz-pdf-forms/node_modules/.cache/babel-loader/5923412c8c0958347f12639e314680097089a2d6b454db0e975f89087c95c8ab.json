{"ast":null,"code":"import { isThenable } from './is.js';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/** SyncPromise internal states */\nconst STATE_PENDING = 0;\nconst STATE_RESOLVED = 1;\nconst STATE_REJECTED = 2;\n\n/**\n * Creates a resolved sync promise.\n *\n * @param value the value to resolve the promise with\n * @returns the resolved sync promise\n */\nfunction resolvedSyncPromise(value) {\n  return new SyncPromise(resolve => {\n    resolve(value);\n  });\n}\n\n/**\n * Creates a rejected sync promise.\n *\n * @param value the value to reject the promise with\n * @returns the rejected sync promise\n */\nfunction rejectedSyncPromise(reason) {\n  return new SyncPromise((_, reject) => {\n    reject(reason);\n  });\n}\n\n/**\n * Thenable class that behaves like a Promise and follows it's interface\n * but is not async internally\n */\nclass SyncPromise {\n  constructor(executor) {\n    this._state = STATE_PENDING;\n    this._handlers = [];\n    this._runExecutor(executor);\n  }\n\n  /** @inheritdoc */\n  then(onfulfilled, onrejected) {\n    return new SyncPromise((resolve, reject) => {\n      this._handlers.push([false, result => {\n        if (!onfulfilled) {\n          // TODO: ¯\\_(ツ)_/¯\n          // TODO: FIXME\n          resolve(result);\n        } else {\n          try {\n            resolve(onfulfilled(result));\n          } catch (e) {\n            reject(e);\n          }\n        }\n      }, reason => {\n        if (!onrejected) {\n          reject(reason);\n        } else {\n          try {\n            resolve(onrejected(reason));\n          } catch (e) {\n            reject(e);\n          }\n        }\n      }]);\n      this._executeHandlers();\n    });\n  }\n\n  /** @inheritdoc */\n  catch(onrejected) {\n    return this.then(val => val, onrejected);\n  }\n\n  /** @inheritdoc */\n  finally(onfinally) {\n    return new SyncPromise((resolve, reject) => {\n      let val;\n      let isRejected;\n      return this.then(value => {\n        isRejected = false;\n        val = value;\n        if (onfinally) {\n          onfinally();\n        }\n      }, reason => {\n        isRejected = true;\n        val = reason;\n        if (onfinally) {\n          onfinally();\n        }\n      }).then(() => {\n        if (isRejected) {\n          reject(val);\n          return;\n        }\n        resolve(val);\n      });\n    });\n  }\n\n  /** Excute the resolve/reject handlers. */\n  _executeHandlers() {\n    if (this._state === STATE_PENDING) {\n      return;\n    }\n    const cachedHandlers = this._handlers.slice();\n    this._handlers = [];\n    cachedHandlers.forEach(handler => {\n      if (handler[0]) {\n        return;\n      }\n      if (this._state === STATE_RESOLVED) {\n        handler[1](this._value);\n      }\n      if (this._state === STATE_REJECTED) {\n        handler[2](this._value);\n      }\n      handler[0] = true;\n    });\n  }\n\n  /** Run the executor for the SyncPromise. */\n  _runExecutor(executor) {\n    const setResult = (state, value) => {\n      if (this._state !== STATE_PENDING) {\n        return;\n      }\n      if (isThenable(value)) {\n        void value.then(resolve, reject);\n        return;\n      }\n      this._state = state;\n      this._value = value;\n      this._executeHandlers();\n    };\n    const resolve = value => {\n      setResult(STATE_RESOLVED, value);\n    };\n    const reject = reason => {\n      setResult(STATE_REJECTED, reason);\n    };\n    try {\n      executor(resolve, reject);\n    } catch (e) {\n      reject(e);\n    }\n  }\n}\nexport { SyncPromise, rejectedSyncPromise, resolvedSyncPromise };\n//# sourceMappingURL=syncpromise.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}