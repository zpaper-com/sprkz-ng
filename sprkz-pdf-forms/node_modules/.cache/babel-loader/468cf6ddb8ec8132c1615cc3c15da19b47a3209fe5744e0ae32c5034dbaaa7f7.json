{"ast":null,"code":"import*as pdfjsLib from'pdfjs-dist';import{isFeatureEnabled}from'./unleashService';// Configure PDF.js worker\npdfjsLib.GlobalWorkerOptions.workerSrc=process.env.REACT_APP_PDF_WORKER_URL||'/pdf.worker.min.mjs';export class PDFService{// Maximum number of pages to cache\n/**\n   * Load PDF document from URL or data\n   */static async loadDocument(options){const startTime=performance.now();// Check feature flags for PDF processing options\nconst enableLazyLoading=isFeatureEnabled('PDF_LAZY_LOADING');const enablePerformanceMonitoring=isFeatureEnabled('PERFORMANCE_MONITORING');if(enablePerformanceMonitoring){console.log('PDF loading started:',options);}try{const cacheKey=options.url||'data-pdf';// Check cache first (if lazy loading is enabled)\nif(enableLazyLoading&&options.url&&this.loadedDocuments.has(cacheKey)){if(enablePerformanceMonitoring){const duration=performance.now()-startTime;console.log(`PDF loaded from cache in ${duration.toFixed(2)}ms`);}return this.loadedDocuments.get(cacheKey);}const loadingTask=options.url?pdfjsLib.getDocument({url:options.url,withCredentials:options.withCredentials||false}):pdfjsLib.getDocument({data:options.data});const pdfDoc=await loadingTask.promise;// Cache the document (if lazy loading is enabled)\nif(enableLazyLoading&&options.url){this.loadedDocuments.set(cacheKey,pdfDoc);}if(enablePerformanceMonitoring){const duration=performance.now()-startTime;console.log(`PDF loaded successfully in ${duration.toFixed(2)}ms. Pages: ${pdfDoc.numPages}`);}return pdfDoc;}catch(error){const duration=performance.now()-startTime;const pdfError={type:'LOADING_FAILED',message:`Failed to load PDF after ${duration.toFixed(2)}ms: ${error instanceof Error?error.message:'Unknown error'}`,originalError:error instanceof Error?error:new Error(String(error))};console.error('PDF loading error:',pdfError);throw pdfError;}}/**\n   * Get a specific page from the PDF document\n   */static async getPage(pdfDoc,pageNumber){const startTime=performance.now();const cacheKey=`${pdfDoc.fingerprints[0]}-page-${pageNumber}`;// Feature flags\nconst enableLazyLoading=isFeatureEnabled('PDF_LAZY_LOADING');const enablePerformanceMonitoring=isFeatureEnabled('PERFORMANCE_MONITORING');try{// Check cache first (if lazy loading enabled)\nif(enableLazyLoading&&this.loadedPages.has(cacheKey)){if(enablePerformanceMonitoring){const duration=performance.now()-startTime;console.log(`Page ${pageNumber} loaded from cache in ${duration.toFixed(2)}ms`);}return this.loadedPages.get(cacheKey);}if(pageNumber<1||pageNumber>pdfDoc.numPages){throw new Error(`Invalid page number: ${pageNumber}. Document has ${pdfDoc.numPages} pages.`);}const page=await pdfDoc.getPage(pageNumber);// Cache the page with size management\nthis.manageCacheSize();this.loadedPages.set(cacheKey,page);const duration=performance.now()-startTime;console.log(`Page ${pageNumber} loaded in ${duration.toFixed(2)}ms`);return page;}catch(error){const duration=performance.now()-startTime;const pdfError={type:'LOADING_FAILED',message:`Failed to load page ${pageNumber} after ${duration.toFixed(2)}ms: ${error instanceof Error?error.message:'Unknown error'}`,originalError:error instanceof Error?error:new Error(String(error))};console.error('Page loading error:',pdfError);throw pdfError;}}/**\n   * Render page to canvas with proper scaling\n   */static async renderPageToCanvas(page,canvas){let scale=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;const startTime=performance.now();try{const viewport=page.getViewport({scale});const context=canvas.getContext('2d');if(!context){throw new Error('Could not get 2D context from canvas');}// Set canvas dimensions\ncanvas.width=viewport.width;canvas.height=viewport.height;canvas.style.width=`${viewport.width}px`;canvas.style.height=`${viewport.height}px`;const renderContext={canvasContext:context,viewport:viewport};await page.render(renderContext).promise;const duration=performance.now()-startTime;console.log(`Page rendered to canvas in ${duration.toFixed(2)}ms (${viewport.width}x${viewport.height})`);}catch(error){const duration=performance.now()-startTime;const pdfError={type:'RENDERING_FAILED',message:`Failed to render page to canvas after ${duration.toFixed(2)}ms: ${error instanceof Error?error.message:'Unknown error'}`,originalError:error instanceof Error?error:new Error(String(error))};console.error('Canvas rendering error:',pdfError);throw pdfError;}}/**\n   * Extract text content from a page\n   */static async extractTextContent(page){try{const textContent=await page.getTextContent();return textContent.items.map(item=>'str'in item?item.str:'').join(' ');}catch(error){const pdfError={type:'PARSING_FAILED',message:`Failed to extract text content: ${error instanceof Error?error.message:'Unknown error'}`,originalError:error instanceof Error?error:new Error(String(error))};console.error('Text extraction error:',pdfError);throw pdfError;}}/**\n   * Extract form fields from a page using annotation layer\n   */static async extractFormFields(page){try{const annotations=await page.getAnnotations({intent:'display'});const formFields=[];for(const annotation of annotations){if(annotation.subtype==='Widget'){const field={name:annotation.fieldName||`field_${annotation.id}`,type:annotation.fieldType||'unknown',value:annotation.fieldValue||'',required:!annotation.readOnly&&(annotation.required||false),readOnly:annotation.readOnly||false,page:page.pageNumber,rect:annotation.rect,options:annotation.options||null,multiline:annotation.multiLine||false,maxLength:annotation.maxLen||null,id:annotation.id,subtype:annotation.subtype};formFields.push(field);}}console.log(`Extracted ${formFields.length} form fields from page ${page.pageNumber}`);return formFields;}catch(error){const pdfError={type:'PARSING_FAILED',message:`Failed to extract form fields: ${error instanceof Error?error.message:'Unknown error'}`,originalError:error instanceof Error?error:new Error(String(error))};console.error('Form field extraction error:',pdfError);throw pdfError;}}/**\n   * Generate thumbnail for a page\n   */static async generateThumbnail(page){let maxWidth=arguments.length>1&&arguments[1]!==undefined?arguments[1]:150;const startTime=performance.now();const cacheKey=`${page.pageNumber}-${maxWidth}`;// Check thumbnail cache first\nif(this.thumbnailCache.has(cacheKey)){const cachedThumbnail=this.thumbnailCache.get(cacheKey);console.log(`Thumbnail loaded from cache in 0ms`);return cachedThumbnail;}try{const viewport=page.getViewport({scale:1});const scale=maxWidth/viewport.width;const scaledViewport=page.getViewport({scale});const canvas=document.createElement('canvas');const context=canvas.getContext('2d');if(!context){throw new Error('Could not create canvas context for thumbnail');}canvas.width=scaledViewport.width;canvas.height=scaledViewport.height;await page.render({canvasContext:context,viewport:scaledViewport}).promise;const thumbnailDataUrl=canvas.toDataURL('image/png');// Cache the thumbnail\nthis.thumbnailCache.set(cacheKey,thumbnailDataUrl);const duration=performance.now()-startTime;console.log(`Thumbnail generated in ${duration.toFixed(2)}ms (${canvas.width}x${canvas.height})`);return thumbnailDataUrl;}catch(error){const duration=performance.now()-startTime;const pdfError={type:'RENDERING_FAILED',message:`Failed to generate thumbnail after ${duration.toFixed(2)}ms: ${error instanceof Error?error.message:'Unknown error'}`,originalError:error instanceof Error?error:new Error(String(error))};console.error('Thumbnail generation error:',pdfError);throw pdfError;}}/**\n   * Preload adjacent pages for smooth navigation\n   */static async preloadAdjacentPages(pdfDoc,currentPage){let range=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;const pagesToPreload=[];for(let i=Math.max(1,currentPage-range);i<=Math.min(pdfDoc.numPages,currentPage+range);i++){if(i!==currentPage){pagesToPreload.push(i);}}const preloadPromises=pagesToPreload.map(async pageNum=>{try{await this.getPage(pdfDoc,pageNum);console.log(`Preloaded page ${pageNum}`);}catch(error){console.warn(`Failed to preload page ${pageNum}:`,error);}});await Promise.allSettled(preloadPromises);}/**\n   * Manage cache size to prevent memory leaks\n   */static manageCacheSize(){if(this.loadedPages.size>this.maxCacheSize){const keysToDelete=Array.from(this.loadedPages.keys()).slice(0,10);// Remove oldest 10 entries\nkeysToDelete.forEach(key=>this.loadedPages.delete(key));console.log(`Cache cleaned up - removed ${keysToDelete.length} pages`);}}/**\n   * Clean up cached resources\n   */static cleanup(documentUrl){if(documentUrl){this.loadedDocuments.delete(documentUrl);// Clean up related pages\nconst keysToDelete=Array.from(this.loadedPages.keys()).filter(key=>key.includes(documentUrl));keysToDelete.forEach(key=>this.loadedPages.delete(key));}else{// Clean up all cached resources\nthis.loadedDocuments.clear();this.loadedPages.clear();this.thumbnailCache.clear();}console.log('PDF service cache cleaned up');}/**\n   * Get default PDF URL from environment or URL parameter\n   */static getDefaultPDFUrl(){// Check URL parameter first\nconst urlParams=new URLSearchParams(window.location.search);const pdfParam=urlParams.get('f')||urlParams.get('file')||urlParams.get('pdf');if(pdfParam){// Resolve relative paths to pdfs directory\nif(!pdfParam.startsWith('http')&&!pdfParam.startsWith('/')){return`/pdfs/${pdfParam}`;}return pdfParam;}// Return default PDF from environment\nreturn process.env.REACT_APP_DEFAULT_PDF||'/pdfs/makana2025.pdf';}}PDFService.loadedDocuments=new Map();PDFService.loadedPages=new Map();PDFService.thumbnailCache=new Map();PDFService.maxCacheSize=50;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}