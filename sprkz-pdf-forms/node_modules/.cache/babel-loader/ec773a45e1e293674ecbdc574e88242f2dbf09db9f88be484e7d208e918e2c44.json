{"ast":null,"code":"import { TRACING_DEFAULTS, getLocationHref, browserPerformanceTimeOrigin, parseStringToURLObject, registerSpanErrorInstrumentation, GLOBAL_OBJ, getClient, debug, getIsolationScope, generateTraceId, getCurrentScope, propagationContextFromHeaders, spanToJSON, dateTimestampInSeconds, timestampInSeconds, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, startInactiveSpan, startIdleSpan, getDynamicSamplingContextFromSpan, spanIsSampled, SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON, addNonEnumerableProperty, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '@sentry/core';\nimport { addHistoryInstrumentationHandler, registerInpInteractionListener, startTrackingWebVitals, startTrackingINP, startTrackingElementTiming, startTrackingLongAnimationFrames, startTrackingLongTasks, startTrackingInteractions, addPerformanceEntries } from '@sentry-internal/browser-utils';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { WINDOW, getHttpRequestData } from '../helpers.js';\nimport { registerBackgroundTabDetection } from './backgroundtab.js';\nimport { linkTraces } from './linkedTraces.js';\nimport { defaultRequestInstrumentationOptions, instrumentOutgoingRequests } from './request.js';\nconst BROWSER_TRACING_INTEGRATION_ID = 'BrowserTracing';\nconst DEFAULT_BROWSER_TRACING_OPTIONS = {\n  ...TRACING_DEFAULTS,\n  instrumentNavigation: true,\n  instrumentPageLoad: true,\n  markBackgroundSpan: true,\n  enableLongTask: true,\n  enableLongAnimationFrame: true,\n  enableInp: true,\n  enableElementTiming: true,\n  ignoreResourceSpans: [],\n  ignorePerformanceApiSpans: [],\n  detectRedirects: true,\n  linkPreviousTrace: 'in-memory',\n  consistentTraceSampling: false,\n  _experiments: {},\n  ...defaultRequestInstrumentationOptions\n};\n\n/**\n * The Browser Tracing integration automatically instruments browser pageload/navigation\n * actions as transactions, and captures requests, metrics and errors as spans.\n *\n * The integration can be configured with a variety of options, and can be extended to use\n * any routing library.\n *\n * We explicitly export the proper type here, as this has to be extended in some cases.\n */\nconst browserTracingIntegration = (_options = {}) => {\n  const latestRoute = {\n    name: undefined,\n    source: undefined\n  };\n\n  /**\n   * This is just a small wrapper that makes `document` optional.\n   * We want to be extra-safe and always check that this exists, to ensure weird environments do not blow up.\n   */\n  const optionalWindowDocument = WINDOW.document;\n  const {\n    enableInp,\n    enableElementTiming,\n    enableLongTask,\n    enableLongAnimationFrame,\n    _experiments: {\n      enableInteractions,\n      enableStandaloneClsSpans,\n      enableStandaloneLcpSpans\n    },\n    beforeStartSpan,\n    idleTimeout,\n    finalTimeout,\n    childSpanTimeout,\n    markBackgroundSpan,\n    traceFetch,\n    traceXHR,\n    trackFetchStreamPerformance,\n    shouldCreateSpanForRequest,\n    enableHTTPTimings,\n    ignoreResourceSpans,\n    ignorePerformanceApiSpans,\n    instrumentPageLoad,\n    instrumentNavigation,\n    detectRedirects,\n    linkPreviousTrace,\n    consistentTraceSampling,\n    onRequestSpanStart\n  } = {\n    ...DEFAULT_BROWSER_TRACING_OPTIONS,\n    ..._options\n  };\n  let _collectWebVitals;\n  let lastInteractionTimestamp;\n\n  /** Create routing idle transaction. */\n  function _createRouteSpan(client, startSpanOptions, makeActive = true) {\n    const isPageloadTransaction = startSpanOptions.op === 'pageload';\n    const finalStartSpanOptions = beforeStartSpan ? beforeStartSpan(startSpanOptions) : startSpanOptions;\n    const attributes = finalStartSpanOptions.attributes || {};\n\n    // If `finalStartSpanOptions.name` is different than `startSpanOptions.name`\n    // it is because `beforeStartSpan` set a custom name. Therefore we set the source to 'custom'.\n    if (startSpanOptions.name !== finalStartSpanOptions.name) {\n      attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] = 'custom';\n      finalStartSpanOptions.attributes = attributes;\n    }\n    if (!makeActive) {\n      // We want to ensure this has 0s duration\n      const now = dateTimestampInSeconds();\n      startInactiveSpan({\n        ...finalStartSpanOptions,\n        startTime: now\n      }).end(now);\n      return;\n    }\n    latestRoute.name = finalStartSpanOptions.name;\n    latestRoute.source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n    const idleSpan = startIdleSpan(finalStartSpanOptions, {\n      idleTimeout,\n      finalTimeout,\n      childSpanTimeout,\n      // should wait for finish signal if it's a pageload transaction\n      disableAutoFinish: isPageloadTransaction,\n      beforeSpanEnd: span => {\n        // This will generally always be defined here, because it is set in `setup()` of the integration\n        // but technically, it is optional, so we guard here to be extra safe\n        _collectWebVitals?.();\n        addPerformanceEntries(span, {\n          recordClsOnPageloadSpan: !enableStandaloneClsSpans,\n          recordLcpOnPageloadSpan: !enableStandaloneLcpSpans,\n          ignoreResourceSpans,\n          ignorePerformanceApiSpans\n        });\n        setActiveIdleSpan(client, undefined);\n\n        // A trace should stay consistent over the entire timespan of one route - even after the pageload/navigation ended.\n        // Only when another navigation happens, we want to create a new trace.\n        // This way, e.g. errors that occur after the pageload span ended are still associated to the pageload trace.\n        const scope = getCurrentScope();\n        const oldPropagationContext = scope.getPropagationContext();\n        scope.setPropagationContext({\n          ...oldPropagationContext,\n          traceId: idleSpan.spanContext().traceId,\n          sampled: spanIsSampled(idleSpan),\n          dsc: getDynamicSamplingContextFromSpan(span)\n        });\n      }\n    });\n    setActiveIdleSpan(client, idleSpan);\n    function emitFinish() {\n      if (optionalWindowDocument && ['interactive', 'complete'].includes(optionalWindowDocument.readyState)) {\n        client.emit('idleSpanEnableAutoFinish', idleSpan);\n      }\n    }\n    if (isPageloadTransaction && optionalWindowDocument) {\n      optionalWindowDocument.addEventListener('readystatechange', () => {\n        emitFinish();\n      });\n      emitFinish();\n    }\n  }\n  return {\n    name: BROWSER_TRACING_INTEGRATION_ID,\n    setup(client) {\n      registerSpanErrorInstrumentation();\n      _collectWebVitals = startTrackingWebVitals({\n        recordClsStandaloneSpans: enableStandaloneClsSpans || false,\n        recordLcpStandaloneSpans: enableStandaloneLcpSpans || false,\n        client\n      });\n      if (enableInp) {\n        startTrackingINP();\n      }\n      if (enableElementTiming) {\n        startTrackingElementTiming();\n      }\n      if (enableLongAnimationFrame && GLOBAL_OBJ.PerformanceObserver && PerformanceObserver.supportedEntryTypes && PerformanceObserver.supportedEntryTypes.includes('long-animation-frame')) {\n        startTrackingLongAnimationFrames();\n      } else if (enableLongTask) {\n        startTrackingLongTasks();\n      }\n      if (enableInteractions) {\n        startTrackingInteractions();\n      }\n      if (detectRedirects && optionalWindowDocument) {\n        const interactionHandler = () => {\n          lastInteractionTimestamp = timestampInSeconds();\n        };\n        addEventListener('click', interactionHandler, {\n          capture: true\n        });\n        addEventListener('keydown', interactionHandler, {\n          capture: true,\n          passive: true\n        });\n      }\n      function maybeEndActiveSpan() {\n        const activeSpan = getActiveIdleSpan(client);\n        if (activeSpan && !spanToJSON(activeSpan).timestamp) {\n          DEBUG_BUILD && debug.log(`[Tracing] Finishing current active span with op: ${spanToJSON(activeSpan).op}`);\n          // If there's an open active span, we need to finish it before creating an new one.\n          activeSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON, 'cancelled');\n          activeSpan.end();\n        }\n      }\n      client.on('startNavigationSpan', (startSpanOptions, navigationOptions) => {\n        if (getClient() !== client) {\n          return;\n        }\n        if (navigationOptions?.isRedirect) {\n          DEBUG_BUILD && debug.warn('[Tracing] Detected redirect, navigation span will not be the root span, but a child span.');\n          _createRouteSpan(client, {\n            op: 'navigation.redirect',\n            ...startSpanOptions\n          }, false);\n          return;\n        }\n        maybeEndActiveSpan();\n        getIsolationScope().setPropagationContext({\n          traceId: generateTraceId(),\n          sampleRand: Math.random()\n        });\n        const scope = getCurrentScope();\n        scope.setPropagationContext({\n          traceId: generateTraceId(),\n          sampleRand: Math.random()\n        });\n        // We reset this to ensure we do not have lingering incorrect data here\n        // places that call this hook may set this where appropriate - else, the URL at span sending time is used\n        scope.setSDKProcessingMetadata({\n          normalizedRequest: undefined\n        });\n        _createRouteSpan(client, {\n          op: 'navigation',\n          ...startSpanOptions\n        });\n      });\n      client.on('startPageLoadSpan', (startSpanOptions, traceOptions = {}) => {\n        if (getClient() !== client) {\n          return;\n        }\n        maybeEndActiveSpan();\n        const sentryTrace = traceOptions.sentryTrace || getMetaContent('sentry-trace');\n        const baggage = traceOptions.baggage || getMetaContent('baggage');\n        const propagationContext = propagationContextFromHeaders(sentryTrace, baggage);\n        const scope = getCurrentScope();\n        scope.setPropagationContext(propagationContext);\n\n        // We store the normalized request data on the scope, so we get the request data at time of span creation\n        // otherwise, the URL etc. may already be of the following navigation, and we'd report the wrong URL\n        scope.setSDKProcessingMetadata({\n          normalizedRequest: getHttpRequestData()\n        });\n        _createRouteSpan(client, {\n          op: 'pageload',\n          ...startSpanOptions\n        });\n      });\n    },\n    afterAllSetup(client) {\n      let startingUrl = getLocationHref();\n      if (linkPreviousTrace !== 'off') {\n        linkTraces(client, {\n          linkPreviousTrace,\n          consistentTraceSampling\n        });\n      }\n      if (WINDOW.location) {\n        if (instrumentPageLoad) {\n          const origin = browserPerformanceTimeOrigin();\n          startBrowserTracingPageLoadSpan(client, {\n            name: WINDOW.location.pathname,\n            // pageload should always start at timeOrigin (and needs to be in s, not ms)\n            startTime: origin ? origin / 1000 : undefined,\n            attributes: {\n              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.pageload.browser'\n            }\n          });\n        }\n        if (instrumentNavigation) {\n          addHistoryInstrumentationHandler(({\n            to,\n            from\n          }) => {\n            /**\n             * This early return is there to account for some cases where a navigation transaction starts right after\n             * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't\n             * create an uneccessary navigation transaction.\n             *\n             * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also\n             * only be caused in certain development environments where the usage of a hot module reloader is causing\n             * errors.\n             */\n            if (from === undefined && startingUrl?.indexOf(to) !== -1) {\n              startingUrl = undefined;\n              return;\n            }\n            startingUrl = undefined;\n            const parsed = parseStringToURLObject(to);\n            const activeSpan = getActiveIdleSpan(client);\n            const navigationIsRedirect = activeSpan && detectRedirects && isRedirect(activeSpan, lastInteractionTimestamp);\n            startBrowserTracingNavigationSpan(client, {\n              name: parsed?.pathname || WINDOW.location.pathname,\n              attributes: {\n                [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n                [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.browser'\n              }\n            }, {\n              url: to,\n              isRedirect: navigationIsRedirect\n            });\n          });\n        }\n      }\n      if (markBackgroundSpan) {\n        registerBackgroundTabDetection();\n      }\n      if (enableInteractions) {\n        registerInteractionListener(client, idleTimeout, finalTimeout, childSpanTimeout, latestRoute);\n      }\n      if (enableInp) {\n        registerInpInteractionListener();\n      }\n      instrumentOutgoingRequests(client, {\n        traceFetch,\n        traceXHR,\n        trackFetchStreamPerformance,\n        tracePropagationTargets: client.getOptions().tracePropagationTargets,\n        shouldCreateSpanForRequest,\n        enableHTTPTimings,\n        onRequestSpanStart\n      });\n    }\n  };\n};\n\n/**\n * Manually start a page load span.\n * This will only do something if a browser tracing integration integration has been setup.\n *\n * If you provide a custom `traceOptions` object, it will be used to continue the trace\n * instead of the default behavior, which is to look it up on the <meta> tags.\n */\nfunction startBrowserTracingPageLoadSpan(client, spanOptions, traceOptions) {\n  client.emit('startPageLoadSpan', spanOptions, traceOptions);\n  getCurrentScope().setTransactionName(spanOptions.name);\n  const pageloadSpan = getActiveIdleSpan(client);\n  if (pageloadSpan) {\n    client.emit('afterStartPageLoadSpan', pageloadSpan);\n  }\n  return pageloadSpan;\n}\n\n/**\n * Manually start a navigation span.\n * This will only do something if a browser tracing integration has been setup.\n */\nfunction startBrowserTracingNavigationSpan(client, spanOptions, options) {\n  const {\n    url,\n    isRedirect\n  } = options || {};\n  client.emit('beforeStartNavigationSpan', spanOptions, {\n    isRedirect\n  });\n  client.emit('startNavigationSpan', spanOptions, {\n    isRedirect\n  });\n  const scope = getCurrentScope();\n  scope.setTransactionName(spanOptions.name);\n\n  // We store the normalized request data on the scope, so we get the request data at time of span creation\n  // otherwise, the URL etc. may already be of the following navigation, and we'd report the wrong URL\n  if (url && !isRedirect) {\n    scope.setSDKProcessingMetadata({\n      normalizedRequest: {\n        ...getHttpRequestData(),\n        url\n      }\n    });\n  }\n  return getActiveIdleSpan(client);\n}\n\n/** Returns the value of a meta tag */\nfunction getMetaContent(metaName) {\n  /**\n   * This is just a small wrapper that makes `document` optional.\n   * We want to be extra-safe and always check that this exists, to ensure weird environments do not blow up.\n   */\n  const optionalWindowDocument = WINDOW.document;\n  const metaTag = optionalWindowDocument?.querySelector(`meta[name=${metaName}]`);\n  return metaTag?.getAttribute('content') || undefined;\n}\n\n/** Start listener for interaction transactions */\nfunction registerInteractionListener(client, idleTimeout, finalTimeout, childSpanTimeout, latestRoute) {\n  /**\n   * This is just a small wrapper that makes `document` optional.\n   * We want to be extra-safe and always check that this exists, to ensure weird environments do not blow up.\n   */\n  const optionalWindowDocument = WINDOW.document;\n  let inflightInteractionSpan;\n  const registerInteractionTransaction = () => {\n    const op = 'ui.action.click';\n    const activeIdleSpan = getActiveIdleSpan(client);\n    if (activeIdleSpan) {\n      const currentRootSpanOp = spanToJSON(activeIdleSpan).op;\n      if (['navigation', 'pageload'].includes(currentRootSpanOp)) {\n        DEBUG_BUILD && debug.warn(`[Tracing] Did not create ${op} span because a pageload or navigation span is in progress.`);\n        return undefined;\n      }\n    }\n    if (inflightInteractionSpan) {\n      inflightInteractionSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON, 'interactionInterrupted');\n      inflightInteractionSpan.end();\n      inflightInteractionSpan = undefined;\n    }\n    if (!latestRoute.name) {\n      DEBUG_BUILD && debug.warn(`[Tracing] Did not create ${op} transaction because _latestRouteName is missing.`);\n      return undefined;\n    }\n    inflightInteractionSpan = startIdleSpan({\n      name: latestRoute.name,\n      op,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: latestRoute.source || 'url'\n      }\n    }, {\n      idleTimeout,\n      finalTimeout,\n      childSpanTimeout\n    });\n  };\n  if (optionalWindowDocument) {\n    addEventListener('click', registerInteractionTransaction, {\n      capture: true\n    });\n  }\n}\n\n// We store the active idle span on the client object, so we can access it from exported functions\nconst ACTIVE_IDLE_SPAN_PROPERTY = '_sentry_idleSpan';\nfunction getActiveIdleSpan(client) {\n  return client[ACTIVE_IDLE_SPAN_PROPERTY];\n}\nfunction setActiveIdleSpan(client, span) {\n  addNonEnumerableProperty(client, ACTIVE_IDLE_SPAN_PROPERTY, span);\n}\n\n// The max. time in seconds between two pageload/navigation spans that makes us consider the second one a redirect\nconst REDIRECT_THRESHOLD = 0.3;\nfunction isRedirect(activeSpan, lastInteractionTimestamp) {\n  const spanData = spanToJSON(activeSpan);\n  const now = dateTimestampInSeconds();\n\n  // More than 300ms since last navigation/pageload span?\n  // --> never consider this a redirect\n  const startTimestamp = spanData.start_timestamp;\n  if (now - startTimestamp > REDIRECT_THRESHOLD) {\n    return false;\n  }\n\n  // A click happened in the last 300ms?\n  // --> never consider this a redirect\n  if (lastInteractionTimestamp && now - lastInteractionTimestamp <= REDIRECT_THRESHOLD) {\n    return false;\n  }\n  return true;\n}\nexport { BROWSER_TRACING_INTEGRATION_ID, browserTracingIntegration, getMetaContent, startBrowserTracingNavigationSpan, startBrowserTracingPageLoadSpan };\n//# sourceMappingURL=browserTracingIntegration.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}