{"ast":null,"code":"import { isParameterizedString, isError, isPlainObject, isErrorEvent } from './is.js';\nimport { addExceptionMechanism, addExceptionTypeValue } from './misc.js';\nimport { normalizeToSize } from './normalize.js';\nimport { extractExceptionKeysForMessage } from './object.js';\n\n/**\n * Extracts stack frames from the error.stack string\n */\nfunction parseStackFrames(stackParser, error) {\n  return stackParser(error.stack || '', 1);\n}\n\n/**\n * Extracts stack frames from the error and builds a Sentry Exception\n */\nfunction exceptionFromError(stackParser, error) {\n  const exception = {\n    type: error.name || error.constructor.name,\n    value: error.message\n  };\n  const frames = parseStackFrames(stackParser, error);\n  if (frames.length) {\n    exception.stacktrace = {\n      frames\n    };\n  }\n  return exception;\n}\n\n/** If a plain object has a property that is an `Error`, return this error. */\nfunction getErrorPropertyFromObject(obj) {\n  for (const prop in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n      const value = obj[prop];\n      if (value instanceof Error) {\n        return value;\n      }\n    }\n  }\n  return undefined;\n}\nfunction getMessageForObject(exception) {\n  if ('name' in exception && typeof exception.name === 'string') {\n    let message = `'${exception.name}' captured as exception`;\n    if ('message' in exception && typeof exception.message === 'string') {\n      message += ` with message '${exception.message}'`;\n    }\n    return message;\n  } else if ('message' in exception && typeof exception.message === 'string') {\n    return exception.message;\n  }\n  const keys = extractExceptionKeysForMessage(exception);\n\n  // Some ErrorEvent instances do not have an `error` property, which is why they are not handled before\n  // We still want to try to get a decent message for these cases\n  if (isErrorEvent(exception)) {\n    return `Event \\`ErrorEvent\\` captured as exception with message \\`${exception.message}\\``;\n  }\n  const className = getObjectClassName(exception);\n  return `${className && className !== 'Object' ? `'${className}'` : 'Object'} captured as exception with keys: ${keys}`;\n}\nfunction getObjectClassName(obj) {\n  try {\n    const prototype = Object.getPrototypeOf(obj);\n    return prototype ? prototype.constructor.name : undefined;\n  } catch {\n    // ignore errors here\n  }\n}\nfunction getException(client, mechanism, exception, hint) {\n  if (isError(exception)) {\n    return [exception, undefined];\n  }\n\n  // Mutate this!\n  mechanism.synthetic = true;\n  if (isPlainObject(exception)) {\n    const normalizeDepth = client?.getOptions().normalizeDepth;\n    const extras = {\n      ['__serialized__']: normalizeToSize(exception, normalizeDepth)\n    };\n    const errorFromProp = getErrorPropertyFromObject(exception);\n    if (errorFromProp) {\n      return [errorFromProp, extras];\n    }\n    const message = getMessageForObject(exception);\n    const ex = hint?.syntheticException || new Error(message);\n    ex.message = message;\n    return [ex, extras];\n  }\n\n  // This handles when someone does: `throw \"something awesome\";`\n  // We use synthesized Error here so we can extract a (rough) stack trace.\n  const ex = hint?.syntheticException || new Error(exception);\n  ex.message = `${exception}`;\n  return [ex, undefined];\n}\n\n/**\n * Builds and Event from a Exception\n * @hidden\n */\nfunction eventFromUnknownInput(client, stackParser, exception, hint) {\n  const providedMechanism = hint?.data && hint.data.mechanism;\n  const mechanism = providedMechanism || {\n    handled: true,\n    type: 'generic'\n  };\n  const [ex, extras] = getException(client, mechanism, exception, hint);\n  const event = {\n    exception: {\n      values: [exceptionFromError(stackParser, ex)]\n    }\n  };\n  if (extras) {\n    event.extra = extras;\n  }\n  addExceptionTypeValue(event, undefined, undefined);\n  addExceptionMechanism(event, mechanism);\n  return {\n    ...event,\n    event_id: hint?.event_id\n  };\n}\n\n/**\n * Builds and Event from a Message\n * @hidden\n */\nfunction eventFromMessage(stackParser, message, level = 'info', hint, attachStacktrace) {\n  const event = {\n    event_id: hint?.event_id,\n    level\n  };\n  if (attachStacktrace && hint?.syntheticException) {\n    const frames = parseStackFrames(stackParser, hint.syntheticException);\n    if (frames.length) {\n      event.exception = {\n        values: [{\n          value: message,\n          stacktrace: {\n            frames\n          }\n        }]\n      };\n      addExceptionMechanism(event, {\n        synthetic: true\n      });\n    }\n  }\n  if (isParameterizedString(message)) {\n    const {\n      __sentry_template_string__,\n      __sentry_template_values__\n    } = message;\n    event.logentry = {\n      message: __sentry_template_string__,\n      params: __sentry_template_values__\n    };\n    return event;\n  }\n  event.message = message;\n  return event;\n}\nexport { eventFromMessage, eventFromUnknownInput, exceptionFromError, parseStackFrames };","map":{"version":3,"names":["parseStackFrames","stackParser","error","stack","exceptionFromError","exception","type","name","constructor","value","message","frames","length","stacktrace","getErrorPropertyFromObject","obj","prop","Object","prototype","hasOwnProperty","call","Error","undefined","getMessageForObject","keys","extractExceptionKeysForMessage","isErrorEvent","className","getObjectClassName","getPrototypeOf","getException","client","mechanism","hint","isError","synthetic","isPlainObject","normalizeDepth","getOptions","extras","normalizeToSize","errorFromProp","ex","syntheticException","eventFromUnknownInput","providedMechanism","data","handled","event","values","extra","addExceptionTypeValue","addExceptionMechanism","event_id","eventFromMessage","level","attachStacktrace","isParameterizedString","__sentry_template_string__","__sentry_template_values__","logentry","params"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/core/src/utils/eventbuilder.ts"],"sourcesContent":["import type { Client } from '../client';\nimport type { Event, EventHint } from '../types-hoist/event';\nimport type { Exception } from '../types-hoist/exception';\nimport type { Extras } from '../types-hoist/extra';\nimport type { Mechanism } from '../types-hoist/mechanism';\nimport type { ParameterizedString } from '../types-hoist/parameterize';\nimport type { SeverityLevel } from '../types-hoist/severity';\nimport type { StackFrame } from '../types-hoist/stackframe';\nimport type { StackParser } from '../types-hoist/stacktrace';\nimport { isError, isErrorEvent, isParameterizedString, isPlainObject } from './is';\nimport { addExceptionMechanism, addExceptionTypeValue } from './misc';\nimport { normalizeToSize } from './normalize';\nimport { extractExceptionKeysForMessage } from './object';\n\n/**\n * Extracts stack frames from the error.stack string\n */\nexport function parseStackFrames(stackParser: StackParser, error: Error): StackFrame[] {\n  return stackParser(error.stack || '', 1);\n}\n\n/**\n * Extracts stack frames from the error and builds a Sentry Exception\n */\nexport function exceptionFromError(stackParser: StackParser, error: Error): Exception {\n  const exception: Exception = {\n    type: error.name || error.constructor.name,\n    value: error.message,\n  };\n\n  const frames = parseStackFrames(stackParser, error);\n  if (frames.length) {\n    exception.stacktrace = { frames };\n  }\n\n  return exception;\n}\n\n/** If a plain object has a property that is an `Error`, return this error. */\nfunction getErrorPropertyFromObject(obj: Record<string, unknown>): Error | undefined {\n  for (const prop in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n      const value = obj[prop];\n      if (value instanceof Error) {\n        return value;\n      }\n    }\n  }\n\n  return undefined;\n}\n\nfunction getMessageForObject(exception: Record<string, unknown>): string {\n  if ('name' in exception && typeof exception.name === 'string') {\n    let message = `'${exception.name}' captured as exception`;\n\n    if ('message' in exception && typeof exception.message === 'string') {\n      message += ` with message '${exception.message}'`;\n    }\n\n    return message;\n  } else if ('message' in exception && typeof exception.message === 'string') {\n    return exception.message;\n  }\n\n  const keys = extractExceptionKeysForMessage(exception);\n\n  // Some ErrorEvent instances do not have an `error` property, which is why they are not handled before\n  // We still want to try to get a decent message for these cases\n  if (isErrorEvent(exception)) {\n    return `Event \\`ErrorEvent\\` captured as exception with message \\`${exception.message}\\``;\n  }\n\n  const className = getObjectClassName(exception);\n\n  return `${\n    className && className !== 'Object' ? `'${className}'` : 'Object'\n  } captured as exception with keys: ${keys}`;\n}\n\nfunction getObjectClassName(obj: unknown): string | undefined | void {\n  try {\n    const prototype: unknown | null = Object.getPrototypeOf(obj);\n    return prototype ? prototype.constructor.name : undefined;\n  } catch {\n    // ignore errors here\n  }\n}\n\nfunction getException(\n  client: Client,\n  mechanism: Mechanism,\n  exception: unknown,\n  hint?: EventHint,\n): [Error, Extras | undefined] {\n  if (isError(exception)) {\n    return [exception, undefined];\n  }\n\n  // Mutate this!\n  mechanism.synthetic = true;\n\n  if (isPlainObject(exception)) {\n    const normalizeDepth = client?.getOptions().normalizeDepth;\n    const extras = { ['__serialized__']: normalizeToSize(exception as Record<string, unknown>, normalizeDepth) };\n\n    const errorFromProp = getErrorPropertyFromObject(exception);\n    if (errorFromProp) {\n      return [errorFromProp, extras];\n    }\n\n    const message = getMessageForObject(exception);\n    const ex = hint?.syntheticException || new Error(message);\n    ex.message = message;\n\n    return [ex, extras];\n  }\n\n  // This handles when someone does: `throw \"something awesome\";`\n  // We use synthesized Error here so we can extract a (rough) stack trace.\n  const ex = hint?.syntheticException || new Error(exception as string);\n  ex.message = `${exception}`;\n\n  return [ex, undefined];\n}\n\n/**\n * Builds and Event from a Exception\n * @hidden\n */\nexport function eventFromUnknownInput(\n  client: Client,\n  stackParser: StackParser,\n  exception: unknown,\n  hint?: EventHint,\n): Event {\n  const providedMechanism: Mechanism | undefined = hint?.data && (hint.data as { mechanism: Mechanism }).mechanism;\n  const mechanism: Mechanism = providedMechanism || {\n    handled: true,\n    type: 'generic',\n  };\n\n  const [ex, extras] = getException(client, mechanism, exception, hint);\n\n  const event: Event = {\n    exception: {\n      values: [exceptionFromError(stackParser, ex)],\n    },\n  };\n\n  if (extras) {\n    event.extra = extras;\n  }\n\n  addExceptionTypeValue(event, undefined, undefined);\n  addExceptionMechanism(event, mechanism);\n\n  return {\n    ...event,\n    event_id: hint?.event_id,\n  };\n}\n\n/**\n * Builds and Event from a Message\n * @hidden\n */\nexport function eventFromMessage(\n  stackParser: StackParser,\n  message: ParameterizedString,\n  level: SeverityLevel = 'info',\n  hint?: EventHint,\n  attachStacktrace?: boolean,\n): Event {\n  const event: Event = {\n    event_id: hint?.event_id,\n    level,\n  };\n\n  if (attachStacktrace && hint?.syntheticException) {\n    const frames = parseStackFrames(stackParser, hint.syntheticException);\n    if (frames.length) {\n      event.exception = {\n        values: [\n          {\n            value: message,\n            stacktrace: { frames },\n          },\n        ],\n      };\n      addExceptionMechanism(event, { synthetic: true });\n    }\n  }\n\n  if (isParameterizedString(message)) {\n    const { __sentry_template_string__, __sentry_template_values__ } = message;\n\n    event.logentry = {\n      message: __sentry_template_string__,\n      params: __sentry_template_values__,\n    };\n    return event;\n  }\n\n  event.message = message;\n  return event;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}