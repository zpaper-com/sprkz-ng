{"ast":null,"code":"import { DEBUG_BUILD } from '../debug-build.js';\nimport { debug } from '../utils/debug-logger.js';\nimport { envelopeContainsItemType } from '../utils/envelope.js';\nimport { parseRetryAfterHeader } from '../utils/ratelimit.js';\nconst MIN_DELAY = 100; // 100 ms\nconst START_DELAY = 5000; // 5 seconds\nconst MAX_DELAY = 3.6e6; // 1 hour\n\n/**\n * Wraps a transport and stores and retries events when they fail to send.\n *\n * @param createTransport The transport to wrap.\n */\nfunction makeOfflineTransport(createTransport) {\n  function log(...args) {\n    DEBUG_BUILD && debug.log('[Offline]:', ...args);\n  }\n  return options => {\n    const transport = createTransport(options);\n    if (!options.createStore) {\n      throw new Error('No `createStore` function was provided');\n    }\n    const store = options.createStore(options);\n    let retryDelay = START_DELAY;\n    let flushTimer;\n    function shouldQueue(env, error, retryDelay) {\n      // We want to drop client reports because they can be generated when we retry sending events while offline.\n      if (envelopeContainsItemType(env, ['client_report'])) {\n        return false;\n      }\n      if (options.shouldStore) {\n        return options.shouldStore(env, error, retryDelay);\n      }\n      return true;\n    }\n    function flushIn(delay) {\n      if (flushTimer) {\n        clearTimeout(flushTimer);\n      }\n      flushTimer = setTimeout(async () => {\n        flushTimer = undefined;\n        const found = await store.shift();\n        if (found) {\n          log('Attempting to send previously queued event');\n\n          // We should to update the sent_at timestamp to the current time.\n          found[0].sent_at = new Date().toISOString();\n          void send(found, true).catch(e => {\n            log('Failed to retry sending', e);\n          });\n        }\n      }, delay);\n\n      // We need to unref the timer in node.js, otherwise the node process never exit.\n      if (typeof flushTimer !== 'number' && flushTimer.unref) {\n        flushTimer.unref();\n      }\n    }\n    function flushWithBackOff() {\n      if (flushTimer) {\n        return;\n      }\n      flushIn(retryDelay);\n      retryDelay = Math.min(retryDelay * 2, MAX_DELAY);\n    }\n    async function send(envelope, isRetry = false) {\n      // We queue all replay envelopes to avoid multiple replay envelopes being sent at the same time. If one fails, we\n      // need to retry them in order.\n      if (!isRetry && envelopeContainsItemType(envelope, ['replay_event', 'replay_recording'])) {\n        await store.push(envelope);\n        flushIn(MIN_DELAY);\n        return {};\n      }\n      try {\n        if (options.shouldSend && (await options.shouldSend(envelope)) === false) {\n          throw new Error('Envelope not sent because `shouldSend` callback returned false');\n        }\n        const result = await transport.send(envelope);\n        let delay = MIN_DELAY;\n        if (result) {\n          // If there's a retry-after header, use that as the next delay.\n          if (result.headers?.['retry-after']) {\n            delay = parseRetryAfterHeader(result.headers['retry-after']);\n          } else if (result.headers?.['x-sentry-rate-limits']) {\n            delay = 60000; // 60 seconds\n          } // If we have a server error, return now so we don't flush the queue.\n          else if ((result.statusCode || 0) >= 400) {\n            return result;\n          }\n        }\n        flushIn(delay);\n        retryDelay = START_DELAY;\n        return result;\n      } catch (e) {\n        if (await shouldQueue(envelope, e, retryDelay)) {\n          // If this envelope was a retry, we want to add it to the front of the queue so it's retried again first.\n          if (isRetry) {\n            await store.unshift(envelope);\n          } else {\n            await store.push(envelope);\n          }\n          flushWithBackOff();\n          log('Error sending. Event queued.', e);\n          return {};\n        } else {\n          throw e;\n        }\n      }\n    }\n    if (options.flushAtStartup) {\n      flushWithBackOff();\n    }\n    return {\n      send,\n      flush: timeout => {\n        // If there's no timeout, we should attempt to flush the offline queue.\n        if (timeout === undefined) {\n          retryDelay = START_DELAY;\n          flushIn(MIN_DELAY);\n        }\n        return transport.flush(timeout);\n      }\n    };\n  };\n}\nexport { MIN_DELAY, START_DELAY, makeOfflineTransport };\n//# sourceMappingURL=offline.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}