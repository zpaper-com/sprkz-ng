{"ast":null,"code":"import { getClient, showReportDialog, withScope } from '@sentry/browser';\nimport { debug } from '@sentry/core';\nimport * as React from 'react';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { captureReactException } from './error.js';\nimport { hoistNonReactStatics } from './hoist-non-react-statics.js';\nconst UNKNOWN_COMPONENT = 'unknown';\nconst INITIAL_STATE = {\n  componentStack: null,\n  error: null,\n  eventId: null\n};\n\n/**\n * A ErrorBoundary component that logs errors to Sentry.\n * NOTE: If you are a Sentry user, and you are seeing this stack frame, it means the\n * Sentry React SDK ErrorBoundary caught an error invoking your application code. This\n * is expected behavior and NOT indicative of a bug with the Sentry React SDK.\n */\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = INITIAL_STATE;\n    this._openFallbackReportDialog = true;\n    const client = getClient();\n    if (client && props.showDialog) {\n      this._openFallbackReportDialog = false;\n      this._cleanupHook = client.on('afterSendEvent', event => {\n        if (!event.type && this._lastEventId && event.event_id === this._lastEventId) {\n          showReportDialog({\n            ...props.dialogOptions,\n            eventId: this._lastEventId\n          });\n        }\n      });\n    }\n  }\n  componentDidCatch(error, errorInfo) {\n    const {\n      componentStack\n    } = errorInfo;\n    const {\n      beforeCapture,\n      onError,\n      showDialog,\n      dialogOptions\n    } = this.props;\n    withScope(scope => {\n      if (beforeCapture) {\n        beforeCapture(scope, error, componentStack);\n      }\n      const handled = this.props.handled != null ? this.props.handled : !!this.props.fallback;\n      const eventId = captureReactException(error, errorInfo, {\n        mechanism: {\n          handled\n        }\n      });\n      if (onError) {\n        onError(error, componentStack, eventId);\n      }\n      if (showDialog) {\n        this._lastEventId = eventId;\n        if (this._openFallbackReportDialog) {\n          showReportDialog({\n            ...dialogOptions,\n            eventId\n          });\n        }\n      }\n\n      // componentDidCatch is used over getDerivedStateFromError\n      // so that componentStack is accessible through state.\n      this.setState({\n        error,\n        componentStack,\n        eventId\n      });\n    });\n  }\n  componentDidMount() {\n    const {\n      onMount\n    } = this.props;\n    if (onMount) {\n      onMount();\n    }\n  }\n  componentWillUnmount() {\n    const {\n      error,\n      componentStack,\n      eventId\n    } = this.state;\n    const {\n      onUnmount\n    } = this.props;\n    if (onUnmount) {\n      if (this.state === INITIAL_STATE) {\n        // If the error boundary never encountered an error, call onUnmount with null values\n        onUnmount(null, null, null);\n      } else {\n        // `componentStack` and `eventId` are guaranteed to be non-null here because `onUnmount` is only called\n        // when the error boundary has already encountered an error.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        onUnmount(error, componentStack, eventId);\n      }\n    }\n    if (this._cleanupHook) {\n      this._cleanupHook();\n      this._cleanupHook = undefined;\n    }\n  }\n  resetErrorBoundary() {\n    const {\n      onReset\n    } = this.props;\n    const {\n      error,\n      componentStack,\n      eventId\n    } = this.state;\n    if (onReset) {\n      // `componentStack` and `eventId` are guaranteed to be non-null here because `onReset` is only called\n      // when the error boundary has already encountered an error.\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      onReset(error, componentStack, eventId);\n    }\n    this.setState(INITIAL_STATE);\n  }\n  render() {\n    const {\n      fallback,\n      children\n    } = this.props;\n    const state = this.state;\n\n    // `componentStack` is only null in the initial state, when no error has been captured.\n    // If an error has been captured, `componentStack` will be a string.\n    // We cannot check `state.error` because null can be thrown as an error.\n    if (state.componentStack === null) {\n      return typeof children === 'function' ? children() : children;\n    }\n    const element = typeof fallback === 'function' ? React.createElement(fallback, {\n      error: state.error,\n      componentStack: state.componentStack,\n      resetError: () => this.resetErrorBoundary(),\n      eventId: state.eventId\n    }) : fallback;\n    if (React.isValidElement(element)) {\n      return element;\n    }\n    if (fallback) {\n      DEBUG_BUILD && debug.warn('fallback did not produce a valid ReactElement');\n    }\n\n    // Fail gracefully if no fallback provided or is not valid\n    return null;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction withErrorBoundary(WrappedComponent, errorBoundaryOptions) {\n  const componentDisplayName = WrappedComponent.displayName || WrappedComponent.name || UNKNOWN_COMPONENT;\n  const Wrapped = props => React.createElement(ErrorBoundary, {\n    ...errorBoundaryOptions\n  }, React.createElement(WrappedComponent, {\n    ...props\n  }));\n  Wrapped.displayName = `errorBoundary(${componentDisplayName})`;\n\n  // Copy over static methods from Wrapped component to Profiler HOC\n  // See: https://reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over\n  hoistNonReactStatics(Wrapped, WrappedComponent);\n  return Wrapped;\n}\nexport { ErrorBoundary, UNKNOWN_COMPONENT, withErrorBoundary };","map":{"version":3,"names":["UNKNOWN_COMPONENT","INITIAL_STATE","componentStack","error","eventId","ErrorBoundary","React","Component","constructor","props","state","_openFallbackReportDialog","client","getClient","showDialog","_cleanupHook","on","event","type","_lastEventId","event_id","showReportDialog","dialogOptions","componentDidCatch","errorInfo","beforeCapture","onError","withScope","scope","handled","fallback","captureReactException","mechanism","setState","componentDidMount","onMount","componentWillUnmount","onUnmount","undefined","resetErrorBoundary","onReset","render","children","element","createElement","resetError","isValidElement","DEBUG_BUILD","debug","warn","withErrorBoundary","WrappedComponent","errorBoundaryOptions","componentDisplayName","displayName","name","Wrapped","hoistNonReactStatics"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/node_modules/@sentry/react/src/errorboundary.tsx"],"sourcesContent":["import type { ReportDialogOptions } from '@sentry/browser';\nimport { getClient, showReportDialog, withScope } from '@sentry/browser';\nimport type { Scope } from '@sentry/core';\nimport { debug } from '@sentry/core';\nimport * as React from 'react';\nimport { DEBUG_BUILD } from './debug-build';\nimport { captureReactException } from './error';\nimport { hoistNonReactStatics } from './hoist-non-react-statics';\n\nexport const UNKNOWN_COMPONENT = 'unknown';\n\nexport type FallbackRender = (errorData: {\n  error: unknown;\n  componentStack: string;\n  eventId: string;\n  resetError(): void;\n}) => React.ReactElement;\n\ntype OnUnmountType = {\n  (error: null, componentStack: null, eventId: null): void;\n  (error: unknown, componentStack: string, eventId: string): void;\n};\n\nexport type ErrorBoundaryProps = {\n  children?: React.ReactNode | (() => React.ReactNode);\n  /** If a Sentry report dialog should be rendered on error */\n  showDialog?: boolean | undefined;\n  /**\n   * Options to be passed into the Sentry report dialog.\n   * No-op if {@link showDialog} is false.\n   */\n  dialogOptions?: ReportDialogOptions | undefined;\n  /**\n   * A fallback component that gets rendered when the error boundary encounters an error.\n   *\n   * Can either provide a React Component, or a function that returns React Component as\n   * a valid fallback prop. If a function is provided, the function will be called with\n   * the error, the component stack, and an function that resets the error boundary on error.\n   *\n   */\n  fallback?: React.ReactElement | FallbackRender | undefined;\n  /**\n   * If set to `true` or `false`, the error `handled` property will be set to the given value.\n   * If unset, the default behaviour is to rely on the presence of the `fallback` prop to determine\n   * if the error was handled or not.\n   */\n  handled?: boolean | undefined;\n  /** Called when the error boundary encounters an error */\n  onError?: ((error: unknown, componentStack: string, eventId: string) => void) | undefined;\n  /** Called on componentDidMount() */\n  onMount?: (() => void) | undefined;\n  /**\n   * Called when the error boundary resets due to a reset call from the\n   * fallback render props function.\n   */\n  onReset?: ((error: unknown, componentStack: string, eventId: string) => void) | undefined;\n  /**\n   * Called on componentWillUnmount() with the error, componentStack, and eventId.\n   *\n   * If the error boundary never encountered an error, the error\n   * componentStack, and eventId will be null.\n   */\n  onUnmount?: OnUnmountType | undefined;\n  /** Called before the error is captured by Sentry, allows for you to add tags or context using the scope */\n  beforeCapture?: ((scope: Scope, error: unknown, componentStack: string) => void) | undefined;\n};\n\ntype ErrorBoundaryState =\n  | {\n      componentStack: null;\n      error: null;\n      eventId: null;\n    }\n  | {\n      componentStack: React.ErrorInfo['componentStack'];\n      error: unknown;\n      eventId: string;\n    };\n\nconst INITIAL_STATE: ErrorBoundaryState = {\n  componentStack: null,\n  error: null,\n  eventId: null,\n};\n\n/**\n * A ErrorBoundary component that logs errors to Sentry.\n * NOTE: If you are a Sentry user, and you are seeing this stack frame, it means the\n * Sentry React SDK ErrorBoundary caught an error invoking your application code. This\n * is expected behavior and NOT indicative of a bug with the Sentry React SDK.\n */\nclass ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {\n  public state: ErrorBoundaryState;\n\n  private readonly _openFallbackReportDialog: boolean;\n\n  private _lastEventId?: string;\n  private _cleanupHook?: () => void;\n\n  public constructor(props: ErrorBoundaryProps) {\n    super(props);\n\n    this.state = INITIAL_STATE;\n    this._openFallbackReportDialog = true;\n\n    const client = getClient();\n    if (client && props.showDialog) {\n      this._openFallbackReportDialog = false;\n      this._cleanupHook = client.on('afterSendEvent', event => {\n        if (!event.type && this._lastEventId && event.event_id === this._lastEventId) {\n          showReportDialog({ ...props.dialogOptions, eventId: this._lastEventId });\n        }\n      });\n    }\n  }\n\n  public componentDidCatch(error: unknown, errorInfo: React.ErrorInfo): void {\n    const { componentStack } = errorInfo;\n    const { beforeCapture, onError, showDialog, dialogOptions } = this.props;\n    withScope(scope => {\n      if (beforeCapture) {\n        beforeCapture(scope, error, componentStack);\n      }\n\n      const handled = this.props.handled != null ? this.props.handled : !!this.props.fallback;\n      const eventId = captureReactException(error, errorInfo, { mechanism: { handled } });\n\n      if (onError) {\n        onError(error, componentStack, eventId);\n      }\n      if (showDialog) {\n        this._lastEventId = eventId;\n        if (this._openFallbackReportDialog) {\n          showReportDialog({ ...dialogOptions, eventId });\n        }\n      }\n\n      // componentDidCatch is used over getDerivedStateFromError\n      // so that componentStack is accessible through state.\n      this.setState({ error, componentStack, eventId });\n    });\n  }\n\n  public componentDidMount(): void {\n    const { onMount } = this.props;\n    if (onMount) {\n      onMount();\n    }\n  }\n\n  public componentWillUnmount(): void {\n    const { error, componentStack, eventId } = this.state;\n    const { onUnmount } = this.props;\n    if (onUnmount) {\n      if (this.state === INITIAL_STATE) {\n        // If the error boundary never encountered an error, call onUnmount with null values\n        onUnmount(null, null, null);\n      } else {\n        // `componentStack` and `eventId` are guaranteed to be non-null here because `onUnmount` is only called\n        // when the error boundary has already encountered an error.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        onUnmount(error, componentStack!, eventId!);\n      }\n    }\n\n    if (this._cleanupHook) {\n      this._cleanupHook();\n      this._cleanupHook = undefined;\n    }\n  }\n\n  public resetErrorBoundary(): void {\n    const { onReset } = this.props;\n    const { error, componentStack, eventId } = this.state;\n    if (onReset) {\n      // `componentStack` and `eventId` are guaranteed to be non-null here because `onReset` is only called\n      // when the error boundary has already encountered an error.\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      onReset(error, componentStack!, eventId!);\n    }\n    this.setState(INITIAL_STATE);\n  }\n\n  public render(): React.ReactNode {\n    const { fallback, children } = this.props;\n    const state = this.state;\n\n    // `componentStack` is only null in the initial state, when no error has been captured.\n    // If an error has been captured, `componentStack` will be a string.\n    // We cannot check `state.error` because null can be thrown as an error.\n    if (state.componentStack === null) {\n      return typeof children === 'function' ? children() : children;\n    }\n\n    const element =\n      typeof fallback === 'function'\n        ? React.createElement(fallback, {\n            error: state.error,\n            componentStack: state.componentStack,\n            resetError: () => this.resetErrorBoundary(),\n            eventId: state.eventId,\n          })\n        : fallback;\n\n    if (React.isValidElement(element)) {\n      return element;\n    }\n\n    if (fallback) {\n      DEBUG_BUILD && debug.warn('fallback did not produce a valid ReactElement');\n    }\n\n    // Fail gracefully if no fallback provided or is not valid\n    return null;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction withErrorBoundary<P extends Record<string, any>>(\n  WrappedComponent: React.ComponentType<P>,\n  errorBoundaryOptions: ErrorBoundaryProps,\n): React.FC<P> {\n  const componentDisplayName = WrappedComponent.displayName || WrappedComponent.name || UNKNOWN_COMPONENT;\n\n  const Wrapped: React.FC<P> = (props: P) => (\n    <ErrorBoundary {...errorBoundaryOptions}>\n      <WrappedComponent {...props} />\n    </ErrorBoundary>\n  );\n\n  Wrapped.displayName = `errorBoundary(${componentDisplayName})`;\n\n  // Copy over static methods from Wrapped component to Profiler HOC\n  // See: https://reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over\n  hoistNonReactStatics(Wrapped, WrappedComponent);\n  return Wrapped;\n}\n\nexport { ErrorBoundary, withErrorBoundary };\n"],"mappings":";;;;;;AASO,MAAMA,iBAAA,GAAoB;AAsEjC,MAAMC,aAAa,GAAuB;EACxCC,cAAc,EAAE,IAAI;EACpBC,KAAK,EAAE,IAAI;EACXC,OAAO,EAAE;AACX,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,aAAA,SAAsBC,KAAK,CAACC,SAAS,CAAyC;EAQ3EC,WAAWA,CAACC,KAAK,EAAsB;IAC5C,KAAK,CAACA,KAAK,CAAC;IAEZ,IAAI,CAACC,KAAA,GAAQT,aAAa;IAC1B,IAAI,CAACU,yBAAA,GAA4B,IAAI;IAErC,MAAMC,MAAA,GAASC,SAAS,EAAE;IAC1B,IAAID,MAAA,IAAUH,KAAK,CAACK,UAAU,EAAE;MAC9B,IAAI,CAACH,yBAAA,GAA4B,KAAK;MACtC,IAAI,CAACI,YAAA,GAAeH,MAAM,CAACI,EAAE,CAAC,gBAAgB,EAAEC,KAAA,IAAS;QACvD,IAAI,CAACA,KAAK,CAACC,IAAA,IAAQ,IAAI,CAACC,YAAA,IAAgBF,KAAK,CAACG,QAAA,KAAa,IAAI,CAACD,YAAY,EAAE;UAC5EE,gBAAgB,CAAC;YAAE,GAAGZ,KAAK,CAACa,aAAa;YAAElB,OAAO,EAAE,IAAI,CAACe;UAAA,CAAc,CAAC;QAClF;MACA,CAAO,CAAC;IACR;EACA;EAESI,iBAAiBA,CAACpB,KAAK,EAAWqB,SAAS,EAAyB;IACzE,MAAM;MAAEtB;IAAA,CAAe,GAAIsB,SAAS;IACpC,MAAM;MAAEC,aAAa;MAAEC,OAAO;MAAEZ,UAAU;MAAEQ;IAAA,CAAc,GAAI,IAAI,CAACb,KAAK;IACxEkB,SAAS,CAACC,KAAA,IAAS;MACjB,IAAIH,aAAa,EAAE;QACjBA,aAAa,CAACG,KAAK,EAAEzB,KAAK,EAAED,cAAc,CAAC;MACnD;MAEM,MAAM2B,OAAA,GAAU,IAAI,CAACpB,KAAK,CAACoB,OAAA,IAAW,OAAO,IAAI,CAACpB,KAAK,CAACoB,OAAA,GAAU,CAAC,CAAC,IAAI,CAACpB,KAAK,CAACqB,QAAQ;MACvF,MAAM1B,OAAA,GAAU2B,qBAAqB,CAAC5B,KAAK,EAAEqB,SAAS,EAAE;QAAEQ,SAAS,EAAE;UAAEH;QAAA;MAAQ,CAAG,CAAC;MAEnF,IAAIH,OAAO,EAAE;QACXA,OAAO,CAACvB,KAAK,EAAED,cAAc,EAAEE,OAAO,CAAC;MAC/C;MACM,IAAIU,UAAU,EAAE;QACd,IAAI,CAACK,YAAA,GAAef,OAAO;QAC3B,IAAI,IAAI,CAACO,yBAAyB,EAAE;UAClCU,gBAAgB,CAAC;YAAE,GAAGC,aAAa;YAAElB;UAAA,CAAS,CAAC;QACzD;MACA;;MAEA;MACA;MACM,IAAI,CAAC6B,QAAQ,CAAC;QAAE9B,KAAK;QAAED,cAAc;QAAEE;MAAA,CAAS,CAAC;IACvD,CAAK,CAAC;EACN;EAES8B,iBAAiBA,CAAA,EAAS;IAC/B,MAAM;MAAEC;IAAA,IAAY,IAAI,CAAC1B,KAAK;IAC9B,IAAI0B,OAAO,EAAE;MACXA,OAAO,EAAE;IACf;EACA;EAESC,oBAAoBA,CAAA,EAAS;IAClC,MAAM;MAAEjC,KAAK;MAAED,cAAc;MAAEE;IAAA,CAAQ,GAAI,IAAI,CAACM,KAAK;IACrD,MAAM;MAAE2B;IAAA,IAAc,IAAI,CAAC5B,KAAK;IAChC,IAAI4B,SAAS,EAAE;MACb,IAAI,IAAI,CAAC3B,KAAA,KAAUT,aAAa,EAAE;QACxC;QACQoC,SAAS,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;MACnC,OAAa;QACb;QACA;QACA;QACQA,SAAS,CAAClC,KAAK,EAAED,cAAc,EAAGE,OAAO,CAAE;MACnD;IACA;IAEI,IAAI,IAAI,CAACW,YAAY,EAAE;MACrB,IAAI,CAACA,YAAY,EAAE;MACnB,IAAI,CAACA,YAAA,GAAeuB,SAAS;IACnC;EACA;EAESC,kBAAkBA,CAAA,EAAS;IAChC,MAAM;MAAEC;IAAA,IAAY,IAAI,CAAC/B,KAAK;IAC9B,MAAM;MAAEN,KAAK;MAAED,cAAc;MAAEE;IAAA,CAAQ,GAAI,IAAI,CAACM,KAAK;IACrD,IAAI8B,OAAO,EAAE;MACjB;MACA;MACA;MACMA,OAAO,CAACrC,KAAK,EAAED,cAAc,EAAGE,OAAO,CAAE;IAC/C;IACI,IAAI,CAAC6B,QAAQ,CAAChC,aAAa,CAAC;EAChC;EAESwC,MAAMA,CAAA,EAAoB;IAC/B,MAAM;MAAEX,QAAQ;MAAEY;IAAA,CAAS,GAAI,IAAI,CAACjC,KAAK;IACzC,MAAMC,KAAA,GAAQ,IAAI,CAACA,KAAK;;IAE5B;IACA;IACA;IACI,IAAIA,KAAK,CAACR,cAAA,KAAmB,IAAI,EAAE;MACjC,OAAO,OAAOwC,QAAA,KAAa,aAAaA,QAAQ,EAAC,GAAIA,QAAQ;IACnE;IAEI,MAAMC,OAAA,GACJ,OAAOb,QAAA,KAAa,aAChBxB,KAAK,CAACsC,aAAa,CAACd,QAAQ,EAAE;MAC5B3B,KAAK,EAAEO,KAAK,CAACP,KAAK;MAClBD,cAAc,EAAEQ,KAAK,CAACR,cAAc;MACpC2C,UAAU,EAAEA,CAAA,KAAM,IAAI,CAACN,kBAAkB,EAAE;MAC3CnC,OAAO,EAAEM,KAAK,CAACN;IAC3B,CAAW,IACD0B,QAAQ;IAEd,IAAIxB,KAAK,CAACwC,cAAc,CAACH,OAAO,CAAC,EAAE;MACjC,OAAOA,OAAO;IACpB;IAEI,IAAIb,QAAQ,EAAE;MACZiB,WAAA,IAAeC,KAAK,CAACC,IAAI,CAAC,+CAA+C,CAAC;IAChF;;IAEA;IACI,OAAO,IAAI;EACf;AACA;;AAEA;AACA,SAASC,iBAAiBA,CACxBC,gBAAgB,EAChBC,oBAAoB,EACP;EACb,MAAMC,oBAAA,GAAuBF,gBAAgB,CAACG,WAAA,IAAeH,gBAAgB,CAACI,IAAA,IAAQvD,iBAAiB;EAEvG,MAAMwD,OAAO,GAAiB/C,KAAK,IACjCH,KAAA,CAAAsC,aAAA,CAACvC,aAAA;IAAc,GAAI+C;EAAoB,GACrC9C,KAAA,CAAAsC,aAAA,CAACO,gBAAA;IAAiB,GAAI1C;EAAK,EACjC,CACG;EAED+C,OAAO,CAACF,WAAA,GAAc,iBAAiBD,oBAAoB,GAAG;;EAEhE;EACA;EACEI,oBAAoB,CAACD,OAAO,EAAEL,gBAAgB,CAAC;EAC/C,OAAOK,OAAO;AAChB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}