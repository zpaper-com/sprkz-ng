{"ast":null,"code":"var _jsxFileName = \"/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/src/contexts/FormContext.tsx\";\nimport React, { createContext, useContext, useReducer, useCallback, useEffect } from 'react';\nimport { FormFieldService } from '../services/formFieldService';\nimport { ValidationService } from '../services/validationService';\n\n// Form Actions\n\n// Form State Context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst FormContext = /*#__PURE__*/createContext(undefined);\n\n// Initial state\nconst initialState = {\n  fields: new Map(),\n  currentFieldIndex: -1,\n  completedFields: [],\n  requiredFields: [],\n  totalRequiredFields: 0,\n  completionPercentage: 0,\n  isValid: false,\n  validationResults: new Map()\n};\n\n// Form reducer\nfunction formReducer(state, action) {\n  switch (action.type) {\n    case 'INITIALIZE_FIELDS':\n      {\n        const fields = action.payload;\n        const fieldMap = new Map();\n        const requiredFields = [];\n        fields.forEach(field => {\n          fieldMap.set(field.name, {\n            fieldName: field.name,\n            value: field.value,\n            page: field.page,\n            isValid: !field.required || field.isComplete,\n            errors: field.validationErrors\n          });\n          if (field.required && !field.readOnly) {\n            requiredFields.push(field.name);\n          }\n        });\n        return {\n          ...state,\n          fields: fieldMap,\n          requiredFields,\n          totalRequiredFields: requiredFields.length,\n          completedFields: fields.filter(f => f.isComplete).map(f => f.name),\n          completionPercentage: FormFieldService.calculateCompletionPercentage(fields),\n          currentFieldIndex: 0\n        };\n      }\n    case 'UPDATE_FIELD_VALUE':\n      {\n        const {\n          fieldName,\n          value,\n          page\n        } = action.payload;\n        const newFields = new Map(state.fields);\n        const existingField = newFields.get(fieldName);\n        if (existingField) {\n          const updatedField = {\n            ...existingField,\n            value,\n            page,\n            isValid: true,\n            // Will be validated separately\n            errors: []\n          };\n          newFields.set(fieldName, updatedField);\n        }\n        return {\n          ...state,\n          fields: newFields\n        };\n      }\n    case 'SET_CURRENT_FIELD':\n      {\n        return {\n          ...state,\n          currentFieldIndex: action.payload\n        };\n      }\n    case 'MARK_FIELD_COMPLETE':\n      {\n        const fieldName = action.payload;\n        const completedFields = [...state.completedFields];\n        if (!completedFields.includes(fieldName)) {\n          completedFields.push(fieldName);\n        }\n        return {\n          ...state,\n          completedFields,\n          completionPercentage: Math.round(completedFields.length / Math.max(state.totalRequiredFields, 1) * 100)\n        };\n      }\n    case 'SET_FIELD_ERRORS':\n      {\n        const {\n          fieldName,\n          errors\n        } = action.payload;\n        const newFields = new Map(state.fields);\n        const field = newFields.get(fieldName);\n        if (field) {\n          newFields.set(fieldName, {\n            ...field,\n            errors,\n            isValid: errors.length === 0\n          });\n        }\n        return {\n          ...state,\n          fields: newFields\n        };\n      }\n    case 'SET_FIELD_VALIDATION':\n      {\n        const {\n          fieldName,\n          validation\n        } = action.payload;\n        const newValidationResults = new Map(state.validationResults);\n        const newFields = new Map(state.fields);\n        const field = newFields.get(fieldName);\n        newValidationResults.set(fieldName, validation);\n        if (field) {\n          newFields.set(fieldName, {\n            ...field,\n            errors: validation.errors,\n            isValid: validation.isValid\n          });\n        }\n        return {\n          ...state,\n          fields: newFields,\n          validationResults: newValidationResults\n        };\n      }\n    case 'CALCULATE_PROGRESS':\n      {\n        const completedRequiredFields = state.completedFields.filter(fieldName => state.requiredFields.includes(fieldName));\n        return {\n          ...state,\n          completionPercentage: Math.round(completedRequiredFields.length / Math.max(state.totalRequiredFields, 1) * 100)\n        };\n      }\n    case 'RESET_FORM':\n      {\n        return {\n          ...initialState,\n          fields: new Map(Array.from(state.fields.entries()).map(([key, field]) => [key, {\n            ...field,\n            value: field.fieldName.includes('checkbox') ? false : '',\n            isValid: !state.requiredFields.includes(field.fieldName),\n            errors: []\n          }])),\n          requiredFields: state.requiredFields,\n          totalRequiredFields: state.totalRequiredFields\n        };\n      }\n    default:\n      return state;\n  }\n}\n\n// Form Provider\nexport const FormProvider = ({\n  children\n}) => {\n  const [state, dispatch] = useReducer(formReducer, initialState);\n\n  // Initialize fields\n  const initializeFields = useCallback(fields => {\n    dispatch({\n      type: 'INITIALIZE_FIELDS',\n      payload: fields\n    });\n  }, []);\n\n  // Update field value\n  const updateFieldValue = useCallback((fieldName, value, page) => {\n    dispatch({\n      type: 'UPDATE_FIELD_VALUE',\n      payload: {\n        fieldName,\n        value,\n        page\n      }\n    });\n\n    // Auto-validate the field after a short delay\n    setTimeout(async () => {\n      await validateField(fieldName);\n    }, 100);\n  }, []);\n\n  // Set current field\n  const setCurrentField = useCallback(index => {\n    dispatch({\n      type: 'SET_CURRENT_FIELD',\n      payload: index\n    });\n  }, []);\n\n  // Mark field as complete\n  const markFieldComplete = useCallback(fieldName => {\n    dispatch({\n      type: 'MARK_FIELD_COMPLETE',\n      payload: fieldName\n    });\n    dispatch({\n      type: 'CALCULATE_PROGRESS'\n    });\n  }, []);\n\n  // Validate field using ValidationService\n  const validateField = useCallback(async fieldName => {\n    const fieldValue = state.fields.get(fieldName);\n    if (!fieldValue) {\n      const emptyResult = {\n        isValid: false,\n        errors: ['Field not found'],\n        warnings: [],\n        fieldName,\n        validatedAt: Date.now()\n      };\n      return emptyResult;\n    }\n\n    // Create a temporary FormField for validation\n    const tempField = {\n      name: fieldName,\n      type: 'text',\n      // Default type, should be enhanced based on field analysis\n      value: fieldValue.value,\n      required: state.requiredFields.includes(fieldName),\n      readOnly: false,\n      page: fieldValue.page,\n      rect: [0, 0, 0, 0],\n      isComplete: state.completedFields.includes(fieldName),\n      validationErrors: [],\n      id: fieldName,\n      subtype: ''\n    };\n\n    // Get all fields for dependency validation\n    const allFields = Array.from(state.fields.entries()).map(([name, value]) => ({\n      name,\n      type: 'text',\n      value: value.value,\n      required: state.requiredFields.includes(name),\n      readOnly: false,\n      page: value.page,\n      rect: [0, 0, 0, 0],\n      isComplete: state.completedFields.includes(name),\n      validationErrors: value.errors,\n      id: name,\n      subtype: ''\n    }));\n    try {\n      const validationResult = await ValidationService.validateField(tempField, fieldValue.value, allFields, {\n        validateRequired: true,\n        validateFormat: true,\n        validateDependencies: true,\n        excludeReadOnly: true\n      });\n\n      // Update state with validation result\n      dispatch({\n        type: 'SET_FIELD_VALIDATION',\n        payload: {\n          fieldName,\n          validation: validationResult\n        }\n      });\n\n      // Mark field as complete if valid\n      if (validationResult.isValid && !state.completedFields.includes(fieldName)) {\n        markFieldComplete(fieldName);\n      }\n      return validationResult;\n    } catch (error) {\n      console.error(`Validation failed for field \"${fieldName}\":`, error);\n      const errorResult = {\n        isValid: false,\n        errors: ['Validation error occurred'],\n        warnings: [],\n        fieldName,\n        validatedAt: Date.now()\n      };\n      dispatch({\n        type: 'SET_FIELD_VALIDATION',\n        payload: {\n          fieldName,\n          validation: errorResult\n        }\n      });\n      return errorResult;\n    }\n  }, [state.fields, state.requiredFields, state.completedFields, markFieldComplete]);\n\n  // Validate all fields\n  const validateAllFields = useCallback(async () => {\n    const allFields = Array.from(state.fields.entries()).map(([name, value]) => ({\n      name,\n      type: 'text',\n      value: value.value,\n      required: state.requiredFields.includes(name),\n      readOnly: false,\n      page: value.page,\n      rect: [0, 0, 0, 0],\n      isComplete: state.completedFields.includes(name),\n      validationErrors: value.errors,\n      id: name,\n      subtype: ''\n    }));\n    const fieldValues = {};\n    state.fields.forEach((value, name) => {\n      fieldValues[name] = value.value;\n    });\n    try {\n      const validationResults = await ValidationService.validateFields(allFields, fieldValues, {\n        validateRequired: true,\n        validateFormat: true,\n        validateDependencies: true,\n        excludeReadOnly: true\n      });\n\n      // Update all validation results in state\n      Object.entries(validationResults).forEach(([fieldName, result]) => {\n        dispatch({\n          type: 'SET_FIELD_VALIDATION',\n          payload: {\n            fieldName,\n            validation: result\n          }\n        });\n      });\n      return validationResults;\n    } catch (error) {\n      console.error('Bulk validation failed:', error);\n      return {};\n    }\n  }, [state.fields, state.requiredFields, state.completedFields]);\n\n  // Get next incomplete field\n  const getNextIncompleteField = useCallback(() => {\n    const incompleteFields = Array.from(state.fields.entries()).filter(([fieldName]) => !state.completedFields.includes(fieldName) && state.requiredFields.includes(fieldName));\n    if (incompleteFields.length === 0) return null;\n    return {\n      name: incompleteFields[0][0],\n      type: 'text',\n      value: incompleteFields[0][1].value,\n      required: true,\n      readOnly: false,\n      page: incompleteFields[0][1].page,\n      rect: [0, 0, 0, 0],\n      isComplete: false,\n      validationErrors: incompleteFields[0][1].errors,\n      id: incompleteFields[0][0],\n      subtype: ''\n    };\n  }, [state.fields, state.completedFields, state.requiredFields]);\n\n  // Get current field\n  const getCurrentField = useCallback(() => {\n    const fieldsArray = Array.from(state.fields.keys());\n    if (state.currentFieldIndex < 0 || state.currentFieldIndex >= fieldsArray.length) {\n      return null;\n    }\n    const fieldName = fieldsArray[state.currentFieldIndex];\n    const fieldValue = state.fields.get(fieldName);\n    if (!fieldValue) return null;\n    return {\n      name: fieldName,\n      type: 'text',\n      value: fieldValue.value,\n      required: state.requiredFields.includes(fieldName),\n      readOnly: false,\n      page: fieldValue.page,\n      rect: [0, 0, 0, 0],\n      isComplete: state.completedFields.includes(fieldName),\n      validationErrors: fieldValue.errors,\n      id: fieldName,\n      subtype: ''\n    };\n  }, [state.fields, state.currentFieldIndex, state.requiredFields, state.completedFields]);\n\n  // Get field by name\n  const getFieldByName = useCallback(fieldName => {\n    const fieldValue = state.fields.get(fieldName);\n    if (!fieldValue) return null;\n    return {\n      name: fieldName,\n      type: 'text',\n      value: fieldValue.value,\n      required: state.requiredFields.includes(fieldName),\n      readOnly: false,\n      page: fieldValue.page,\n      rect: [0, 0, 0, 0],\n      isComplete: state.completedFields.includes(fieldName),\n      validationErrors: fieldValue.errors,\n      id: fieldName,\n      subtype: ''\n    };\n  }, [state.fields, state.requiredFields, state.completedFields]);\n\n  // Get completion percentage\n  const getCompletionPercentage = useCallback(() => {\n    return state.completionPercentage;\n  }, [state.completionPercentage]);\n\n  // Get required fields status\n  const getRequiredFieldsStatus = useCallback(() => {\n    const completedRequired = state.completedFields.filter(fieldName => state.requiredFields.includes(fieldName));\n    return {\n      completed: completedRequired.length,\n      total: state.totalRequiredFields\n    };\n  }, [state.completedFields, state.requiredFields, state.totalRequiredFields]);\n\n  // Check if form is valid\n  const isFormValid = useCallback(() => {\n    const allRequiredCompleted = state.requiredFields.every(fieldName => state.completedFields.includes(fieldName));\n    const noErrors = Array.from(state.fields.values()).every(field => field.errors.length === 0);\n    return allRequiredCompleted && noErrors;\n  }, [state.requiredFields, state.completedFields, state.fields]);\n\n  // Get all form errors\n  const getFormErrors = useCallback(() => {\n    const errors = {};\n    state.fields.forEach((field, fieldName) => {\n      if (field.errors.length > 0) {\n        errors[fieldName] = field.errors;\n      }\n    });\n    return errors;\n  }, [state.fields]);\n\n  // Get field validation result\n  const getFieldValidation = useCallback(fieldName => {\n    return state.validationResults.get(fieldName) || null;\n  }, [state.validationResults]);\n\n  // Reset form\n  const resetForm = useCallback(() => {\n    dispatch({\n      type: 'RESET_FORM'\n    });\n    ValidationService.clearValidationCache();\n    console.log('Form has been reset to initial state');\n  }, []);\n\n  // Reset form after successful submission\n  const resetAfterSubmission = useCallback(() => {\n    resetForm();\n\n    // Additional cleanup for post-submission reset\n    setTimeout(() => {\n      // Clear any temporary data\n      sessionStorage.removeItem('sprkz-form-draft');\n      console.log('Post-submission cleanup completed');\n    }, 100);\n  }, [resetForm]);\n\n  // Update isValid when state changes\n  useEffect(() => {\n    const formValid = isFormValid();\n    if (state.isValid !== formValid) {\n      // Update state.isValid if needed (would require additional action)\n    }\n  }, [state.fields, state.completedFields, state.requiredFields, isFormValid, state.isValid]);\n  const contextValue = {\n    state,\n    updateFieldValue,\n    setCurrentField,\n    markFieldComplete,\n    validateField,\n    validateAllFields,\n    getNextIncompleteField,\n    getCurrentField,\n    getFieldByName,\n    getCompletionPercentage,\n    getRequiredFieldsStatus,\n    isFormValid,\n    getFormErrors,\n    getFieldValidation,\n    resetForm,\n    resetAfterSubmission,\n    initializeFields\n  };\n  return /*#__PURE__*/_jsxDEV(FormContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 546,\n    columnNumber: 5\n  }, this);\n};\n\n// Hook to use form context\nexport const useForm = () => {\n  const context = useContext(FormContext);\n  if (context === undefined) {\n    throw new Error('useForm must be used within a FormProvider');\n  }\n  return context;\n};","map":{"version":3,"names":["React","createContext","useContext","useReducer","useCallback","useEffect","FormFieldService","ValidationService","jsxDEV","_jsxDEV","FormContext","undefined","initialState","fields","Map","currentFieldIndex","completedFields","requiredFields","totalRequiredFields","completionPercentage","isValid","validationResults","formReducer","state","action","type","payload","fieldMap","forEach","field","set","name","fieldName","value","page","required","isComplete","errors","validationErrors","readOnly","push","length","filter","f","map","calculateCompletionPercentage","newFields","existingField","get","updatedField","includes","Math","round","max","validation","newValidationResults","completedRequiredFields","Array","from","entries","key","FormProvider","children","dispatch","initializeFields","updateFieldValue","setTimeout","validateField","setCurrentField","index","markFieldComplete","fieldValue","emptyResult","warnings","validatedAt","Date","now","tempField","rect","id","subtype","allFields","validationResult","validateRequired","validateFormat","validateDependencies","excludeReadOnly","error","console","errorResult","validateAllFields","fieldValues","validateFields","Object","result","getNextIncompleteField","incompleteFields","getCurrentField","fieldsArray","keys","getFieldByName","getCompletionPercentage","getRequiredFieldsStatus","completedRequired","completed","total","isFormValid","allRequiredCompleted","every","noErrors","values","getFormErrors","getFieldValidation","resetForm","clearValidationCache","log","resetAfterSubmission","sessionStorage","removeItem","formValid","contextValue","Provider","fileName","_jsxFileName","lineNumber","columnNumber","useForm","context","Error"],"sources":["/home/shawnstorie/sprkz-ng/sprkz-pdf-forms/src/contexts/FormContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useReducer, useCallback, useEffect } from 'react';\nimport { FormField, FormState, FormFieldValue } from '../types/pdf';\nimport { FormFieldService } from '../services/formFieldService';\nimport { ValidationService, ValidationResult } from '../services/validationService';\n\n// Form Actions\ntype FormAction = \n  | { type: 'INITIALIZE_FIELDS'; payload: FormField[] }\n  | { type: 'UPDATE_FIELD_VALUE'; payload: { fieldName: string; value: any; page: number } }\n  | { type: 'SET_CURRENT_FIELD'; payload: number }\n  | { type: 'MARK_FIELD_COMPLETE'; payload: string }\n  | { type: 'SET_FIELD_ERRORS'; payload: { fieldName: string; errors: string[] } }\n  | { type: 'SET_FIELD_VALIDATION'; payload: { fieldName: string; validation: ValidationResult } }\n  | { type: 'RESET_FORM' }\n  | { type: 'CALCULATE_PROGRESS' };\n\n// Form State Context\ninterface FormContextType {\n  state: FormState;\n  // Field management\n  updateFieldValue: (fieldName: string, value: any, page: number) => void;\n  setCurrentField: (index: number) => void;\n  markFieldComplete: (fieldName: string) => void;\n  validateField: (fieldName: string) => Promise<ValidationResult>;\n  validateAllFields: () => Promise<Record<string, ValidationResult>>;\n  // Navigation helpers\n  getNextIncompleteField: () => FormField | null;\n  getCurrentField: () => FormField | null;\n  getFieldByName: (fieldName: string) => FormField | null;\n  // Progress tracking\n  getCompletionPercentage: () => number;\n  getRequiredFieldsStatus: () => { completed: number; total: number };\n  // Form validation\n  isFormValid: () => boolean;\n  getFormErrors: () => Record<string, string[]>;\n  getFieldValidation: (fieldName: string) => ValidationResult | null;\n  // Utility\n  resetForm: () => void;\n  resetAfterSubmission: () => void;\n  initializeFields: (fields: FormField[]) => void;\n}\n\nconst FormContext = createContext<FormContextType | undefined>(undefined);\n\n// Initial state\nconst initialState: FormState = {\n  fields: new Map(),\n  currentFieldIndex: -1,\n  completedFields: [],\n  requiredFields: [],\n  totalRequiredFields: 0,\n  completionPercentage: 0,\n  isValid: false,\n  validationResults: new Map()\n};\n\n// Form reducer\nfunction formReducer(state: FormState, action: FormAction): FormState {\n  switch (action.type) {\n    case 'INITIALIZE_FIELDS': {\n      const fields = action.payload;\n      const fieldMap = new Map<string, FormFieldValue>();\n      const requiredFields: string[] = [];\n\n      fields.forEach(field => {\n        fieldMap.set(field.name, {\n          fieldName: field.name,\n          value: field.value,\n          page: field.page,\n          isValid: !field.required || field.isComplete,\n          errors: field.validationErrors\n        });\n\n        if (field.required && !field.readOnly) {\n          requiredFields.push(field.name);\n        }\n      });\n\n      return {\n        ...state,\n        fields: fieldMap,\n        requiredFields,\n        totalRequiredFields: requiredFields.length,\n        completedFields: fields.filter(f => f.isComplete).map(f => f.name),\n        completionPercentage: FormFieldService.calculateCompletionPercentage(fields),\n        currentFieldIndex: 0\n      };\n    }\n\n    case 'UPDATE_FIELD_VALUE': {\n      const { fieldName, value, page } = action.payload;\n      const newFields = new Map(state.fields);\n      const existingField = newFields.get(fieldName);\n\n      if (existingField) {\n        const updatedField: FormFieldValue = {\n          ...existingField,\n          value,\n          page,\n          isValid: true, // Will be validated separately\n          errors: []\n        };\n        newFields.set(fieldName, updatedField);\n      }\n\n      return {\n        ...state,\n        fields: newFields\n      };\n    }\n\n    case 'SET_CURRENT_FIELD': {\n      return {\n        ...state,\n        currentFieldIndex: action.payload\n      };\n    }\n\n    case 'MARK_FIELD_COMPLETE': {\n      const fieldName = action.payload;\n      const completedFields = [...state.completedFields];\n      \n      if (!completedFields.includes(fieldName)) {\n        completedFields.push(fieldName);\n      }\n\n      return {\n        ...state,\n        completedFields,\n        completionPercentage: Math.round((completedFields.length / Math.max(state.totalRequiredFields, 1)) * 100)\n      };\n    }\n\n    case 'SET_FIELD_ERRORS': {\n      const { fieldName, errors } = action.payload;\n      const newFields = new Map(state.fields);\n      const field = newFields.get(fieldName);\n\n      if (field) {\n        newFields.set(fieldName, {\n          ...field,\n          errors,\n          isValid: errors.length === 0\n        });\n      }\n\n      return {\n        ...state,\n        fields: newFields\n      };\n    }\n\n    case 'SET_FIELD_VALIDATION': {\n      const { fieldName, validation } = action.payload;\n      const newValidationResults = new Map(state.validationResults);\n      const newFields = new Map(state.fields);\n      const field = newFields.get(fieldName);\n\n      newValidationResults.set(fieldName, validation);\n\n      if (field) {\n        newFields.set(fieldName, {\n          ...field,\n          errors: validation.errors,\n          isValid: validation.isValid\n        });\n      }\n\n      return {\n        ...state,\n        fields: newFields,\n        validationResults: newValidationResults\n      };\n    }\n\n    case 'CALCULATE_PROGRESS': {\n      const completedRequiredFields = state.completedFields.filter(fieldName =>\n        state.requiredFields.includes(fieldName)\n      );\n\n      return {\n        ...state,\n        completionPercentage: Math.round((completedRequiredFields.length / Math.max(state.totalRequiredFields, 1)) * 100)\n      };\n    }\n\n    case 'RESET_FORM': {\n      return {\n        ...initialState,\n        fields: new Map(\n          Array.from(state.fields.entries()).map(([key, field]) => [\n            key,\n            {\n              ...field,\n              value: field.fieldName.includes('checkbox') ? false : '',\n              isValid: !state.requiredFields.includes(field.fieldName),\n              errors: []\n            }\n          ])\n        ),\n        requiredFields: state.requiredFields,\n        totalRequiredFields: state.totalRequiredFields\n      };\n    }\n\n    default:\n      return state;\n  }\n}\n\n// Form Provider\nexport const FormProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const [state, dispatch] = useReducer(formReducer, initialState);\n\n  // Initialize fields\n  const initializeFields = useCallback((fields: FormField[]) => {\n    dispatch({ type: 'INITIALIZE_FIELDS', payload: fields });\n  }, []);\n\n  // Update field value\n  const updateFieldValue = useCallback((fieldName: string, value: any, page: number) => {\n    dispatch({ type: 'UPDATE_FIELD_VALUE', payload: { fieldName, value, page } });\n    \n    // Auto-validate the field after a short delay\n    setTimeout(async () => {\n      await validateField(fieldName);\n    }, 100);\n  }, []);\n\n  // Set current field\n  const setCurrentField = useCallback((index: number) => {\n    dispatch({ type: 'SET_CURRENT_FIELD', payload: index });\n  }, []);\n\n  // Mark field as complete\n  const markFieldComplete = useCallback((fieldName: string) => {\n    dispatch({ type: 'MARK_FIELD_COMPLETE', payload: fieldName });\n    dispatch({ type: 'CALCULATE_PROGRESS' });\n  }, []);\n\n  // Validate field using ValidationService\n  const validateField = useCallback(async (fieldName: string): Promise<ValidationResult> => {\n    const fieldValue = state.fields.get(fieldName);\n    if (!fieldValue) {\n      const emptyResult: ValidationResult = {\n        isValid: false,\n        errors: ['Field not found'],\n        warnings: [],\n        fieldName,\n        validatedAt: Date.now()\n      };\n      return emptyResult;\n    }\n\n    // Create a temporary FormField for validation\n    const tempField: FormField = {\n      name: fieldName,\n      type: 'text', // Default type, should be enhanced based on field analysis\n      value: fieldValue.value,\n      required: state.requiredFields.includes(fieldName),\n      readOnly: false,\n      page: fieldValue.page,\n      rect: [0, 0, 0, 0],\n      isComplete: state.completedFields.includes(fieldName),\n      validationErrors: [],\n      id: fieldName,\n      subtype: ''\n    };\n\n    // Get all fields for dependency validation\n    const allFields: FormField[] = Array.from(state.fields.entries()).map(([name, value]) => ({\n      name,\n      type: 'text',\n      value: value.value,\n      required: state.requiredFields.includes(name),\n      readOnly: false,\n      page: value.page,\n      rect: [0, 0, 0, 0],\n      isComplete: state.completedFields.includes(name),\n      validationErrors: value.errors,\n      id: name,\n      subtype: ''\n    }));\n\n    try {\n      const validationResult = await ValidationService.validateField(\n        tempField, \n        fieldValue.value, \n        allFields,\n        {\n          validateRequired: true,\n          validateFormat: true,\n          validateDependencies: true,\n          excludeReadOnly: true\n        }\n      );\n\n      // Update state with validation result\n      dispatch({ \n        type: 'SET_FIELD_VALIDATION', \n        payload: { fieldName, validation: validationResult } \n      });\n\n      // Mark field as complete if valid\n      if (validationResult.isValid && !state.completedFields.includes(fieldName)) {\n        markFieldComplete(fieldName);\n      }\n\n      return validationResult;\n\n    } catch (error) {\n      console.error(`Validation failed for field \"${fieldName}\":`, error);\n      const errorResult: ValidationResult = {\n        isValid: false,\n        errors: ['Validation error occurred'],\n        warnings: [],\n        fieldName,\n        validatedAt: Date.now()\n      };\n      \n      dispatch({ \n        type: 'SET_FIELD_VALIDATION', \n        payload: { fieldName, validation: errorResult } \n      });\n      \n      return errorResult;\n    }\n  }, [state.fields, state.requiredFields, state.completedFields, markFieldComplete]);\n\n  // Validate all fields\n  const validateAllFields = useCallback(async (): Promise<Record<string, ValidationResult>> => {\n    const allFields: FormField[] = Array.from(state.fields.entries()).map(([name, value]) => ({\n      name,\n      type: 'text',\n      value: value.value,\n      required: state.requiredFields.includes(name),\n      readOnly: false,\n      page: value.page,\n      rect: [0, 0, 0, 0],\n      isComplete: state.completedFields.includes(name),\n      validationErrors: value.errors,\n      id: name,\n      subtype: ''\n    }));\n\n    const fieldValues: Record<string, any> = {};\n    state.fields.forEach((value, name) => {\n      fieldValues[name] = value.value;\n    });\n\n    try {\n      const validationResults = await ValidationService.validateFields(\n        allFields,\n        fieldValues,\n        {\n          validateRequired: true,\n          validateFormat: true,\n          validateDependencies: true,\n          excludeReadOnly: true\n        }\n      );\n\n      // Update all validation results in state\n      Object.entries(validationResults).forEach(([fieldName, result]) => {\n        dispatch({\n          type: 'SET_FIELD_VALIDATION',\n          payload: { fieldName, validation: result }\n        });\n      });\n\n      return validationResults;\n\n    } catch (error) {\n      console.error('Bulk validation failed:', error);\n      return {};\n    }\n  }, [state.fields, state.requiredFields, state.completedFields]);\n\n  // Get next incomplete field\n  const getNextIncompleteField = useCallback((): FormField | null => {\n    const incompleteFields = Array.from(state.fields.entries())\n      .filter(([fieldName]) => \n        !state.completedFields.includes(fieldName) && \n        state.requiredFields.includes(fieldName)\n      );\n\n    if (incompleteFields.length === 0) return null;\n\n    return {\n      name: incompleteFields[0][0],\n      type: 'text',\n      value: incompleteFields[0][1].value,\n      required: true,\n      readOnly: false,\n      page: incompleteFields[0][1].page,\n      rect: [0, 0, 0, 0],\n      isComplete: false,\n      validationErrors: incompleteFields[0][1].errors,\n      id: incompleteFields[0][0],\n      subtype: ''\n    };\n  }, [state.fields, state.completedFields, state.requiredFields]);\n\n  // Get current field\n  const getCurrentField = useCallback((): FormField | null => {\n    const fieldsArray = Array.from(state.fields.keys());\n    if (state.currentFieldIndex < 0 || state.currentFieldIndex >= fieldsArray.length) {\n      return null;\n    }\n\n    const fieldName = fieldsArray[state.currentFieldIndex];\n    const fieldValue = state.fields.get(fieldName);\n    if (!fieldValue) return null;\n\n    return {\n      name: fieldName,\n      type: 'text',\n      value: fieldValue.value,\n      required: state.requiredFields.includes(fieldName),\n      readOnly: false,\n      page: fieldValue.page,\n      rect: [0, 0, 0, 0],\n      isComplete: state.completedFields.includes(fieldName),\n      validationErrors: fieldValue.errors,\n      id: fieldName,\n      subtype: ''\n    };\n  }, [state.fields, state.currentFieldIndex, state.requiredFields, state.completedFields]);\n\n  // Get field by name\n  const getFieldByName = useCallback((fieldName: string): FormField | null => {\n    const fieldValue = state.fields.get(fieldName);\n    if (!fieldValue) return null;\n\n    return {\n      name: fieldName,\n      type: 'text',\n      value: fieldValue.value,\n      required: state.requiredFields.includes(fieldName),\n      readOnly: false,\n      page: fieldValue.page,\n      rect: [0, 0, 0, 0],\n      isComplete: state.completedFields.includes(fieldName),\n      validationErrors: fieldValue.errors,\n      id: fieldName,\n      subtype: ''\n    };\n  }, [state.fields, state.requiredFields, state.completedFields]);\n\n  // Get completion percentage\n  const getCompletionPercentage = useCallback((): number => {\n    return state.completionPercentage;\n  }, [state.completionPercentage]);\n\n  // Get required fields status\n  const getRequiredFieldsStatus = useCallback(() => {\n    const completedRequired = state.completedFields.filter(fieldName =>\n      state.requiredFields.includes(fieldName)\n    );\n\n    return {\n      completed: completedRequired.length,\n      total: state.totalRequiredFields\n    };\n  }, [state.completedFields, state.requiredFields, state.totalRequiredFields]);\n\n  // Check if form is valid\n  const isFormValid = useCallback((): boolean => {\n    const allRequiredCompleted = state.requiredFields.every(fieldName =>\n      state.completedFields.includes(fieldName)\n    );\n\n    const noErrors = Array.from(state.fields.values()).every(field =>\n      field.errors.length === 0\n    );\n\n    return allRequiredCompleted && noErrors;\n  }, [state.requiredFields, state.completedFields, state.fields]);\n\n  // Get all form errors\n  const getFormErrors = useCallback((): Record<string, string[]> => {\n    const errors: Record<string, string[]> = {};\n\n    state.fields.forEach((field, fieldName) => {\n      if (field.errors.length > 0) {\n        errors[fieldName] = field.errors;\n      }\n    });\n\n    return errors;\n  }, [state.fields]);\n\n  // Get field validation result\n  const getFieldValidation = useCallback((fieldName: string): ValidationResult | null => {\n    return state.validationResults.get(fieldName) || null;\n  }, [state.validationResults]);\n\n  // Reset form\n  const resetForm = useCallback(() => {\n    dispatch({ type: 'RESET_FORM' });\n    ValidationService.clearValidationCache();\n    console.log('Form has been reset to initial state');\n  }, []);\n\n  // Reset form after successful submission\n  const resetAfterSubmission = useCallback(() => {\n    resetForm();\n    \n    // Additional cleanup for post-submission reset\n    setTimeout(() => {\n      // Clear any temporary data\n      sessionStorage.removeItem('sprkz-form-draft');\n      console.log('Post-submission cleanup completed');\n    }, 100);\n  }, [resetForm]);\n\n  // Update isValid when state changes\n  useEffect(() => {\n    const formValid = isFormValid();\n    if (state.isValid !== formValid) {\n      // Update state.isValid if needed (would require additional action)\n    }\n  }, [state.fields, state.completedFields, state.requiredFields, isFormValid, state.isValid]);\n\n  const contextValue: FormContextType = {\n    state,\n    updateFieldValue,\n    setCurrentField,\n    markFieldComplete,\n    validateField,\n    validateAllFields,\n    getNextIncompleteField,\n    getCurrentField,\n    getFieldByName,\n    getCompletionPercentage,\n    getRequiredFieldsStatus,\n    isFormValid,\n    getFormErrors,\n    getFieldValidation,\n    resetForm,\n    resetAfterSubmission,\n    initializeFields\n  };\n\n  return (\n    <FormContext.Provider value={contextValue}>\n      {children}\n    </FormContext.Provider>\n  );\n};\n\n// Hook to use form context\nexport const useForm = () => {\n  const context = useContext(FormContext);\n  if (context === undefined) {\n    throw new Error('useForm must be used within a FormProvider');\n  }\n  return context;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}