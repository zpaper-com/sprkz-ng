{"version":3,"file":"browserTracingIntegration.js","sources":["../../../../src/tracing/browserTracingIntegration.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport type { Client, IntegrationFn, Span, StartSpanOptions, TransactionSource, WebFetchHeaders } from '@sentry/core';\nimport {\n  addNonEnumerableProperty,\n  browserPerformanceTimeOrigin,\n  dateTimestampInSeconds,\n  debug,\n  generateTraceId,\n  getClient,\n  getCurrentScope,\n  getDynamicSamplingContextFromSpan,\n  getIsolationScope,\n  getLocationHref,\n  GLOBAL_OBJ,\n  parseStringToURLObject,\n  propagationContextFromHeaders,\n  registerSpanErrorInstrumentation,\n  SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  spanIsSampled,\n  spanToJSON,\n  startIdleSpan,\n  startInactiveSpan,\n  timestampInSeconds,\n  TRACING_DEFAULTS,\n} from '@sentry/core';\nimport {\n  addHistoryInstrumentationHandler,\n  addPerformanceEntries,\n  registerInpInteractionListener,\n  startTrackingElementTiming,\n  startTrackingINP,\n  startTrackingInteractions,\n  startTrackingLongAnimationFrames,\n  startTrackingLongTasks,\n  startTrackingWebVitals,\n} from '@sentry-internal/browser-utils';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { getHttpRequestData, WINDOW } from '../helpers';\nimport { registerBackgroundTabDetection } from './backgroundtab';\nimport { linkTraces } from './linkedTraces';\nimport { defaultRequestInstrumentationOptions, instrumentOutgoingRequests } from './request';\n\nexport const BROWSER_TRACING_INTEGRATION_ID = 'BrowserTracing';\n\ninterface RouteInfo {\n  name: string | undefined;\n  source: TransactionSource | undefined;\n}\n\n/** Options for Browser Tracing integration */\nexport interface BrowserTracingOptions {\n  /**\n   * The time that has to pass without any span being created.\n   * If this time is exceeded, the idle span will finish.\n   *\n   * Default: 1000 (ms)\n   */\n  idleTimeout: number;\n\n  /**\n   * The max. time an idle span may run.\n   * If this time is exceeded, the idle span will finish no matter what.\n   *\n   * Default: 30000 (ms)\n   */\n  finalTimeout: number;\n\n  /**\n   The max. time an idle span may run.\n   * If this time is exceeded, the idle span will finish no matter what.\n   *\n   * Default: 15000 (ms)\n   */\n  childSpanTimeout: number;\n\n  /**\n   * If a span should be created on page load.\n   * If this is set to `false`, this integration will not start the default page load span.\n   * Default: true\n   */\n  instrumentPageLoad: boolean;\n\n  /**\n   * If a span should be created on navigation (history change).\n   * If this is set to `false`, this integration will not start the default navigation spans.\n   * Default: true\n   */\n  instrumentNavigation: boolean;\n\n  /**\n   * Flag spans where tabs moved to background with \"cancelled\". Browser background tab timing is\n   * not suited towards doing precise measurements of operations. By default, we recommend that this option\n   * be enabled as background transactions can mess up your statistics in nondeterministic ways.\n   *\n   * Default: true\n   */\n  markBackgroundSpan: boolean;\n\n  /**\n   * If true, Sentry will capture long tasks and add them to the corresponding transaction.\n   *\n   * Default: true\n   */\n  enableLongTask: boolean;\n\n  /**\n   * If true, Sentry will capture long animation frames and add them to the corresponding transaction.\n   *\n   * Default: false\n   */\n  enableLongAnimationFrame: boolean;\n\n  /**\n   * If true, Sentry will capture first input delay and add it to the corresponding transaction.\n   *\n   * Default: true\n   */\n  enableInp: boolean;\n\n  /**\n   * If true, Sentry will capture [element timing](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceElementTiming)\n   * information and add it to the corresponding transaction.\n   *\n   * Default: true\n   */\n  enableElementTiming: boolean;\n\n  /**\n   * Flag to disable patching all together for fetch requests.\n   *\n   * Default: true\n   */\n  traceFetch: boolean;\n\n  /**\n   * Flag to disable patching all together for xhr requests.\n   *\n   * Default: true\n   */\n  traceXHR: boolean;\n\n  /**\n   * Flag to disable tracking of long-lived streams, like server-sent events (SSE) via fetch.\n   * Do not enable this in case you have live streams or very long running streams.\n   *\n   * Default: false\n   */\n  trackFetchStreamPerformance: boolean;\n\n  /**\n   * If true, Sentry will capture http timings and add them to the corresponding http spans.\n   *\n   * Default: true\n   */\n  enableHTTPTimings: boolean;\n\n  /**\n   * Resource spans with `op`s matching strings in the array will not be emitted.\n   *\n   * Default: []\n   */\n  ignoreResourceSpans: Array<'resouce.script' | 'resource.css' | 'resource.img' | 'resource.other' | string>;\n\n  /**\n   * Spans created from the following browser Performance APIs,\n   *\n   * - [`performance.mark(...)`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark)\n   * - [`performance.measure(...)`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/measure)\n   *\n   * will not be emitted if their names match strings in this array.\n   *\n   * This is useful, if you come across `mark` or `measure` spans in your Sentry traces\n   * that you want to ignore. For example, sometimes, browser extensions or libraries\n   * emit these entries on their own, which might not be relevant to your application.\n   *\n   * * @example\n   * ```ts\n   * Sentry.init({\n   *   integrations: [\n   *     Sentry.browserTracingIntegration({\n   *      ignorePerformanceApiSpans: ['myMeasurement', /myMark/],\n   *     }),\n   *   ],\n   * });\n   *\n   * // no spans will be created for these:\n   * performance.mark('myMark');\n   * performance.measure('myMeasurement');\n   *\n   * // spans will be created for these:\n   * performance.mark('authenticated');\n   * performance.measure('input-duration', ...);\n   * ```\n   *\n   * Default: [] - By default, all `mark` and `measure` entries are sent as spans.\n   */\n  ignorePerformanceApiSpans: Array<string | RegExp>;\n\n  /**\n   * By default, the SDK will try to detect redirects and avoid creating separate spans for them.\n   * If you want to opt-out of this behavior, you can set this option to `false`.\n   *\n   * Default: true\n   */\n  detectRedirects: boolean;\n\n  /**\n   * Link the currently started trace to a previous trace (e.g. a prior pageload, navigation or\n   * manually started span). When enabled, this option will allow you to navigate between traces\n   * in the Sentry UI.\n   *\n   * You can set this option to the following values:\n   *\n   * - `'in-memory'`: The previous trace data will be stored in memory.\n   *   This is useful for single-page applications and enabled by default.\n   *\n   * - `'session-storage'`: The previous trace data will be stored in the `sessionStorage`.\n   *   This is useful for multi-page applications or static sites but it means that the\n   *   Sentry SDK writes to the browser's `sessionStorage`.\n   *\n   * - `'off'`: The previous trace data will not be stored or linked.\n   *\n   * You can also use {@link BrowserTracingOptions.consistentTraceSampling} to get\n   * consistent trace sampling of subsequent traces. Otherwise, by default, your\n   * `tracesSampleRate` or `tracesSampler` config significantly influences how often\n   * traces will be linked.\n   *\n   * @default 'in-memory' - see explanation above\n   */\n  linkPreviousTrace: 'in-memory' | 'session-storage' | 'off';\n\n  /**\n   * If true, Sentry will consistently sample subsequent traces based on the\n   * sampling decision of the initial trace. For example, if the initial page\n   * load trace was sampled positively, all subsequent traces (e.g. navigations)\n   * are also sampled positively. In case the initial trace was sampled negatively,\n   * all subsequent traces are also sampled negatively.\n   *\n   * This option allows you to get consistent, linked traces within a user journey\n   * while maintaining an overall quota based on your trace sampling settings.\n   *\n   * This option is only effective if {@link BrowserTracingOptions.linkPreviousTrace}\n   * is enabled (i.e. not set to `'off'`).\n   *\n   * @default `false` - this is an opt-in feature.\n   */\n  consistentTraceSampling: boolean;\n\n  /**\n   * _experiments allows the user to send options to define how this integration works.\n   *\n   * Default: undefined\n   */\n  _experiments: Partial<{\n    enableInteractions: boolean;\n    enableStandaloneClsSpans: boolean;\n    enableStandaloneLcpSpans: boolean;\n  }>;\n\n  /**\n   * A callback which is called before a span for a pageload or navigation is started.\n   * It receives the options passed to `startSpan`, and expects to return an updated options object.\n   */\n  beforeStartSpan?: (options: StartSpanOptions) => StartSpanOptions;\n\n  /**\n   * This function will be called before creating a span for a request with the given url.\n   * Return false if you don't want a span for the given url.\n   *\n   * Default: (url: string) => true\n   */\n  shouldCreateSpanForRequest?(this: void, url: string): boolean;\n\n  /**\n   * This callback is invoked directly after a span is started for an outgoing fetch or XHR request.\n   * You can use it to annotate the span with additional data or attributes, for example by setting\n   * attributes based on the passed request headers.\n   */\n  onRequestSpanStart?(span: Span, requestInformation: { headers?: WebFetchHeaders }): void;\n}\n\nconst DEFAULT_BROWSER_TRACING_OPTIONS: BrowserTracingOptions = {\n  ...TRACING_DEFAULTS,\n  instrumentNavigation: true,\n  instrumentPageLoad: true,\n  markBackgroundSpan: true,\n  enableLongTask: true,\n  enableLongAnimationFrame: true,\n  enableInp: true,\n  enableElementTiming: true,\n  ignoreResourceSpans: [],\n  ignorePerformanceApiSpans: [],\n  detectRedirects: true,\n  linkPreviousTrace: 'in-memory',\n  consistentTraceSampling: false,\n  _experiments: {},\n  ...defaultRequestInstrumentationOptions,\n};\n\n/**\n * The Browser Tracing integration automatically instruments browser pageload/navigation\n * actions as transactions, and captures requests, metrics and errors as spans.\n *\n * The integration can be configured with a variety of options, and can be extended to use\n * any routing library.\n *\n * We explicitly export the proper type here, as this has to be extended in some cases.\n */\nexport const browserTracingIntegration = ((_options: Partial<BrowserTracingOptions> = {}) => {\n  const latestRoute: RouteInfo = {\n    name: undefined,\n    source: undefined,\n  };\n\n  /**\n   * This is just a small wrapper that makes `document` optional.\n   * We want to be extra-safe and always check that this exists, to ensure weird environments do not blow up.\n   */\n  const optionalWindowDocument = WINDOW.document as (typeof WINDOW)['document'] | undefined;\n\n  const {\n    enableInp,\n    enableElementTiming,\n    enableLongTask,\n    enableLongAnimationFrame,\n    _experiments: { enableInteractions, enableStandaloneClsSpans, enableStandaloneLcpSpans },\n    beforeStartSpan,\n    idleTimeout,\n    finalTimeout,\n    childSpanTimeout,\n    markBackgroundSpan,\n    traceFetch,\n    traceXHR,\n    trackFetchStreamPerformance,\n    shouldCreateSpanForRequest,\n    enableHTTPTimings,\n    ignoreResourceSpans,\n    ignorePerformanceApiSpans,\n    instrumentPageLoad,\n    instrumentNavigation,\n    detectRedirects,\n    linkPreviousTrace,\n    consistentTraceSampling,\n    onRequestSpanStart,\n  } = {\n    ...DEFAULT_BROWSER_TRACING_OPTIONS,\n    ..._options,\n  };\n\n  let _collectWebVitals: undefined | (() => void);\n  let lastInteractionTimestamp: number | undefined;\n\n  /** Create routing idle transaction. */\n  function _createRouteSpan(client: Client, startSpanOptions: StartSpanOptions, makeActive = true): void {\n    const isPageloadTransaction = startSpanOptions.op === 'pageload';\n\n    const finalStartSpanOptions: StartSpanOptions = beforeStartSpan\n      ? beforeStartSpan(startSpanOptions)\n      : startSpanOptions;\n\n    const attributes = finalStartSpanOptions.attributes || {};\n\n    // If `finalStartSpanOptions.name` is different than `startSpanOptions.name`\n    // it is because `beforeStartSpan` set a custom name. Therefore we set the source to 'custom'.\n    if (startSpanOptions.name !== finalStartSpanOptions.name) {\n      attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] = 'custom';\n      finalStartSpanOptions.attributes = attributes;\n    }\n\n    if (!makeActive) {\n      // We want to ensure this has 0s duration\n      const now = dateTimestampInSeconds();\n      startInactiveSpan({\n        ...finalStartSpanOptions,\n        startTime: now,\n      }).end(now);\n      return;\n    }\n\n    latestRoute.name = finalStartSpanOptions.name;\n    latestRoute.source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n\n    const idleSpan = startIdleSpan(finalStartSpanOptions, {\n      idleTimeout,\n      finalTimeout,\n      childSpanTimeout,\n      // should wait for finish signal if it's a pageload transaction\n      disableAutoFinish: isPageloadTransaction,\n      beforeSpanEnd: span => {\n        // This will generally always be defined here, because it is set in `setup()` of the integration\n        // but technically, it is optional, so we guard here to be extra safe\n        _collectWebVitals?.();\n        addPerformanceEntries(span, {\n          recordClsOnPageloadSpan: !enableStandaloneClsSpans,\n          recordLcpOnPageloadSpan: !enableStandaloneLcpSpans,\n          ignoreResourceSpans,\n          ignorePerformanceApiSpans,\n        });\n        setActiveIdleSpan(client, undefined);\n\n        // A trace should stay consistent over the entire timespan of one route - even after the pageload/navigation ended.\n        // Only when another navigation happens, we want to create a new trace.\n        // This way, e.g. errors that occur after the pageload span ended are still associated to the pageload trace.\n        const scope = getCurrentScope();\n        const oldPropagationContext = scope.getPropagationContext();\n\n        scope.setPropagationContext({\n          ...oldPropagationContext,\n          traceId: idleSpan.spanContext().traceId,\n          sampled: spanIsSampled(idleSpan),\n          dsc: getDynamicSamplingContextFromSpan(span),\n        });\n      },\n    });\n\n    setActiveIdleSpan(client, idleSpan);\n\n    function emitFinish(): void {\n      if (optionalWindowDocument && ['interactive', 'complete'].includes(optionalWindowDocument.readyState)) {\n        client.emit('idleSpanEnableAutoFinish', idleSpan);\n      }\n    }\n\n    if (isPageloadTransaction && optionalWindowDocument) {\n      optionalWindowDocument.addEventListener('readystatechange', () => {\n        emitFinish();\n      });\n\n      emitFinish();\n    }\n  }\n\n  return {\n    name: BROWSER_TRACING_INTEGRATION_ID,\n    setup(client) {\n      registerSpanErrorInstrumentation();\n\n      _collectWebVitals = startTrackingWebVitals({\n        recordClsStandaloneSpans: enableStandaloneClsSpans || false,\n        recordLcpStandaloneSpans: enableStandaloneLcpSpans || false,\n        client,\n      });\n\n      if (enableInp) {\n        startTrackingINP();\n      }\n\n      if (enableElementTiming) {\n        startTrackingElementTiming();\n      }\n\n      if (\n        enableLongAnimationFrame &&\n        GLOBAL_OBJ.PerformanceObserver &&\n        PerformanceObserver.supportedEntryTypes &&\n        PerformanceObserver.supportedEntryTypes.includes('long-animation-frame')\n      ) {\n        startTrackingLongAnimationFrames();\n      } else if (enableLongTask) {\n        startTrackingLongTasks();\n      }\n\n      if (enableInteractions) {\n        startTrackingInteractions();\n      }\n\n      if (detectRedirects && optionalWindowDocument) {\n        const interactionHandler = (): void => {\n          lastInteractionTimestamp = timestampInSeconds();\n        };\n        addEventListener('click', interactionHandler, { capture: true });\n        addEventListener('keydown', interactionHandler, { capture: true, passive: true });\n      }\n\n      function maybeEndActiveSpan(): void {\n        const activeSpan = getActiveIdleSpan(client);\n\n        if (activeSpan && !spanToJSON(activeSpan).timestamp) {\n          DEBUG_BUILD && debug.log(`[Tracing] Finishing current active span with op: ${spanToJSON(activeSpan).op}`);\n          // If there's an open active span, we need to finish it before creating an new one.\n          activeSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON, 'cancelled');\n          activeSpan.end();\n        }\n      }\n\n      client.on('startNavigationSpan', (startSpanOptions, navigationOptions) => {\n        if (getClient() !== client) {\n          return;\n        }\n\n        if (navigationOptions?.isRedirect) {\n          DEBUG_BUILD &&\n            debug.warn('[Tracing] Detected redirect, navigation span will not be the root span, but a child span.');\n          _createRouteSpan(\n            client,\n            {\n              op: 'navigation.redirect',\n              ...startSpanOptions,\n            },\n            false,\n          );\n          return;\n        }\n\n        maybeEndActiveSpan();\n\n        getIsolationScope().setPropagationContext({ traceId: generateTraceId(), sampleRand: Math.random() });\n\n        const scope = getCurrentScope();\n        scope.setPropagationContext({ traceId: generateTraceId(), sampleRand: Math.random() });\n        // We reset this to ensure we do not have lingering incorrect data here\n        // places that call this hook may set this where appropriate - else, the URL at span sending time is used\n        scope.setSDKProcessingMetadata({\n          normalizedRequest: undefined,\n        });\n\n        _createRouteSpan(client, {\n          op: 'navigation',\n          ...startSpanOptions,\n        });\n      });\n\n      client.on('startPageLoadSpan', (startSpanOptions, traceOptions = {}) => {\n        if (getClient() !== client) {\n          return;\n        }\n        maybeEndActiveSpan();\n\n        const sentryTrace = traceOptions.sentryTrace || getMetaContent('sentry-trace');\n        const baggage = traceOptions.baggage || getMetaContent('baggage');\n\n        const propagationContext = propagationContextFromHeaders(sentryTrace, baggage);\n\n        const scope = getCurrentScope();\n        scope.setPropagationContext(propagationContext);\n\n        // We store the normalized request data on the scope, so we get the request data at time of span creation\n        // otherwise, the URL etc. may already be of the following navigation, and we'd report the wrong URL\n        scope.setSDKProcessingMetadata({\n          normalizedRequest: getHttpRequestData(),\n        });\n\n        _createRouteSpan(client, {\n          op: 'pageload',\n          ...startSpanOptions,\n        });\n      });\n    },\n    afterAllSetup(client) {\n      let startingUrl: string | undefined = getLocationHref();\n\n      if (linkPreviousTrace !== 'off') {\n        linkTraces(client, { linkPreviousTrace, consistentTraceSampling });\n      }\n\n      if (WINDOW.location) {\n        if (instrumentPageLoad) {\n          const origin = browserPerformanceTimeOrigin();\n          startBrowserTracingPageLoadSpan(client, {\n            name: WINDOW.location.pathname,\n            // pageload should always start at timeOrigin (and needs to be in s, not ms)\n            startTime: origin ? origin / 1000 : undefined,\n            attributes: {\n              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.pageload.browser',\n            },\n          });\n        }\n\n        if (instrumentNavigation) {\n          addHistoryInstrumentationHandler(({ to, from }) => {\n            /**\n             * This early return is there to account for some cases where a navigation transaction starts right after\n             * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't\n             * create an uneccessary navigation transaction.\n             *\n             * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also\n             * only be caused in certain development environments where the usage of a hot module reloader is causing\n             * errors.\n             */\n            if (from === undefined && startingUrl?.indexOf(to) !== -1) {\n              startingUrl = undefined;\n              return;\n            }\n\n            startingUrl = undefined;\n            const parsed = parseStringToURLObject(to);\n            const activeSpan = getActiveIdleSpan(client);\n            const navigationIsRedirect =\n              activeSpan && detectRedirects && isRedirect(activeSpan, lastInteractionTimestamp);\n            startBrowserTracingNavigationSpan(\n              client,\n              {\n                name: parsed?.pathname || WINDOW.location.pathname,\n                attributes: {\n                  [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n                  [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.browser',\n                },\n              },\n              { url: to, isRedirect: navigationIsRedirect },\n            );\n          });\n        }\n      }\n\n      if (markBackgroundSpan) {\n        registerBackgroundTabDetection();\n      }\n\n      if (enableInteractions) {\n        registerInteractionListener(client, idleTimeout, finalTimeout, childSpanTimeout, latestRoute);\n      }\n\n      if (enableInp) {\n        registerInpInteractionListener();\n      }\n\n      instrumentOutgoingRequests(client, {\n        traceFetch,\n        traceXHR,\n        trackFetchStreamPerformance,\n        tracePropagationTargets: client.getOptions().tracePropagationTargets,\n        shouldCreateSpanForRequest,\n        enableHTTPTimings,\n        onRequestSpanStart,\n      });\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Manually start a page load span.\n * This will only do something if a browser tracing integration integration has been setup.\n *\n * If you provide a custom `traceOptions` object, it will be used to continue the trace\n * instead of the default behavior, which is to look it up on the <meta> tags.\n */\nexport function startBrowserTracingPageLoadSpan(\n  client: Client,\n  spanOptions: StartSpanOptions,\n  traceOptions?: { sentryTrace?: string | undefined; baggage?: string | undefined },\n): Span | undefined {\n  client.emit('startPageLoadSpan', spanOptions, traceOptions);\n  getCurrentScope().setTransactionName(spanOptions.name);\n\n  const pageloadSpan = getActiveIdleSpan(client);\n\n  if (pageloadSpan) {\n    client.emit('afterStartPageLoadSpan', pageloadSpan);\n  }\n\n  return pageloadSpan;\n}\n\n/**\n * Manually start a navigation span.\n * This will only do something if a browser tracing integration has been setup.\n */\nexport function startBrowserTracingNavigationSpan(\n  client: Client,\n  spanOptions: StartSpanOptions,\n  options?: { url?: string; isRedirect?: boolean },\n): Span | undefined {\n  const { url, isRedirect } = options || {};\n  client.emit('beforeStartNavigationSpan', spanOptions, { isRedirect });\n  client.emit('startNavigationSpan', spanOptions, { isRedirect });\n\n  const scope = getCurrentScope();\n  scope.setTransactionName(spanOptions.name);\n\n  // We store the normalized request data on the scope, so we get the request data at time of span creation\n  // otherwise, the URL etc. may already be of the following navigation, and we'd report the wrong URL\n  if (url && !isRedirect) {\n    scope.setSDKProcessingMetadata({\n      normalizedRequest: {\n        ...getHttpRequestData(),\n        url,\n      },\n    });\n  }\n\n  return getActiveIdleSpan(client);\n}\n\n/** Returns the value of a meta tag */\nexport function getMetaContent(metaName: string): string | undefined {\n  /**\n   * This is just a small wrapper that makes `document` optional.\n   * We want to be extra-safe and always check that this exists, to ensure weird environments do not blow up.\n   */\n  const optionalWindowDocument = WINDOW.document as (typeof WINDOW)['document'] | undefined;\n\n  const metaTag = optionalWindowDocument?.querySelector(`meta[name=${metaName}]`);\n  return metaTag?.getAttribute('content') || undefined;\n}\n\n/** Start listener for interaction transactions */\nfunction registerInteractionListener(\n  client: Client,\n  idleTimeout: BrowserTracingOptions['idleTimeout'],\n  finalTimeout: BrowserTracingOptions['finalTimeout'],\n  childSpanTimeout: BrowserTracingOptions['childSpanTimeout'],\n  latestRoute: RouteInfo,\n): void {\n  /**\n   * This is just a small wrapper that makes `document` optional.\n   * We want to be extra-safe and always check that this exists, to ensure weird environments do not blow up.\n   */\n  const optionalWindowDocument = WINDOW.document as (typeof WINDOW)['document'] | undefined;\n\n  let inflightInteractionSpan: Span | undefined;\n  const registerInteractionTransaction = (): void => {\n    const op = 'ui.action.click';\n\n    const activeIdleSpan = getActiveIdleSpan(client);\n    if (activeIdleSpan) {\n      const currentRootSpanOp = spanToJSON(activeIdleSpan).op;\n      if (['navigation', 'pageload'].includes(currentRootSpanOp as string)) {\n        DEBUG_BUILD &&\n          debug.warn(`[Tracing] Did not create ${op} span because a pageload or navigation span is in progress.`);\n        return undefined;\n      }\n    }\n\n    if (inflightInteractionSpan) {\n      inflightInteractionSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON, 'interactionInterrupted');\n      inflightInteractionSpan.end();\n      inflightInteractionSpan = undefined;\n    }\n\n    if (!latestRoute.name) {\n      DEBUG_BUILD && debug.warn(`[Tracing] Did not create ${op} transaction because _latestRouteName is missing.`);\n      return undefined;\n    }\n\n    inflightInteractionSpan = startIdleSpan(\n      {\n        name: latestRoute.name,\n        op,\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: latestRoute.source || 'url',\n        },\n      },\n      {\n        idleTimeout,\n        finalTimeout,\n        childSpanTimeout,\n      },\n    );\n  };\n\n  if (optionalWindowDocument) {\n    addEventListener('click', registerInteractionTransaction, { capture: true });\n  }\n}\n\n// We store the active idle span on the client object, so we can access it from exported functions\nconst ACTIVE_IDLE_SPAN_PROPERTY = '_sentry_idleSpan';\nfunction getActiveIdleSpan(client: Client): Span | undefined {\n  return (client as { [ACTIVE_IDLE_SPAN_PROPERTY]?: Span })[ACTIVE_IDLE_SPAN_PROPERTY];\n}\n\nfunction setActiveIdleSpan(client: Client, span: Span | undefined): void {\n  addNonEnumerableProperty(client, ACTIVE_IDLE_SPAN_PROPERTY, span);\n}\n\n// The max. time in seconds between two pageload/navigation spans that makes us consider the second one a redirect\nconst REDIRECT_THRESHOLD = 0.3;\n\nfunction isRedirect(activeSpan: Span, lastInteractionTimestamp: number | undefined): boolean {\n  const spanData = spanToJSON(activeSpan);\n\n  const now = dateTimestampInSeconds();\n\n  // More than 300ms since last navigation/pageload span?\n  // --> never consider this a redirect\n  const startTimestamp = spanData.start_timestamp;\n  if (now - startTimestamp > REDIRECT_THRESHOLD) {\n    return false;\n  }\n\n  // A click happened in the last 300ms?\n  // --> never consider this a redirect\n  if (lastInteractionTimestamp && now - lastInteractionTimestamp <= REDIRECT_THRESHOLD) {\n    return false;\n  }\n\n  return true;\n}\n"],"names":[],"mappings":"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"}