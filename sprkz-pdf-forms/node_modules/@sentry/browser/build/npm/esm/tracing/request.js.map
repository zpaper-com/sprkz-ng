{"version":3,"file":"request.js","sources":["../../../../src/tracing/request.ts"],"sourcesContent":["import type { Client, HandlerDataXhr, SentryWrappedXMLHttpRequest, Span, WebFetchHeaders } from '@sentry/core';\nimport {\n  addFetchEndInstrumentationHandler,\n  addFetchInstrumentationHandler,\n  getActiveSpan,\n  getClient,\n  getLocationHref,\n  getTraceData,\n  hasSpansEnabled,\n  instrumentFetchRequest,\n  parseUrl,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SentryNonRecordingSpan,\n  setHttpStatus,\n  spanToJSON,\n  startInactiveSpan,\n  stringMatchesSomePattern,\n  stripUrlQueryAndFragment,\n} from '@sentry/core';\nimport type { XhrHint } from '@sentry-internal/browser-utils';\nimport {\n  addPerformanceInstrumentationHandler,\n  addXhrInstrumentationHandler,\n  SENTRY_XHR_DATA_KEY,\n} from '@sentry-internal/browser-utils';\nimport { WINDOW } from '../helpers';\nimport { resourceTimingToSpanAttributes } from './resource-timing';\n\n/** Options for Request Instrumentation */\nexport interface RequestInstrumentationOptions {\n  /**\n   * List of strings and/or Regular Expressions used to determine which outgoing requests will have `sentry-trace` and `baggage`\n   * headers attached.\n   *\n   * **Default:** If this option is not provided, tracing headers will be attached to all outgoing requests.\n   * If you are using a browser SDK, by default, tracing headers will only be attached to outgoing requests to the same origin.\n   *\n   * **Disclaimer:** Carelessly setting this option in browser environments may result into CORS errors!\n   * Only attach tracing headers to requests to the same origin, or to requests to services you can control CORS headers of.\n   * Cross-origin requests, meaning requests to a different domain, for example a request to `https://api.example.com/` while you're on `https://example.com/`, take special care.\n   * If you are attaching headers to cross-origin requests, make sure the backend handling the request returns a `\"Access-Control-Allow-Headers: sentry-trace, baggage\"` header to ensure your requests aren't blocked.\n   *\n   * If you provide a `tracePropagationTargets` array, the entries you provide will be matched against the entire URL of the outgoing request.\n   * If you are using a browser SDK, the entries will also be matched against the pathname of the outgoing requests.\n   * This is so you can have matchers for relative requests, for example, `/^\\/api/` if you want to trace requests to your `/api` routes on the same domain.\n   *\n   * If any of the two match any of the provided values, tracing headers will be attached to the outgoing request.\n   * Both, the string values, and the RegExes you provide in the array will match if they partially match the URL or pathname.\n   *\n   * Examples:\n   * - `tracePropagationTargets: [/^\\/api/]` and request to `https://same-origin.com/api/posts`:\n   *   - Tracing headers will be attached because the request is sent to the same origin and the regex matches the pathname \"/api/posts\".\n   * - `tracePropagationTargets: [/^\\/api/]` and request to `https://different-origin.com/api/posts`:\n   *   - Tracing headers will not be attached because the pathname will only be compared when the request target lives on the same origin.\n   * - `tracePropagationTargets: [/^\\/api/, 'https://external-api.com']` and request to `https://external-api.com/v1/data`:\n   *   - Tracing headers will be attached because the request URL matches the string `'https://external-api.com'`.\n   */\n  tracePropagationTargets?: Array<string | RegExp>;\n\n  /**\n   * Flag to disable patching all together for fetch requests.\n   *\n   * Default: true\n   */\n  traceFetch: boolean;\n\n  /**\n   * Flag to disable patching all together for xhr requests.\n   *\n   * Default: true\n   */\n  traceXHR: boolean;\n\n  /**\n   * Flag to disable tracking of long-lived streams, like server-sent events (SSE) via fetch.\n   * Do not enable this in case you have live streams or very long running streams.\n   *\n   * Disabled by default since it can lead to issues with streams using the `cancel()` api\n   * (https://github.com/getsentry/sentry-javascript/issues/13950)\n   *\n   * Default: false\n   */\n  trackFetchStreamPerformance: boolean;\n\n  /**\n   * If true, Sentry will capture http timings and add them to the corresponding http spans.\n   *\n   * Default: true\n   */\n  enableHTTPTimings: boolean;\n\n  /**\n   * This function will be called before creating a span for a request with the given url.\n   * Return false if you don't want a span for the given url.\n   *\n   * Default: (url: string) => true\n   */\n  shouldCreateSpanForRequest?(this: void, url: string): boolean;\n\n  /**\n   * Is called when spans are started for outgoing requests.\n   */\n  onRequestSpanStart?(span: Span, requestInformation: { headers?: WebFetchHeaders }): void;\n}\n\nconst responseToSpanId = new WeakMap<object, string>();\nconst spanIdToEndTimestamp = new Map<string, number>();\n\nexport const defaultRequestInstrumentationOptions: RequestInstrumentationOptions = {\n  traceFetch: true,\n  traceXHR: true,\n  enableHTTPTimings: true,\n  trackFetchStreamPerformance: false,\n};\n\n/** Registers span creators for xhr and fetch requests  */\nexport function instrumentOutgoingRequests(client: Client, _options?: Partial<RequestInstrumentationOptions>): void {\n  const {\n    traceFetch,\n    traceXHR,\n    trackFetchStreamPerformance,\n    shouldCreateSpanForRequest,\n    enableHTTPTimings,\n    tracePropagationTargets,\n    onRequestSpanStart,\n  } = {\n    ...defaultRequestInstrumentationOptions,\n    ..._options,\n  };\n\n  const shouldCreateSpan =\n    typeof shouldCreateSpanForRequest === 'function' ? shouldCreateSpanForRequest : (_: string) => true;\n\n  const shouldAttachHeadersWithTargets = (url: string): boolean => shouldAttachHeaders(url, tracePropagationTargets);\n\n  const spans: Record<string, Span> = {};\n\n  if (traceFetch) {\n    // Keeping track of http requests, whose body payloads resolved later than the initial resolved request\n    // e.g. streaming using server sent events (SSE)\n    client.addEventProcessor(event => {\n      if (event.type === 'transaction' && event.spans) {\n        event.spans.forEach(span => {\n          if (span.op === 'http.client') {\n            const updatedTimestamp = spanIdToEndTimestamp.get(span.span_id);\n            if (updatedTimestamp) {\n              span.timestamp = updatedTimestamp / 1000;\n              spanIdToEndTimestamp.delete(span.span_id);\n            }\n          }\n        });\n      }\n      return event;\n    });\n\n    if (trackFetchStreamPerformance) {\n      addFetchEndInstrumentationHandler(handlerData => {\n        if (handlerData.response) {\n          const span = responseToSpanId.get(handlerData.response);\n          if (span && handlerData.endTimestamp) {\n            spanIdToEndTimestamp.set(span, handlerData.endTimestamp);\n          }\n        }\n      });\n    }\n\n    addFetchInstrumentationHandler(handlerData => {\n      const createdSpan = instrumentFetchRequest(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n\n      if (handlerData.response && handlerData.fetchData.__span) {\n        responseToSpanId.set(handlerData.response, handlerData.fetchData.__span);\n      }\n\n      // We cannot use `window.location` in the generic fetch instrumentation,\n      // but we need it for reliable `server.address` attribute.\n      // so we extend this in here\n      if (createdSpan) {\n        const fullUrl = getFullURL(handlerData.fetchData.url);\n        const host = fullUrl ? parseUrl(fullUrl).host : undefined;\n        createdSpan.setAttributes({\n          'http.url': fullUrl,\n          'server.address': host,\n        });\n\n        if (enableHTTPTimings) {\n          addHTTPTimings(createdSpan);\n        }\n\n        onRequestSpanStart?.(createdSpan, { headers: handlerData.headers });\n      }\n    });\n  }\n\n  if (traceXHR) {\n    addXhrInstrumentationHandler(handlerData => {\n      const createdSpan = xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n      if (createdSpan) {\n        if (enableHTTPTimings) {\n          addHTTPTimings(createdSpan);\n        }\n\n        let headers;\n        try {\n          headers = new Headers(handlerData.xhr.__sentry_xhr_v3__?.request_headers);\n        } catch {\n          // noop\n        }\n        onRequestSpanStart?.(createdSpan, { headers });\n      }\n    });\n  }\n}\n\nfunction isPerformanceResourceTiming(entry: PerformanceEntry): entry is PerformanceResourceTiming {\n  return (\n    entry.entryType === 'resource' &&\n    'initiatorType' in entry &&\n    typeof (entry as PerformanceResourceTiming).nextHopProtocol === 'string' &&\n    (entry.initiatorType === 'fetch' || entry.initiatorType === 'xmlhttprequest')\n  );\n}\n\n/**\n * Creates a temporary observer to listen to the next fetch/xhr resourcing timings,\n * so that when timings hit their per-browser limit they don't need to be removed.\n *\n * @param span A span that has yet to be finished, must contain `url` on data.\n */\nfunction addHTTPTimings(span: Span): void {\n  const { url } = spanToJSON(span).data;\n\n  if (!url || typeof url !== 'string') {\n    return;\n  }\n\n  const cleanup = addPerformanceInstrumentationHandler('resource', ({ entries }) => {\n    entries.forEach(entry => {\n      if (isPerformanceResourceTiming(entry) && entry.name.endsWith(url)) {\n        const spanAttributes = resourceTimingToSpanAttributes(entry);\n        spanAttributes.forEach(attributeArray => span.setAttribute(...attributeArray));\n        // In the next tick, clean this handler up\n        // We have to wait here because otherwise this cleans itself up before it is fully done\n        setTimeout(cleanup);\n      }\n    });\n  });\n}\n\n/**\n * A function that determines whether to attach tracing headers to a request.\n * We only export this function for testing purposes.\n */\nexport function shouldAttachHeaders(\n  targetUrl: string,\n  tracePropagationTargets: (string | RegExp)[] | undefined,\n): boolean {\n  // window.location.href not being defined is an edge case in the browser but we need to handle it.\n  // Potentially dangerous situations where it may not be defined: Browser Extensions, Web Workers, patching of the location obj\n  const href = getLocationHref();\n\n  if (!href) {\n    // If there is no window.location.origin, we default to only attaching tracing headers to relative requests, i.e. ones that start with `/`\n    // BIG DISCLAIMER: Users can call URLs with a double slash (fetch(\"//example.com/api\")), this is a shorthand for \"send to the same protocol\",\n    // so we need a to exclude those requests, because they might be cross origin.\n    const isRelativeSameOriginRequest = !!targetUrl.match(/^\\/(?!\\/)/);\n    if (!tracePropagationTargets) {\n      return isRelativeSameOriginRequest;\n    } else {\n      return stringMatchesSomePattern(targetUrl, tracePropagationTargets);\n    }\n  } else {\n    let resolvedUrl;\n    let currentOrigin;\n\n    // URL parsing may fail, we default to not attaching trace headers in that case.\n    try {\n      resolvedUrl = new URL(targetUrl, href);\n      currentOrigin = new URL(href).origin;\n    } catch {\n      return false;\n    }\n\n    const isSameOriginRequest = resolvedUrl.origin === currentOrigin;\n    if (!tracePropagationTargets) {\n      return isSameOriginRequest;\n    } else {\n      return (\n        stringMatchesSomePattern(resolvedUrl.toString(), tracePropagationTargets) ||\n        (isSameOriginRequest && stringMatchesSomePattern(resolvedUrl.pathname, tracePropagationTargets))\n      );\n    }\n  }\n}\n\n/**\n * Create and track xhr request spans\n *\n * @returns Span if a span was created, otherwise void.\n */\nexport function xhrCallback(\n  handlerData: HandlerDataXhr,\n  shouldCreateSpan: (url: string) => boolean,\n  shouldAttachHeaders: (url: string) => boolean,\n  spans: Record<string, Span>,\n): Span | undefined {\n  const xhr = handlerData.xhr;\n  const sentryXhrData = xhr?.[SENTRY_XHR_DATA_KEY];\n\n  if (!xhr || xhr.__sentry_own_request__ || !sentryXhrData) {\n    return undefined;\n  }\n\n  const { url, method } = sentryXhrData;\n\n  const shouldCreateSpanResult = hasSpansEnabled() && shouldCreateSpan(url);\n\n  // check first if the request has finished and is tracked by an existing span which should now end\n  if (handlerData.endTimestamp && shouldCreateSpanResult) {\n    const spanId = xhr.__sentry_xhr_span_id__;\n    if (!spanId) return;\n\n    const span = spans[spanId];\n    if (span && sentryXhrData.status_code !== undefined) {\n      setHttpStatus(span, sentryXhrData.status_code);\n      span.end();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return undefined;\n  }\n\n  const fullUrl = getFullURL(url);\n  const parsedUrl = fullUrl ? parseUrl(fullUrl) : parseUrl(url);\n\n  const urlForSpanName = stripUrlQueryAndFragment(url);\n\n  const hasParent = !!getActiveSpan();\n\n  const span =\n    shouldCreateSpanResult && hasParent\n      ? startInactiveSpan({\n          name: `${method} ${urlForSpanName}`,\n          attributes: {\n            url,\n            type: 'xhr',\n            'http.method': method,\n            'http.url': fullUrl,\n            'server.address': parsedUrl?.host,\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.browser',\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.client',\n            ...(parsedUrl?.search && { 'http.query': parsedUrl?.search }),\n            ...(parsedUrl?.hash && { 'http.fragment': parsedUrl?.hash }),\n          },\n        })\n      : new SentryNonRecordingSpan();\n\n  xhr.__sentry_xhr_span_id__ = span.spanContext().spanId;\n  spans[xhr.__sentry_xhr_span_id__] = span;\n\n  if (shouldAttachHeaders(url)) {\n    addTracingHeadersToXhrRequest(\n      xhr,\n      // If performance is disabled (TWP) or there's no active root span (pageload/navigation/interaction),\n      // we do not want to use the span as base for the trace headers,\n      // which means that the headers will be generated from the scope and the sampling decision is deferred\n      hasSpansEnabled() && hasParent ? span : undefined,\n    );\n  }\n\n  const client = getClient();\n  if (client) {\n    client.emit('beforeOutgoingRequestSpan', span, handlerData as XhrHint);\n  }\n\n  return span;\n}\n\nfunction addTracingHeadersToXhrRequest(xhr: SentryWrappedXMLHttpRequest, span?: Span): void {\n  const { 'sentry-trace': sentryTrace, baggage } = getTraceData({ span });\n\n  if (sentryTrace) {\n    setHeaderOnXhr(xhr, sentryTrace, baggage);\n  }\n}\n\nfunction setHeaderOnXhr(\n  xhr: SentryWrappedXMLHttpRequest,\n  sentryTraceHeader: string,\n  sentryBaggageHeader: string | undefined,\n): void {\n  const originalHeaders = xhr.__sentry_xhr_v3__?.request_headers;\n\n  if (originalHeaders?.['sentry-trace']) {\n    // bail if a sentry-trace header is already set\n    return;\n  }\n\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    xhr.setRequestHeader!('sentry-trace', sentryTraceHeader);\n    if (sentryBaggageHeader) {\n      // only add our headers if\n      // - no pre-existing baggage header exists\n      // - or it is set and doesn't yet contain sentry values\n      const originalBaggageHeader = originalHeaders?.['baggage'];\n      if (!originalBaggageHeader || !baggageHeaderHasSentryValues(originalBaggageHeader)) {\n        // From MDN: \"If this method is called several times with the same header, the values are merged into one single request header.\"\n        // We can therefore simply set a baggage header without checking what was there before\n        // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        xhr.setRequestHeader!('baggage', sentryBaggageHeader);\n      }\n    }\n  } catch {\n    // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n  }\n}\n\nfunction baggageHeaderHasSentryValues(baggageHeader: string): boolean {\n  return baggageHeader.split(',').some(value => value.trim().startsWith('sentry-'));\n}\n\nfunction getFullURL(url: string): string | undefined {\n  try {\n    // By adding a base URL to new URL(), this will also work for relative urls\n    // If `url` is a full URL, the base URL is ignored anyhow\n    const parsed = new URL(url, WINDOW.location.origin);\n    return parsed.href;\n  } catch {\n    return undefined;\n  }\n}\n"],"names":[],"mappings":";;;;;AA6BA;;AA6EA,MAAM,gBAAA,GAAmB,IAAI,OAAO,EAAkB;AACtD,MAAM,oBAAA,GAAuB,IAAI,GAAG,EAAkB;;AAE/C,MAAM,oCAAoC,GAAkC;AACnF,EAAE,UAAU,EAAE,IAAI;AAClB,EAAE,QAAQ,EAAE,IAAI;AAChB,EAAE,iBAAiB,EAAE,IAAI;AACzB,EAAE,2BAA2B,EAAE,KAAK;AACpC;;AAEA;AACO,SAAS,0BAA0B,CAAC,MAAM,EAAU,QAAQ,EAAiD;AACpH,EAAE,MAAM;AACR,IAAI,UAAU;AACd,IAAI,QAAQ;AACZ,IAAI,2BAA2B;AAC/B,IAAI,0BAA0B;AAC9B,IAAI,iBAAiB;AACrB,IAAI,uBAAuB;AAC3B,IAAI,kBAAkB;AACtB,MAAM;AACN,IAAI,GAAG,oCAAoC;AAC3C,IAAI,GAAG,QAAQ;AACf,GAAG;;AAEH,EAAE,MAAM,gBAAA;AACR,IAAI,OAAO,0BAAA,KAA+B,UAAA,GAAa,0BAAA,GAA6B,CAAC,CAAC,KAAa,IAAI;;AAEvG,EAAE,MAAM,8BAAA,GAAiC,CAAC,GAAG,KAAsB,mBAAmB,CAAC,GAAG,EAAE,uBAAuB,CAAC;;AAEpH,EAAE,MAAM,KAAK,GAAyB,EAAE;;AAExC,EAAE,IAAI,UAAU,EAAE;AAClB;AACA;AACA,IAAI,MAAM,CAAC,iBAAiB,CAAC,SAAS;AACtC,MAAM,IAAI,KAAK,CAAC,IAAA,KAAS,aAAA,IAAiB,KAAK,CAAC,KAAK,EAAE;AACvD,QAAQ,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ;AACpC,UAAU,IAAI,IAAI,CAAC,EAAA,KAAO,aAAa,EAAE;AACzC,YAAY,MAAM,gBAAA,GAAmB,oBAAoB,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC;AAC3E,YAAY,IAAI,gBAAgB,EAAE;AAClC,cAAc,IAAI,CAAC,SAAA,GAAY,gBAAA,GAAmB,IAAI;AACtD,cAAc,oBAAoB,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC;AACvD;AACA;AACA,SAAS,CAAC;AACV;AACA,MAAM,OAAO,KAAK;AAClB,KAAK,CAAC;;AAEN,IAAI,IAAI,2BAA2B,EAAE;AACrC,MAAM,iCAAiC,CAAC,WAAA,IAAe;AACvD,QAAQ,IAAI,WAAW,CAAC,QAAQ,EAAE;AAClC,UAAU,MAAM,IAAA,GAAO,gBAAgB,CAAC,GAAG,CAAC,WAAW,CAAC,QAAQ,CAAC;AACjE,UAAU,IAAI,IAAA,IAAQ,WAAW,CAAC,YAAY,EAAE;AAChD,YAAY,oBAAoB,CAAC,GAAG,CAAC,IAAI,EAAE,WAAW,CAAC,YAAY,CAAC;AACpE;AACA;AACA,OAAO,CAAC;AACR;;AAEA,IAAI,8BAA8B,CAAC,WAAA,IAAe;AAClD,MAAM,MAAM,WAAA,GAAc,sBAAsB,CAAC,WAAW,EAAE,gBAAgB,EAAE,8BAA8B,EAAE,KAAK,CAAC;;AAEtH,MAAM,IAAI,WAAW,CAAC,QAAA,IAAY,WAAW,CAAC,SAAS,CAAC,MAAM,EAAE;AAChE,QAAQ,gBAAgB,CAAC,GAAG,CAAC,WAAW,CAAC,QAAQ,EAAE,WAAW,CAAC,SAAS,CAAC,MAAM,CAAC;AAChF;;AAEA;AACA;AACA;AACA,MAAM,IAAI,WAAW,EAAE;AACvB,QAAQ,MAAM,OAAA,GAAU,UAAU,CAAC,WAAW,CAAC,SAAS,CAAC,GAAG,CAAC;AAC7D,QAAQ,MAAM,IAAA,GAAO,OAAA,GAAU,QAAQ,CAAC,OAAO,CAAC,CAAC,IAAA,GAAO,SAAS;AACjE,QAAQ,WAAW,CAAC,aAAa,CAAC;AAClC,UAAU,UAAU,EAAE,OAAO;AAC7B,UAAU,gBAAgB,EAAE,IAAI;AAChC,SAAS,CAAC;;AAEV,QAAQ,IAAI,iBAAiB,EAAE;AAC/B,UAAU,cAAc,CAAC,WAAW,CAAC;AACrC;;AAEA,QAAQ,kBAAkB,GAAG,WAAW,EAAE,EAAE,OAAO,EAAE,WAAW,CAAC,OAAA,EAAS,CAAC;AAC3E;AACA,KAAK,CAAC;AACN;;AAEA,EAAE,IAAI,QAAQ,EAAE;AAChB,IAAI,4BAA4B,CAAC,WAAA,IAAe;AAChD,MAAM,MAAM,WAAA,GAAc,WAAW,CAAC,WAAW,EAAE,gBAAgB,EAAE,8BAA8B,EAAE,KAAK,CAAC;AAC3G,MAAM,IAAI,WAAW,EAAE;AACvB,QAAQ,IAAI,iBAAiB,EAAE;AAC/B,UAAU,cAAc,CAAC,WAAW,CAAC;AACrC;;AAEA,QAAQ,IAAI,OAAO;AACnB,QAAQ,IAAI;AACZ,UAAU,OAAA,GAAU,IAAI,OAAO,CAAC,WAAW,CAAC,GAAG,CAAC,iBAAiB,EAAE,eAAe,CAAC;AACnF,UAAU,MAAM;AAChB;AACA;AACA,QAAQ,kBAAkB,GAAG,WAAW,EAAE,EAAE,OAAA,EAAS,CAAC;AACtD;AACA,KAAK,CAAC;AACN;AACA;;AAEA,SAAS,2BAA2B,CAAC,KAAK,EAAwD;AAClG,EAAE;AACF,IAAI,KAAK,CAAC,SAAA,KAAc,UAAA;AACxB,IAAI,eAAA,IAAmB,KAAA;AACvB,IAAI,OAAO,CAAC,KAAA,GAAoC,eAAA,KAAoB,QAAA;AACpE,KAAK,KAAK,CAAC,aAAA,KAAkB,OAAA,IAAW,KAAK,CAAC,aAAA,KAAkB,gBAAgB;AAChF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,cAAc,CAAC,IAAI,EAAc;AAC1C,EAAE,MAAM,EAAE,GAAA,EAAI,GAAI,UAAU,CAAC,IAAI,CAAC,CAAC,IAAI;;AAEvC,EAAE,IAAI,CAAC,GAAA,IAAO,OAAO,GAAA,KAAQ,QAAQ,EAAE;AACvC,IAAI;AACJ;;AAEA,EAAE,MAAM,OAAA,GAAU,oCAAoC,CAAC,UAAU,EAAE,CAAC,EAAE,OAAA,EAAS,KAAK;AACpF,IAAI,OAAO,CAAC,OAAO,CAAC,SAAS;AAC7B,MAAM,IAAI,2BAA2B,CAAC,KAAK,CAAA,IAAK,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;AAC1E,QAAQ,MAAM,cAAA,GAAiB,8BAA8B,CAAC,KAAK,CAAC;AACpE,QAAQ,cAAc,CAAC,OAAO,CAAC,cAAA,IAAkB,IAAI,CAAC,YAAY,CAAC,GAAG,cAAc,CAAC,CAAC;AACtF;AACA;AACA,QAAQ,UAAU,CAAC,OAAO,CAAC;AAC3B;AACA,KAAK,CAAC;AACN,GAAG,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACO,SAAS,mBAAmB;AACnC,EAAE,SAAS;AACX,EAAE,uBAAuB;AACzB,EAAW;AACX;AACA;AACA,EAAE,MAAM,IAAA,GAAO,eAAe,EAAE;;AAEhC,EAAE,IAAI,CAAC,IAAI,EAAE;AACb;AACA;AACA;AACA,IAAI,MAAM,2BAAA,GAA8B,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,WAAW,CAAC;AACtE,IAAI,IAAI,CAAC,uBAAuB,EAAE;AAClC,MAAM,OAAO,2BAA2B;AACxC,WAAW;AACX,MAAM,OAAO,wBAAwB,CAAC,SAAS,EAAE,uBAAuB,CAAC;AACzE;AACA,SAAS;AACT,IAAI,IAAI,WAAW;AACnB,IAAI,IAAI,aAAa;;AAErB;AACA,IAAI,IAAI;AACR,MAAM,WAAA,GAAc,IAAI,GAAG,CAAC,SAAS,EAAE,IAAI,CAAC;AAC5C,MAAM,aAAA,GAAgB,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC,MAAM;AAC1C,MAAM,MAAM;AACZ,MAAM,OAAO,KAAK;AAClB;;AAEA,IAAI,MAAM,mBAAA,GAAsB,WAAW,CAAC,MAAA,KAAW,aAAa;AACpE,IAAI,IAAI,CAAC,uBAAuB,EAAE;AAClC,MAAM,OAAO,mBAAmB;AAChC,WAAW;AACX,MAAM;AACN,QAAQ,wBAAwB,CAAC,WAAW,CAAC,QAAQ,EAAE,EAAE,uBAAuB,CAAA;AAChF,SAAS,mBAAA,IAAuB,wBAAwB,CAAC,WAAW,CAAC,QAAQ,EAAE,uBAAuB,CAAC;AACvG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO,SAAS,WAAW;AAC3B,EAAE,WAAW;AACb,EAAE,gBAAgB;AAClB,EAAE,mBAAmB;AACrB,EAAE,KAAK;AACP,EAAoB;AACpB,EAAE,MAAM,GAAA,GAAM,WAAW,CAAC,GAAG;AAC7B,EAAE,MAAM,aAAA,GAAgB,GAAG,GAAG,mBAAmB,CAAC;;AAElD,EAAE,IAAI,CAAC,GAAA,IAAO,GAAG,CAAC,sBAAA,IAA0B,CAAC,aAAa,EAAE;AAC5D,IAAI,OAAO,SAAS;AACpB;;AAEA,EAAE,MAAM,EAAE,GAAG,EAAE,MAAA,EAAO,GAAI,aAAa;;AAEvC,EAAE,MAAM,sBAAA,GAAyB,eAAe,MAAM,gBAAgB,CAAC,GAAG,CAAC;;AAE3E;AACA,EAAE,IAAI,WAAW,CAAC,YAAA,IAAgB,sBAAsB,EAAE;AAC1D,IAAI,MAAM,MAAA,GAAS,GAAG,CAAC,sBAAsB;AAC7C,IAAI,IAAI,CAAC,MAAM,EAAE;;AAEjB,IAAI,MAAM,IAAA,GAAO,KAAK,CAAC,MAAM,CAAC;AAC9B,IAAI,IAAI,IAAA,IAAQ,aAAa,CAAC,WAAA,KAAgB,SAAS,EAAE;AACzD,MAAM,aAAa,CAAC,IAAI,EAAE,aAAa,CAAC,WAAW,CAAC;AACpD,MAAM,IAAI,CAAC,GAAG,EAAE;;AAEhB;AACA,MAAM,OAAO,KAAK,CAAC,MAAM,CAAC;AAC1B;AACA,IAAI,OAAO,SAAS;AACpB;;AAEA,EAAE,MAAM,OAAA,GAAU,UAAU,CAAC,GAAG,CAAC;AACjC,EAAE,MAAM,SAAA,GAAY,OAAA,GAAU,QAAQ,CAAC,OAAO,CAAA,GAAI,QAAQ,CAAC,GAAG,CAAC;;AAE/D,EAAE,MAAM,cAAA,GAAiB,wBAAwB,CAAC,GAAG,CAAC;;AAEtD,EAAE,MAAM,SAAA,GAAY,CAAC,CAAC,aAAa,EAAE;;AAErC,EAAE,MAAM,IAAA;AACR,IAAI,0BAA0B;AAC9B,QAAQ,iBAAiB,CAAC;AAC1B,UAAU,IAAI,EAAE,CAAC,EAAA,MAAA,CAAA,CAAA,EAAA,cAAA,CAAA,CAAA;AACA,UAAA,UAAA,EAAA;AACA,YAAA,GAAA;AACA,YAAA,IAAA,EAAA,KAAA;AACA,YAAA,aAAA,EAAA,MAAA;AACA,YAAA,UAAA,EAAA,OAAA;AACA,YAAA,gBAAA,EAAA,SAAA,EAAA,IAAA;AACA,YAAA,CAAA,gCAAA,GAAA,mBAAA;AACA,YAAA,CAAA,4BAAA,GAAA,aAAA;AACA,YAAA,IAAA,SAAA,EAAA,MAAA,IAAA,EAAA,YAAA,EAAA,SAAA,EAAA,MAAA,EAAA,CAAA;AACA,YAAA,IAAA,SAAA,EAAA,IAAA,IAAA,EAAA,eAAA,EAAA,SAAA,EAAA,IAAA,EAAA,CAAA;AACA,WAAA;AACA,SAAA;AACA,QAAA,IAAA,sBAAA,EAAA;;AAEA,EAAA,GAAA,CAAA,sBAAA,GAAA,IAAA,CAAA,WAAA,EAAA,CAAA,MAAA;AACA,EAAA,KAAA,CAAA,GAAA,CAAA,sBAAA,CAAA,GAAA,IAAA;;AAEA,EAAA,IAAA,mBAAA,CAAA,GAAA,CAAA,EAAA;AACA,IAAA,6BAAA;AACA,MAAA,GAAA;AACA;AACA;AACA;AACA,MAAA,eAAA,EAAA,IAAA,SAAA,GAAA,IAAA,GAAA,SAAA;AACA,KAAA;AACA;;AAEA,EAAA,MAAA,MAAA,GAAA,SAAA,EAAA;AACA,EAAA,IAAA,MAAA,EAAA;AACA,IAAA,MAAA,CAAA,IAAA,CAAA,2BAAA,EAAA,IAAA,EAAA,WAAA,EAAA;AACA;;AAEA,EAAA,OAAA,IAAA;AACA;;AAEA,SAAA,6BAAA,CAAA,GAAA,EAAA,IAAA,EAAA;AACA,EAAA,MAAA,EAAA,cAAA,EAAA,WAAA,EAAA,OAAA,EAAA,GAAA,YAAA,CAAA,EAAA,IAAA,EAAA,CAAA;;AAEA,EAAA,IAAA,WAAA,EAAA;AACA,IAAA,cAAA,CAAA,GAAA,EAAA,WAAA,EAAA,OAAA,CAAA;AACA;AACA;;AAEA,SAAA,cAAA;AACA,EAAA,GAAA;AACA,EAAA,iBAAA;AACA,EAAA,mBAAA;AACA,EAAA;AACA,EAAA,MAAA,eAAA,GAAA,GAAA,CAAA,iBAAA,EAAA,eAAA;;AAEA,EAAA,IAAA,eAAA,GAAA,cAAA,CAAA,EAAA;AACA;AACA,IAAA;AACA;;AAEA,EAAA,IAAA;AACA;AACA,IAAA,GAAA,CAAA,gBAAA,CAAA,cAAA,EAAA,iBAAA,CAAA;AACA,IAAA,IAAA,mBAAA,EAAA;AACA;AACA;AACA;AACA,MAAA,MAAA,qBAAA,GAAA,eAAA,GAAA,SAAA,CAAA;AACA,MAAA,IAAA,CAAA,qBAAA,IAAA,CAAA,4BAAA,CAAA,qBAAA,CAAA,EAAA;AACA;AACA;AACA;AACA;AACA,QAAA,GAAA,CAAA,gBAAA,CAAA,SAAA,EAAA,mBAAA,CAAA;AACA;AACA;AACA,GAAA,CAAA,MAAA;AACA;AACA;AACA;;AAEA,SAAA,4BAAA,CAAA,aAAA,EAAA;AACA,EAAA,OAAA,aAAA,CAAA,KAAA,CAAA,GAAA,CAAA,CAAA,IAAA,CAAA,KAAA,IAAA,KAAA,CAAA,IAAA,EAAA,CAAA,UAAA,CAAA,SAAA,CAAA,CAAA;AACA;;AAEA,SAAA,UAAA,CAAA,GAAA,EAAA;AACA,EAAA,IAAA;AACA;AACA;AACA,IAAA,MAAA,MAAA,GAAA,IAAA,GAAA,CAAA,GAAA,EAAA,MAAA,CAAA,QAAA,CAAA,MAAA,CAAA;AACA,IAAA,OAAA,MAAA,CAAA,IAAA;AACA,GAAA,CAAA,MAAA;AACA,IAAA,OAAA,SAAA;AACA;AACA;;;;"}