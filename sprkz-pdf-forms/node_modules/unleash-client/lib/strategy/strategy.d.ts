import { Context } from '../context';
import { Variant, VariantDefinition } from '../variant';
export interface StrategyTransportInterface {
    name: string;
    parameters: any;
    constraints: Constraint[];
    segments?: number[];
    variants?: VariantDefinition[];
}
export interface EnhancedStrategyTransportInterface extends Omit<StrategyTransportInterface, 'segments'> {
    segments?: Array<Segment | undefined>;
}
export interface Constraint {
    contextName: string;
    operator: Operator;
    inverted: boolean;
    values: string[];
    value?: string | number | Date;
    caseInsensitive?: boolean;
}
export interface Segment {
    id: number;
    constraints: Constraint[];
}
export declare enum Operator {
    IN = "IN",
    NOT_IN = "NOT_IN",
    STR_ENDS_WITH = "STR_ENDS_WITH",
    STR_STARTS_WITH = "STR_STARTS_WITH",
    STR_CONTAINS = "STR_CONTAINS",
    NUM_EQ = "NUM_EQ",
    NUM_GT = "NUM_GT",
    NUM_GTE = "NUM_GTE",
    NUM_LT = "NUM_LT",
    NUM_LTE = "NUM_LTE",
    DATE_AFTER = "DATE_AFTER",
    DATE_BEFORE = "DATE_BEFORE",
    SEMVER_EQ = "SEMVER_EQ",
    SEMVER_GT = "SEMVER_GT",
    SEMVER_LT = "SEMVER_LT"
}
export type OperatorImpl = (constraint: Constraint, context: Context) => boolean;
export type StrategyResult = {
    enabled: true;
    variant?: Variant;
} | {
    enabled: false;
};
export declare class Strategy {
    name: string;
    private returnValue;
    constructor(name: string, returnValue?: boolean);
    checkConstraint(constraint: Constraint, context: Context): boolean;
    checkConstraints(context: Context, constraints?: IterableIterator<Constraint | undefined>): boolean;
    isEnabled(parameters: any, context: Context): boolean;
    isEnabledWithConstraints(parameters: any, context: Context, constraints: IterableIterator<Constraint | undefined>): boolean;
    getResult(parameters: any, context: Context, constraints: IterableIterator<Constraint | undefined>, variants?: VariantDefinition[]): StrategyResult;
}
//# sourceMappingURL=strategy.d.ts.map